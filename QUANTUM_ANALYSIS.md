â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                                                                               â•‘
â•‘        â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•—   â–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ–ˆâ•—     â•‘
â•‘       â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ•‘â•šâ•â•â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ•‘     â•‘
â•‘       â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â–ˆâ–ˆâ•— â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â–ˆâ–ˆâ–ˆâ–ˆâ•”â–ˆâ–ˆâ•‘     â•‘
â•‘       â–ˆâ–ˆâ•‘â–„â–„ â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘     â•‘
â•‘       â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘ â•šâ–ˆâ–ˆâ–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘ â•šâ•â• â–ˆâ–ˆâ•‘     â•‘
â•‘        â•šâ•â•â–€â–€â•â•  â•šâ•â•â•â•â•â• â•šâ•â•  â•šâ•â•â•šâ•â•  â•šâ•â•â•â•   â•šâ•â•    â•šâ•â•â•â•â•â• â•šâ•â•     â•šâ•â•     â•‘
â•‘                                                                               â•‘
â•‘        â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•—  â–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—       â•‘
â•‘       â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘  â•šâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•”â•â•šâ•â•â–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—      â•‘
â•‘       â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â–ˆâ–ˆâ•— â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘   â•šâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•   â–ˆâ–ˆâ–ˆâ•”â• â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•      â•‘
â•‘       â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘    â•šâ–ˆâ–ˆâ•”â•   â–ˆâ–ˆâ–ˆâ•”â•  â–ˆâ–ˆâ•”â•â•â•  â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—      â•‘
â•‘       â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘ â•šâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘      â•‘
â•‘       â•šâ•â•  â•šâ•â•â•šâ•â•  â•šâ•â•â•â•â•šâ•â•  â•šâ•â•â•šâ•â•â•â•â•â•â•â•šâ•â•   â•šâ•â•â•â•â•â•â•â•šâ•â•â•â•â•â•â•â•šâ•â•  â•šâ•â•      â•‘
â•‘                                                                               â•‘
â•‘                    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€          â•‘
â•‘                         Deep Code Intelligence at Light Speed                 â•‘
â•‘                    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€          â•‘
â•‘                                                                               â•‘
â•‘    ğŸ”¬ Advanced Static Analysis  â€¢  ğŸ¯ Precision Error Detection               â•‘
â•‘    âš¡ Real-time MIDI/Audio Safety  â€¢  ğŸ› ï¸  Auto-fix Capabilities              â•‘
â•‘    ğŸ“Š Multi-format Reporting  â€¢  ğŸš€ Cargo Integration                         â•‘
â•‘    ğŸ¤– AI-Powered Fix Recommendations  â€¢  âš™ï¸  Grok-4 Integration              â•‘
â•‘                                                                               â•‘
â•‘                          Version 2.0.0  â€¢  Built with Rust                    â•‘
â•‘                        Copyright Â© 2024-2025 â€¢ All Rights Reserved            â•‘
â•‘                                                                               â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Project: /home/dojevou/projects/midi-software-center
Analysis Date/Time: 2025-12-02T08:23:28.827051731-08:00

# Quantum Analyzer - Claude Code Tasks

Generated: 2025-12-02T08:23:28.827051731-08:00
Project: /home/dojevou/projects/midi-software-center

## Priority Tasks


### ğŸ”´ CRITICAL Priority

- [ ] **Dangerous: 'eval' usage detected (line 27)**
  - 
  - File: `/home/dojevou/projects/midi-software-center/app/verify-fix.sh`
  - Category: Safety
  - Suggested fix:
Avoid eval; use arrays or functions instead

- [ ] **SQL syntax error: Failed to parse SQL**
  - 
  - File: `/home/dojevou/projects/midi-software-center/tests/fixtures/database/cleanup_test_data.sql`
  - Category: Build
  - Suggested fix:
Fix SQL syntax error

- [ ] **SQL syntax error: Failed to parse SQL**
  - 
  - File: `/home/dojevou/projects/midi-software-center/tests/fixtures/database/test_data.sql`
  - Category: Build
  - Suggested fix:
Fix SQL syntax error

- [ ] **SQL syntax error: Failed to parse SQL**
  - 
  - File: `/home/dojevou/projects/midi-software-center/database/optimizations/RESTORE_SAFETY.sql`
  - Category: Build
  - Suggested fix:
Fix SQL syntax error

- [ ] **SQL syntax error: Failed to parse SQL**
  - 
  - File: `/home/dojevou/projects/midi-software-center/database/optimizations/add_tagging_indexes.sql`
  - Category: Build
  - Suggested fix:
Fix SQL syntax error

- [ ] **SQL syntax error: Failed to parse SQL**
  - 
  - File: `/home/dojevou/projects/midi-software-center/database/optimizations/ULTRA_FAST_CONFIG.sql`
  - Category: Build
  - Suggested fix:
Fix SQL syntax error

- [ ] **SQL syntax error: Failed to parse SQL**
  - 
  - File: `/home/dojevou/projects/midi-software-center/database/organize_by_instruments_enhanced.sql`
  - Category: Build
  - Suggested fix:
Fix SQL syntax error

- [ ] **SQL syntax error: Failed to parse SQL**
  - 
  - File: `/home/dojevou/projects/midi-software-center/database/scripts/insert_sample_data.sql`
  - Category: Build
  - Suggested fix:
Fix SQL syntax error

- [ ] **Security: MD5/SHA1 are weak for password hashing (line 39)**
  - 
  - File: `/home/dojevou/projects/midi-software-center/database/scripts/insert_sample_data.sql`
  - Category: Safety
  - Suggested fix:
Use bcrypt, scrypt, or Argon2 for password hashing

- [ ] **SQL syntax error: Failed to parse SQL**
  - 
  - File: `/home/dojevou/projects/midi-software-center/database/INDEX_BACKUP.sql`
  - Category: Build
  - Suggested fix:
Fix SQL syntax error

- [ ] **SQL syntax error: Failed to parse SQL**
  - 
  - File: `/home/dojevou/projects/midi-software-center/database/rollbacks/012_daw_features_rollback.sql`
  - Category: Build
  - Suggested fix:
Fix SQL syntax error

- [ ] **SQL syntax error: Failed to parse SQL**
  - 
  - File: `/home/dojevou/projects/midi-software-center/database/migrations/update_normalized_filenames.sql`
  - Category: Build
  - Suggested fix:
Fix SQL syntax error

- [ ] **SQL syntax error: Failed to parse SQL**
  - 
  - File: `/home/dojevou/projects/midi-software-center/database/migrations/012_daw_features.sql`
  - Category: Build
  - Suggested fix:
Fix SQL syntax error

- [ ] **SQL syntax error: Failed to parse SQL**
  - 
  - File: `/home/dojevou/projects/midi-software-center/database/migrations/009_text_metadata.sql`
  - Category: Build
  - Suggested fix:
Fix SQL syntax error

- [ ] **SQL syntax error: Failed to parse SQL**
  - 
  - File: `/home/dojevou/projects/midi-software-center/database/migrations/001_initial_schema.sql`
  - Category: Build
  - Suggested fix:
Fix SQL syntax error

- [ ] **SQL syntax error: Failed to parse SQL**
  - 
  - File: `/home/dojevou/projects/midi-software-center/database/migrations/007_enhanced_tags.sql`
  - Category: Build
  - Suggested fix:
Fix SQL syntax error

- [ ] **SQL syntax error: Failed to parse SQL**
  - 
  - File: `/home/dojevou/projects/midi-software-center/database/organize_by_instruments_optimized.sql`
  - Category: Build
  - Suggested fix:
Fix SQL syntax error

- [ ] **SQL syntax error: Failed to parse SQL**
  - 
  - File: `/home/dojevou/projects/midi-software-center/verification/sql/schema_validation.sql`
  - Category: Build
  - Suggested fix:
Fix SQL syntax error

- [ ] **SQL syntax error: Failed to parse SQL**
  - 
  - File: `/home/dojevou/projects/midi-software-center/scripts/infer-instruments-parallel.sql`
  - Category: Build
  - Suggested fix:
Fix SQL syntax error

- [ ] **SQL syntax error: Failed to parse SQL**
  - 
  - File: `/home/dojevou/projects/midi-software-center/scripts/extract-pattern-types-simple.sql`
  - Category: Build
  - Suggested fix:
Fix SQL syntax error

- [ ] **SQL syntax error: Failed to parse SQL**
  - 
  - File: `/home/dojevou/projects/midi-software-center/scripts/extract-pattern-types.sql`
  - Category: Build
  - Suggested fix:
Fix SQL syntax error

- [ ] **SQL syntax error: Failed to parse SQL**
  - 
  - File: `/home/dojevou/projects/midi-software-center/_disabled_tests/docs/performance/PERFORMANCE-SQL-MIGRATIONS.sql`
  - Category: Build
  - Suggested fix:
Fix SQL syntax error


### ğŸŸ  HIGH Priority

- [ ] **Missing key in #each block**
  - Each items should have a unique key for better performance
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/components/Slider.svelte`
  - Category: Performance
  - Suggested fix:
Add (item.id) or use key={item.id} directive

- [ ] **Missing key in #each block**
  - Each items should have a unique key for better performance
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/components/TagCloud.svelte`
  - Category: Performance
  - Suggested fix:
Add (item.id) or use key={item.id} directive

- [ ] **Missing key in #each block**
  - Each items should have a unique key for better performance
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/components/VUMeter.svelte`
  - Category: Performance
  - Suggested fix:
Add (item.id) or use key={item.id} directive

- [ ] **Missing key in #each block**
  - Each items should have a unique key for better performance
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/components/VUMeter.svelte`
  - Category: Performance
  - Suggested fix:
Add (item.id) or use key={item.id} directive

- [ ] **Missing key in #each block**
  - Each items should have a unique key for better performance
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/components/MenuBar.svelte`
  - Category: Performance
  - Suggested fix:
Add (item.id) or use key={item.id} directive

- [ ] **Missing key in #each block**
  - Each items should have a unique key for better performance
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/components/MenuBar.svelte`
  - Category: Performance
  - Suggested fix:
Add (item.id) or use key={item.id} directive

- [ ] **Missing key in #each block**
  - Each items should have a unique key for better performance
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/components/Knob.svelte`
  - Category: Performance
  - Suggested fix:
Add (item.id) or use key={item.id} directive

- [ ] **Missing key in #each block**
  - Each items should have a unique key for better performance
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/components/VirtualKeyboard.svelte`
  - Category: Performance
  - Suggested fix:
Add (item.id) or use key={item.id} directive

- [ ] **Missing key in #each block**
  - Each items should have a unique key for better performance
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/components/VirtualKeyboard.svelte`
  - Category: Performance
  - Suggested fix:
Add (item.id) or use key={item.id} directive

- [ ] **Missing key in #each block**
  - Each items should have a unique key for better performance
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/components/VirtualKeyboard.svelte`
  - Category: Performance
  - Suggested fix:
Add (item.id) or use key={item.id} directive

- [ ] **Missing key in #each block**
  - Each items should have a unique key for better performance
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/components/VirtualKeyboard.svelte`
  - Category: Performance
  - Suggested fix:
Add (item.id) or use key={item.id} directive

- [ ] **Missing key in #each block**
  - Each items should have a unique key for better performance
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/TagEditorWindow.svelte`
  - Category: Performance
  - Suggested fix:
Add (item.id) or use key={item.id} directive

- [ ] **Missing key in #each block**
  - Each items should have a unique key for better performance
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/TagEditorWindow.svelte`
  - Category: Performance
  - Suggested fix:
Add (item.id) or use key={item.id} directive

- [ ] **Missing key in #each block**
  - Each items should have a unique key for better performance
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/AutomationWindow.svelte`
  - Category: Performance
  - Suggested fix:
Add (item.id) or use key={item.id} directive

- [ ] **Missing key in #each block**
  - Each items should have a unique key for better performance
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/AutomationWindow.svelte`
  - Category: Performance
  - Suggested fix:
Add (item.id) or use key={item.id} directive

- [ ] **Missing key in #each block**
  - Each items should have a unique key for better performance
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/AutomationWindow.svelte`
  - Category: Performance
  - Suggested fix:
Add (item.id) or use key={item.id} directive

- [ ] **Missing key in #each block**
  - Each items should have a unique key for better performance
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/LoopBrowserWindow.svelte`
  - Category: Performance
  - Suggested fix:
Add (item.id) or use key={item.id} directive

- [ ] **Missing key in #each block**
  - Each items should have a unique key for better performance
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/LoopBrowserWindow.svelte`
  - Category: Performance
  - Suggested fix:
Add (item.id) or use key={item.id} directive

- [ ] **Missing key in #each block**
  - Each items should have a unique key for better performance
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/LoopBrowserWindow.svelte`
  - Category: Performance
  - Suggested fix:
Add (item.id) or use key={item.id} directive

- [ ] **Missing key in #each block**
  - Each items should have a unique key for better performance
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/LoopBrowserWindow.svelte`
  - Category: Performance
  - Suggested fix:
Add (item.id) or use key={item.id} directive

- [ ] **Missing key in #each block**
  - Each items should have a unique key for better performance
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/ProjectBrowserWindow.svelte`
  - Category: Performance
  - Suggested fix:
Add (item.id) or use key={item.id} directive

- [ ] **Missing key in #each block**
  - Each items should have a unique key for better performance
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/ProjectBrowserWindow.svelte`
  - Category: Performance
  - Suggested fix:
Add (item.id) or use key={item.id} directive

- [ ] **Missing key in #each block**
  - Each items should have a unique key for better performance
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/ProjectBrowserWindow.svelte`
  - Category: Performance
  - Suggested fix:
Add (item.id) or use key={item.id} directive

- [ ] **Missing key in #each block**
  - Each items should have a unique key for better performance
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/ProjectBrowserWindow.svelte`
  - Category: Performance
  - Suggested fix:
Add (item.id) or use key={item.id} directive

- [ ] **Missing key in #each block**
  - Each items should have a unique key for better performance
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/ProjectBrowserWindow.svelte`
  - Category: Performance
  - Suggested fix:
Add (item.id) or use key={item.id} directive

- [ ] **Missing key in #each block**
  - Each items should have a unique key for better performance
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/ProjectBrowserWindow.svelte`
  - Category: Performance
  - Suggested fix:
Add (item.id) or use key={item.id} directive

- [ ] **Missing key in #each block**
  - Each items should have a unique key for better performance
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/FavoritesWindow.svelte`
  - Category: Performance
  - Suggested fix:
Add (item.id) or use key={item.id} directive

- [ ] **Missing key in #each block**
  - Each items should have a unique key for better performance
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/VelocityEditorWindow.svelte`
  - Category: Performance
  - Suggested fix:
Add (item.id) or use key={item.id} directive

- [ ] **Missing key in #each block**
  - Each items should have a unique key for better performance
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/VelocityEditorWindow.svelte`
  - Category: Performance
  - Suggested fix:
Add (item.id) or use key={item.id} directive

- [ ] **Missing key in #each block**
  - Each items should have a unique key for better performance
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/SettingsWindow.svelte`
  - Category: Performance
  - Suggested fix:
Add (item.id) or use key={item.id} directive

- [ ] **Missing key in #each block**
  - Each items should have a unique key for better performance
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/SettingsWindow.svelte`
  - Category: Performance
  - Suggested fix:
Add (item.id) or use key={item.id} directive

- [ ] **Missing key in #each block**
  - Each items should have a unique key for better performance
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/SettingsWindow.svelte`
  - Category: Performance
  - Suggested fix:
Add (item.id) or use key={item.id} directive

- [ ] **Missing key in #each block**
  - Each items should have a unique key for better performance
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/ExportWindow.svelte`
  - Category: Performance
  - Suggested fix:
Add (item.id) or use key={item.id} directive

- [ ] **Missing key in #each block**
  - Each items should have a unique key for better performance
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/ExportWindow.svelte`
  - Category: Performance
  - Suggested fix:
Add (item.id) or use key={item.id} directive

- [ ] **Missing key in #each block**
  - Each items should have a unique key for better performance
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/ExportWindow.svelte`
  - Category: Performance
  - Suggested fix:
Add (item.id) or use key={item.id} directive

- [ ] **Missing key in #each block**
  - Each items should have a unique key for better performance
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/ExportWindow.svelte`
  - Category: Performance
  - Suggested fix:
Add (item.id) or use key={item.id} directive

- [ ] **Missing key in #each block**
  - Each items should have a unique key for better performance
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/ExportWindow.svelte`
  - Category: Performance
  - Suggested fix:
Add (item.id) or use key={item.id} directive

- [ ] **Missing key in #each block**
  - Each items should have a unique key for better performance
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/DatabaseWindow.svelte`
  - Category: Performance
  - Suggested fix:
Add (item.id) or use key={item.id} directive

- [ ] **Missing key in #each block**
  - Each items should have a unique key for better performance
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/DatabaseWindow.svelte`
  - Category: Performance
  - Suggested fix:
Add (item.id) or use key={item.id} directive

- [ ] **Missing key in #each block**
  - Each items should have a unique key for better performance
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/DatabaseWindow.svelte`
  - Category: Performance
  - Suggested fix:
Add (item.id) or use key={item.id} directive

- [ ] **Missing key in #each block**
  - Each items should have a unique key for better performance
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/FileDetailsWindow.svelte`
  - Category: Performance
  - Suggested fix:
Add (item.id) or use key={item.id} directive

- [ ] **Missing key in #each block**
  - Each items should have a unique key for better performance
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/FileDetailsWindow.svelte`
  - Category: Performance
  - Suggested fix:
Add (item.id) or use key={item.id} directive

- [ ] **Missing key in #each block**
  - Each items should have a unique key for better performance
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/FileDetailsWindow.svelte`
  - Category: Performance
  - Suggested fix:
Add (item.id) or use key={item.id} directive

- [ ] **Missing key in #each block**
  - Each items should have a unique key for better performance
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/FileDetailsWindow.svelte`
  - Category: Performance
  - Suggested fix:
Add (item.id) or use key={item.id} directive

- [ ] **Missing key in #each block**
  - Each items should have a unique key for better performance
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/FileDetailsWindow.svelte`
  - Category: Performance
  - Suggested fix:
Add (item.id) or use key={item.id} directive

- [ ] **Missing key in #each block**
  - Each items should have a unique key for better performance
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/FileDetailsWindow.svelte`
  - Category: Performance
  - Suggested fix:
Add (item.id) or use key={item.id} directive

- [ ] **Missing key in #each block**
  - Each items should have a unique key for better performance
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/FileDetailsWindow.svelte`
  - Category: Performance
  - Suggested fix:
Add (item.id) or use key={item.id} directive

- [ ] **Missing key in #each block**
  - Each items should have a unique key for better performance
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/MIDIDeviceWindow.svelte`
  - Category: Performance
  - Suggested fix:
Add (item.id) or use key={item.id} directive

- [ ] **Missing key in #each block**
  - Each items should have a unique key for better performance
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/MIDIDeviceWindow.svelte`
  - Category: Performance
  - Suggested fix:
Add (item.id) or use key={item.id} directive

- [ ] **Missing key in #each block**
  - Each items should have a unique key for better performance
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/MIDIDeviceWindow.svelte`
  - Category: Performance
  - Suggested fix:
Add (item.id) or use key={item.id} directive

- [ ] **Missing key in #each block**
  - Each items should have a unique key for better performance
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/MIDIDeviceWindow.svelte`
  - Category: Performance
  - Suggested fix:
Add (item.id) or use key={item.id} directive

- [ ] **Missing key in #each block**
  - Each items should have a unique key for better performance
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/MIDIDeviceWindow.svelte`
  - Category: Performance
  - Suggested fix:
Add (item.id) or use key={item.id} directive

- [ ] **Missing key in #each block**
  - Each items should have a unique key for better performance
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/MIDIDeviceWindow.svelte`
  - Category: Performance
  - Suggested fix:
Add (item.id) or use key={item.id} directive

- [ ] **Performance: Possible N+1 query pattern (line 190)**
  - 
  - File: `/home/dojevou/projects/midi-software-center/database/organize_by_instruments.sql`
  - Category: Performance
  - Suggested fix:
Use JOINs or batch queries instead of loops

- [ ] **Security: String concatenation in SQL may enable injection (line 166)**
  - 
  - File: `/home/dojevou/projects/midi-software-center/database/organize_by_instruments.sql`
  - Category: Safety
  - Suggested fix:
Use parameterized queries with $1, $2 placeholders

- [ ] **Security: String concatenation in SQL may enable injection (line 527)**
  - 
  - File: `/home/dojevou/projects/midi-software-center/database/organize_by_instruments_enhanced.sql`
  - Category: Safety
  - Suggested fix:
Use parameterized queries with $1, $2 placeholders

- [ ] **Security: String concatenation in SQL may enable injection (line 528)**
  - 
  - File: `/home/dojevou/projects/midi-software-center/database/organize_by_instruments_enhanced.sql`
  - Category: Safety
  - Suggested fix:
Use parameterized queries with $1, $2 placeholders

- [ ] **Security: String concatenation in SQL may enable injection (line 529)**
  - 
  - File: `/home/dojevou/projects/midi-software-center/database/organize_by_instruments_enhanced.sql`
  - Category: Safety
  - Suggested fix:
Use parameterized queries with $1, $2 placeholders

- [ ] **Security: String concatenation in SQL may enable injection (line 163)**
  - 
  - File: `/home/dojevou/projects/midi-software-center/database/scripts/insert_sample_data.sql`
  - Category: Safety
  - Suggested fix:
Use parameterized queries with $1, $2 placeholders

- [ ] **Security: String concatenation in SQL may enable injection (line 460)**
  - 
  - File: `/home/dojevou/projects/midi-software-center/database/organize_by_instruments_optimized.sql`
  - Category: Safety
  - Suggested fix:
Use parameterized queries with $1, $2 placeholders

- [ ] **Security: String concatenation in SQL may enable injection (line 461)**
  - 
  - File: `/home/dojevou/projects/midi-software-center/database/organize_by_instruments_optimized.sql`
  - Category: Safety
  - Suggested fix:
Use parameterized queries with $1, $2 placeholders

- [ ] **Security: String concatenation in SQL may enable injection (line 462)**
  - 
  - File: `/home/dojevou/projects/midi-software-center/database/organize_by_instruments_optimized.sql`
  - Category: Safety
  - Suggested fix:
Use parameterized queries with $1, $2 placeholders

- [ ] **Security: String concatenation in SQL may enable injection (line 165)**
  - 
  - File: `/home/dojevou/projects/midi-software-center/scripts/infer-instruments-parallel.sql`
  - Category: Safety
  - Suggested fix:
Use parameterized queries with $1, $2 placeholders

- [ ] **Security: String concatenation in SQL may enable injection (line 172)**
  - 
  - File: `/home/dojevou/projects/midi-software-center/scripts/infer-instruments-parallel.sql`
  - Category: Safety
  - Suggested fix:
Use parameterized queries with $1, $2 placeholders

- [ ] **Security: String concatenation in SQL may enable injection (line 189)**
  - 
  - File: `/home/dojevou/projects/midi-software-center/scripts/infer-instruments-parallel.sql`
  - Category: Safety
  - Suggested fix:
Use parameterized queries with $1, $2 placeholders

- [ ] **Security: String concatenation in SQL may enable injection (line 214)**
  - 
  - File: `/home/dojevou/projects/midi-software-center/scripts/infer-instruments-enhanced.sql`
  - Category: Safety
  - Suggested fix:
Use parameterized queries with $1, $2 placeholders

- [ ] **Security: String concatenation in SQL may enable injection (line 222)**
  - 
  - File: `/home/dojevou/projects/midi-software-center/scripts/infer-instruments-enhanced.sql`
  - Category: Safety
  - Suggested fix:
Use parameterized queries with $1, $2 placeholders

- [ ] **Security: String concatenation in SQL may enable injection (line 229)**
  - 
  - File: `/home/dojevou/projects/midi-software-center/scripts/infer-instruments-enhanced.sql`
  - Category: Safety
  - Suggested fix:
Use parameterized queries with $1, $2 placeholders

- [ ] **Security: String concatenation in SQL may enable injection (line 237)**
  - 
  - File: `/home/dojevou/projects/midi-software-center/scripts/infer-instruments-enhanced.sql`
  - Category: Safety
  - Suggested fix:
Use parameterized queries with $1, $2 placeholders

- [ ] **Performance: Possible N+1 query pattern (line 15)**
  - 
  - File: `/home/dojevou/projects/midi-software-center/scripts/extract-pattern-types-simple.sql`
  - Category: Performance
  - Suggested fix:
Use JOINs or batch queries instead of loops


### ğŸŸ¡ MEDIUM Priority

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/browsers/project_browser.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/browsers/project_browser.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/command_palette.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/daw.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/daw.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/daw.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/daw.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/daw.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/daw.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/daw.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/daw.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/daw.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/daw.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/daw.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/daw.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/daw.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/daw.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/daw.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/daw.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/daw.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/daw.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/daw.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/daw.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/daw.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/daw.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/daw.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/daw.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/mixer.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/mixer.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/mixer.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/mixer.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/mixer.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/mixer.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/mixer.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/mixer.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/mixer.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/mixer.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/mixer.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/mixer.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/mixer.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/mixer.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/mixer.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/mixer.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/mixer.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/mixer.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/mixer.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/mixer.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/mixer.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/pipeline.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/pipeline.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/pipeline.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/pipeline.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/pipeline.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/pipeline.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/pipeline.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/pipeline.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/pipeline.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/pipeline.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/pipeline.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/pipeline.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/pipeline.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/pipeline.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/pipeline.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/pipeline.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/pipeline.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/pipeline.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/pipeline.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/pipeline.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/pipeline.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/pipeline.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/pipeline.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/pipeline.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/system.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/system.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/system.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/system.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/system.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/system.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/system.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/editors/controller.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/editors/tempo.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/profiling/query_analyzer.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/fast_tagger.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/fast_tagger.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/fast_tagger_full.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/fast_tagger_full.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/find_duplicates.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/import_split_files.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/import_split_files.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/import_split_files.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/infer_instruments.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/infer_instruments.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/infer_instruments.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/infer_instruments.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/infer_instruments.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/infer_instruments.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/infer_instruments.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/infer_instruments.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/infer_instruments.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/infer_instruments.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/infer_instruments.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/infer_instruments.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/infer_instruments.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/infer_instruments.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/infer_instruments.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/midi_doctor.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/midi_doctor.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/midi_doctor.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/midi_to_mpcpattern.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/midi_to_mpcpattern_parallel.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/midi_to_mpcpattern_parallel.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/mpc_backup.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/normalize_filenames.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/normalize_filenames.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/orchestrator.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/orchestrator.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/orchestrator.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/orchestrator.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/orchestrator.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/parallel_extract.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/parallel_extract.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/parallel_extract.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/chord_analyzer.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/chord_analyzer.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/normalization/filename.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/scripts/import-tool/src/main.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/scripts/import-tool/src/main.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/scripts/import-tool/src/main.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/scripts/import-tool/src/main.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/scripts/import-tool/src/main.rs`
  - Category: Safety

- [ ] **Large Svelte component**
  - Component has 775 lines (recommended: < 300)
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/components/Slider.svelte`
  - Category: Performance
  - Suggested fix:
Consider splitting into smaller components

- [ ] **Large Svelte component**
  - Component has 775 lines (recommended: < 300)
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/components/VUMeter.svelte`
  - Category: Performance
  - Suggested fix:
Consider splitting into smaller components

- [ ] **Large Svelte component**
  - Component has 304 lines (recommended: < 300)
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/components/AutomationLane.svelte`
  - Category: Performance
  - Suggested fix:
Consider splitting into smaller components

- [ ] **Large Svelte component**
  - Component has 377 lines (recommended: < 300)
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/components/Toolbar.svelte`
  - Category: Performance
  - Suggested fix:
Consider splitting into smaller components

- [ ] **Large Svelte component**
  - Component has 648 lines (recommended: < 300)
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/components/MenuBar.svelte`
  - Category: Performance
  - Suggested fix:
Consider splitting into smaller components

- [ ] **Large Svelte component**
  - Component has 665 lines (recommended: < 300)
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/components/Knob.svelte`
  - Category: Performance
  - Suggested fix:
Consider splitting into smaller components

- [ ] **Large Svelte component**
  - Component has 624 lines (recommended: < 300)
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/components/VirtualKeyboard.svelte`
  - Category: Performance
  - Suggested fix:
Consider splitting into smaller components

- [ ] **Large Svelte component**
  - Component has 482 lines (recommended: < 300)
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/CommandPaletteWindow.svelte`
  - Category: Performance
  - Suggested fix:
Consider splitting into smaller components

- [ ] **Large Svelte component**
  - Component has 573 lines (recommended: < 300)
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/TagEditorWindow.svelte`
  - Category: Performance
  - Suggested fix:
Consider splitting into smaller components

- [ ] **Large Svelte component**
  - Component has 492 lines (recommended: < 300)
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/AutomationWindow.svelte`
  - Category: Performance
  - Suggested fix:
Consider splitting into smaller components

- [ ] **Large Svelte component**
  - Component has 419 lines (recommended: < 300)
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/PipelineWindow.svelte`
  - Category: Performance
  - Suggested fix:
Consider splitting into smaller components

- [ ] **Large Svelte component**
  - Component has 850 lines (recommended: < 300)
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/LoopBrowserWindow.svelte`
  - Category: Performance
  - Suggested fix:
Consider splitting into smaller components

- [ ] **Large Svelte component**
  - Component has 507 lines (recommended: < 300)
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/MixerWindow.svelte`
  - Category: Performance
  - Suggested fix:
Consider splitting into smaller components

- [ ] **Large Svelte component**
  - Component has 913 lines (recommended: < 300)
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/ProjectBrowserWindow.svelte`
  - Category: Performance
  - Suggested fix:
Consider splitting into smaller components

- [ ] **Large Svelte component**
  - Component has 570 lines (recommended: < 300)
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/FavoritesWindow.svelte`
  - Category: Performance
  - Suggested fix:
Consider splitting into smaller components

- [ ] **Image missing alt attribute**
  - Images should have alt text for accessibility
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/FavoritesWindow.svelte`
  - Category: Documentation
  - Suggested fix:
Add alt="description" to image

- [ ] **Large Svelte component**
  - Component has 329 lines (recommended: < 300)
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/DAWWindow.svelte`
  - Category: Performance
  - Suggested fix:
Consider splitting into smaller components

- [ ] **Large Svelte component**
  - Component has 779 lines (recommended: < 300)
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/VelocityEditorWindow.svelte`
  - Category: Performance
  - Suggested fix:
Consider splitting into smaller components

- [ ] **Large Svelte component**
  - Component has 1225 lines (recommended: < 300)
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/SettingsWindow.svelte`
  - Category: Performance
  - Suggested fix:
Consider splitting into smaller components

- [ ] **Large Svelte component**
  - Component has 884 lines (recommended: < 300)
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/ExportWindow.svelte`
  - Category: Performance
  - Suggested fix:
Consider splitting into smaller components

- [ ] **Large Svelte component**
  - Component has 558 lines (recommended: < 300)
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/DatabaseWindow.svelte`
  - Category: Performance
  - Suggested fix:
Consider splitting into smaller components

- [ ] **Large Svelte component**
  - Component has 1094 lines (recommended: < 300)
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/FileDetailsWindow.svelte`
  - Category: Performance
  - Suggested fix:
Consider splitting into smaller components

- [ ] **Large Svelte component**
  - Component has 708 lines (recommended: < 300)
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/MIDIDeviceWindow.svelte`
  - Category: Performance
  - Suggested fix:
Consider splitting into smaller components

- [ ] **Large Svelte component**
  - Component has 400 lines (recommended: < 300)
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/PianoRollWindow.svelte`
  - Category: Performance
  - Suggested fix:
Consider splitting into smaller components

- [ ] **Anti-pattern: Bare 'except:' catches all exceptions (line 249)**
  - 
  - File: `/home/dojevou/projects/midi-software-center/scripts/grok/ultra_supercharged_grok_reviewer.py`
  - Category: Documentation
  - Suggested fix:
Use specific exception: 'except ValueError:' or at least 'except Exception:'

- [ ] **Anti-pattern: Bare 'except:' catches all exceptions (line 266)**
  - 
  - File: `/home/dojevou/projects/midi-software-center/scripts/grok/ultra_supercharged_grok_reviewer.py`
  - Category: Documentation
  - Suggested fix:
Use specific exception: 'except ValueError:' or at least 'except Exception:'

- [ ] **Anti-pattern: Bare 'except:' catches all exceptions (line 358)**
  - 
  - File: `/home/dojevou/projects/midi-software-center/scripts/grok/ultra_supercharged_grok_reviewer.py`
  - Category: Documentation
  - Suggested fix:
Use specific exception: 'except ValueError:' or at least 'except Exception:'

- [ ] **Anti-pattern: Bare 'except:' catches all exceptions (line 370)**
  - 
  - File: `/home/dojevou/projects/midi-software-center/scripts/grok/ultra_supercharged_grok_reviewer.py`
  - Category: Documentation
  - Suggested fix:
Use specific exception: 'except ValueError:' or at least 'except Exception:'

- [ ] **Performance: SELECT * fetches all columns (line 387)**
  - 
  - File: `/home/dojevou/projects/midi-software-center/database/organize_by_instruments.sql`
  - Category: Performance
  - Suggested fix:
Specify only needed columns: SELECT col1, col2

- [ ] **Performance: SELECT * fetches all columns (line 408)**
  - 
  - File: `/home/dojevou/projects/midi-software-center/database/organize_by_instruments.sql`
  - Category: Performance
  - Suggested fix:
Specify only needed columns: SELECT col1, col2

- [ ] **Performance: SELECT * fetches all columns (line 533)**
  - 
  - File: `/home/dojevou/projects/midi-software-center/database/organize_by_instruments_enhanced.sql`
  - Category: Performance
  - Suggested fix:
Specify only needed columns: SELECT col1, col2

- [ ] **Migration best practice: Wrap DDL in transaction**
  - 
  - File: `/home/dojevou/projects/midi-software-center/database/migrations/011_enhanced_analysis_json.sql`
  - Category: Documentation
  - Suggested fix:
Add BEGIN; at start and COMMIT; at end

- [ ] **Migration best practice: Wrap DDL in transaction**
  - 
  - File: `/home/dojevou/projects/midi-software-center/database/migrations/010_harmonic_analysis.sql`
  - Category: Documentation
  - Suggested fix:
Add BEGIN; at start and COMMIT; at end

- [ ] **Performance: NOT IN with subquery is slow (line 368)**
  - 
  - File: `/home/dojevou/projects/midi-software-center/database/migrations/007_enhanced_tags.sql`
  - Category: Performance
  - Suggested fix:
Use NOT EXISTS or LEFT JOIN instead

- [ ] **Migration best practice: Wrap DDL in transaction**
  - 
  - File: `/home/dojevou/projects/midi-software-center/database/migrations/002_add_parent_folder.sql`
  - Category: Documentation
  - Suggested fix:
Add BEGIN; at start and COMMIT; at end


### ğŸŸ¢ LOW Priority

- [ ] **Function 'main' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/app/src-tauri/build.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn main () { tauri_build :: build () }

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/app/src-tauri/src/main.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/app/src-tauri/src/main.rs`
  - Category: Performance

- [ ] **Function 'init_logging' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/app/src-tauri/src/main.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Initialize logging/tracing system"] fn init_logging () { let log_dir = std :: env :: var ("LOG_DIR") . unwrap_or_else (| _ | "./logs" . to_string ()) ; std :: fs :: create_dir_all (& log_dir) . ok () ; let file_appender = tracing_appender :: rolling :: daily (log_dir , "midi-app.log") ; let (non_blocking , _guard) = tracing_appender :: non_blocking (file_appender) ; tracing_subscriber :: registry () . with (tracing_subscriber :: EnvFilter :: try_from_default_env () . unwrap_or_else (| _ | { "info,midi_app=debug,midi_pipeline=debug,midi_daw=debug" . into () }) ,) . with (tracing_subscriber :: fmt :: layer () . with_writer (std :: io :: stdout)) . with (tracing_subscriber :: fmt :: layer () . with_writer (non_blocking)) . init () ; }

- [ ] **Function 'main' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/build.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn main () { tauri_build :: build () }

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/automation.rs`
  - Category: Performance

- [ ] **Function 'mask_password' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/bin/profile_queries.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Mask password in database URL for safe logging"] fn mask_password (url : & str) -> String { if let Some (pos) = url . find ("://") { if let Some (at_pos) = url [pos + 3 ..] . find ('@') { let prefix = & url [.. pos + 3] ; let suffix = & url [pos + 3 + at_pos ..] ; if let Some (colon_pos) = url [pos + 3 .. pos + 3 + at_pos] . find (':') { let username = & url [pos + 3 .. pos + 3 + colon_pos] ; return format ! ("{}{}:***{}" , prefix , username , suffix) ; } } } url . to_string () }

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/browsers/loop_browser.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/browsers/loop_browser.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/browsers/loop_browser.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/browsers/loop_browser.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/browsers/loop_browser.rs`
  - Category: Performance

- [ ] **Function 'create_test_loop' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/browsers/loop_browser.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn create_test_loop (id : & str , name : & str , bpm : f32) -> LoopInfo { LoopInfo :: new (id . to_string () , name . to_string () , format ! ("/path/to/{}.mid" , id) , bpm , 4 , "drums" . to_string () ,) }

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/browsers/project_browser.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/browsers/project_browser.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/browsers/project_browser.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/browsers/project_browser.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/browsers/project_browser.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/browsers/project_browser.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/browsers/project_browser.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/browsers/project_browser.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/command_palette.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/command_palette.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/command_palette.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/analysis.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/analysis.rs`
  - Category: Performance

- [ ] **Function 'create_automation_lane' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/automation.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Create automation lane"] # [doc = ""] # [doc = " # Arguments"] # [doc = " * `track_id` - Parent track ID"] # [doc = " * `parameter_type` - Parameter to automate"] # [doc = ""] # [doc = " # Returns"] # [doc = " Lane ID, or error message"] # [tauri :: command] pub fn create_automation_lane (track_id : i32 , parameter_type : ParameterType , state : State < '_ , AutomationState > ,) -> Result < i32 , String > { let mut manager = state . manager . lock () . map_err (| e | format ! ("Failed to lock manager: {}" , e)) ? ; manager . create_lane (track_id , parameter_type) }

- [ ] **Function 'delete_automation_lane' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/automation.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Delete automation lane"] # [doc = ""] # [doc = " # Arguments"] # [doc = " * `track_id` - Parent track ID"] # [doc = " * `parameter_type` - Parameter type"] # [doc = ""] # [doc = " # Returns"] # [doc = " Ok or error message"] # [tauri :: command] pub fn delete_automation_lane (track_id : i32 , parameter_type : ParameterType , state : State < '_ , AutomationState > ,) -> Result < () , String > { let mut manager = state . manager . lock () . map_err (| e | format ! ("Failed to lock manager: {}" , e)) ? ; manager . delete_lane (track_id , parameter_type) }

- [ ] **Function 'add_automation_point' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/automation.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Add automation point"] # [doc = ""] # [doc = " # Arguments"] # [doc = " * `track_id` - Parent track ID"] # [doc = " * `parameter_type` - Parameter type"] # [doc = " * `time` - Time in ticks"] # [doc = " * `value` - Normalized value (0.0-1.0)"] # [doc = ""] # [doc = " # Returns"] # [doc = " Point ID, or error message"] # [tauri :: command] pub fn add_automation_point (track_id : i32 , parameter_type : ParameterType , time : u64 , value : f64 , state : State < '_ , AutomationState > ,) -> Result < i32 , String > { let mut manager = state . manager . lock () . map_err (| e | format ! ("Failed to lock manager: {}" , e)) ? ; manager . add_point (track_id , parameter_type , time , value) }

- [ ] **Function 'remove_automation_point' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/automation.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Remove automation point"] # [doc = ""] # [doc = " # Arguments"] # [doc = " * `track_id` - Parent track ID"] # [doc = " * `parameter_type` - Parameter type"] # [doc = " * `point_id` - Point ID to remove"] # [doc = ""] # [doc = " # Returns"] # [doc = " Ok or error message"] # [tauri :: command] pub fn remove_automation_point (track_id : i32 , parameter_type : ParameterType , point_id : i32 , state : State < '_ , AutomationState > ,) -> Result < () , String > { let mut manager = state . manager . lock () . map_err (| e | format ! ("Failed to lock manager: {}" , e)) ? ; manager . remove_point (track_id , parameter_type , point_id) }

- [ ] **Function 'move_automation_point' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/automation.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Move automation point"] # [doc = ""] # [doc = " # Arguments"] # [doc = " * `track_id` - Parent track ID"] # [doc = " * `parameter_type` - Parameter type"] # [doc = " * `point_id` - Point ID to move"] # [doc = " * `new_time` - New time position"] # [doc = " * `new_value` - New normalized value"] # [doc = ""] # [doc = " # Returns"] # [doc = " Ok or error message"] # [tauri :: command] pub fn move_automation_point (track_id : i32 , parameter_type : ParameterType , point_id : i32 , new_time : u64 , new_value : f64 , state : State < '_ , AutomationState > ,) -> Result < () , String > { let mut manager = state . manager . lock () . map_err (| e | format ! ("Failed to lock manager: {}" , e)) ? ; manager . move_point (track_id , parameter_type , point_id , new_time , new_value) }

- [ ] **Function 'set_automation_curve_type' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/automation.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Set automation curve type"] # [doc = ""] # [doc = " # Arguments"] # [doc = " * `track_id` - Parent track ID"] # [doc = " * `parameter_type` - Parameter type"] # [doc = " * `curve_type` - New curve type"] # [doc = ""] # [doc = " # Returns"] # [doc = " Ok or error message"] # [tauri :: command] pub fn set_automation_curve_type (track_id : i32 , parameter_type : ParameterType , curve_type : CurveType , state : State < '_ , AutomationState > ,) -> Result < () , String > { let mut manager = state . manager . lock () . map_err (| e | format ! ("Failed to lock manager: {}" , e)) ? ; manager . set_curve_type (track_id , parameter_type , curve_type) }

- [ ] **Function 'get_automation_lane' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/automation.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Get automation lane"] # [doc = ""] # [doc = " # Arguments"] # [doc = " * `track_id` - Parent track ID"] # [doc = " * `parameter_type` - Parameter type"] # [doc = ""] # [doc = " # Returns"] # [doc = " Automation lane, or error message"] # [tauri :: command] pub fn get_automation_lane (track_id : i32 , parameter_type : ParameterType , state : State < '_ , AutomationState > ,) -> Result < AutomationLane , String > { let manager = state . manager . lock () . map_err (| e | format ! ("Failed to lock manager: {}" , e)) ? ; manager . get_lane (track_id , parameter_type) }

- [ ] **Function 'get_track_automation' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/automation.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Get all automation lanes for track"] # [doc = ""] # [doc = " # Arguments"] # [doc = " * `track_id` - Track ID"] # [doc = ""] # [doc = " # Returns"] # [doc = " Vector of all lanes for track"] # [tauri :: command] pub fn get_track_automation (track_id : i32 , state : State < '_ , AutomationState > ,) -> Result < Vec < AutomationLane > , String > { let manager = state . manager . lock () . map_err (| e | format ! ("Failed to lock manager: {}" , e)) ? ; Ok (manager . get_track_lanes (track_id)) }

- [ ] **Function 'get_automation_value' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/automation.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Get automation value at specific time"] # [doc = ""] # [doc = " # Arguments"] # [doc = " * `track_id` - Track ID"] # [doc = " * `parameter_type` - Parameter type"] # [doc = " * `time` - Time in ticks"] # [doc = ""] # [doc = " # Returns"] # [doc = " Interpolated value, or None if no automation"] # [tauri :: command] pub fn get_automation_value (track_id : i32 , parameter_type : ParameterType , time : u64 , state : State < '_ , AutomationState > ,) -> Result < Option < f64 > , String > { let manager = state . manager . lock () . map_err (| e | format ! ("Failed to lock manager: {}" , e)) ? ; Ok (manager . get_value_at (track_id , parameter_type , time)) }

- [ ] **Function 'clear_track_automation' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/automation.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Clear all automation for track"] # [doc = ""] # [doc = " # Arguments"] # [doc = " * `track_id` - Track ID"] # [doc = ""] # [doc = " # Returns"] # [doc = " Ok or error message"] # [tauri :: command] pub fn clear_track_automation (track_id : i32 , state : State < '_ , AutomationState > ,) -> Result < () , String > { let mut manager = state . manager . lock () . map_err (| e | format ! ("Failed to lock manager: {}" , e)) ? ; manager . remove_track (track_id) ; Ok (()) }

- [ ] **Function 'clear_all_automation' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/automation.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Clear all automation"] # [doc = ""] # [doc = " # Returns"] # [doc = " Ok or error message"] # [tauri :: command] pub fn clear_all_automation (state : State < '_ , AutomationState >) -> Result < () , String > { let mut manager = state . manager . lock () . map_err (| e | format ! ("Failed to lock manager: {}" , e)) ? ; manager . clear_all () ; Ok (()) }

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/daw.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/daw.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/daw.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/daw.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/daw.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/daw.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/daw.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/daw.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/daw.rs`
  - Category: Performance

- [ ] **Function 'generate_effect_id' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/effect.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn generate_effect_id () -> EffectId { format ! ("fx_{}" , uuid :: Uuid :: new_v4 () . to_string () . replace ("-" , "") [.. 12] . to_string ()) }

- [ ] **Function 'normalize_value' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/effect.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn normalize_value (value : f64 , min : f64 , max : f64 , logarithmic : bool) -> f64 { if logarithmic && min > 0.0 { let log_min = min . ln () ; let log_max = max . ln () ; let log_value = value . ln () ; (log_value - log_min) / (log_max - log_min) } else { (value - min) / (max - min) } }

- [ ] **Function 'denormalize_value' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/effect.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn denormalize_value (normalized : f64 , min : f64 , max : f64 , logarithmic : bool) -> f64 { if logarithmic && min > 0.0 { let log_min = min . ln () ; let log_max = max . ln () ; (log_min + normalized * (log_max - log_min)) . exp () } else { min + normalized * (max - min) } }

- [ ] **Function 'format_parameter_value' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/effect.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn format_parameter_value (value : f64 , format : & ParameterFormat) -> String { match format { ParameterFormat :: Float { decimals } => format ! ("{:.1$}" , value , * decimals as usize) , ParameterFormat :: Db => format ! ("{:.1} dB" , value) , ParameterFormat :: Hz => { if value >= 1000.0 { format ! ("{:.2} kHz" , value / 1000.0) } else { format ! ("{:.1} Hz" , value) } } , ParameterFormat :: Ms => { if value >= 1000.0 { format ! ("{:.2} s" , value / 1000.0) } else { format ! ("{:.1} ms" , value) } } , ParameterFormat :: Percent => format ! ("{:.0}%" , value * 100.0) , ParameterFormat :: Ratio => { if value >= 1.0 { format ! ("{:.1}:1" , value) } else { format ! ("1:{:.1}" , 1.0 / value) } } , ParameterFormat :: Semitones => { if value >= 0.0 { format ! ("+{:.0} st" , value) } else { format ! ("{:.0} st" , value) } } , ParameterFormat :: Cents => { if value >= 0.0 { format ! ("+{:.0} ct" , value) } else { format ! ("{:.0} ct" , value) } } , ParameterFormat :: OnOff => { if value >= 0.5 { "On" . to_string () } else { "Off" . to_string () } } , ParameterFormat :: Enum { values } => { let index = (value . round () as usize) . min (values . len () . saturating_sub (1)) ; values . get (index) . cloned () . unwrap_or_else (| | format ! ("{}" , index)) } , } }

- [ ] **Function 'get_default_parameters' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/effect.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Get default parameters for an effect type"] fn get_default_parameters (effect_type : & EffectType) -> Vec < ParameterDef > { match effect_type { EffectType :: Compressor => vec ! [ParameterDef { id : "threshold" . into () , name : "Threshold" . into () , unit : "dB" . into () , min : - 60.0 , max : 0.0 , default : - 20.0 , step : 0.5 , logarithmic : false , format : ParameterFormat :: Db , group : Some ("Dynamics" . into ()) , automatable : true , } , ParameterDef { id : "ratio" . into () , name : "Ratio" . into () , unit : ":1" . into () , min : 1.0 , max : 20.0 , default : 4.0 , step : 0.1 , logarithmic : true , format : ParameterFormat :: Ratio , group : Some ("Dynamics" . into ()) , automatable : true , } , ParameterDef { id : "attack" . into () , name : "Attack" . into () , unit : "ms" . into () , min : 0.1 , max : 100.0 , default : 10.0 , step : 0.1 , logarithmic : true , format : ParameterFormat :: Ms , group : Some ("Envelope" . into ()) , automatable : true , } , ParameterDef { id : "release" . into () , name : "Release" . into () , unit : "ms" . into () , min : 10.0 , max : 1000.0 , default : 100.0 , step : 1.0 , logarithmic : true , format : ParameterFormat :: Ms , group : Some ("Envelope" . into ()) , automatable : true , } , ParameterDef { id : "makeup" . into () , name : "Makeup Gain" . into () , unit : "dB" . into () , min : 0.0 , max : 24.0 , default : 0.0 , step : 0.5 , logarithmic : false , format : ParameterFormat :: Db , group : Some ("Output" . into ()) , automatable : true , } , ParameterDef { id : "knee" . into () , name : "Knee" . into () , unit : "dB" . into () , min : 0.0 , max : 12.0 , default : 6.0 , step : 0.5 , logarithmic : false , format : ParameterFormat :: Db , group : Some ("Dynamics" . into ()) , automatable : true , } ,] , EffectType :: Delay => vec ! [ParameterDef { id : "time" . into () , name : "Time" . into () , unit : "ms" . into () , min : 1.0 , max : 2000.0 , default : 250.0 , step : 1.0 , logarithmic : true , format : ParameterFormat :: Ms , group : Some ("Delay" . into ()) , automatable : true , } , ParameterDef { id : "feedback" . into () , name : "Feedback" . into () , unit : "%" . into () , min : 0.0 , max : 1.0 , default : 0.3 , step : 0.01 , logarithmic : false , format : ParameterFormat :: Percent , group : Some ("Delay" . into ()) , automatable : true , } , ParameterDef { id : "lowcut" . into () , name : "Low Cut" . into () , unit : "Hz" . into () , min : 20.0 , max : 2000.0 , default : 100.0 , step : 1.0 , logarithmic : true , format : ParameterFormat :: Hz , group : Some ("Filter" . into ()) , automatable : true , } , ParameterDef { id : "highcut" . into () , name : "High Cut" . into () , unit : "Hz" . into () , min : 1000.0 , max : 20000.0 , default : 8000.0 , step : 10.0 , logarithmic : true , format : ParameterFormat :: Hz , group : Some ("Filter" . into ()) , automatable : true , } , ParameterDef { id : "sync" . into () , name : "Tempo Sync" . into () , unit : "" . into () , min : 0.0 , max : 1.0 , default : 0.0 , step : 1.0 , logarithmic : false , format : ParameterFormat :: OnOff , group : Some ("Sync" . into ()) , automatable : false , } ,] , EffectType :: Room | EffectType :: Hall | EffectType :: Plate | EffectType :: Spring | EffectType :: Convolution | EffectType :: Shimmer => vec ! [ParameterDef { id : "size" . into () , name : "Size" . into () , unit : "%" . into () , min : 0.0 , max : 1.0 , default : 0.5 , step : 0.01 , logarithmic : false , format : ParameterFormat :: Percent , group : Some ("Room" . into ()) , automatable : true , } , ParameterDef { id : "decay" . into () , name : "Decay" . into () , unit : "s" . into () , min : 0.1 , max : 10.0 , default : 2.0 , step : 0.1 , logarithmic : true , format : ParameterFormat :: Float { decimals : 1 } , group : Some ("Room" . into ()) , automatable : true , } , ParameterDef { id : "predelay" . into () , name : "Pre-delay" . into () , unit : "ms" . into () , min : 0.0 , max : 200.0 , default : 20.0 , step : 1.0 , logarithmic : false , format : ParameterFormat :: Ms , group : Some ("Room" . into ()) , automatable : true , } , ParameterDef { id : "damping" . into () , name : "Damping" . into () , unit : "%" . into () , min : 0.0 , max : 1.0 , default : 0.5 , step : 0.01 , logarithmic : false , format : ParameterFormat :: Percent , group : Some ("Tone" . into ()) , automatable : true , } , ParameterDef { id : "diffusion" . into () , name : "Diffusion" . into () , unit : "%" . into () , min : 0.0 , max : 1.0 , default : 0.7 , step : 0.01 , logarithmic : false , format : ParameterFormat :: Percent , group : Some ("Tone" . into ()) , automatable : true , } ,] , EffectType :: Gain => vec ! [ParameterDef { id : "gain" . into () , name : "Gain" . into () , unit : "dB" . into () , min : - 24.0 , max : 24.0 , default : 0.0 , step : 0.1 , logarithmic : false , format : ParameterFormat :: Db , group : None , automatable : true , }] , _ => vec ! [ParameterDef { id : "mix" . into () , name : "Mix" . into () , unit : "%" . into () , min : 0.0 , max : 1.0 , default : 1.0 , step : 0.01 , logarithmic : false , format : ParameterFormat :: Percent , group : None , automatable : true , } ,] , } }

- [ ] **Function 'create_default_values' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/effect.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Create default parameter values from definitions"] fn create_default_values (defs : & [ParameterDef]) -> Vec < ParameterValue > { defs . iter () . map (| def | { let normalized = normalize_value (def . default , def . min , def . max , def . logarithmic) ; ParameterValue { id : def . id . clone () , value : def . default , normalized , display : format_parameter_value (def . default , & def . format) , is_automated : false , modulation_amount : 0.0 , } }) . collect () }

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/effect.rs`
  - Category: Performance

- [ ] **Function 'get_available_effects_impl' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/effect.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Get all available effect types"] pub fn get_available_effects_impl () -> Vec < EffectTypeMeta > { let effect_types = vec ! [EffectType :: Compressor , EffectType :: Limiter , EffectType :: Gate , EffectType :: ParametricEq , EffectType :: HighPass , EffectType :: LowPass , EffectType :: Overdrive , EffectType :: Distortion , EffectType :: BitCrusher , EffectType :: Chorus , EffectType :: Flanger , EffectType :: Phaser , EffectType :: Delay , EffectType :: PingPong , EffectType :: Room , EffectType :: Hall , EffectType :: Plate , EffectType :: PitchShifter , EffectType :: Gain , EffectType :: Pan , EffectType :: StereoWidth , EffectType :: Spectrum , EffectType :: LevelMeter ,] ; effect_types . into_iter () . map (| effect_type | { let parameters = get_default_parameters (& effect_type) ; EffectTypeMeta { name : effect_type . display_name () . to_string () , category : effect_type . category () , has_sidechain : matches ! (effect_type , EffectType :: Compressor | EffectType :: Gate | EffectType :: Expander) , latency_samples : 0 , effect_type , parameters , } }) . collect () }

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/effect.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/effect.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/effect.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/effect.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/effect.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/effect.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/effect.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/effect.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/effect.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/effect.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/effect.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/effect.rs`
  - Category: Performance

- [ ] **Function 'get_available_effects' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/effect.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [tauri :: command] pub fn get_available_effects () -> Vec < EffectTypeMeta > { get_available_effects_impl () }

- [ ] **Function 'create_demo_events' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/export.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Create demonstration MIDI events"] # [doc = ""] # [doc = " This is a placeholder for integration with the sequencer."] # [doc = " A real implementation would:"] # [doc = " 1. Get all tracks from the sequencer engine"] # [doc = " 2. Merge events from all enabled tracks"] # [doc = " 3. Apply track properties (mute, solo, volume, pan)"] # [doc = " 4. Sort events by timestamp"] # [doc = ""] # [doc = " Current implementation creates a simple C major arpeggio pattern."] fn create_demo_events () -> Vec < MidiEvent > { vec ! [MidiEvent { event_type : MidiEventType :: NoteOn , tick : 0 , channel : 0 , note : Some (60) , velocity : Some (80) , controller : None , value : None , program : None , } , MidiEvent { event_type : MidiEventType :: NoteOff , tick : 480 , channel : 0 , note : Some (60) , velocity : Some (0) , controller : None , value : None , program : None , } , MidiEvent { event_type : MidiEventType :: NoteOn , tick : 480 , channel : 0 , note : Some (64) , velocity : Some (80) , controller : None , value : None , program : None , } , MidiEvent { event_type : MidiEventType :: NoteOff , tick : 960 , channel : 0 , note : Some (64) , velocity : Some (0) , controller : None , value : None , program : None , } , MidiEvent { event_type : MidiEventType :: NoteOn , tick : 960 , channel : 0 , note : Some (67) , velocity : Some (80) , controller : None , value : None , program : None , } , MidiEvent { event_type : MidiEventType :: NoteOff , tick : 1440 , channel : 0 , note : Some (67) , velocity : Some (0) , controller : None , value : None , program : None , } , MidiEvent { event_type : MidiEventType :: NoteOn , tick : 1440 , channel : 0 , note : Some (72) , velocity : Some (80) , controller : None , value : None , program : None , } , MidiEvent { event_type : MidiEventType :: NoteOff , tick : 1920 , channel : 0 , note : Some (72) , velocity : Some (0) , controller : None , value : None , program : None , } ,] }

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/mixer.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/mixer.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/mixer.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/mixer.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/mixer.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/mixer.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/mixer.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/mixer.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/mixer.rs`
  - Category: Performance

- [ ] **Function 'validate_pitch' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/piano_roll.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn validate_pitch (pitch : i32) -> Result < () , PianoRollError > { if ! (0 ..= 127) . contains (& pitch) { return Err (PianoRollError :: InvalidPitch (pitch)) ; } Ok (()) }

- [ ] **Function 'validate_velocity' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/piano_roll.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn validate_velocity (velocity : i32) -> Result < () , PianoRollError > { if ! (0 ..= 127) . contains (& velocity) { return Err (PianoRollError :: InvalidVelocity (velocity)) ; } Ok (()) }

- [ ] **Function 'validate_duration' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/piano_roll.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn validate_duration (duration : i64) -> Result < () , PianoRollError > { if duration <= 0 { return Err (PianoRollError :: InvalidDuration (duration)) ; } Ok (()) }

- [ ] **Function 'validate_channel' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/piano_roll.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn validate_channel (channel : i32) -> Result < () , PianoRollError > { if ! (0 ..= 15) . contains (& channel) { return Err (PianoRollError :: InvalidChannel (channel)) ; } Ok (()) }

- [ ] **Function 'validate_note_input' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/piano_roll.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn validate_note_input (note : & NoteInput) -> Result < () , PianoRollError > { validate_pitch (note . pitch) ? ; validate_velocity (note . velocity) ? ; validate_duration (note . duration) ? ; validate_channel (note . channel) ? ; Ok (()) }

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/piano_roll.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/piano_roll.rs`
  - Category: Performance

- [ ] **Function 'quantize_value' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/piano_roll.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Apply quantization to a single value"] fn quantize_value (value : i64 , grid_size : i64 , strength : f64 , swing : f64) -> i64 { let grid_position = (value as f64 / grid_size as f64) . round () as i64 ; let quantized = grid_position * grid_size ; let swung = if grid_position % 2 == 1 { quantized + (grid_size as f64 * swing * 0.5) as i64 } else { quantized } ; let result = value as f64 + (swung as f64 - value as f64) * strength ; result . round () as i64 }

- [ ] **Function 'snap_to_scale' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/piano_roll.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Snap a pitch to the nearest scale degree"] fn snap_to_scale (pitch : i32 , scale_notes : & [i32]) -> i32 { let octave = pitch / 12 ; let pitch_class = pitch % 12 ; let nearest = scale_notes . iter () . min_by_key (| & & note | { let diff = (note - pitch_class) . abs () ; diff . min (12 - diff) }) . copied () . unwrap_or (pitch_class) ; octave * 12 + nearest }

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/piano_roll.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/piano_roll.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/piano_roll.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/piano_roll.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/piano_roll.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/piano_roll.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/piano_roll.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/pipeline.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/pipeline.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/pipeline.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/pipeline.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/pipeline.rs`
  - Category: Performance

- [ ] **Function 'read_file_bytes' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/repair.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn read_file_bytes (path : & Path , max_size : u64) -> Result < Vec < u8 > , RepairError > { let metadata = fs :: metadata (path) . map_err (| e | RepairError :: IoError (format ! ("Cannot read metadata: {}" , e))) ? ; if metadata . len () > max_size { return Err (RepairError :: FileTooLarge (metadata . len () , max_size)) ; } let mut file = fs :: File :: open (path) ? ; let mut buffer = Vec :: with_capacity (metadata . len () as usize) ; file . read_to_end (& mut buffer) ? ; Ok (buffer) }

- [ ] **Function 'is_midi_file' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/repair.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn is_midi_file (data : & [u8]) -> bool { data . len () >= 14 && & data [0 .. 4] == MIDI_HEADER }

- [ ] **Function 'find_pattern' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/repair.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn find_pattern (data : & [u8] , pattern : & [u8]) -> Option < usize > { data . windows (pattern . len ()) . position (| w | w == pattern) }

- [ ] **Function 'find_all_patterns' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/repair.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn find_all_patterns (data : & [u8] , pattern : & [u8]) -> Vec < usize > { data . windows (pattern . len ()) . enumerate () . filter (| (_ , w) | * w == pattern) . map (| (i , _) | i) . collect () }

- [ ] **Function 'read_u16_be' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/repair.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn read_u16_be (data : & [u8] , offset : usize) -> u16 { if offset + 2 > data . len () { return 0 ; } ((data [offset] as u16) << 8) | (data [offset + 1] as u16) }

- [ ] **Function 'read_u32_be' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/repair.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn read_u32_be (data : & [u8] , offset : usize) -> u32 { if offset + 4 > data . len () { return 0 ; } ((data [offset] as u32) << 24) | ((data [offset + 1] as u32) << 16) | ((data [offset + 2] as u32) << 8) | (data [offset + 3] as u32) }

- [ ] **Function 'write_u32_be' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/repair.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn write_u32_be (value : u32) -> [u8 ; 4] { [(value >> 24) as u8 , (value >> 16) as u8 , (value >> 8) as u8 , value as u8] }

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/repair.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/repair.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/repair.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/repair.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/repair.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/repair.rs`
  - Category: Performance

- [ ] **Function 'get_repair_strategies' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/repair.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [tauri :: command] pub fn get_repair_strategies () -> Vec < RepairStrategyInfo > { vec ! [RepairStrategy :: Auto , RepairStrategy :: Conservative , RepairStrategy :: Aggressive , RepairStrategy :: AddEndOfTrack , RepairStrategy :: TrimGarbage , RepairStrategy :: FixTrackLength , RepairStrategy :: FixTrackCount , RepairStrategy :: RemoveInvalidEvents , RepairStrategy :: ClampValues , RepairStrategy :: Rebuild ,] . into_iter () . map (| s | RepairStrategyInfo { id : s , name : format ! ("{:?}" , s) , description : s . description () . to_string () , }) . collect () }

- [ ] **Function 'get_corruption_types' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/repair.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [tauri :: command] pub fn get_corruption_types () -> Vec < CorruptionTypeInfo > { vec ! [CorruptionType :: MissingEndOfTrack , CorruptionType :: InvalidHeader , CorruptionType :: TruncatedFile , CorruptionType :: InvalidTrackLength , CorruptionType :: GarbageAtEnd , CorruptionType :: InvalidDeltaTime , CorruptionType :: InvalidEventType , CorruptionType :: InvalidRunningStatus , CorruptionType :: InvalidMetaEvent , CorruptionType :: InvalidSysexEvent , CorruptionType :: MissingTrackHeader , CorruptionType :: TrackCountMismatch , CorruptionType :: NestedSysex , CorruptionType :: InvalidChannel , CorruptionType :: InvalidNote , CorruptionType :: InvalidVelocity , CorruptionType :: FileTooLarge , CorruptionType :: Unknown ,] . into_iter () . map (| t | CorruptionTypeInfo { id : t , name : format ! ("{:?}" , t) , description : t . description () . to_string () , severity : t . severity () , }) . collect () }

- [ ] **Function 'current_timestamp' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/settings.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn current_timestamp () -> i64 { std :: time :: SystemTime :: now () . duration_since (std :: time :: UNIX_EPOCH) . map (| d | d . as_secs () as i64) . unwrap_or (0) }

- [ ] **Function 'generate_profile_id' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/settings.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn generate_profile_id () -> String { format ! ("profile_{}" , current_timestamp ()) }

- [ ] **Function 'ensure_profiles_dir' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/settings.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn ensure_profiles_dir (profiles_dir : & PathBuf) -> Result < () , SettingsError > { if ! profiles_dir . exists () { fs :: create_dir_all (profiles_dir) . map_err (| e | { SettingsError :: FileError (format ! ("Failed to create profiles directory: {}" , e)) }) ? ; } Ok (()) }

- [ ] **Function 'profile_path' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/settings.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn profile_path (profiles_dir : & PathBuf , profile_id : & str) -> PathBuf { profiles_dir . join (format ! ("{}.json" , profile_id)) }

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/settings.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/settings.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/settings.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/settings.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/settings.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/settings.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/settings.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/settings.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/settings.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/settings.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/settings.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/settings.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/settings.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/settings.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/settings.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/settings.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/settings.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/settings.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/settings.rs`
  - Category: Performance

- [ ] **Function 'get_settings_categories' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/settings.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [tauri :: command] pub fn get_settings_categories () -> Vec < SettingsCategoryInfo > { SettingsCategory :: all () . into_iter () . map (| cat | SettingsCategoryInfo { id : cat , name : cat . display_name () . to_string () }) . collect () }

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/system.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/system.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/system.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/system.rs`
  - Category: Performance

- [ ] **Function 'read_file_bytes' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/trim.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Read file bytes with size validation"] fn read_file_bytes (path : & Path) -> Result < Vec < u8 > , TrimError > { let metadata = fs :: metadata (path) . map_err (| _ | TrimError :: FileNotFound (path . display () . to_string ())) ? ; let size = metadata . len () ; if size > MAX_FILE_SIZE { return Err (TrimError :: FileTooLarge (size , MAX_FILE_SIZE)) ; } fs :: read (path) . map_err (TrimError :: Io) }

- [ ] **Function 'detect_file_type' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/trim.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Detect file type from extension and content"] fn detect_file_type (path : & Path , data : & [u8]) -> TrimFileType { if let Some (ext) = path . extension () { let ext_lower = ext . to_string_lossy () . to_lowercase () ; match ext_lower . as_str () { "mid" | "midi" | "smf" => return TrimFileType :: Midi , "wav" | "wave" | "aif" | "aiff" | "mp3" | "flac" | "ogg" => return TrimFileType :: Audio , _ => { } , } } if data . len () >= 4 && & data [0 .. 4] == MIDI_HEADER { return TrimFileType :: Midi ; } if data . len () >= 4 && & data [0 .. 4] == b"RIFF" { return TrimFileType :: Audio ; } TrimFileType :: Midi }

- [ ] **Function 'read_vlq' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/trim.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Read variable-length quantity from MIDI data"] fn read_vlq (data : & [u8] , offset : usize) -> Option < (u32 , usize) > { let mut value : u32 = 0 ; let mut bytes_read = 0 ; for i in 0 .. 4 { if offset + i >= data . len () { return None ; } let byte = data [offset + i] ; value = (value << 7) | (byte & 0x7F) as u32 ; bytes_read += 1 ; if byte & 0x80 == 0 { break ; } } Some ((value , bytes_read)) }

- [ ] **Function 'write_vlq' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/trim.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Write variable-length quantity to buffer"] fn write_vlq (value : u32) -> Vec < u8 > { if value == 0 { return vec ! [0] ; } let mut bytes = Vec :: new () ; let mut v = value ; let mut first = true ; while v > 0 || first { let mut byte = (v & 0x7F) as u8 ; v >>= 7 ; if ! first { byte |= 0x80 ; } bytes . push (byte) ; first = false ; } bytes . reverse () ; bytes }

- [ ] **Function 'read_u16_be' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/trim.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Read 16-bit big-endian value"] fn read_u16_be (data : & [u8] , offset : usize) -> Option < u16 > { if offset + 2 > data . len () { return None ; } Some (u16 :: from_be_bytes ([data [offset] , data [offset + 1]])) }

- [ ] **Function 'read_u32_be' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/trim.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Read 32-bit big-endian value"] fn read_u32_be (data : & [u8] , offset : usize) -> Option < u32 > { if offset + 4 > data . len () { return None ; } Some (u32 :: from_be_bytes ([data [offset] , data [offset + 1] , data [offset + 2] , data [offset + 3] ,])) }

- [ ] **Function 'write_u32_be' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/trim.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Write 32-bit big-endian value"] fn write_u32_be (value : u32) -> [u8 ; 4] { value . to_be_bytes () }

- [ ] **Function 'analyze_midi_file' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/trim.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Analyze MIDI file for trimming"] fn analyze_midi_file (data : & [u8] , options : & TrimOptions) -> Result < TrimAnalysis , TrimError > { if data . len () < 14 || & data [0 .. 4] != MIDI_HEADER { return Err (TrimError :: InvalidFormat ("Not a valid MIDI file" . to_string () ,)) ; } let header_length = read_u32_be (data , 4) . ok_or_else (| | TrimError :: InvalidFormat ("Invalid header length" . to_string ())) ? ; let _format = read_u16_be (data , 8) . ok_or_else (| | TrimError :: InvalidFormat ("Invalid format" . to_string ())) ? ; let num_tracks = read_u16_be (data , 10) . ok_or_else (| | TrimError :: InvalidFormat ("Invalid track count" . to_string ())) ? ; let ppqn = read_u16_be (data , 12) . ok_or_else (| | TrimError :: InvalidFormat ("Invalid PPQN" . to_string ())) ? ; let mut offset = 8 + header_length as usize ; let mut first_event_tick : u64 = u64 :: MAX ; let mut last_event_tick : u64 = 0 ; let mut total_events : u32 = 0 ; let mut warnings = Vec :: new () ; for _track_idx in 0 .. num_tracks { if offset + 8 > data . len () { warnings . push ("Truncated track header" . to_string ()) ; break ; } if & data [offset .. offset + 4] != TRACK_HEADER { warnings . push ("Invalid track header" . to_string ()) ; break ; } let track_length = read_u32_be (data , offset + 4) . ok_or_else (| | TrimError :: InvalidFormat ("Invalid track length" . to_string ())) ? as usize ; let track_start = offset + 8 ; let track_end = track_start + track_length ; if track_end > data . len () { warnings . push ("Track extends beyond file" . to_string ()) ; break ; } let mut pos = track_start ; let mut current_tick : u64 = 0 ; let mut running_status : u8 = 0 ; while pos < track_end { if let Some ((delta , vlq_len)) = read_vlq (data , pos) { current_tick += delta as u64 ; pos += vlq_len ; } else { break ; } if pos >= track_end { break ; } let status = data [pos] ; if status == 0xFF { if pos + 2 >= track_end { break ; } let meta_type = data [pos + 1] ; if let Some ((length , vlq_len)) = read_vlq (data , pos + 2) { pos += 2 + vlq_len + length as usize ; if meta_type == 0x2F { break ; } } else { break ; } } else if status == 0xF0 || status == 0xF7 { if let Some ((length , vlq_len)) = read_vlq (data , pos + 1) { pos += 1 + vlq_len + length as usize ; } else { break ; } } else if status & 0x80 != 0 { running_status = status ; pos += 1 ; let event_type = status & 0xF0 ; let data_bytes = match event_type { 0xC0 | 0xD0 => 1 , _ => 2 , } ; if event_type == 0x90 || event_type == 0x80 { total_events += 1 ; if current_tick < first_event_tick { first_event_tick = current_tick ; } if current_tick > last_event_tick { last_event_tick = current_tick ; } } pos += data_bytes ; } else { let event_type = running_status & 0xF0 ; let data_bytes = match event_type { 0xC0 | 0xD0 => 0 , _ => 1 , } ; if event_type == 0x90 || event_type == 0x80 { total_events += 1 ; if current_tick < first_event_tick { first_event_tick = current_tick ; } if current_tick > last_event_tick { last_event_tick = current_tick ; } } pos += 1 + data_bytes ; } } offset = track_end ; } if first_event_tick == u64 :: MAX { first_event_tick = 0 ; } let silence_threshold = options . silence_threshold_ticks . unwrap_or (DEFAULT_SILENCE_THRESHOLD_TICKS) as u64 ; let leading_silence = first_event_tick ; let trailing_silence = if last_event_tick > 0 && offset > 0 { silence_threshold . min (last_event_tick / 10) } else { 0 } ; let original_duration = last_event_tick . max (first_event_tick) ; let ppqn_val = options . ppqn . unwrap_or (ppqn) as f64 ; let original_duration_ms = (original_duration as f64 / ppqn_val) * 500.0 ; let needs_trimming = leading_silence > silence_threshold ; let estimated_trimmed_size = if needs_trimming { (data . len () as f64 * 0.95) as u64 } else { data . len () as u64 } ; let space_savings = if data . len () > 0 { ((data . len () as u64 - estimated_trimmed_size) as f32 / data . len () as f32) * 100.0 } else { 0.0 } ; Ok (TrimAnalysis { file_path : String :: new () , file_type : TrimFileType :: Midi , original_size : data . len () as u64 , original_duration , original_duration_ms , leading_silence , trailing_silence , content_start : first_event_tick , content_end : last_event_tick , recommended_start : first_event_tick , recommended_end : last_event_tick , estimated_trimmed_size , space_savings_percent : space_savings , event_count : Some (total_events) , track_count : Some (num_tracks) , sample_rate : None , channels : None , needs_trimming , warnings , }) }

- [ ] **Function 'trim_midi_file' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/trim.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Trim MIDI file by removing leading silence"] fn trim_midi_file (data : & [u8] , options : & TrimOptions , analysis : & TrimAnalysis ,) -> Result < Vec < u8 > , TrimError > { if data . len () < 14 || & data [0 .. 4] != MIDI_HEADER { return Err (TrimError :: InvalidFormat ("Not a valid MIDI file" . to_string () ,)) ; } let header_length = read_u32_be (data , 4) . ok_or_else (| | TrimError :: InvalidFormat ("Invalid header length" . to_string ())) ? ; let num_tracks = read_u16_be (data , 10) . ok_or_else (| | TrimError :: InvalidFormat ("Invalid track count" . to_string ())) ? ; let trim_start = match options . mode { TrimMode :: LeadingSilence | TrimMode :: BothSilence | TrimMode :: Normalize => { analysis . leading_silence } , TrimMode :: ToRange => options . start_position . unwrap_or (0) , _ => 0 , } ; if trim_start == 0 { return Ok (data . to_vec ()) ; } let mut output = Vec :: with_capacity (data . len ()) ; output . extend_from_slice (& data [0 .. 8 + header_length as usize]) ; let mut offset = 8 + header_length as usize ; for _track_idx in 0 .. num_tracks { if offset + 8 > data . len () { break ; } if & data [offset .. offset + 4] != TRACK_HEADER { break ; } let track_length = read_u32_be (data , offset + 4) . ok_or_else (| | TrimError :: InvalidFormat ("Invalid track length" . to_string ())) ? as usize ; let track_start = offset + 8 ; let track_end = track_start + track_length ; if track_end > data . len () { break ; } let mut new_track_data = Vec :: with_capacity (track_length) ; let mut pos = track_start ; let mut current_tick : u64 = 0 ; let mut running_status : u8 = 0 ; let mut first_event_in_track = true ; while pos < track_end { let event_start = pos ; if let Some ((delta , vlq_len)) = read_vlq (data , pos) { let new_tick = current_tick + delta as u64 ; pos += vlq_len ; if pos >= track_end { break ; } let status = data [pos] ; let event_data_start = pos ; let event_end ; if status == 0xFF { if pos + 2 >= track_end { break ; } let meta_type = data [pos + 1] ; if let Some ((length , vlq_len)) = read_vlq (data , pos + 2) { event_end = pos + 2 + vlq_len + length as usize ; let is_tempo_event = meta_type == 0x51 || meta_type == 0x58 ; let should_preserve = options . preserve_tempo_events && is_tempo_event ; if should_preserve || new_tick >= trim_start { let adjusted_tick = if new_tick >= trim_start { new_tick - trim_start } else { 0 } ; let new_delta = if first_event_in_track { adjusted_tick as u32 } else { (adjusted_tick - current_tick . saturating_sub (trim_start)) as u32 } ; new_track_data . extend (write_vlq (new_delta)) ; new_track_data . extend_from_slice (& data [event_data_start .. event_end]) ; first_event_in_track = false ; } if meta_type == 0x2F { pos = event_end ; break ; } } else { break ; } } else if status == 0xF0 || status == 0xF7 { if let Some ((length , vlq_len)) = read_vlq (data , pos + 1) { event_end = pos + 1 + vlq_len + length as usize ; if new_tick >= trim_start { let adjusted_delta = (new_tick - trim_start) as u32 ; let new_delta = if first_event_in_track { adjusted_delta } else { adjusted_delta . saturating_sub ((current_tick . saturating_sub (trim_start)) as u32 ,) } ; new_track_data . extend (write_vlq (new_delta)) ; new_track_data . extend_from_slice (& data [event_data_start .. event_end]) ; first_event_in_track = false ; } } else { break ; } } else if status & 0x80 != 0 { running_status = status ; let event_type = status & 0xF0 ; let data_bytes = match event_type { 0xC0 | 0xD0 => 1 , _ => 2 , } ; event_end = pos + 1 + data_bytes ; if new_tick >= trim_start { let adjusted_delta = (new_tick - trim_start) as u32 ; let new_delta = if first_event_in_track { adjusted_delta } else { adjusted_delta . saturating_sub ((current_tick . saturating_sub (trim_start)) as u32) } ; new_track_data . extend (write_vlq (new_delta)) ; new_track_data . extend_from_slice (& data [event_data_start .. event_end]) ; first_event_in_track = false ; } } else { let event_type = running_status & 0xF0 ; let data_bytes = match event_type { 0xC0 | 0xD0 => 1 , _ => 2 , } ; event_end = pos + data_bytes ; if new_tick >= trim_start { let adjusted_delta = (new_tick - trim_start) as u32 ; let new_delta = if first_event_in_track { adjusted_delta } else { adjusted_delta . saturating_sub ((current_tick . saturating_sub (trim_start)) as u32) } ; new_track_data . extend (write_vlq (new_delta)) ; new_track_data . extend_from_slice (& data [event_data_start .. event_end]) ; first_event_in_track = false ; } } current_tick = new_tick ; pos = event_end ; } else { break ; } } if ! new_track_data . ends_with (END_OF_TRACK) { new_track_data . extend (write_vlq (0)) ; new_track_data . extend_from_slice (END_OF_TRACK) ; } output . extend_from_slice (TRACK_HEADER) ; output . extend_from_slice (& write_u32_be (new_track_data . len () as u32)) ; output . extend (new_track_data) ; offset = track_end ; } Ok (output) }

- [ ] **Function 'current_timestamp_ms' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/trim.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Get current timestamp in milliseconds"] fn current_timestamp_ms () -> u64 { std :: time :: SystemTime :: now () . duration_since (std :: time :: UNIX_EPOCH) . map (| d | d . as_millis () as u64) . unwrap_or (0) }

- [ ] **Function 'analyze_file_impl' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/trim.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Analyze a file for potential trimming"] pub fn analyze_file_impl (path : & str , options : & TrimOptions) -> Result < TrimAnalysis , TrimError > { let file_path = Path :: new (path) ; let data = read_file_bytes (file_path) ? ; let file_type = match options . file_type { TrimFileType :: Auto => detect_file_type (file_path , & data) , ft => ft , } ; let mut analysis = match file_type { TrimFileType :: Midi => analyze_midi_file (& data , options) ? , TrimFileType :: Audio => { return Err (TrimError :: UnsupportedFileType ("Audio trimming not yet implemented" . to_string () ,)) ; } , TrimFileType :: Auto => { return Err (TrimError :: InvalidFormat ("Could not detect file type" . to_string () ,)) ; } , } ; analysis . file_path = path . to_string () ; analysis . file_type = file_type ; Ok (analysis) }

- [ ] **Function 'trim_file_impl' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/trim.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Trim a single file"] pub fn trim_file_impl (path : & str , options : & TrimOptions) -> Result < TrimResult , TrimError > { let start_time = current_timestamp_ms () ; let file_path = Path :: new (path) ; let data = read_file_bytes (file_path) ? ; let file_type = match options . file_type { TrimFileType :: Auto => detect_file_type (file_path , & data) , ft => ft , } ; let analysis = match file_type { TrimFileType :: Midi => analyze_midi_file (& data , options) ? , _ => { return Err (TrimError :: UnsupportedFileType ("Only MIDI files supported" . to_string () ,)) ; } , } ; if ! analysis . needs_trimming { return Ok (TrimResult { original_path : path . to_string () , output_path : path . to_string () , backup_path : None , success : true , error : None , original_size : data . len () as u64 , trimmed_size : data . len () as u64 , bytes_saved : 0 , original_duration : analysis . original_duration , trimmed_duration : analysis . original_duration , removed_from_start : 0 , removed_from_end : 0 , processing_time_ms : current_timestamp_ms () - start_time , }) ; } let backup_path = if options . create_backup { let suffix = options . backup_suffix . as_deref () . unwrap_or (".bak") ; let backup = format ! ("{}{}" , path , suffix) ; fs :: copy (file_path , & backup) . map_err (TrimError :: Io) ? ; Some (backup) } else { None } ; let trimmed_data = match file_type { TrimFileType :: Midi => trim_midi_file (& data , options , & analysis) ? , _ => data . clone () , } ; let output_path = options . output_path . clone () . unwrap_or_else (| | path . to_string ()) ; let output_file_path = Path :: new (& output_path) ; if output_file_path . exists () && ! options . overwrite && output_path != path { return Err (TrimError :: WriteError (format ! ("Output file already exists: {}" , output_path))) ; } fs :: write (output_file_path , & trimmed_data) . map_err (TrimError :: Io) ? ; let processing_time = current_timestamp_ms () - start_time ; Ok (TrimResult { original_path : path . to_string () , output_path , backup_path , success : true , error : None , original_size : data . len () as u64 , trimmed_size : trimmed_data . len () as u64 , bytes_saved : data . len () as i64 - trimmed_data . len () as i64 , original_duration : analysis . original_duration , trimmed_duration : analysis . original_duration - analysis . leading_silence , removed_from_start : analysis . leading_silence , removed_from_end : analysis . trailing_silence , processing_time_ms : processing_time , }) }

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/trim.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/trim.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/trim.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/trim.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/trim.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/trim.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/trim.rs`
  - Category: Performance

- [ ] **Function 'get_trim_modes' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/trim.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Get available trim modes"] # [command] pub fn get_trim_modes () -> Vec < String > { vec ! ["leading_silence" . to_string () , "trailing_silence" . to_string () , "both_silence" . to_string () , "to_range" . to_string () , "to_time_range" . to_string () , "to_loop_region" . to_string () , "to_selection" . to_string () , "normalize" . to_string () ,] }

- [ ] **Function 'get_default_trim_options' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/trim.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Get default trim options"] # [command] pub fn get_default_trim_options () -> TrimOptions { TrimOptions :: default () }

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/window.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/window.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/window.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/window.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/window.rs`
  - Category: Performance

- [ ] **Function 'key_distance' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/core/compatibility/music.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Calculate distance between two keys in semitones"] # [doc = ""] # [doc = " Returns the minimum distance around the circle of fifths (0-6)."] # [doc = " Example: C to G is 5 semitones (perfect fifth)."] # [doc = ""] # [doc = " # Arguments"] # [doc = " * `key1` - First key"] # [doc = " * `key2` - Second key"] # [doc = ""] # [doc = " # Returns"] # [doc = " Minimum distance (0-6 semitones)"] pub fn key_distance (key1 : Key , key2 : Key) -> i32 { let diff = (key1 . semitone () - key2 . semitone ()) . abs () ; diff . min (12 - diff) }

- [ ] **Function 'keys_compatible' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/core/compatibility/music.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Check if two key signatures are compatible"] # [doc = ""] # [doc = " Keys are compatible if they:"] # [doc = " - Are the same key"] # [doc = " - Are relative major/minor (share the same notes)"] # [doc = " - Are a perfect fifth apart (circle of fifths)"] pub fn keys_compatible (ks1 : & KeySignature , ks2 : & KeySignature) -> bool { if ks1 . key == ks2 . key && ks1 . mode == ks2 . mode { return true ; } if is_relative_key (ks1 , ks2) { return true ; } let distance = key_distance (ks1 . key , ks2 . key) ; if distance == 5 { return true ; } false }

- [ ] **Function 'is_relative_key' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/core/compatibility/music.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Check if two keys are relative (share the same notes)"] # [doc = ""] # [doc = " Relative keys have different modes but share the same notes."] # [doc = " Example: C Major and A Minor are relative keys."] # [doc = ""] # [doc = " # Arguments"] # [doc = " * `ks1` - First key signature"] # [doc = " * `ks2` - Second key signature"] # [doc = ""] # [doc = " # Returns"] # [doc = " True if keys are relative (e.g., C Major and A Minor)"] pub fn is_relative_key (ks1 : & KeySignature , ks2 : & KeySignature) -> bool { if ks1 . mode == ks2 . mode { return false ; } let major = if ks1 . mode == Mode :: Major { ks1 } else { ks2 } ; let minor = if ks1 . mode == Mode :: Minor { ks1 } else { ks2 } ; let diff = (major . key . semitone () - minor . key . semitone () + 12) % 12 ; diff == 3 }

- [ ] **Function 'key_compatibility_score' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/core/compatibility/music.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Get compatibility score for two key signatures (0-100)"] # [doc = ""] # [doc = " Scoring:"] # [doc = " - 100: Same key and mode (perfect match)"] # [doc = " - 95: Relative major/minor (share notes)"] # [doc = " - 85: Perfect fifth apart (circle of fifths)"] # [doc = " - 70: Major/minor third apart"] # [doc = " - 55: Whole tone apart"] # [doc = " - 40: Semitone apart"] # [doc = " - 20: Tritone (augmented fourth)"] pub fn key_compatibility_score (ks1 : & KeySignature , ks2 : & KeySignature) -> f32 { if ks1 . key == ks2 . key && ks1 . mode == ks2 . mode { return 100.0 ; } if is_relative_key (ks1 , ks2) { return 95.0 ; } let distance = key_distance (ks1 . key , ks2 . key) ; if distance == 5 { return 85.0 ; } if distance == 3 || distance == 4 { return 70.0 ; } if distance == 2 { return 55.0 ; } if distance == 1 { return 40.0 ; } if distance == 6 { return 20.0 ; } 50.0 }

- [ ] **Function 'bpm_compatibility_score' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/core/compatibility/music.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Calculate BPM compatibility score (0-100)"] # [doc = ""] # [doc = " Scores tempo similarity for DJ mixing and mashups."] # [doc = ""] # [doc = " # Arguments"] # [doc = " * `bpm1` - First tempo in BPM"] # [doc = " * `bpm2` - Second tempo in BPM"] # [doc = ""] # [doc = " # Returns"] # [doc = " Compatibility score (0-100)"] pub fn bpm_compatibility_score (bpm1 : f32 , bpm2 : f32) -> f32 { let diff = (bpm1 - bpm2) . abs () ; if diff < 1.0 { return 100.0 ; } if diff < 5.0 { return 95.0 - (diff * 1.0) ; } if diff < 10.0 { return 90.0 - (diff * 0.5) ; } if diff < 20.0 { return 80.0 - (diff * 0.3) ; } if diff < 40.0 { return 70.0 - (diff * 0.2) ; } 30.0 }

- [ ] **Function 'bpm_time_stretchable' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/core/compatibility/music.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Check if BPMs can be time-stretched to match"] # [doc = ""] # [doc = " Returns true if the tempo ratio matches common musical ratios:"] # [doc = " - 2:1 (double-time)"] # [doc = " - 3:2 (sesquialtera)"] # [doc = " - 4:3 (perfect fourth)"] # [doc = " - And their inverses"] # [doc = ""] # [doc = " # Arguments"] # [doc = " * `bpm1` - First tempo"] # [doc = " * `bpm2` - Second tempo"] # [doc = ""] # [doc = " # Returns"] # [doc = " True if tempos can be time-stretched with minimal artifacts"] pub fn bpm_time_stretchable (bpm1 : f32 , bpm2 : f32) -> bool { let ratio = bpm1 / bpm2 ; let ratios = [2.0 , 1.5 , 1.333 , 0.5 , 0.667 , 0.75] ; for target_ratio in ratios { if (ratio - target_ratio) . abs () < 0.1 { return true ; } } false }

- [ ] **Function 'calculate_compatibility' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/core/compatibility/scoring.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Calculate overall compatibility score between two MIDI files"] # [doc = ""] # [doc = " This is the main entry point for compatibility calculation."] # [doc = " It combines multiple factors with weighted scoring:"] # [doc = " - 40% Key compatibility (harmonic compatibility)"] # [doc = " - 40% BPM compatibility (tempo matching)"] # [doc = " - 20% Category compatibility (style/instrument matching)"] # [doc = ""] # [doc = " # Arguments"] # [doc = " * `source` - The source file to compare against"] # [doc = " * `candidate` - The candidate file to score"] # [doc = ""] # [doc = " # Returns"] # [doc = " CompatibilityScore with detailed breakdown"] pub fn calculate_compatibility (source : & MidiFile , candidate : & MidiFile) -> CompatibilityScore { let mut total_score = 0.0 ; let mut explanations = Vec :: new () ; let key_score = if let (Some (key1_str) , Some (key2_str)) = (& source . key_signature , & candidate . key_signature) { if let (Some (key1) , Some (key2)) = (KeySignature :: parse (key1_str) , KeySignature :: parse (key2_str)) { let score = key_compatibility_score (& key1 , & key2) ; if score >= 95.0 { explanations . push ("Perfect key match" . to_string ()) ; } else if score >= 85.0 { explanations . push ("Excellent key compatibility" . to_string ()) ; } else if score >= 70.0 { explanations . push ("Good key compatibility" . to_string ()) ; } else if score < 50.0 { explanations . push ("Keys may clash" . to_string ()) ; } total_score += score * 0.4 ; score } else { 50.0 } } else { 50.0 } ; let bpm_score = if let (Some (bpm1) , Some (bpm2)) = (source . bpm , candidate . bpm) { let score = bpm_compatibility_score (bpm1 as f32 , bpm2 as f32) ; if score >= 95.0 { explanations . push ("Nearly identical tempo" . to_string ()) ; } else if score >= 80.0 { explanations . push ("Similar tempo" . to_string ()) ; } else if bpm_time_stretchable (bpm1 as f32 , bpm2 as f32) { explanations . push ("Tempo can be time-stretched" . to_string ()) ; } else if score < 50.0 { explanations . push ("Very different tempos" . to_string ()) ; } total_score += score * 0.4 ; score } else { 50.0 } ; let category_score = if let (Some (cat1) , Some (cat2)) = (& source . primary_category , & candidate . primary_category) { let score = if cat1 == cat2 { 100.0 } else { category_compatibility (cat1 , cat2) } ; if score >= 90.0 { explanations . push ("Same or complementary category" . to_string ()) ; } total_score += score * 0.2 ; score } else { 50.0 } ; let explanation = if explanations . is_empty () { "Limited metadata available" . to_string () } else { explanations . join (". ") } ; CompatibilityScore { total_score , key_score , bpm_score , category_score , explanation } }

- [ ] **Function 'category_compatibility' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/core/compatibility/scoring.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Determine category compatibility"] # [doc = ""] # [doc = " Scores how well two categories work together musically."] # [doc = " Same category = 100, complementary categories = 80, different = 50."] fn category_compatibility (cat1 : & str , cat2 : & str) -> f32 { let cat1 = cat1 . to_lowercase () ; let cat2 = cat2 . to_lowercase () ; if cat1 == cat2 { return 100.0 ; } let complementary_pairs = vec ! [("kick" , "bass") , ("kick" , "drum") , ("snare" , "hihat") , ("bass" , "chord") , ("chord" , "lead") , ("pad" , "lead") , ("melody" , "chord") , ("drum" , "percussion") ,] ; for (a , b) in complementary_pairs { if (cat1 . contains (a) && cat2 . contains (b)) || (cat1 . contains (b) && cat2 . contains (a)) { return 80.0 ; } } 50.0 }

- [ ] **Function 'explain_compatibility' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/core/compatibility/scoring.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Generate human-readable explanation for compatibility score"] # [doc = ""] # [doc = " Creates a summary explanation based on the overall score."] # [doc = ""] # [doc = " # Arguments"] # [doc = " * `source` - Source file (not currently used, but available for context)"] # [doc = " * `candidate` - Candidate file (not currently used, but available for context)"] # [doc = " * `score` - The compatibility score to explain"] # [doc = ""] # [doc = " # Returns"] # [doc = " Human-readable explanation string"] pub fn explain_compatibility (_source : & MidiFile , _candidate : & MidiFile , score : & CompatibilityScore ,) -> String { let mut parts = Vec :: new () ; if score . total_score >= 90.0 { parts . push ("Highly compatible" . to_string ()) ; } else if score . total_score >= 75.0 { parts . push ("Very compatible" . to_string ()) ; } else if score . total_score >= 60.0 { parts . push ("Compatible" . to_string ()) ; } else if score . total_score >= 50.0 { parts . push ("Somewhat compatible" . to_string ()) ; } else { parts . push ("Limited compatibility" . to_string ()) ; } parts . push (score . explanation . clone ()) ; parts . join (". ") }

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/core/compatibility/scoring.rs`
  - Category: Performance

- [ ] **Function 'create_test_file' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/core/compatibility/scoring.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn create_test_file () -> MidiFile { MidiFile { id : 1 , filename : "test.mid" . to_string () , filepath : "/test/test.mid" . to_string () , file_size_bytes : 1024 , content_hash : vec ! [] , is_multi_track : false , parent_file_id : None , track_number : None , total_tracks : None , manufacturer : None , collection_name : None , folder_tags : vec ! [] , parent_folder : None , num_tracks : 1 , created_at : chrono :: Utc :: now () , analyzed_at : None , bpm : Some (120.0) , key_signature : Some ("C" . to_string ()) , time_signature : Some ("4/4" . to_string ()) , duration_seconds : Some (10.0) , total_notes : 100 , primary_category : Some ("bass" . to_string ()) , } }

- [ ] **Function 'load_midi_file' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/core/midi/loader.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Load and parse a MIDI file from disk"] # [doc = ""] # [doc = " Returns all MIDI events with absolute tick positions."] # [doc = ""] # [doc = " # Arguments"] # [doc = " * `filepath` - Path to the MIDI file"] # [doc = ""] # [doc = " # Returns"] # [doc = " Result containing vector of parsed MIDI events with timing information"] pub fn load_midi_file (filepath : & str) -> Result < LoadedMidiFile , String > { let path = Path :: new (filepath) ; if ! path . exists () { return Err (format ! ("MIDI file not found: {}" , filepath)) ; } let bytes = fs :: read (path) . map_err (| e | format ! ("Failed to read MIDI file {}: {}" , filepath , e)) ? ; let smf = Smf :: parse (& bytes) . map_err (| e | format ! ("Failed to parse MIDI file {}: {}" , filepath , e)) ? ; let ticks_per_quarter = match smf . header . timing { Timing :: Metrical (tpq) => tpq . as_int () as u32 , Timing :: Timecode (fps , sub) => { let ticks_per_second = fps . as_f32 () * sub as f32 ; (ticks_per_second * 0.5) as u32 } , } ; let format_num = match smf . header . format { midly :: Format :: SingleTrack => 0 , midly :: Format :: Parallel => 1 , midly :: Format :: Sequential => 2 , } ; debug ! ("Loaded MIDI file: {} (format {}, {} tracks, {} ticks/quarter)" , filepath , format_num , smf . tracks . len () , ticks_per_quarter) ; let mut all_events = Vec :: new () ; for (track_idx , track) in smf . tracks . iter () . enumerate () { let track_events = parse_track_events (track , track_idx as u8 , ticks_per_quarter) ? ; all_events . extend (track_events) ; } all_events . sort_by_key (| e | e . tick) ; Ok (LoadedMidiFile { events : all_events , ticks_per_quarter , num_tracks : smf . tracks . len () as u16 , format : format_num , }) }

- [ ] **Function 'parse_track_events' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/core/midi/loader.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Parse events from a single MIDI track"] fn parse_track_events (track : & midly :: Track , default_channel : u8 , ticks_per_quarter : u32 ,) -> Result < Vec < MidiEvent > , String > { let mut events = Vec :: new () ; let mut absolute_tick : u64 = 0 ; let mut current_channel = default_channel ; for event in track . iter () { absolute_tick += event . delta . as_int () as u64 ; match event . kind { TrackEventKind :: Midi { channel , message } => { current_channel = channel . as_int () ; if let Some (midi_event) = convert_midi_message (message , current_channel , absolute_tick , ticks_per_quarter) { events . push (midi_event) ; } } , TrackEventKind :: Meta (_) => { } , TrackEventKind :: SysEx (_) => { } , TrackEventKind :: Escape (_) => { } , } } debug ! ("Parsed {} events from track (channel {})" , events . len () , current_channel) ; Ok (events) }

- [ ] **Function 'convert_midi_message' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/core/midi/loader.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Convert midly MIDI message to our MidiEvent format"] fn convert_midi_message (message : MidlyMessage , channel : u8 , tick : u64 , _ticks_per_quarter : u32 ,) -> Option < MidiEvent > { match message { MidlyMessage :: NoteOff { key , vel } => Some (MidiEvent { event_type : MidiEventType :: NoteOff , tick , channel , note : Some (key . as_int ()) , velocity : Some (vel . as_int ()) , controller : None , value : None , program : None , }) , MidlyMessage :: NoteOn { key , vel } => { let event_type = if vel . as_int () == 0 { MidiEventType :: NoteOff } else { MidiEventType :: NoteOn } ; Some (MidiEvent { event_type , tick , channel , note : Some (key . as_int ()) , velocity : Some (vel . as_int ()) , controller : None , value : None , program : None , }) } , MidlyMessage :: Aftertouch { key , vel } => Some (MidiEvent { event_type : MidiEventType :: Aftertouch , tick , channel , note : Some (key . as_int ()) , value : Some (vel . as_int ()) , velocity : None , controller : None , program : None , }) , MidlyMessage :: Controller { controller , value } => Some (MidiEvent { event_type : MidiEventType :: ControlChange , tick , channel , controller : Some (controller . as_int ()) , value : Some (value . as_int ()) , note : None , velocity : None , program : None , }) , MidlyMessage :: ProgramChange { program } => Some (MidiEvent { event_type : MidiEventType :: ProgramChange , tick , channel , program : Some (program . as_int ()) , note : None , velocity : None , controller : None , value : None , }) , MidlyMessage :: ChannelAftertouch { vel } => Some (MidiEvent { event_type : MidiEventType :: Aftertouch , tick , channel , value : Some (vel . as_int ()) , note : None , velocity : None , controller : None , program : None , }) , MidlyMessage :: PitchBend { bend } => { let bend_value = bend . as_int () as u16 ; Some (MidiEvent { event_type : MidiEventType :: PitchBend , tick , channel , value : Some ((bend_value & 0x7F) as u8) , velocity : Some (((bend_value >> 7) & 0x7F) as u8) , note : None , controller : None , program : None , }) } , } }

- [ ] **Function 'parse_midi' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/core/midi/parser.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Parse complete MIDI file"] pub fn parse_midi (data : & [u8]) -> Result < MidiPattern , ParseError > { if data . is_empty () { return Err (ParseError :: IncompleteData (0)) ; } let mut reader = MidiReader :: new (data) ; let header = parse_header (& mut reader) ? ; let mut all_events = Vec :: new () ; for _ in 0 .. header . num_tracks { let track_events = parse_track (& mut reader) ? ; all_events . extend (track_events) ; } all_events . sort_by_key (| e | e . tick) ; let total_ticks = all_events . last () . map (| e | e . tick) . unwrap_or (0) ; Ok (MidiPattern { events : all_events , ticks_per_quarter_note : header . ticks_per_quarter_note , total_ticks , }) }

- [ ] **Function 'parse_header' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/core/midi/parser.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Parse MIDI header (MThd chunk)"] fn parse_header (reader : & mut MidiReader) -> Result < MidiHeader , ParseError > { let chunk_type = reader . read_bytes (4) ? ; if chunk_type != b"MThd" { return Err (ParseError :: InvalidFormat ("Expected MThd header" . to_string () ,)) ; } let length = reader . read_u32 () ? ; if length != 6 { return Err (ParseError :: InvalidFormat (format ! ("Invalid header length: {}" , length))) ; } let format = reader . read_u16 () ? ; if format > 2 { return Err (ParseError :: UnsupportedFormat (format ! ("MIDI format {}" , format))) ; } let num_tracks = reader . read_u16 () ? ; let ticks_per_quarter_note = reader . read_u16 () ? ; Ok (MidiHeader { num_tracks , ticks_per_quarter_note }) }

- [ ] **Function 'parse_track' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/core/midi/parser.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Parse a single track (MTrk chunk)"] fn parse_track (reader : & mut MidiReader) -> Result < Vec < MidiEvent > , ParseError > { let chunk_type = reader . read_bytes (4) ? ; if chunk_type != b"MTrk" { return Err (ParseError :: InvalidTrack ("Expected MTrk header" . to_string ())) ; } let track_length = reader . read_u32 () ? as usize ; let track_end = reader . position () + track_length ; let mut events = Vec :: new () ; let mut current_tick : u64 = 0 ; let mut running_status : Option < u8 > = None ; while reader . position () < track_end { let delta_time = reader . read_variable_length () ? ; current_tick += delta_time ; let status_byte = reader . peek_u8 () ? ; let status = if status_byte & 0x80 == 0 { running_status . ok_or (ParseError :: InvalidTrack ("No running status available" . to_string () ,)) ? } else { let s = reader . read_u8 () ? ; if s != 0xFF && s != 0xF0 && s != 0xF7 { running_status = Some (s) ; } s } ; if status == 0xFF { let _meta_type = reader . read_u8 () ? ; let length = reader . read_variable_length () ? ; reader . skip (length as usize) ? ; } else if status == 0xF0 || status == 0xF7 { let length = reader . read_variable_length () ? ; reader . skip (length as usize) ? ; } else { let command = status & 0xF0 ; let channel = status & 0x0F ; let event = match command { 0x90 => { let note = reader . read_u8 () ? ; let velocity = reader . read_u8 () ? ; Some (MidiEvent { event_type : MidiEventType :: NoteOn , tick : current_tick , channel , note : Some (note) , velocity : Some (velocity) , controller : None , value : None , program : None , }) } , 0x80 => { let note = reader . read_u8 () ? ; let _velocity = reader . read_u8 () ? ; Some (MidiEvent { event_type : MidiEventType :: NoteOff , tick : current_tick , channel , note : Some (note) , velocity : Some (0) , controller : None , value : None , program : None , }) } , 0xB0 => { let controller = reader . read_u8 () ? ; let value = reader . read_u8 () ? ; Some (MidiEvent { event_type : MidiEventType :: ControlChange , tick : current_tick , channel , note : None , velocity : None , controller : Some (controller) , value : Some (value) , program : None , }) } , 0xC0 => { let program = reader . read_u8 () ? ; Some (MidiEvent { event_type : MidiEventType :: ProgramChange , tick : current_tick , channel , note : None , velocity : None , controller : None , value : None , program : Some (program) , }) } , 0xE0 => { let _lsb = reader . read_u8 () ? ; let _msb = reader . read_u8 () ? ; Some (MidiEvent { event_type : MidiEventType :: PitchBend , tick : current_tick , channel , note : None , velocity : None , controller : None , value : None , program : None , }) } , 0xD0 => { let _value = reader . read_u8 () ? ; Some (MidiEvent { event_type : MidiEventType :: Aftertouch , tick : current_tick , channel , note : None , velocity : None , controller : None , value : None , program : None , }) } , _ => None , } ; if let Some (e) = event { events . push (e) ; } } } Ok (events) }

- [ ] **Function 'make_valid_header' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/core/midi/parser.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn make_valid_header (format : u16 , num_tracks : u16 , ticks : u16) -> Vec < u8 > { let mut data = vec ! [] ; data . extend_from_slice (b"MThd") ; data . extend_from_slice (& 6u32 . to_be_bytes ()) ; data . extend_from_slice (& format . to_be_bytes ()) ; data . extend_from_slice (& num_tracks . to_be_bytes ()) ; data . extend_from_slice (& ticks . to_be_bytes ()) ; data }

- [ ] **Function 'make_track_header' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/core/midi/parser.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn make_track_header (length : u32) -> Vec < u8 > { let mut data = vec ! [] ; data . extend_from_slice (b"MTrk") ; data . extend_from_slice (& length . to_be_bytes ()) ; data }

- [ ] **Function 'make_simple_midi_file' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/core/midi/parser.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn make_simple_midi_file () -> Vec < u8 > { let mut data = vec ! [] ; data . extend_from_slice (& make_valid_header (1 , 1 , 480)) ; let mut track = vec ! [] ; track . extend_from_slice (& [0x00 , 0x90 , 0x3C , 0x64]) ; track . extend_from_slice (& [0x60 , 0x80 , 0x3C , 0x00]) ; data . extend_from_slice (& make_track_header (track . len () as u32)) ; data . extend_from_slice (& track) ; data }

- [ ] **Function 'validate_channel' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/core/midi/validator.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Validate MIDI channel (0-15)"] # [doc = ""] # [doc = " MIDI channels are 0-indexed (0-15 represent MIDI channels 1-16)."] pub fn validate_channel (channel : u8) -> Result < u8 , String > { if channel > 15 { Err (format ! ("Invalid MIDI channel: {}. Must be 0-15" , channel)) } else { Ok (channel) } }

- [ ] **Function 'validate_note' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/core/midi/validator.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Validate MIDI note (0-127)"] # [doc = ""] # [doc = " MIDI note numbers range from 0 to 127 (C-1 to G9)."] pub fn validate_note (note : u8) -> Result < u8 , String > { if note > 127 { Err (format ! ("Invalid MIDI note: {}. Must be 0-127" , note)) } else { Ok (note) } }

- [ ] **Function 'validate_velocity' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/core/midi/validator.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Validate MIDI velocity (0-127)"] # [doc = ""] # [doc = " Velocity 0 is treated as note off in some contexts."] pub fn validate_velocity (velocity : u8) -> Result < u8 , String > { if velocity > 127 { Err (format ! ("Invalid velocity: {}. Must be 0-127" , velocity)) } else { Ok (velocity) } }

- [ ] **Function 'validate_control_value' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/core/midi/validator.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Validate MIDI control value (0-127)"] # [doc = ""] # [doc = " Used for control change messages and other data values."] pub fn validate_control_value (value : u8) -> Result < u8 , String > { if value > 127 { Err (format ! ("Invalid control value: {}. Must be 0-127" , value)) } else { Ok (value) } }

- [ ] **Function 'validate_message' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/core/midi/validator.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Validate complete MIDI message"] # [doc = ""] # [doc = " Performs comprehensive validation of all message fields."] pub fn validate_message (msg : & MidiMessage) -> Result < () , String > { validate_channel (msg . channel) ? ; match msg . event_type { MidiEventType :: NoteOn | MidiEventType :: NoteOff => { validate_note (msg . data1) ? ; validate_velocity (msg . data2) ? ; } , MidiEventType :: ControlChange => { validate_control_value (msg . data1) ? ; validate_control_value (msg . data2) ? ; } , MidiEventType :: ProgramChange => { validate_control_value (msg . data1) ? ; } , MidiEventType :: Aftertouch => { validate_control_value (msg . data1) ? ; } , MidiEventType :: PitchBend => { } , } Ok (()) }

- [ ] **Function 'write_midi_file' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/core/midi/writer.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Write MIDI file from events"] # [doc = ""] # [doc = " Pure function that generates MIDI file bytes from event data."] # [doc = " Takes events, timing resolution, and tempo as input."] # [doc = ""] # [doc = " # Arguments"] # [doc = ""] # [doc = " * `events` - Slice of MIDI events to write"] # [doc = " * `ticks_per_quarter` - Timing resolution (typically 480 or 960)"] # [doc = " * `tempo_bpm` - Tempo in beats per minute (e.g., 120.0)"] # [doc = ""] # [doc = " # Returns"] # [doc = ""] # [doc = " * `Ok(Vec<u8>)` - Complete MIDI file as bytes"] # [doc = " * `Err(String)` - Error message if generation fails"] # [doc = ""] pub fn write_midi_file (events : & [MidiEvent] , ticks_per_quarter : u16 , tempo_bpm : f32 ,) -> Result < Vec < u8 > , String > { let mut data = Vec :: new () ; write_header (& mut data , 1 , 1 , ticks_per_quarter) ; write_track (& mut data , events , tempo_bpm , ticks_per_quarter) ; Ok (data) }

- [ ] **Function 'write_header' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/core/midi/writer.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Write MIDI header chunk (MThd)"] fn write_header (data : & mut Vec < u8 > , format : u16 , tracks : u16 , tpqn : u16) { data . extend_from_slice (b"MThd") ; data . extend_from_slice (& 6u32 . to_be_bytes ()) ; data . extend_from_slice (& format . to_be_bytes ()) ; data . extend_from_slice (& tracks . to_be_bytes ()) ; data . extend_from_slice (& tpqn . to_be_bytes ()) ; }

- [ ] **Function 'write_track' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/core/midi/writer.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Write MIDI track chunk (MTrk)"] fn write_track (data : & mut Vec < u8 > , events : & [MidiEvent] , tempo_bpm : f32 , _tpqn : u16) { let mut track_data = Vec :: new () ; write_tempo_event (& mut track_data , tempo_bpm) ; let mut last_tick = 0u64 ; for event in events { let delta = event . tick . saturating_sub (last_tick) ; write_variable_length (& mut track_data , delta) ; write_event (& mut track_data , event) ; last_tick = event . tick ; } write_variable_length (& mut track_data , 0) ; track_data . extend_from_slice (& [0xFF , 0x2F , 0x00]) ; data . extend_from_slice (b"MTrk") ; data . extend_from_slice (& (track_data . len () as u32) . to_be_bytes ()) ; data . extend_from_slice (& track_data) ; }

- [ ] **Function 'write_tempo_event' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/core/midi/writer.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Write tempo meta event"] # [doc = ""] # [doc = " MIDI tempo is stored as microseconds per quarter note."] # [doc = " Conversion: microseconds_per_quarter = 60,000,000 / BPM"] fn write_tempo_event (data : & mut Vec < u8 > , bpm : f32) { let microseconds_per_quarter = (60_000_000.0 / bpm) as u32 ; write_variable_length (data , 0) ; data . push (0xFF) ; data . push (0x51) ; data . push (0x03) ; data . extend_from_slice (& microseconds_per_quarter . to_be_bytes () [1 .. 4]) ; }

- [ ] **Function 'write_event' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/core/midi/writer.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Write single MIDI event"] fn write_event (data : & mut Vec < u8 > , event : & MidiEvent) { match event . event_type { MidiEventType :: NoteOn => { data . push (0x90 | (event . channel & 0x0F)) ; data . push (event . note . unwrap_or (0) & 0x7F) ; data . push (event . velocity . unwrap_or (100) & 0x7F) ; } , MidiEventType :: NoteOff => { data . push (0x80 | (event . channel & 0x0F)) ; data . push (event . note . unwrap_or (0) & 0x7F) ; data . push (0x00) ; } , MidiEventType :: ControlChange => { data . push (0xB0 | (event . channel & 0x0F)) ; data . push (event . controller . unwrap_or (0) & 0x7F) ; data . push (event . value . unwrap_or (0) & 0x7F) ; } , MidiEventType :: ProgramChange => { data . push (0xC0 | (event . channel & 0x0F)) ; data . push (event . program . unwrap_or (0) & 0x7F) ; } , MidiEventType :: PitchBend => { data . push (0xE0 | (event . channel & 0x0F)) ; data . push (0x00) ; data . push (0x40) ; } , MidiEventType :: Aftertouch => { data . push (0xD0 | (event . channel & 0x0F)) ; data . push (0x00) ; } , } }

- [ ] **Function 'write_variable_length' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/core/midi/writer.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Write variable-length quantity (MIDI standard encoding)"] # [doc = ""] # [doc = " MIDI uses variable-length quantities to save space."] # [doc = " - Values 0-127: single byte (0xxxxxxx)"] # [doc = " - Larger values: multiple bytes (1xxxxxxx 1xxxxxxx ... 0xxxxxxx)"] # [doc = " - Most significant bit = 1 means \"more bytes follow\""] # [doc = " - Each byte contributes 7 bits to the value"] # [doc = ""] # [doc = " Examples:"] # [doc = " - 0 â†’ [0x00]"] # [doc = " - 127 â†’ [0x7F]"] # [doc = " - 128 â†’ [0x81, 0x00]"] # [doc = " - 8192 â†’ [0xC0, 0x00]"] fn write_variable_length (data : & mut Vec < u8 > , mut value : u64) { let mut bytes = Vec :: new () ; bytes . push ((value & 0x7F) as u8) ; value >>= 7 ; while value > 0 { bytes . push (((value & 0x7F) | 0x80) as u8) ; value >>= 7 ; } bytes . reverse () ; data . extend_from_slice (& bytes) ; }

- [ ] **Function 'microseconds_per_tick' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/core/sequencer/timing.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Calculate microseconds per tick at given BPM"] # [doc = ""] # [doc = " Used for high-precision timing in MIDI playback."] # [doc = ""] # [doc = " # Arguments"] # [doc = " * `bpm` - Beats per minute"] # [doc = " * `ticks_per_quarter` - MIDI resolution (typically 480)"] # [doc = ""] # [doc = " # Returns"] # [doc = " Microseconds per tick as f64"] pub fn microseconds_per_tick (bpm : f32 , ticks_per_quarter : u16) -> f64 { let microseconds_per_minute = 60_000_000.0 ; let microseconds_per_beat = microseconds_per_minute / bpm as f64 ; microseconds_per_beat / ticks_per_quarter as f64 }

- [ ] **Function 'tick_to_bar_beat' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/core/sequencer/timing.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Calculate bar and beat from tick position"] # [doc = ""] # [doc = " Converts absolute tick position to musical bar:beat notation."] # [doc = ""] # [doc = " # Arguments"] # [doc = " * `tick` - Absolute tick position"] # [doc = " * `ticks_per_quarter` - MIDI resolution"] # [doc = " * `beats_per_bar` - Time signature numerator (typically 4)"] # [doc = ""] # [doc = " # Returns"] # [doc = " Tuple of (bar, beat) as (u32, u32)"] pub fn tick_to_bar_beat (tick : u64 , ticks_per_quarter : u16 , beats_per_bar : u8) -> (u32 , u32) { let ticks_per_beat = ticks_per_quarter as u64 ; let ticks_per_bar = ticks_per_beat * beats_per_bar as u64 ; let bar = (tick / ticks_per_bar) as u32 ; let beat = ((tick % ticks_per_bar) / ticks_per_beat) as u32 ; (bar , beat) }

- [ ] **Function 'bar_beat_to_tick' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/core/sequencer/timing.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Calculate tick position from bar and beat"] # [doc = ""] # [doc = " Converts musical bar:beat notation to absolute tick position."] # [doc = ""] # [doc = " # Arguments"] # [doc = " * `bar` - Bar number (0-indexed)"] # [doc = " * `beat` - Beat within bar (0-indexed)"] # [doc = " * `ticks_per_quarter` - MIDI resolution"] # [doc = " * `beats_per_bar` - Time signature numerator"] # [doc = ""] # [doc = " # Returns"] # [doc = " Absolute tick position as u64"] pub fn bar_beat_to_tick (bar : u32 , beat : u32 , ticks_per_quarter : u16 , beats_per_bar : u8) -> u64 { let ticks_per_beat = ticks_per_quarter as u64 ; let ticks_per_bar = ticks_per_beat * beats_per_bar as u64 ; (bar as u64 * ticks_per_bar) + (beat as u64 * ticks_per_beat) }

- [ ] **Function 'ticks_to_seconds' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/core/sequencer/timing.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Calculate seconds from ticks"] # [doc = ""] # [doc = " Converts MIDI ticks to real time in seconds."] # [doc = ""] # [doc = " # Arguments"] # [doc = " * `tick` - Absolute tick position"] # [doc = " * `bpm` - Current tempo"] # [doc = " * `ticks_per_quarter` - MIDI resolution"] # [doc = ""] # [doc = " # Returns"] # [doc = " Time in seconds as f64"] pub fn ticks_to_seconds (tick : u64 , bpm : f32 , ticks_per_quarter : u16) -> f64 { let us_per_tick = microseconds_per_tick (bpm , ticks_per_quarter) ; (tick as f64 * us_per_tick) / 1_000_000.0 }

- [ ] **Function 'seconds_to_ticks' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/core/sequencer/timing.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Calculate ticks from seconds"] # [doc = ""] # [doc = " Converts real time in seconds to MIDI ticks."] # [doc = ""] # [doc = " # Arguments"] # [doc = " * `seconds` - Time in seconds"] # [doc = " * `bpm` - Current tempo"] # [doc = " * `ticks_per_quarter` - MIDI resolution"] # [doc = ""] # [doc = " # Returns"] # [doc = " Absolute tick position as u64"] pub fn seconds_to_ticks (seconds : f64 , bpm : f32 , ticks_per_quarter : u16) -> u64 { let us_per_tick = microseconds_per_tick (bpm , ticks_per_quarter) ; ((seconds * 1_000_000.0) / us_per_tick) as u64 }

- [ ] **Function 'ticks_to_microseconds' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/core/sequencer/timing.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Convert ticks to microseconds"] # [doc = ""] # [doc = " Converts MIDI ticks to microseconds for precise timing."] # [doc = ""] # [doc = " # Arguments"] # [doc = " * `ticks` - Number of ticks"] # [doc = " * `tpqn` - Ticks per quarter note"] # [doc = " * `bpm` - Beats per minute"] # [doc = ""] # [doc = " # Returns"] # [doc = " Time in microseconds as u64"] pub fn ticks_to_microseconds (ticks : u64 , tpqn : u16 , bpm : f32) -> u64 { let us_per_tick = microseconds_per_tick (bpm , tpqn) ; (ticks as f64 * us_per_tick) as u64 }

- [ ] **Function 'microseconds_to_ticks' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/core/sequencer/timing.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Convert microseconds to ticks"] # [doc = ""] # [doc = " Converts microseconds to MIDI ticks."] # [doc = ""] # [doc = " # Arguments"] # [doc = " * `micros` - Time in microseconds"] # [doc = " * `tpqn` - Ticks per quarter note"] # [doc = " * `bpm` - Beats per minute"] # [doc = ""] # [doc = " # Returns"] # [doc = " Number of ticks as u64"] pub fn microseconds_to_ticks (micros : u64 , tpqn : u16 , bpm : f32) -> u64 { let us_per_tick = microseconds_per_tick (bpm , tpqn) ; (micros as f64 / us_per_tick) as u64 }

- [ ] **Function 'calculate_bar_position' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/core/sequencer/timing.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Calculate bar position from tick"] # [doc = ""] # [doc = " Converts absolute tick to bar:beat:tick position."] # [doc = ""] # [doc = " # Arguments"] # [doc = " * `tick` - Absolute tick position"] # [doc = " * `tpqn` - Ticks per quarter note"] # [doc = " * `time_sig_num` - Time signature numerator (e.g., 4 in 4/4)"] # [doc = " * `time_sig_denom` - Time signature denominator (e.g., 4 in 4/4)"] # [doc = ""] # [doc = " # Returns"] # [doc = " BarPosition with bar, beat, and tick within beat"] pub fn calculate_bar_position (tick : u64 , tpqn : u16 , time_sig_num : u8 , time_sig_denom : u8 ,) -> BarPosition { let ticks_per_beat = (tpqn as u64 * 4) / time_sig_denom as u64 ; let ticks_per_bar = ticks_per_beat * time_sig_num as u64 ; let bar = (tick / ticks_per_bar) as u32 ; let tick_in_bar = tick % ticks_per_bar ; let beat = (tick_in_bar / ticks_per_beat) as u32 ; let tick_in_beat = tick_in_bar % ticks_per_beat ; BarPosition { bar , beat , tick : tick_in_beat } }

- [ ] **Function 'ticks_per_bar' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/core/sequencer/timing.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Calculate ticks per bar"] # [doc = ""] # [doc = " Calculates the number of ticks in one bar based on time signature."] # [doc = ""] # [doc = " # Arguments"] # [doc = " * `tpqn` - Ticks per quarter note"] # [doc = " * `time_sig_num` - Time signature numerator (e.g., 4 in 4/4)"] # [doc = " * `time_sig_denom` - Time signature denominator (e.g., 4 in 4/4)"] # [doc = ""] # [doc = " # Returns"] # [doc = " Number of ticks per bar as u64"] # [doc = ""] # [doc = " # Examples"] # [doc = " - 4/4 time with 480 TPQN: 1920 ticks per bar (4 quarter notes)"] # [doc = " - 3/4 time with 480 TPQN: 1440 ticks per bar (3 quarter notes)"] # [doc = " - 6/8 time with 480 TPQN: 1440 ticks per bar (2 dotted quarter notes)"] pub fn ticks_per_bar (tpqn : u16 , time_sig_num : u8 , time_sig_denom : u8) -> u64 { let ticks_per_beat = (tpqn as u64 * 4) / time_sig_denom as u64 ; ticks_per_beat * time_sig_num as u64 }

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/hardware/device_manager.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/hardware/device_manager.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/hardware/device_manager.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/hardware/device_manager.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/hardware/midi_backend.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/hardware/midi_backend.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/hardware/midi_backend.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/hardware/midi_backend.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/hardware/midi_backend.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/hardware/midi_backend.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/hardware/midi_monitor.rs`
  - Category: Performance

- [ ] **Function 'parse_destination' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/hardware/midi_router.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Parse destination string into RouteDestination"] fn parse_destination (dest : & str) -> Result < RouteDestination > { if let Some (device_id) = dest . strip_prefix ("device:") { Ok (RouteDestination :: Device (device_id . to_string ())) } else if let Some (track_id) = dest . strip_prefix ("track:") { let track_num = track_id . parse :: < i32 > () . context ("Invalid track number") ? ; Ok (RouteDestination :: Track (track_num)) } else if let Some (virtual_id) = dest . strip_prefix ("virtual:") { Ok (RouteDestination :: Virtual (virtual_id . to_string ())) } else { Ok (RouteDestination :: Device (dest . to_string ())) } }

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/main.rs`
  - Category: Performance

- [ ] **Function 'init_logging' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/main.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Initialize logging/tracing system"] fn init_logging () { let log_dir = std :: env :: var ("LOG_DIR") . unwrap_or_else (| _ | "./logs" . to_string ()) ; std :: fs :: create_dir_all (& log_dir) . ok () ; let file_appender = tracing_appender :: rolling :: daily (log_dir , "daw.log") ; let (non_blocking , _guard) = tracing_appender :: non_blocking (file_appender) ; tracing_subscriber :: registry () . with (tracing_subscriber :: EnvFilter :: try_from_default_env () . unwrap_or_else (| _ | "info,midi_daw=debug" . into ()) ,) . with (tracing_subscriber :: fmt :: layer () . with_writer (std :: io :: stdout)) . with (tracing_subscriber :: fmt :: layer () . with_writer (non_blocking)) . init () ; }

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/midi/manager.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/midi/manager.rs`
  - Category: Performance

- [ ] **Function 'parse_manufacturer' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/midi/manager.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Parse manufacturer from device name"] # [doc = ""] # [doc = " Attempts to extract manufacturer name from MIDI device name."] # [doc = " This is a best-effort approach as device naming is not standardized."] fn parse_manufacturer (name : & str) -> Option < String > { if name . contains ("Steinberg") { Some ("Steinberg" . to_string ()) } else if name . contains ("Akai") { Some ("Akai" . to_string ()) } else if name . contains ("Roland") { Some ("Roland" . to_string ()) } else if name . contains ("Yamaha") { Some ("Yamaha" . to_string ()) } else if name . contains ("Korg") { Some ("Korg" . to_string ()) } else if name . contains ("Moog") { Some ("Moog" . to_string ()) } else if name . contains ("Arturia") { Some ("Arturia" . to_string ()) } else if name . contains ("Native Instruments") || name . contains ("NI") { Some ("Native Instruments" . to_string ()) } else { None } }

- [ ] **Function 'default_datetime' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/models/midi_file.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Default datetime for struct initialization (Unix epoch)"] fn default_datetime () -> chrono :: DateTime < chrono :: Utc > { chrono :: DateTime :: UNIX_EPOCH }

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/profiling/memory.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/profiling/memory.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/profiling/memory.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/profiling/memory.rs`
  - Category: Performance

- [ ] **Function 'format_bytes' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/profiling/memory.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Format bytes as human-readable string"] # [doc = ""] # [doc = " # Arguments"] # [doc = ""] # [doc = " * `bytes` - Number of bytes"] # [doc = ""] # [doc = " # Returns"] # [doc = ""] # [doc = " Formatted string (e.g., \"1.23 MB\")"] # [doc = ""] # [doc = " # Example"] # [doc = ""] # [doc = " ```"] # [doc = " use midi_daw::profiling::memory::format_bytes;"] # [doc = ""] # [doc = " assert_eq!(format_bytes(1024), \"1.00 KB\");"] # [doc = " assert_eq!(format_bytes(1024 * 1024), \"1.00 MB\");"] # [doc = " assert_eq!(format_bytes(1024 * 1024 * 1024), \"1.00 GB\");"] # [doc = " ```"] pub fn format_bytes (bytes : usize) -> String { const KB : usize = 1024 ; const MB : usize = KB * 1024 ; const GB : usize = MB * 1024 ; if bytes >= GB { format ! ("{:.2} GB" , bytes as f64 / GB as f64) } else if bytes >= MB { format ! ("{:.2} MB" , bytes as f64 / MB as f64) } else if bytes >= KB { format ! ("{:.2} KB" , bytes as f64 / KB as f64) } else { format ! ("{} B" , bytes) } }

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/profiling/memory.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/profiling/query_analyzer.rs`
  - Category: Performance

- [ ] **Function 'calculate_score_standalone' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/profiling/query_analyzer.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn calculate_score_standalone (execution_time : Duration , rows_affected : i64 , uses_index : bool , query_type : & QueryType ,) -> i32 { let mut score = 100i32 ; let time_ms = execution_time . as_millis () as i32 ; if time_ms > 500 { score -= 30 ; } else if time_ms > 100 { score -= 15 ; } else if time_ms > 50 { score -= 5 ; } if ! uses_index && rows_affected > 100 { score -= 25 ; } if rows_affected > 10000 { score -= 10 ; } match query_type { QueryType :: Insert | QueryType :: Update | QueryType :: Delete => { if time_ms > 100 { score -= 10 ; } } , _ => { } , } score . max (0) . min (100) }

- [ ] **Function 'identify_bottlenecks_standalone' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/profiling/query_analyzer.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn identify_bottlenecks_standalone (execution_time : Duration , rows_affected : i64 , uses_index : bool , explain_plan : & str ,) -> Vec < String > { let mut bottlenecks = Vec :: new () ; if execution_time . as_millis () > 500 { bottlenecks . push ("Slow execution time (>500ms)" . to_string ()) ; } if ! uses_index && rows_affected > 100 { bottlenecks . push ("No index used for large result set" . to_string ()) ; } if explain_plan . contains ("Seq Scan") { bottlenecks . push ("Sequential scan detected - consider adding index" . to_string ()) ; } if explain_plan . contains ("Sort") && ! explain_plan . contains ("Index") { bottlenecks . push ("In-memory sort without index" . to_string ()) ; } bottlenecks }

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/profiling/query_cache.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/profiling/query_cache.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/sequencer/engine.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/sequencer/engine.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/sequencer/engine.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/sequencer/engine.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/sequencer/engine.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/sequencer/engine.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/sequencer/engine.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/sequencer/engine.rs`
  - Category: Performance

- [ ] **Function 'create_test_message' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/sequencer/scheduler.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn create_test_message (note : u8 , velocity : u8) -> MidiMessage { MidiMessage { event_type : MidiEventType :: NoteOn , channel : 0 , data1 : note , data2 : velocity , timestamp : 0 , } }

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/sequencer/track.rs`
  - Category: Performance

- [ ] **Function 'create_test_event' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/sequencer/track.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn create_test_event (channel : u8) -> MidiEvent { use crate :: models :: midi :: MidiEventType ; MidiEvent { event_type : MidiEventType :: NoteOn , tick : 0 , channel , note : Some (60) , velocity : Some (100) , controller : None , value : None , program : None , } }

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/settings/keyboard.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/settings/keyboard.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/settings/keyboard.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/settings/keyboard.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/settings/keyboard.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/settings/keyboard.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/settings/keyboard.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/settings/keyboard.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/settings/keyboard.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/undo_redo/piano_roll.rs`
  - Category: Performance

- [ ] **Function 'create_test_state' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/undo_redo/piano_roll.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn create_test_state () -> Arc < Mutex < PianoRollState > > { Arc :: new (Mutex :: new (PianoRollState :: new ())) }

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/windows/state.rs`
  - Category: Performance

- [ ] **Function 'main' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/build.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn main () { println ! ("cargo:rustc-link-lib=webkit2gtk-4.1") ; println ! ("cargo:rustc-link-lib=javascriptcoregtk-4.1") ; tauri_build :: build () }

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/analyze.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/analyze.rs`
  - Category: Performance

- [ ] **Function 'format_duration' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/analyze.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn format_duration (seconds : f64) -> String { if seconds < 60.0 { format ! ("{:.0}s" , seconds) } else if seconds < 3600.0 { let minutes = (seconds / 60.0) . floor () ; let secs = seconds % 60.0 ; format ! ("{}m {:.0}s" , minutes , secs) } else { let hours = (seconds / 3600.0) . floor () ; let minutes = ((seconds % 3600.0) / 60.0) . floor () ; format ! ("{}h {}m" , hours , minutes) } }

- [ ] **Function 'extract_metadata_from_filename' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/analyze_full_collection.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Extract metadata from filename"] fn extract_metadata_from_filename (filename : & str) -> FileMetadata { let lower = filename . to_lowercase () ; let mut metadata = FileMetadata :: default () ; if let Some (bpm) = extract_bpm (& lower) { metadata . bpm = Some (bpm) ; } if let Some (key) = extract_key (& lower) { metadata . key = Some (key) ; } if let Some (ts) = extract_time_signature (& lower) { metadata . time_signature = Some (ts) ; } metadata . instruments = extract_instruments (& lower) ; metadata . genres = extract_genres (& lower) ; metadata . patterns = extract_patterns (& lower) ; if metadata . instruments . iter () . any (| i | i . contains ("drum") || i == "percussion") { metadata . drum_elements = extract_drum_elements (& lower) ; metadata . is_drum = true ; } metadata }

- [ ] **Function 'extract_bpm' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/analyze_full_collection.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Extract BPM from filename"] fn extract_bpm (filename : & str) -> Option < u32 > { if let Some (bpm) = extract_bpm_pattern1 (filename) { return Some (bpm) ; } if let Some (bpm) = extract_bpm_pattern2 (filename) { return Some (bpm) ; } if let Some (bpm) = extract_bpm_pattern3 (filename) { return Some (bpm) ; } None }

- [ ] **Function 'extract_bpm_pattern1' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/analyze_full_collection.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn extract_bpm_pattern1 (filename : & str) -> Option < u32 > { use regex :: Regex ; let re = Regex :: new (r"[_\-](\d{2,3})[-_]?bpm[_\-]") . ok () ? ; re . captures (filename) . and_then (| cap | cap . get (1)) . and_then (| m | m . as_str () . parse :: < u32 > () . ok ()) . filter (| & bpm | (30 ..= 300) . contains (& bpm)) }

- [ ] **Function 'extract_bpm_pattern2' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/analyze_full_collection.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn extract_bpm_pattern2 (filename : & str) -> Option < u32 > { use regex :: Regex ; let re = Regex :: new (r"[_\-](\d{2,3})[_\-]") . ok () ? ; re . captures (filename) . and_then (| cap | cap . get (1)) . and_then (| m | m . as_str () . parse :: < u32 > () . ok ()) . filter (| & bpm | (30 ..= 300) . contains (& bpm)) }

- [ ] **Function 'extract_bpm_pattern3' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/analyze_full_collection.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn extract_bpm_pattern3 (filename : & str) -> Option < u32 > { use regex :: Regex ; let re = Regex :: new (r"^(\d{2,3})[-_\.]") . ok () ? ; re . captures (filename) . and_then (| cap | cap . get (1)) . and_then (| m | m . as_str () . parse :: < u32 > () . ok ()) . filter (| & bpm | (30 ..= 300) . contains (& bpm)) }

- [ ] **Function 'extract_key' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/analyze_full_collection.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Extract musical key from filename"] fn extract_key (filename : & str) -> Option < String > { use regex :: Regex ; let major_re = Regex :: new (r"[_\-]([A-G]#?b?)[_\-]") . ok () ? ; if let Some (cap) = major_re . captures (filename) { return Some (cap . get (1) ? . as_str () . to_string ()) ; } let minor_re = Regex :: new (r"[_\-]([A-G]#?b?m(?:in)?)[_\-]") . ok () ? ; if let Some (cap) = minor_re . captures (filename) { return Some (cap . get (1) ? . as_str () . to_string ()) ; } None }

- [ ] **Function 'extract_time_signature' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/analyze_full_collection.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Extract time signature from filename"] fn extract_time_signature (filename : & str) -> Option < String > { if filename . contains ("threefour") || filename . contains ("3-4") || filename . contains ("3_4") { return Some ("3/4" . to_string ()) ; } if filename . contains ("sixeight") || filename . contains ("6-8") || filename . contains ("6_8") { return Some ("6/8" . to_string ()) ; } if filename . contains ("fivefour") || filename . contains ("5-4") || filename . contains ("5_4") { return Some ("5/4" . to_string ()) ; } if filename . contains ("seveneight") || filename . contains ("7-8") || filename . contains ("7_8") { return Some ("7/8" . to_string ()) ; } None }

- [ ] **Function 'extract_instruments' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/analyze_full_collection.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Extract instruments from filename"] fn extract_instruments (filename : & str) -> Vec < String > { let mut instruments = Vec :: new () ; if filename . contains ("drum") && ! filename . contains ("syndrome") { instruments . push ("drums" . to_string ()) ; } if filename . contains ("percussion") { instruments . push ("percussion" . to_string ()) ; } if filename . contains ("snare") { instruments . push ("snare" . to_string ()) ; } if filename . contains ("kick") { instruments . push ("kick" . to_string ()) ; } if filename . contains ("hat") || filename . contains ("hihat") { instruments . push ("hat" . to_string ()) ; } if filename . contains ("cymbal") { instruments . push ("cymbal" . to_string ()) ; } if filename . contains ("tom") && ! filename . contains ("atom") && ! filename . contains ("custom") { instruments . push ("tom" . to_string ()) ; } if filename . contains ("ride") { instruments . push ("ride" . to_string ()) ; } if filename . contains ("bass") && ! filename . contains ("bass drum") { instruments . push ("bass" . to_string ()) ; } if filename . contains ("synth") { instruments . push ("synth" . to_string ()) ; } if filename . contains ("pad") { instruments . push ("pad" . to_string ()) ; } if filename . contains ("lead") { instruments . push ("lead" . to_string ()) ; } if filename . contains ("piano") { instruments . push ("piano" . to_string ()) ; } if filename . contains ("organ") { instruments . push ("organ" . to_string ()) ; } if filename . contains ("chord") { instruments . push ("chords" . to_string ()) ; } if filename . contains ("string") { instruments . push ("strings" . to_string ()) ; } if filename . contains ("brass") { instruments . push ("brass" . to_string ()) ; } if filename . contains ("guitar") { instruments . push ("guitar" . to_string ()) ; } instruments }

- [ ] **Function 'extract_genres' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/analyze_full_collection.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Extract genres from filename"] fn extract_genres (filename : & str) -> Vec < String > { let mut genres = Vec :: new () ; if filename . contains ("house") { genres . push ("house" . to_string ()) ; } if filename . contains ("techno") { genres . push ("techno" . to_string ()) ; } if filename . contains ("trance") { genres . push ("trance" . to_string ()) ; } if filename . contains ("dubstep") { genres . push ("dubstep" . to_string ()) ; } if filename . contains ("dnb") || filename . contains ("drum") && filename . contains ("bass") { genres . push ("dnb" . to_string ()) ; } if filename . contains ("jungle") { genres . push ("jungle" . to_string ()) ; } if filename . contains ("breakbeat") || filename . contains ("breaks") { genres . push ("breakbeat" . to_string ()) ; } if filename . contains ("garage") { genres . push ("garage" . to_string ()) ; } if filename . contains ("glitch") { genres . push ("glitch" . to_string ()) ; } if filename . contains ("ambient") { genres . push ("ambient" . to_string ()) ; } if filename . contains ("hiphop") || filename . contains ("hip-hop") { genres . push ("hip-hop" . to_string ()) ; } if filename . contains ("trap") { genres . push ("trap" . to_string ()) ; } if filename . contains ("rnb") || filename . contains ("r&b") { genres . push ("rnb" . to_string ()) ; } if filename . contains ("rock") { genres . push ("rock" . to_string ()) ; } if filename . contains ("metal") { genres . push ("metal" . to_string ()) ; } if filename . contains ("punk") { genres . push ("punk" . to_string ()) ; } if filename . contains ("blues") { genres . push ("blues" . to_string ()) ; } if filename . contains ("funk") { genres . push ("funk" . to_string ()) ; } if filename . contains ("jazz") { genres . push ("jazz" . to_string ()) ; } if filename . contains ("fusion") { genres . push ("fusion" . to_string ()) ; } if filename . contains ("latin") { genres . push ("latin" . to_string ()) ; } if filename . contains ("africa") { genres . push ("african" . to_string ()) ; } if filename . contains ("asia") { genres . push ("asian" . to_string ()) ; } if filename . contains ("world") { genres . push ("world" . to_string ()) ; } if filename . contains ("pop") { genres . push ("pop" . to_string ()) ; } if filename . contains ("disco") { genres . push ("disco" . to_string ()) ; } if filename . contains ("progressive") { genres . push ("progressive" . to_string ()) ; } genres }

- [ ] **Function 'extract_patterns' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/analyze_full_collection.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Extract pattern types from filename"] fn extract_patterns (filename : & str) -> Vec < String > { let mut patterns = Vec :: new () ; if filename . contains ("fill") { patterns . push ("fill" . to_string ()) ; } if filename . contains ("groove") { patterns . push ("groove" . to_string ()) ; } if filename . contains ("intro") { patterns . push ("intro" . to_string ()) ; } if filename . contains ("outro") || filename . contains ("ending") { patterns . push ("ending" . to_string ()) ; } if filename . contains ("breakdown") { patterns . push ("breakdown" . to_string ()) ; } if filename . contains ("turnaround") { patterns . push ("turnaround" . to_string ()) ; } if filename . contains ("verse") { patterns . push ("verse" . to_string ()) ; } if filename . contains ("chorus") { patterns . push ("chorus" . to_string ()) ; } if filename . contains ("bridge") { patterns . push ("bridge" . to_string ()) ; } if filename . contains ("loop") { patterns . push ("loop" . to_string ()) ; } patterns }

- [ ] **Function 'extract_drum_elements' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/analyze_full_collection.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Extract drum elements from filename"] fn extract_drum_elements (filename : & str) -> Vec < String > { let mut elements = Vec :: new () ; if filename . contains ("crash") { elements . push ("crash" . to_string ()) ; } if filename . contains ("ride") { elements . push ("ride" . to_string ()) ; } if filename . contains ("china") { elements . push ("china" . to_string ()) ; } if filename . contains ("splash") { elements . push ("splash" . to_string ()) ; } if filename . contains ("closed") && (filename . contains ("hat") || filename . contains ("hihat")) { elements . push ("closed-hat" . to_string ()) ; } if filename . contains ("open") && (filename . contains ("hat") || filename . contains ("hihat")) { elements . push ("open-hat" . to_string ()) ; } if filename . contains ("pedal") && (filename . contains ("hat") || filename . contains ("hihat")) { elements . push ("pedal-hat" . to_string ()) ; } if filename . contains ("ghost") { elements . push ("ghost-notes" . to_string ()) ; } if filename . contains ("double") && filename . contains ("bass") { elements . push ("double-bass" . to_string ()) ; } if filename . contains ("flam") { elements . push ("flam" . to_string ()) ; } if filename . contains ("roll") { elements . push ("roll" . to_string ()) ; } if filename . contains ("swing") { elements . push ("swing" . to_string ()) ; } if filename . contains ("shuffle") { elements . push ("shuffle" . to_string ()) ; } if filename . contains ("triplet") { elements . push ("triplet" . to_string ()) ; } elements }

- [ ] **Function 'analyze_file' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/analyze_full_collection.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Analyze a single MIDI file"] fn analyze_file (path : & Path , stats : & CollectionStats) { let filename = match path . file_name () . and_then (| n | n . to_str ()) { Some (name) => name , None => return , } ; stats . total_files . fetch_add (1 , Ordering :: Relaxed) ; let metadata = extract_metadata_from_filename (filename) ; if metadata . is_drum { stats . drum_files . fetch_add (1 , Ordering :: Relaxed) ; } for instrument in & metadata . instruments { stats . increment (& stats . instruments , instrument) ; } for genre in & metadata . genres { stats . increment (& stats . genres , genre) ; } for pattern in & metadata . patterns { stats . increment (& stats . patterns , pattern) ; } for element in & metadata . drum_elements { stats . increment (& stats . drum_elements , element) ; } if let Some (bpm) = metadata . bpm { stats . increment_bpm (bpm) ; } if let Some (key) = metadata . key { stats . increment (& stats . keys , & key) ; } if let Some (ts) = metadata . time_signature { stats . increment (& stats . time_signatures , & ts) ; } stats . analyzed_files . fetch_add (1 , Ordering :: Relaxed) ; }

- [ ] **Function 'find_midi_files' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/analyze_full_collection.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Recursively find all MIDI files"] fn find_midi_files (root : & Path) -> Vec < PathBuf > { println ! ("Scanning directory tree...") ; let start = Instant :: now () ; let files : Vec < PathBuf > = walkdir :: WalkDir :: new (root) . follow_links (false) . into_iter () . filter_map (| e | e . ok ()) . filter (| e | { e . path () . extension () . and_then (| ext | ext . to_str ()) . map (| ext | { let ext_lower = ext . to_lowercase () ; ext_lower == "mid" || ext_lower == "midi" }) . unwrap_or (false) }) . map (| e | e . path () . to_path_buf ()) . collect () ; println ! ("Found {} MIDI files in {:?}" , files . len () , start . elapsed ()) ; files }

- [ ] **Function 'generate_report' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/analyze_full_collection.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Generate markdown report"] fn generate_report (stats : & CollectionStats , output_path : & Path) -> std :: io :: Result < () > { let mut output = String :: new () ; output . push_str ("# Complete MIDI Collection Analysis\n\n") ; output . push_str (& format ! ("**Total Files Analyzed:** {}\n\n" , stats . total_files . load (Ordering :: Relaxed))) ; output . push_str (& format ! ("**Drum Files:** {} ({:.1}%)\n\n" , stats . drum_files . load (Ordering :: Relaxed) , stats . drum_files . load (Ordering :: Relaxed) as f64 / stats . total_files . load (Ordering :: Relaxed) as f64 * 100.0)) ; output . push_str ("---\n\n") ; output . push_str ("## Top Instruments Found\n\n") ; output . push_str ("| Instrument | Count | Percentage |\n") ; output . push_str ("|------------|-------|------------|\n") ; let mut instruments : Vec < _ > = stats . instruments . iter () . map (| r | (r . key () . clone () , * r . value ())) . collect () ; instruments . sort_by (| a , b | b . 1 . cmp (& a . 1)) ; let total = stats . total_files . load (Ordering :: Relaxed) ; for (instrument , count) in instruments . iter () . take (50) { output . push_str (& format ! ("| {} | {} | {:.2}% |\n" , instrument , count , * count as f64 / total as f64 * 100.0)) ; } output . push_str ("\n") ; output . push_str ("## Top Genres Found\n\n") ; output . push_str ("| Genre | Count | Percentage |\n") ; output . push_str ("|-------|-------|------------|\n") ; let mut genres : Vec < _ > = stats . genres . iter () . map (| r | (r . key () . clone () , * r . value ())) . collect () ; genres . sort_by (| a , b | b . 1 . cmp (& a . 1)) ; for (genre , count) in genres . iter () . take (50) { output . push_str (& format ! ("| {} | {} | {:.2}% |\n" , genre , count , * count as f64 / total as f64 * 100.0)) ; } output . push_str ("\n") ; output . push_str ("## Top Pattern Types\n\n") ; output . push_str ("| Pattern | Count | Percentage |\n") ; output . push_str ("|---------|-------|------------|\n") ; let mut patterns : Vec < _ > = stats . patterns . iter () . map (| r | (r . key () . clone () , * r . value ())) . collect () ; patterns . sort_by (| a , b | b . 1 . cmp (& a . 1)) ; for (pattern , count) in patterns . iter () . take (30) { output . push_str (& format ! ("| {} | {} | {:.2}% |\n" , pattern , count , * count as f64 / total as f64 * 100.0)) ; } output . push_str ("\n") ; output . push_str ("## Musical Keys Found\n\n") ; output . push_str ("| Key | Count | Percentage |\n") ; output . push_str ("|-----|-------|------------|\n") ; let mut keys : Vec < _ > = stats . keys . iter () . map (| r | (r . key () . clone () , * r . value ())) . collect () ; keys . sort_by (| a , b | b . 1 . cmp (& a . 1)) ; for (key , count) in keys . iter () . take (30) { output . push_str (& format ! ("| {} | {} | {:.2}% |\n" , key , count , * count as f64 / total as f64 * 100.0)) ; } output . push_str ("\n") ; output . push_str ("## BPM Distribution\n\n") ; output . push_str ("| BPM | Count | Percentage |\n") ; output . push_str ("|-----|-------|------------|\n") ; let mut bpms : Vec < _ > = stats . bpms . iter () . map (| r | (* r . key () , * r . value ())) . collect () ; bpms . sort_by (| a , b | b . 1 . cmp (& a . 1)) ; for (bpm , count) in bpms . iter () . take (50) { output . push_str (& format ! ("| {} | {} | {:.2}% |\n" , bpm , count , * count as f64 / total as f64 * 100.0)) ; } output . push_str ("\n") ; output . push_str ("## Time Signatures Found\n\n") ; output . push_str ("| Time Signature | Count | Percentage |\n") ; output . push_str ("|----------------|-------|------------|\n") ; let mut time_sigs : Vec < _ > = stats . time_signatures . iter () . map (| r | (r . key () . clone () , * r . value ())) . collect () ; time_sigs . sort_by (| a , b | b . 1 . cmp (& a . 1)) ; for (ts , count) in time_sigs . iter () { output . push_str (& format ! ("| {} | {} | {:.2}% |\n" , ts , count , * count as f64 / total as f64 * 100.0)) ; } output . push_str ("\n") ; if stats . drum_files . load (Ordering :: Relaxed) > 0 { output . push_str ("## Drum Elements & Techniques\n\n") ; output . push_str ("| Element | Count | Percentage (of drum files) |\n") ; output . push_str ("|---------|-------|---------------------------|\n") ; let mut elements : Vec < _ > = stats . drum_elements . iter () . map (| r | (r . key () . clone () , * r . value ())) . collect () ; elements . sort_by (| a , b | b . 1 . cmp (& a . 1)) ; let drum_total = stats . drum_files . load (Ordering :: Relaxed) ; for (element , count) in elements . iter () . take (50) { output . push_str (& format ! ("| {} | {} | {:.2}% |\n" , element , count , * count as f64 / drum_total as f64 * 100.0)) ; } output . push_str ("\n") ; } output . push_str ("## BPM Ranges Summary\n\n") ; let mut bpm_ranges : HashMap < & str , u64 > = HashMap :: new () ; for (bpm , count) in bpms . iter () { let range = match bpm { 30 ..= 60 => "Very Slow (30-60)" , 61 ..= 90 => "Slow (61-90)" , 91 ..= 120 => "Mid-Tempo (91-120)" , 121 ..= 140 => "Upbeat (121-140)" , 141 ..= 180 => "Fast (141-180)" , 181 ..= 300 => "Very Fast (181-300)" , _ => "Other" , } ; * bpm_ranges . entry (range) . or_insert (0) += count ; } output . push_str ("| BPM Range | Count | Percentage |\n") ; output . push_str ("|-----------|-------|------------|\n") ; let mut ranges : Vec < _ > = bpm_ranges . into_iter () . collect () ; ranges . sort_by (| a , b | b . 1 . cmp (& a . 1)) ; for (range , count) in ranges { output . push_str (& format ! ("| {} | {} | {:.2}% |\n" , range , count , count as f64 / total as f64 * 100.0)) ; } output . push_str ("\n") ; fs :: write (output_path , output) ? ; Ok (()) }

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/analyze_full_collection.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/analyze_full_collection.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/analyze_full_collection.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/analyze_full_collection.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/analyze_full_collection.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/analyze_full_collection.rs`
  - Category: Performance

- [ ] **Function 'main' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/analyze_full_collection.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn main () { let args : Vec < String > = std :: env :: args () . collect () ; let root_path = if args . len () > 1 { PathBuf :: from (& args [1]) } else { PathBuf :: from ("/home/dojevou/projects/midi-software-center/midi-library/archives") } ; let output_path = if args . len () > 2 { PathBuf :: from (& args [2]) } else { PathBuf :: from ("COMPLETE_COLLECTION_ANALYSIS.md") } ; println ! ("MIDI Collection Analysis") ; println ! ("========================") ; println ! ("Root path: {}" , root_path . display ()) ; println ! ("Output: {}" , output_path . display ()) ; println ! () ; let files = find_midi_files (& root_path) ; println ! ("Starting analysis of {} files...\n" , files . len ()) ; let stats = Arc :: new (CollectionStats :: new ()) ; let start = Instant :: now () ; let progress_interval = files . len () / 100 ; files . par_iter () . enumerate () . for_each (| (i , path) | { analyze_file (path , & stats) ; if i % progress_interval == 0 && i > 0 { let analyzed = stats . analyzed_files . load (Ordering :: Relaxed) ; let elapsed = start . elapsed () ; let rate = analyzed as f64 / elapsed . as_secs_f64 () ; println ! ("Progress: {:.1}% ({}/{} files) - {:.0} files/sec" , i as f64 / files . len () as f64 * 100.0 , analyzed , files . len () , rate) ; } }) ; let elapsed = start . elapsed () ; let total = stats . total_files . load (Ordering :: Relaxed) ; let rate = total as f64 / elapsed . as_secs_f64 () ; println ! ("\nAnalysis complete!") ; println ! ("Total files: {}" , total) ; println ! ("Time: {:?}" , elapsed) ; println ! ("Rate: {:.0} files/sec" , rate) ; println ! () ; println ! ("Generating report...") ; match generate_report (& stats , & output_path) { Ok (_) => println ! ("Report saved to: {}" , output_path . display ()) , Err (e) => eprintln ! ("Error generating report: {}" , e) , } }

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/batch_import.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/batch_import.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/batch_import.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/batch_import.rs`
  - Category: Performance

- [ ] **Function 'find_midi_files' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/batch_import.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Find all MIDI files in a directory"] fn find_midi_files (dir : & Path) -> Result < Vec < PathBuf > > { let mut files = Vec :: new () ; for entry in walkdir :: WalkDir :: new (dir) { let entry = entry ? ; let path = entry . path () ; if path . is_file () { if let Some (ext) = path . extension () { if ext . eq_ignore_ascii_case ("mid") || ext . eq_ignore_ascii_case ("midi") { files . push (path . to_path_buf ()) ; } } } } Ok (files) }

- [ ] **Function 'extract_time_signature' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/batch_import.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Extract time signature from MIDI file"] fn extract_time_signature (midi_file : & midi_library_shared :: core :: midi :: types :: MidiFile ,) -> (Option < i16 > , Option < i16 >) { use midi_library_shared :: core :: midi :: types :: Event ; for track in & midi_file . tracks { for timed_event in & track . events { if let Event :: TimeSignature { numerator , denominator , .. } = & timed_event . event { let denom_value = 2i16 . pow (* denominator as u32) ; return (Some (* numerator as i16) , Some (denom_value)) ; } } } (Some (4) , Some (4)) }

- [ ] **Function 'calculate_total_ticks' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/batch_import.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Calculate total ticks in MIDI file"] fn calculate_total_ticks (midi_file : & midi_library_shared :: core :: midi :: types :: MidiFile) -> i64 { let mut max_ticks = 0u32 ; for track in & midi_file . tracks { let mut track_ticks = 0u32 ; for timed_event in & track . events { track_ticks += timed_event . delta_ticks ; } max_ticks = max_ticks . max (track_ticks) ; } max_ticks as i64 }

- [ ] **Function 'analyze_notes' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/batch_import.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Analyze notes in MIDI file"] fn analyze_notes (midi_file : & midi_library_shared :: core :: midi :: types :: MidiFile) -> NoteStats { use midi_library_shared :: core :: midi :: types :: Event ; use std :: collections :: { HashMap , HashSet } ; let mut note_count = 0i32 ; let mut pitches = HashSet :: new () ; let mut min_pitch = 127u8 ; let mut max_pitch = 0u8 ; let mut velocity_sum = 0u32 ; let mut active_notes_per_tick : HashMap < u32 , usize > = HashMap :: new () ; for track in & midi_file . tracks { let mut current_tick = 0u32 ; let mut active_notes = HashSet :: new () ; for timed_event in & track . events { current_tick += timed_event . delta_ticks ; match & timed_event . event { Event :: NoteOn { note , velocity , .. } if * velocity > 0 => { note_count += 1 ; pitches . insert (* note) ; min_pitch = min_pitch . min (* note) ; max_pitch = max_pitch . max (* note) ; velocity_sum += * velocity as u32 ; active_notes . insert (* note) ; active_notes_per_tick . insert (current_tick , active_notes . len ()) ; } , Event :: NoteOff { note , .. } | Event :: NoteOn { note , velocity : 0 , .. } => { active_notes . remove (note) ; } , _ => { } , } } } let avg_velocity = if note_count > 0 { Some (BigDecimal :: from ((velocity_sum / note_count as u32) as i64)) } else { None } ; let polyphony_max = active_notes_per_tick . values () . max () . copied () . map (| v | v as i16) ; let (pitch_min , pitch_max) = if note_count > 0 { (Some (min_pitch as i16) , Some (max_pitch as i16)) } else { (None , None) } ; NoteStats { note_count , unique_pitches : Some (pitches . len () as i32) , pitch_min , pitch_max , avg_velocity , polyphony_max , } }

- [ ] **Function 'print_summary' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/batch_import.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Print final summary"] fn print_summary (stats : & ImportStats) { let elapsed = stats . start_time . map (| t | t . elapsed ()) . unwrap_or_else (| | std :: time :: Duration :: from_secs (0)) ; let duration_secs = elapsed . as_secs_f64 () ; let imported = stats . files_imported . load (Ordering :: SeqCst) ; let rate = if duration_secs > 0.0 { imported as f64 / duration_secs } else { 0.0 } ; println ! ("\n========================================") ; println ! ("BATCH IMPORT COMPLETE") ; println ! ("========================================") ; println ! ("Files found: {}" , stats . files_found . load (Ordering :: SeqCst)) ; println ! ("Successfully imported: {}" , imported) ; println ! ("Duplicates skipped: {}" , stats . files_duplicates . load (Ordering :: SeqCst)) ; println ! ("Errors: {}" , stats . files_errors . load (Ordering :: SeqCst)) ; println ! ("Time: {:.0}h {:.0}m {:.0}s" , duration_secs / 3600.0 , (duration_secs % 3600.0) / 60.0 , duration_secs % 60.0) ; println ! ("Avg speed: {:.0} files/sec" , rate) ; println ! ("========================================") ; println ! ("All files include: BPM, Key, Notes, Stats") ; println ! ("========================================\n") ; }

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/batch_split.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/batch_split.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/batch_split.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/batch_split.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/batch_split.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/batch_split.rs`
  - Category: Performance

- [ ] **Function 'sanitize_filename' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/batch_split.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn sanitize_filename (name : & str) -> String { name . chars () . map (| c | match c { '/' | '\\' | ':' | '*' | '?' | '"' | '<' | '>' | '|' => '_' , c if c . is_control () => '_' , c => c , }) . collect :: < String > () . trim () . to_string () }

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/batch_split_optimized.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/batch_split_optimized.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/batch_split_optimized.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/batch_split_optimized.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/batch_split_optimized.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/batch_split_optimized.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/batch_split_optimized.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/batch_split_optimized.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/batch_split_optimized.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/batch_split_optimized.rs`
  - Category: Performance

- [ ] **Function 'sanitize_filename' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/batch_split_optimized.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn sanitize_filename (name : & str) -> String { name . chars () . map (| c | match c { '/' | '\\' | ':' | '*' | '?' | '"' | '<' | '>' | '|' => '_' , c if c . is_control () => '_' , c => c , }) . collect :: < String > () . trim () . to_string () }

- [ ] **Function 'extract_instruments' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/extract_instruments.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Extract instruments from filename"] fn extract_instruments (filename : & str) -> Vec < String > { let filename_lower = filename . to_lowercase () ; let mut found = Vec :: new () ; for & keyword in INSTRUMENT_KEYWORDS { if filename_lower . contains (keyword) { found . push (keyword . to_string ()) ; } } found }

- [ ] **Function 'find_midi_files' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/extract_instruments.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Find all MIDI files recursively"] fn find_midi_files (root : & str) -> Vec < PathBuf > { println ! ("Scanning for MIDI files...") ; let start = Instant :: now () ; let files : Vec < PathBuf > = walkdir :: WalkDir :: new (root) . follow_links (false) . into_iter () . filter_map (| e | e . ok ()) . filter (| e | { e . path () . extension () . and_then (| ext | ext . to_str ()) . map (| ext | { let ext_lower = ext . to_lowercase () ; ext_lower == "mid" || ext_lower == "midi" }) . unwrap_or (false) }) . map (| e | e . path () . to_path_buf ()) . collect () ; println ! ("Found {} MIDI files in {:?}" , files . len () , start . elapsed ()) ; files }

- [ ] **Function 'process_files' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/extract_instruments.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Process files and extract instruments"] fn process_files (files : Vec < PathBuf >) -> DashMap < String , u64 > { println ! ("\nExtracting instruments from {} files..." , files . len ()) ; let start = Instant :: now () ; let instrument_counts : DashMap < String , u64 > = DashMap :: new () ; let processed = AtomicU64 :: new (0) ; files . par_iter () . for_each (| path | { if let Some (filename) = path . file_name () . and_then (| n | n . to_str ()) { let instruments = extract_instruments (filename) ; for instrument in instruments { instrument_counts . entry (instrument) . and_modify (| count | * count += 1) . or_insert (1) ; } } let count = processed . fetch_add (1 , Ordering :: Relaxed) + 1 ; if count % 10000 == 0 { let elapsed = start . elapsed () ; let rate = count as f64 / elapsed . as_secs_f64 () ; println ! ("Processed: {} files ({:.0} files/sec)" , count , rate) ; } }) ; let elapsed = start . elapsed () ; let total = processed . load (Ordering :: Relaxed) ; let rate = total as f64 / elapsed . as_secs_f64 () ; println ! ("\nProcessing complete: {} files in {:?} ({:.0} files/sec)" , total , elapsed , rate) ; instrument_counts }

- [ ] **Function 'generate_report' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/extract_instruments.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Generate report"] fn generate_report (instrument_counts : DashMap < String , u64 > , total_files : usize ,) -> std :: io :: Result < () > { println ! ("\nGenerating report...") ; let mut instruments : Vec < (String , u64) > = instrument_counts . into_iter () . collect () ; instruments . sort_by (| a , b | b . 1 . cmp (& a . 1)) ; let mut report = String :: new () ; report . push_str ("# MIDI Library Instrument Analysis\n\n") ; report . push_str (& format ! ("**Total Files Analyzed:** {}\n\n" , total_files)) ; report . push_str (& format ! ("**Unique Instruments Found:** {}\n\n" , instruments . len ())) ; report . push_str ("## Instrument Frequency\n\n") ; report . push_str ("| Rank | Instrument | Count | Percentage |\n") ; report . push_str ("|------|------------|-------|------------|\n") ; for (idx , (instrument , count)) in instruments . iter () . enumerate () { let percentage = (* count as f64 / total_files as f64) * 100.0 ; report . push_str (& format ! ("| {} | {} | {} | {:.2}% |\n" , idx + 1 , instrument , count , percentage)) ; } let report_path = "INSTRUMENT_ANALYSIS.md" ; std :: fs :: write (report_path , & report) ? ; println ! ("Report saved to: {}" , report_path) ; let mut instrument_list = String :: new () ; for (instrument , count) in & instruments { instrument_list . push_str (& format ! ("{}: {}\n" , instrument , count)) ; } let list_path = "INSTRUMENT_LIST.txt" ; std :: fs :: write (list_path , instrument_list) ? ; println ! ("Instrument list saved to: {}" , list_path) ; Ok (()) }

- [ ] **Function 'main' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/extract_instruments.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn main () { let args : Vec < String > = std :: env :: args () . collect () ; if args . len () < 2 { eprintln ! ("Usage: {} <midi-library-path>" , args [0]) ; eprintln ! ("\nExample:") ; eprintln ! ("  {} ~/projects/midi-software-center/midi-library/" , args [0]) ; std :: process :: exit (1) ; } let root_path = & args [1] ; println ! ("MIDI Instrument Extractor") ; println ! ("=========================") ; println ! ("Root path: {}" , root_path) ; println ! () ; let files = find_midi_files (root_path) ; if files . is_empty () { println ! ("No MIDI files found!") ; std :: process :: exit (0) ; } let total_files = files . len () ; let instrument_counts = process_files (files) ; match generate_report (instrument_counts , total_files) { Ok (_) => println ! ("\nâœ… Analysis complete!") , Err (e) => { eprintln ! ("\nâŒ Error generating report: {}" , e) ; std :: process :: exit (1) ; } , } }

- [ ] **Function 'normalize_keyword' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/fast_tagger.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Normalize keyword from text"] fn normalize_keyword (text : & str) -> HashSet < String > { let mut keywords = HashSet :: new () ; if text . is_empty () { return keywords ; } let text = text . to_lowercase () ; let re = Regex :: new (r"[_\-\(\)\[\]@#]") . unwrap () ; let text = re . replace_all (& text , " ") ; let noise_words : HashSet < & str > = ["the" , "and" , "for" , "with" , "from" , "midi" , "mid"] . iter () . cloned () . collect () ; for word in text . split_whitespace () { let word = word . trim () ; if word . len () < 3 || word . len () > 50 { continue ; } if word . chars () . all (| c | c . is_numeric ()) { continue ; } if noise_words . contains (word) { continue ; } keywords . insert (word . to_string ()) ; } keywords }

- [ ] **Function 'extract_path_components' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/fast_tagger.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Extract grandparent, parent, and filename from path"] fn extract_path_components (file_id : i64 , filepath : & str) -> PathComponents { let path = Path :: new (filepath) ; let filename = path . file_stem () . and_then (| s | s . to_str ()) . unwrap_or ("") . to_string () ; let parent = path . parent () . and_then (| p | p . file_name ()) . and_then (| n | n . to_str ()) . unwrap_or ("") . to_string () ; let grandparent = path . parent () . and_then (| p | p . parent ()) . and_then (| p | p . file_name ()) . and_then (| n | n . to_str ()) . unwrap_or ("") . to_string () ; PathComponents { file_id , filepath : filepath . to_string () , grandparent , parent , filename } }

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/fast_tagger.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/fast_tagger.rs`
  - Category: Performance

- [ ] **Function 'process_files_for_tags' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/fast_tagger.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Process files and extract matching tags"] fn process_files_for_tags (files : Vec < PathComponents > , tag_map : & HashMap < String , i64 > , stats : Arc < TaggingStats > ,) -> Vec < FileTag > { println ! ("âš™ï¸ Processing files for tag matching...") ; let file_tags : Vec < FileTag > = files . par_iter () . flat_map (| file | { stats . processed . fetch_add (1 , Ordering :: Relaxed) ; let mut keywords = HashSet :: new () ; keywords . extend (normalize_keyword (& file . grandparent)) ; keywords . extend (normalize_keyword (& file . parent)) ; keywords . extend (normalize_keyword (& file . filename)) ; let mut file_tags = Vec :: new () ; for keyword in keywords { if let Some (& tag_id) = tag_map . get (& keyword) { file_tags . push (FileTag { file_id : file . file_id , tag_id }) ; } } if ! file_tags . is_empty () { stats . tagged . fetch_add (1 , Ordering :: Relaxed) ; stats . total_tags_inserted . fetch_add (file_tags . len () as u64 , Ordering :: Relaxed) ; } file_tags }) . collect () ; println ! ("âœ… Matched {} tag relationships" , file_tags . len ()) ; file_tags }

- [ ] **Function 'normalize_keyword' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/fast_tagger_full.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Normalize keyword from text"] fn normalize_keyword (text : & str) -> HashSet < String > { let mut keywords = HashSet :: new () ; if text . is_empty () { return keywords ; } let text = text . to_lowercase () ; let re = Regex :: new (r"[_\-\(\)\[\]@#/\\]") . unwrap () ; let text = re . replace_all (& text , " ") ; let noise_words : HashSet < & str > = ["the" , "and" , "for" , "with" , "from" , "midi" , "mid" , "extracted" , "archive" , "archives" , "files" , "file" , "pack" , "collection" ,] . iter () . cloned () . collect () ; for word in text . split_whitespace () { let word = word . trim () ; if word . len () < 2 || word . len () > 50 { continue ; } if word . chars () . all (| c | c . is_numeric ()) { continue ; } if noise_words . contains (word) { continue ; } keywords . insert (word . to_string ()) ; } keywords }

- [ ] **Function 'extract_path_components' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/fast_tagger_full.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Extract grandparent, parent, and filename from path"] fn extract_path_components (file_id : i64 , filepath : & str) -> PathComponents { let path = Path :: new (filepath) ; let filename = path . file_stem () . and_then (| s | s . to_str ()) . unwrap_or ("") . to_string () ; let parent = path . parent () . and_then (| p | p . file_name ()) . and_then (| n | n . to_str ()) . unwrap_or ("") . to_string () ; let grandparent = path . parent () . and_then (| p | p . parent ()) . and_then (| p | p . file_name ()) . and_then (| n | n . to_str ()) . unwrap_or ("") . to_string () ; PathComponents { file_id , filepath : filepath . to_string () , grandparent , parent , filename } }

- [ ] **Function 'load_keywords_from_file' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/fast_tagger_full.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Load keywords from frequency file (format: \"count keyword\")"] fn load_keywords_from_file (file_path : & str , min_freq : usize ,) -> Result < HashSet < String > , Box < dyn std :: error :: Error > > { println ! ("ğŸ“‹ Loading keywords from: {}" , file_path) ; let start = Instant :: now () ; let content = fs :: read_to_string (file_path) ? ; let mut keywords = HashSet :: new () ; let mut total_count = 0 ; let mut filtered_count = 0 ; let mut parse_errors = 0 ; for line in content . lines () { let line = line . trim () ; if line . is_empty () { continue ; } total_count += 1 ; if let Some (first_space) = line . find (char :: is_whitespace) { let count_str = line [.. first_space] . trim () ; let keyword = line [first_space ..] . trim () ; if keyword . is_empty () { parse_errors += 1 ; continue ; } match count_str . parse :: < usize > () { Ok (freq) if freq >= min_freq => { for kw in normalize_keyword (keyword) { keywords . insert (kw) ; } filtered_count += 1 ; } , Ok (_) => { } , Err (_) => { parse_errors += 1 ; } , } } else { parse_errors += 1 ; } } println ! ("âœ… Loaded {} keywords ({} filtered from {} total, {} parse errors) in {:.2}s" , keywords . len () , filtered_count , total_count , parse_errors , start . elapsed () . as_secs_f64 ()) ; if ! keywords . is_empty () { let sample : Vec < String > = keywords . iter () . take (5) . cloned () . collect () ; println ! ("  Sample keywords: {:?}" , sample) ; } Ok (keywords) }

- [ ] **Function 'load_all_keywords' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/fast_tagger_full.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Load ALL keywords from the three source files"] fn load_all_keywords (args : & Args) -> Result < HashSet < String > , Box < dyn std :: error :: Error > > { println ! ("\nğŸ“š Loading ALL keywords from collection...") ; let start = Instant :: now () ; let mut all_keywords = HashSet :: new () ; println ! ("\n1ï¸âƒ£ Grandparent Folder Keywords:") ; let grandparent_kw = load_keywords_from_file (& args . grandparent_file , args . min_frequency) ? ; all_keywords . extend (grandparent_kw) ; println ! ("\n2ï¸âƒ£ Parent Folder Keywords:") ; let parent_kw = load_keywords_from_file (& args . parent_file , args . min_frequency) ? ; all_keywords . extend (parent_kw) ; println ! ("\n3ï¸âƒ£ Filename Keywords:") ; let filename_kw = load_keywords_from_file (& args . filename_file , args . min_frequency) ? ; all_keywords . extend (filename_kw) ; println ! ("\nâœ… Total unique keywords loaded: {} (in {:.2}s)" , all_keywords . len () , start . elapsed () . as_secs_f64 ()) ; Ok (all_keywords) }

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/fast_tagger_full.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/fast_tagger_full.rs`
  - Category: Performance

- [ ] **Function 'process_files_for_tags' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/fast_tagger_full.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Process files and extract matching tags"] fn process_files_for_tags (files : Vec < PathComponents > , tag_map : & HashMap < String , i64 > , stats : Arc < TaggingStats > ,) -> Vec < FileTag > { println ! ("âš™ï¸ Processing files for tag matching...") ; let file_tags : Vec < FileTag > = files . par_iter () . flat_map (| file | { stats . processed . fetch_add (1 , Ordering :: Relaxed) ; let mut keywords = HashSet :: new () ; keywords . extend (normalize_keyword (& file . grandparent)) ; keywords . extend (normalize_keyword (& file . parent)) ; keywords . extend (normalize_keyword (& file . filename)) ; let mut file_tags = Vec :: new () ; for keyword in keywords { if let Some (& tag_id) = tag_map . get (& keyword) { file_tags . push (FileTag { file_id : file . file_id , tag_id }) ; } } if ! file_tags . is_empty () { stats . tagged . fetch_add (1 , Ordering :: Relaxed) ; stats . total_tags_inserted . fetch_add (file_tags . len () as u64 , Ordering :: Relaxed) ; } file_tags }) . collect () ; println ! ("âœ… Matched {} tag relationships" , file_tags . len ()) ; file_tags }

- [ ] **Function 'hash_file' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/find_duplicates.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Calculate BLAKE3 hash of a file"] fn hash_file (path : & Path) -> Result < String , std :: io :: Error > { let mut file = fs :: File :: open (path) ? ; let mut hasher = blake3 :: Hasher :: new () ; let mut buffer = vec ! [0 ; 65536] ; loop { let bytes_read = file . read (& mut buffer) ? ; if bytes_read == 0 { break ; } hasher . update (& buffer [.. bytes_read]) ; } Ok (hasher . finalize () . to_hex () . to_string ()) }

- [ ] **Function 'find_midi_files' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/find_duplicates.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Find all MIDI files recursively"] fn find_midi_files (root : & Path) -> Vec < PathBuf > { println ! ("Scanning for MIDI files...") ; let start = Instant :: now () ; let files : Vec < PathBuf > = walkdir :: WalkDir :: new (root) . follow_links (false) . into_iter () . filter_map (| e | e . ok ()) . filter (| e | { e . path () . extension () . and_then (| ext | ext . to_str ()) . map (| ext | { let ext_lower = ext . to_lowercase () ; ext_lower == "mid" || ext_lower == "midi" }) . unwrap_or (false) }) . map (| e | e . path () . to_path_buf ()) . collect () ; println ! ("Found {} MIDI files in {:?}" , files . len () , start . elapsed ()) ; files }

- [ ] **Function 'detect_duplicates' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/find_duplicates.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Process files and detect duplicates"] fn detect_duplicates (files : Vec < PathBuf >) -> (HashMap < String , Vec < FileInfo > > , Arc < DuplicateStats >) { println ! ("\nHashing {} files..." , files . len ()) ; let start = Instant :: now () ; let file_map : DashMap < String , Vec < FileInfo > > = DashMap :: new () ; let stats = Arc :: new (DuplicateStats :: new ()) ; let processed = AtomicU64 :: new (0) ; files . par_iter () . for_each (| path | { let size = match fs :: metadata (path) { Ok (metadata) => metadata . len () , Err (_) => return , } ; let hash = match hash_file (path) { Ok (h) => h , Err (_) => return , } ; let info = FileInfo { path : path . clone () , size , hash : hash . clone () } ; file_map . entry (hash) . or_insert_with (Vec :: new) . push (info) ; stats . total_files . fetch_add (1 , Ordering :: Relaxed) ; stats . total_bytes . fetch_add (size , Ordering :: Relaxed) ; let count = processed . fetch_add (1 , Ordering :: Relaxed) + 1 ; if count % 10000 == 0 { let elapsed = start . elapsed () ; let rate = count as f64 / elapsed . as_secs_f64 () ; println ! ("Processed: {}   files ({:.0} files/sec)" , count , rate) ; } }) ; let elapsed = start . elapsed () ; let total = stats . total_files . load (Ordering :: Relaxed) ; let rate = total as f64 / elapsed . as_secs_f64 () ; println ! ("\nHashing complete: {}   files in {:?} ({:.0} files/sec)" , total , elapsed , rate) ; let mut result = HashMap :: new () ; for entry in file_map . into_iter () { result . insert (entry . 0 , entry . 1) ; } (result , stats) }

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/find_duplicates.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/find_duplicates.rs`
  - Category: Performance

- [ ] **Function 'analyze_duplicates' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/find_duplicates.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Analyze duplicates and update stats"] fn analyze_duplicates (file_map : & HashMap < String , Vec < FileInfo > > , stats : & DuplicateStats ,) -> Vec < (String , Vec < FileInfo >) > { let mut duplicates = Vec :: new () ; for (hash , files) in file_map { if files . len () > 1 { stats . unique_files . fetch_add (1 , Ordering :: Relaxed) ; let dup_count = files . len () as u64 - 1 ; stats . duplicate_files . fetch_add (dup_count , Ordering :: Relaxed) ; let file_size = files [0] . size ; stats . duplicate_bytes . fetch_add (file_size * dup_count , Ordering :: Relaxed) ; duplicates . push ((hash . clone () , files . clone ())) ; } else { stats . unique_files . fetch_add (1 , Ordering :: Relaxed) ; } } duplicates . sort_by (| a , b | b . 1 . len () . cmp (& a . 1 . len ())) ; duplicates }

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/find_duplicates.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/find_duplicates.rs`
  - Category: Performance

- [ ] **Function 'format_number' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/find_duplicates.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Format number with thousand separators"] fn format_number (n : u64) -> String { n . to_string () . as_bytes () . rchunks (3) . rev () . map (std :: str :: from_utf8) . collect :: < Result < Vec < & str > , _ > > () . unwrap () . join (",") }

- [ ] **Function 'generate_report' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/find_duplicates.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Generate duplicate report"] fn generate_report (duplicates : & [(String , Vec < FileInfo >)] , stats : & DuplicateStats , output_path : & Path ,) -> std :: io :: Result < () > { let mut output = String :: new () ; output . push_str ("# MIDI Duplicate Files Report\n\n") ; let total_files = stats . total_files . load (Ordering :: Relaxed) ; let total_bytes = stats . total_bytes . load (Ordering :: Relaxed) ; let unique_files = stats . unique_files . load (Ordering :: Relaxed) ; let duplicate_files = stats . duplicate_files . load (Ordering :: Relaxed) ; let duplicate_bytes = stats . duplicate_bytes . load (Ordering :: Relaxed) ; output . push_str ("## Summary Statistics\n\n") ; output . push_str (& format ! ("- **Total files scanned:** {}  \n" , total_files)) ; output . push_str (& format ! ("- **Total size:** {:.2} GB\n" , total_bytes as f64 / 1_073_741_824.0)) ; output . push_str (& format ! ("- **Unique files:** {}  \n" , unique_files)) ; output . push_str (& format ! ("- **Duplicate files:** {}   ({:.1}%)\n" , duplicate_files , duplicate_files as f64 / total_files as f64 * 100.0)) ; output . push_str (& format ! ("- **Space wasted by duplicates:** {:.2} GB\n" , duplicate_bytes as f64 / 1_073_741_824.0)) ; output . push_str (& format ! ("- **Duplicate groups:** {}  \n\n" , duplicates . len ())) ; output . push_str ("## Duplicate Groups\n\n") ; output . push_str ("Each group shows files with identical content. The **first file** in each group will be **KEPT**, all others will be **DELETED**.\n\n") ; for (i , (hash , files)) in duplicates . iter () . enumerate () { output . push_str (& format ! ("### Group {} ({} duplicates)\n\n" , i + 1 , files . len () - 1)) ; output . push_str (& format ! ("**Hash:** `{}`\n" , & hash [.. 16])) ; output . push_str (& format ! ("**Size:** {:.2} KB\n\n" , files [0] . size as f64 / 1024.0)) ; output . push_str ("| Status | Path |\n") ; output . push_str ("|--------|------|\n") ; for (j , file) in files . iter () . enumerate () { let status = if j == 0 { "âœ… KEEP" } else { "âŒ DELETE" } ; output . push_str (& format ! ("| {} | `{}` |\n" , status , file . path . display ())) ; } output . push_str ("\n") ; if i >= 99 { output . push_str (& format ! ("\n*Note: Only showing first 100 groups. Total groups: {}*\n\n" , duplicates . len ())) ; break ; } } output . push_str ("\n---\n\n") ; output . push_str ("## Deletion Summary\n\n") ; output . push_str (& format ! ("Total files to delete: **{}  **\n" , duplicate_files)) ; output . push_str (& format ! ("Space to recover: **{:.2} GB**\n\n" , duplicate_bytes as f64 / 1_073_741_824.0)) ; fs :: write (output_path , output) ? ; let delete_list_path = output_path . with_extension ("delete.txt") ; let mut delete_list = String :: new () ; for (_hash , files) in duplicates { for file in files . iter () . skip (1) { delete_list . push_str (& format ! ("{}\n" , file . path . display ())) ; } } fs :: write (& delete_list_path , delete_list) ? ; println ! ("\nDeletion list saved to: {}" , delete_list_path . display ()) ; Ok (()) }

- [ ] **Function 'execute_deletion' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/find_duplicates.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Execute deletion"] fn execute_deletion (delete_list_path : & Path) -> std :: io :: Result < u64 > { println ! ("\nâš ï¸  EXECUTING DELETION...") ; let content = fs :: read_to_string (delete_list_path) ? ; let files : Vec < & str > = content . lines () . collect () ; let deleted = AtomicU64 :: new (0) ; let failed = AtomicU64 :: new (0) ; files . par_iter () . for_each (| path | { match fs :: remove_file (path) { Ok (_) => { deleted . fetch_add (1 , Ordering :: Relaxed) ; } , Err (e) => { eprintln ! ("Failed to delete {}: {}" , path , e) ; failed . fetch_add (1 , Ordering :: Relaxed) ; } , } let count = deleted . load (Ordering :: Relaxed) ; if count % 1000 == 0 { println ! ("Deleted: {}   files" , count) ; } }) ; let total_deleted = deleted . load (Ordering :: Relaxed) ; let total_failed = failed . load (Ordering :: Relaxed) ; println ! ("\nâœ… Deletion complete!") ; println ! ("Files deleted: {}  " , total_deleted) ; if total_failed > 0 { println ! ("âš ï¸  Failed to delete: {}  " , total_failed) ; } Ok (total_deleted) }

- [ ] **Function 'main' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/find_duplicates.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn main () { let args : Vec < String > = std :: env :: args () . collect () ; if args . len () < 2 { eprintln ! ("Usage: {} <path> [--delete]" , args [0]) ; eprintln ! ("\nOptions:") ; eprintln ! ("  <path>      Path to MIDI directory") ; eprintln ! ("  --delete    Execute deletion (use with caution!)") ; eprintln ! ("\nExample:") ; eprintln ! ("  {} /path/to/midi/files" , args [0]) ; eprintln ! ("  {} /path/to/midi/files --delete" , args [0]) ; std :: process :: exit (1) ; } let root_path = PathBuf :: from (& args [1]) ; let delete_mode = args . len () > 2 && args [2] == "--delete" ; if ! root_path . exists () { eprintln ! ("Error: Path does not exist: {}" , root_path . display ()) ; std :: process :: exit (1) ; } println ! ("MIDI Duplicate Finder") ; println ! ("=====================") ; println ! ("Root path: {}" , root_path . display ()) ; if delete_mode { println ! ("âš ï¸  DELETE MODE ENABLED - Files will be deleted!") ; } else { println ! ("Mode: Analysis only (no deletion)") ; } println ! () ; let files = find_midi_files (& root_path) ; if files . is_empty () { println ! ("No MIDI files found!") ; std :: process :: exit (0) ; } let (file_map , stats) = detect_duplicates (files) ; let duplicates = analyze_duplicates (& file_map , & stats) ; if duplicates . is_empty () { println ! ("\nâœ… No duplicates found! All files are unique.") ; std :: process :: exit (0) ; } let report_path = PathBuf :: from ("DUPLICATE_REPORT.md") ; println ! ("\nGenerating report...") ; match generate_report (& duplicates , & stats , & report_path) { Ok (_) => println ! ("Report saved to: {}" , report_path . display ()) , Err (e) => { eprintln ! ("Error generating report: {}" , e) ; std :: process :: exit (1) ; } , } if delete_mode { println ! ("\nâš ï¸  âš ï¸  âš ï¸  WARNING âš ï¸  âš ï¸  âš ï¸") ; println ! ("You are about to DELETE {}   files!" , stats . duplicate_files . load (Ordering :: Relaxed)) ; println ! ("This will free {:.2} GB of space." , stats . duplicate_bytes . load (Ordering :: Relaxed) as f64 / 1_073_741_824.0) ; println ! ("\nPress Ctrl+C within 10 seconds to cancel...") ; std :: thread :: sleep (std :: time :: Duration :: from_secs (10)) ; let delete_list_path = report_path . with_extension ("delete.txt") ; match execute_deletion (& delete_list_path) { Ok (deleted) => println ! ("\nâœ… Successfully deleted {}   duplicate files!" , deleted) , Err (e) => eprintln ! ("\nâŒ Error during deletion: {}" , e) , } } else { println ! ("\nğŸ“‹ Review the report and deletion list.") ; println ! ("To execute deletion, run:") ; println ! ("  {} {} --delete" , args [0] , root_path . display ()) ; } }

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/import.rs`
  - Category: Performance

- [ ] **Function 'hash_file' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/import_split_files.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Calculate BLAKE3 hash of a file (returns raw bytes)"] fn hash_file (path : & Path) -> Result < Vec < u8 > , std :: io :: Error > { let mut file = fs :: File :: open (path) ? ; let mut hasher = blake3 :: Hasher :: new () ; let mut buffer = vec ! [0 ; 65536] ; loop { let bytes_read = file . read (& mut buffer) ? ; if bytes_read == 0 { break ; } hasher . update (& buffer [.. bytes_read]) ; } Ok (hasher . finalize () . as_bytes () . to_vec ()) }

- [ ] **Function 'extract_parent_info' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/import_split_files.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Extract parent file ID and track number from split filename"] # [doc = " Format: {parent_id}_{original_name}_{track_num}_{instrument}.mid"] fn extract_parent_info (filename : & str) -> (Option < i64 > , Option < i16 >) { if let Some (caps) = regex :: Regex :: new (r"^(\d+)_") . unwrap () . captures (filename) { let parent_id = caps . get (1) . and_then (| m | m . as_str () . parse :: < i64 > () . ok ()) ; let track_number = regex :: Regex :: new (r"_(\d{2})_") . unwrap () . captures (filename) . and_then (| caps | caps . get (1)) . and_then (| m | m . as_str () . parse :: < i16 > () . ok ()) ; return (parent_id , track_number) ; } (None , None) }

- [ ] **Function 'parse_midi_basic' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/import_split_files.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Parse MIDI file for basic metadata"] fn parse_midi_basic (path : & Path) -> Result < (i16 , i16 , i32 , i64) , String > { let data = fs :: read (path) . map_err (| e | format ! ("Failed to read file: {}" , e)) ? ; let smf = Smf :: parse (& data) . map_err (| e | format ! ("Failed to parse MIDI: {}" , e)) ? ; let midi_format = match smf . header . format { midly :: Format :: SingleTrack => 0 , midly :: Format :: Parallel => 1 , midly :: Format :: Sequential => 2 , } ; let num_tracks = smf . tracks . len () as i16 ; let ticks_per_quarter = match smf . header . timing { Timing :: Metrical (tpq) => tpq . as_int () as i32 , Timing :: Timecode (fps , sub) => { let ticks_per_second = fps . as_f32 () * sub as f32 ; (ticks_per_second * 0.5) as i32 } , } ; let mut max_ticks = 0i64 ; for track in & smf . tracks { let mut track_ticks = 0i64 ; for event in track { track_ticks += event . delta . as_int () as i64 ; } if track_ticks > max_ticks { max_ticks = track_ticks ; } } Ok ((midi_format , num_tracks , ticks_per_quarter , max_ticks)) }

- [ ] **Function 'find_midi_files' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/import_split_files.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Find all MIDI files in directory"] fn find_midi_files (root : & Path) -> Vec < PathBuf > { println ! ("ğŸ” Scanning for MIDI files in: {}" , root . display ()) ; let start = Instant :: now () ; let files : Vec < PathBuf > = walkdir :: WalkDir :: new (root) . follow_links (false) . into_iter () . filter_map (| e | e . ok ()) . filter (| e | { e . path () . extension () . and_then (| ext | ext . to_str ()) . map (| ext | { let ext_lower = ext . to_lowercase () ; ext_lower == "mid" || ext_lower == "midi" }) . unwrap_or (false) }) . map (| e | e . path () . to_path_buf ()) . collect () ; println ! ("âœ… Found {} MIDI files in {:.2}s" , files . len () , start . elapsed () . as_secs_f64 ()) ; files }

- [ ] **Function 'process_files' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/import_split_files.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Process files in parallel and extract metadata"] fn process_files (files : Vec < PathBuf > , existing_hashes : Arc < DashMap < Vec < u8 > , () > > , stats : Arc < ImportStats > , skip_existing : bool ,) -> Vec < FileRecord > { println ! ("âš™ï¸ Processing {} files with rayon..." , files . len ()) ; let records : Vec < FileRecord > = files . par_iter () . filter_map (| path | { stats . processed . fetch_add (1 , Ordering :: Relaxed) ; let content_hash = match hash_file (path) { Ok (h) => h , Err (e) => { eprintln ! ("âŒ Hash error for {}: {}" , path . display () , e) ; stats . errors . fetch_add (1 , Ordering :: Relaxed) ; return None ; } , } ; if skip_existing && existing_hashes . contains_key (& content_hash) { stats . skipped . fetch_add (1 , Ordering :: Relaxed) ; return None ; } let file_size_bytes = match fs :: metadata (path) { Ok (m) => m . len () as i64 , Err (e) => { eprintln ! ("âŒ Metadata error for {}: {}" , path . display () , e) ; stats . errors . fetch_add (1 , Ordering :: Relaxed) ; return None ; } , } ; let (format , num_tracks , ticks_per_quarter , duration_ticks) = match parse_midi_basic (path) { Ok (data) => data , Err (e) => { eprintln ! ("âŒ MIDI parse error for {}: {}" , path . display () , e) ; stats . errors . fetch_add (1 , Ordering :: Relaxed) ; return None ; } , } ; let filename = path . file_name () ? . to_str () ? . to_string () ; let (parent_file_id , track_number) = extract_parent_info (& filename) ; Some (FileRecord { filepath : path . to_str () ? . to_string () , filename : filename . clone () , original_filename : filename , content_hash , file_size_bytes , parent_file_id , track_number , format , num_tracks , ticks_per_quarter_note : ticks_per_quarter , duration_ticks , }) }) . collect () ; println ! ("âœ… Processed {} valid records" , records . len ()) ; records }

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/import_split_files.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/import_unified.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/import_unified.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/import_unified.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/import_unified.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/import_unified.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/import_unified.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/import_unified.rs`
  - Category: Performance

- [ ] **Function 'analyze_notes' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/import_unified.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn analyze_notes (midi_file : & MidiFile) -> NoteStats { let mut note_count = 0 ; let mut min_pitch = 127u8 ; let mut max_pitch = 0u8 ; let mut min_velocity = 127u8 ; let mut max_velocity = 0u8 ; let mut velocity_sum = 0u32 ; let mut active_notes_per_tick : std :: collections :: HashMap < u32 , usize > = std :: collections :: HashMap :: new () ; for track in & midi_file . tracks { let mut current_tick = 0u32 ; let mut active_notes = std :: collections :: HashSet :: new () ; for timed_event in & track . events { current_tick += timed_event . delta_ticks ; match & timed_event . event { Event :: NoteOn { note , velocity , .. } if * velocity > 0 => { note_count += 1 ; min_pitch = min_pitch . min (* note) ; max_pitch = max_pitch . max (* note) ; min_velocity = min_velocity . min (* velocity) ; max_velocity = max_velocity . max (* velocity) ; velocity_sum += * velocity as u32 ; active_notes . insert (* note) ; active_notes_per_tick . insert (current_tick , active_notes . len ()) ; } , Event :: NoteOff { note , .. } | Event :: NoteOn { note , velocity : 0 , .. } => { active_notes . remove (note) ; } , _ => { } , } } } let avg_velocity = if note_count > 0 { Some (velocity_sum as f64 / note_count as f64) } else { None } ; let polyphony_max = active_notes_per_tick . values () . max () . copied () . map (| v | v as i16) ; let (pitch_range_low , pitch_range_high , pitch_range_semitones) = if note_count > 0 { let semitones = max_pitch . saturating_sub (min_pitch) as i16 ; (Some (min_pitch as i16) , Some (max_pitch as i16) , Some (semitones) ,) } else { (None , None , None) } ; let (velocity_range_low , velocity_range_high) = if note_count > 0 { (Some (min_velocity as i16) , Some (max_velocity as i16)) } else { (None , None) } ; NoteStats { note_count , pitch_range_low , pitch_range_high , pitch_range_semitones , avg_velocity , velocity_range_low , velocity_range_high , polyphony_max , } }

- [ ] **Function 'extract_time_signature' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/import_unified.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn extract_time_signature (midi_file : & MidiFile) -> (Option < i16 > , Option < i16 >) { for track in & midi_file . tracks { for timed_event in & track . events { if let Event :: TimeSignature { numerator , denominator , .. } = & timed_event . event { let denom_value = 2i16 . pow (* denominator as u32) ; return (Some (* numerator as i16) , Some (denom_value)) ; } } } (Some (4) , Some (4)) }

- [ ] **Function 'calculate_total_ticks' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/import_unified.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn calculate_total_ticks (midi_file : & MidiFile) -> i32 { let mut max_ticks = 0u32 ; for track in & midi_file . tracks { let mut track_ticks = 0u32 ; for timed_event in & track . events { track_ticks += timed_event . delta_ticks ; } max_ticks = max_ticks . max (track_ticks) ; } max_ticks as i32 }

- [ ] **Function 'calculate_duration_seconds' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/import_unified.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn calculate_duration_seconds (midi_file : & MidiFile , bpm : f64) -> Option < f64 > { let total_ticks = calculate_total_ticks (midi_file) as f64 ; let ticks_per_quarter = midi_file . header . ticks_per_quarter_note as f64 ; if total_ticks > 0.0 && ticks_per_quarter > 0.0 && bpm > 0.0 { let quarters = total_ticks / ticks_per_quarter ; let minutes = quarters / bpm ; let seconds = minutes * 60.0 ; Some (seconds) } else { None } }

- [ ] **Function 'extract_instrument_names' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/import_unified.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn extract_instrument_names (midi_file : & MidiFile) -> Vec < String > { let mut instruments = Vec :: new () ; for track in & midi_file . tracks { for timed_event in & track . events { match & timed_event . event { Event :: Text { text_type , text } => { if matches ! (text_type , TextType :: InstrumentName | TextType :: TrackName) && ! instruments . contains (text) { instruments . push (text . clone ()) ; } } , Event :: ProgramChange { program , .. } => { if let Some (instrument_name) = program_to_instrument_name (* program) { if ! instruments . contains (& instrument_name) { instruments . push (instrument_name) ; } } } , _ => { } , } } } instruments }

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/import_unified.rs`
  - Category: Performance

- [ ] **Function 'program_to_instrument_name' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/import_unified.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn program_to_instrument_name (program : u8) -> Option < String > { match program { 0 ..= 7 => Some ("Piano" . to_string ()) , 8 ..= 15 => Some ("Keys" . to_string ()) , 16 ..= 23 => Some ("Organ" . to_string ()) , 24 ..= 31 => Some ("Guitar" . to_string ()) , 32 ..= 39 => Some ("Bass" . to_string ()) , 40 ..= 47 => Some ("Strings" . to_string ()) , 48 ..= 55 => Some ("Ensemble" . to_string ()) , 56 ..= 63 => Some ("Brass" . to_string ()) , 64 ..= 71 => Some ("Woodwind" . to_string ()) , 72 ..= 79 => Some ("Flute" . to_string ()) , 80 ..= 87 => Some ("Lead" . to_string ()) , 88 ..= 95 => Some ("Pad" . to_string ()) , 96 ..= 103 => Some ("FX" . to_string ()) , 104 ..= 111 => Some ("Ethnic" . to_string ()) , 112 ..= 119 => Some ("Percussion" . to_string ()) , 120 ..= 127 => Some ("FX" . to_string ()) , _ => None , } }

- [ ] **Function 'detect_pitch_bend' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/import_unified.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn detect_pitch_bend (midi_file : & MidiFile) -> bool { for track in & midi_file . tracks { for timed_event in & track . events { if matches ! (& timed_event . event , Event :: PitchBend { .. }) { return true ; } } } false }

- [ ] **Function 'detect_cc_messages' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/import_unified.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn detect_cc_messages (midi_file : & MidiFile) -> bool { for track in & midi_file . tracks { for timed_event in & track . events { if matches ! (& timed_event . event , Event :: ControlChange { .. }) { return true ; } } } false }

- [ ] **Function 'calculate_complexity_score' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/import_unified.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn calculate_complexity_score (note_stats : & NoteStats , midi_file : & MidiFile) -> Option < f64 > { if note_stats . note_count == 0 { return Some (0.0) ; } let mut score = 0.0 ; let duration_est = calculate_total_ticks (midi_file) as f64 / (midi_file . header . ticks_per_quarter_note as f64 * 2.0) ; if duration_est > 0.0 { let note_density = note_stats . note_count as f64 / duration_est ; score += (note_density / 10.0) . min (30.0) ; } if let Some (semitones) = note_stats . pitch_range_semitones { score += (semitones as f64 / 2.0) . min (20.0) ; } if let Some (polyphony) = note_stats . polyphony_max { score += (polyphony as f64 * 5.0) . min (25.0) ; } let track_count = midi_file . tracks . len () as f64 ; score += (track_count * 2.0) . min (15.0) ; if let (Some (low) , Some (high)) = (note_stats . velocity_range_low , note_stats . velocity_range_high ,) { let velocity_range = (high - low) as f64 ; score += (velocity_range / 10.0) . min (10.0) ; } Some (score . min (100.0)) }

- [ ] **Function 'print_progress_summary' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/import_unified.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn print_progress_summary (stats : & ImportStats) { let elapsed = stats . start_time . map (| t | t . elapsed () . as_secs_f64 ()) . unwrap_or (0.0) ; let imported = stats . files_imported . load (Ordering :: SeqCst) ; let rate = if elapsed > 0.0 { imported as f64 / elapsed } else { 0.0 } ; println ! ("  ğŸ“Š Progress:") ; println ! ("    Archives: {}/{}" , stats . archives_processed . load (Ordering :: SeqCst) , stats . archives_total . load (Ordering :: SeqCst)) ; println ! ("    Imported: {}" , imported) ; println ! ("    Duplicates: {}" , stats . files_duplicates . load (Ordering :: SeqCst)) ; println ! ("    Errors: {}" , stats . files_errors . load (Ordering :: SeqCst)) ; println ! ("    Rate: {:.1} files/sec" , rate) ; }

- [ ] **Function 'print_final_summary' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/import_unified.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn print_final_summary (stats : & ImportStats) { let elapsed = stats . start_time . map (| t | t . elapsed ()) . unwrap_or_else (| | std :: time :: Duration :: from_secs (0)) ; let duration_secs = elapsed . as_secs_f64 () ; let imported = stats . files_imported . load (Ordering :: SeqCst) ; let rate = if duration_secs > 0.0 { imported as f64 / duration_secs } else { 0.0 } ; println ! ("\n========================================") ; println ! ("UNIFIED IMPORT COMPLETE") ; println ! ("========================================") ; println ! ("Archives processed: {}/{}" , stats . archives_processed . load (Ordering :: SeqCst) , stats . archives_total . load (Ordering :: SeqCst)) ; println ! ("MIDI files found: {}" , stats . files_found . load (Ordering :: SeqCst)) ; println ! ("Successfully imported: {}" , imported) ; println ! ("  With full analysis: {}" , imported) ; println ! ("Duplicates skipped: {}" , stats . files_duplicates . load (Ordering :: SeqCst)) ; println ! ("Errors: {}" , stats . files_errors . load (Ordering :: SeqCst)) ; println ! ("Time: {:.0}h {:.0}m {:.0}s" , duration_secs / 3600.0 , (duration_secs % 3600.0) / 60.0 , duration_secs % 60.0) ; println ! ("Avg speed: {:.0} files/sec" , rate) ; println ! ("========================================") ; println ! ("All files include: BPM, Key, Tags, Complexity") ; println ! ("Ready to use in DAW!") ; println ! ("========================================\n") ; }

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/infer_instruments.rs`
  - Category: Performance

- [ ] **Function 'attempt_repair' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/midi_doctor.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Attempt to repair common MIDI file issues"] fn attempt_repair (data : & [u8]) -> Result < (Vec < u8 > , String) , String > { let mut repaired = data . to_vec () ; let mut fixes = Vec :: new () ; if repaired . len () >= 14 { if & repaired [0 .. 4] == b"MThd" { let mut pos = 14 ; while pos < repaired . len () { if pos + 8 > repaired . len () { break ; } if & repaired [pos .. pos + 4] == b"MTrk" { let track_len = u32 :: from_be_bytes ([repaired [pos + 4] , repaired [pos + 5] , repaired [pos + 6] , repaired [pos + 7] ,]) as usize ; let track_end = pos + 8 + track_len ; if track_end <= repaired . len () { let has_eot = if track_end >= 3 { & repaired [track_end - 3 .. track_end] == & [0xFF , 0x2F , 0x00] } else { false } ; if ! has_eot && track_end < repaired . len () { repaired . splice (track_end .. track_end , [0xFF , 0x2F , 0x00] . iter () . cloned ()) ; let new_len = track_len + 3 ; let len_bytes = new_len . to_be_bytes () ; repaired [pos + 4] = len_bytes [0] ; repaired [pos + 5] = len_bytes [1] ; repaired [pos + 6] = len_bytes [2] ; repaired [pos + 7] = len_bytes [3] ; fixes . push ("Added missing End-of-Track marker" . to_string ()) ; } pos = track_end ; } else { break ; } } else { pos += 1 ; } } } } if repaired . len () > 14 && & repaired [0 .. 4] == b"MThd" { let header_len = u32 :: from_be_bytes ([repaired [4] , repaired [5] , repaired [6] , repaired [7]]) as usize ; if header_len == 6 { let num_tracks = u16 :: from_be_bytes ([repaired [10] , repaired [11]]) as usize ; let mut expected_size = 14 ; let mut pos = 14 ; for _ in 0 .. num_tracks { if pos + 8 > repaired . len () { break ; } if & repaired [pos .. pos + 4] == b"MTrk" { let track_len = u32 :: from_be_bytes ([repaired [pos + 4] , repaired [pos + 5] , repaired [pos + 6] , repaired [pos + 7] ,]) as usize ; expected_size = pos + 8 + track_len ; pos = expected_size ; } else { break ; } } if expected_size < repaired . len () { let trimmed = repaired . len () - expected_size ; repaired . truncate (expected_size) ; fixes . push (format ! ("Trimmed {} bytes of trailing garbage" , trimmed)) ; } } } if fixes . is_empty () { Err ("No repairs needed or possible" . to_string ()) } else { Ok ((repaired , fixes . join (", "))) } }

- [ ] **Function 'diagnose_midi_file' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/midi_doctor.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Diagnose a MIDI file and attempt repair if needed"] fn diagnose_midi_file (path : & Path , repair_dir : Option < & Path >) -> MidiStatus { let data = match fs :: read (path) { Ok (d) => d , Err (_) => return MidiStatus :: Corrupt ("Cannot read file" . to_string ()) , } ; if data . len () < 14 { return MidiStatus :: Corrupt (format ! ("File too small ({} bytes, need 14+)" , data . len ())) ; } if & data [0 .. 4] != b"MThd" { return MidiStatus :: NotMidi ; } match parse_midi_file (& data) { Ok (_) => MidiStatus :: Valid , Err (e) => { match attempt_repair (& data) { Ok ((repaired_data , fix_description)) => { match parse_midi_file (& repaired_data) { Ok (_) => { if let Some (repair_dir) = repair_dir { let filename = path . file_name () . unwrap () ; let output_path = repair_dir . join (filename) ; if let Ok (()) = fs :: write (& output_path , & repaired_data) { MidiStatus :: Repaired (format ! ("{} (saved to repair dir)" , fix_description)) } else { MidiStatus :: Repaired (format ! ("{} (could not save)" , fix_description)) } } else { MidiStatus :: Repaired (fix_description) } } , Err (e2) => { MidiStatus :: Corrupt (format ! ("Repair failed: {} (original: {})" , e2 , e)) } , } } , Err (_) => MidiStatus :: Corrupt (format ! ("{}" , e)) , } } , } }

- [ ] **Function 'main' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/midi_doctor.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn main () { let args : Vec < String > = std :: env :: args () . collect () ; if args . len () < 2 { eprintln ! ("Usage: {} <directory> [repair-output-dir] [workers]" , args [0]) ; eprintln ! ("Example: {} /path/to/midi /path/to/repaired 64" , args [0]) ; eprintln ! () ; eprintln ! ("If repair-output-dir is provided, repaired files will be saved there.") ; std :: process :: exit (1) ; } let scan_dir = & args [1] ; let repair_dir = if args . len () > 2 && ! args [2] . parse :: < usize > () . is_ok () { Some (args [2] . as_str ()) } else { None } ; let workers = if args . len () > 3 { args [3] . parse :: < usize > () . unwrap_or_else (| _ | num_cpus :: get ()) } else if args . len () > 2 && args [2] . parse :: < usize > () . is_ok () { args [2] . parse :: < usize > () . unwrap () } else { num_cpus :: get () } ; println ! ("ğŸ¥ MIDI DOCTOR - Diagnostic and Repair Tool") ; println ! ("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•") ; println ! () ; println ! ("ğŸ“‚ Scan directory: {}" , scan_dir) ; if let Some (repair_dir) = repair_dir { println ! ("ğŸ”§ Repair output:  {}" , repair_dir) ; if let Err (e) = fs :: create_dir_all (repair_dir) { eprintln ! ("âŒ Failed to create repair directory: {}" , e) ; std :: process :: exit (1) ; } } else { println ! ("ğŸ”§ Repair output:  Disabled (diagnostics only)") ; } println ! ("âš¡ Parallel workers: {}" , workers) ; println ! () ; rayon :: ThreadPoolBuilder :: new () . num_threads (workers) . build_global () . unwrap () ; let start = Instant :: now () ; let stats = DiagnosticStats :: default () ; println ! ("ğŸ“Š Scanning for MIDI files...") ; let scan_start = Instant :: now () ; let files : Vec < PathBuf > = WalkDir :: new (scan_dir) . follow_links (false) . into_iter () . filter_map (| e | e . ok ()) . filter (| e | e . file_type () . is_file ()) . filter (| e | { let name = e . file_name () . to_string_lossy () . to_lowercase () ; name . ends_with (".mid") || name . ends_with (".midi") }) . map (| e | e . path () . to_path_buf ()) . collect () ; let scan_elapsed = scan_start . elapsed () . as_secs_f64 () ; println ! ("âœ“ Found {} MIDI files in {:.2}s" , files . len () , scan_elapsed) ; println ! () ; println ! ("ğŸ” Diagnosing MIDI files...") ; let repair_path = repair_dir . map (PathBuf :: from) ; files . par_iter () . for_each (| path | { let status = diagnose_midi_file (path , repair_path . as_deref ()) ; match & status { MidiStatus :: Valid => { stats . valid_files . fetch_add (1 , Ordering :: Relaxed) ; } , MidiStatus :: Repaired (desc) => { stats . repaired_files . fetch_add (1 , Ordering :: Relaxed) ; println ! ("ğŸ”§ REPAIRED: {} - {}" , path . display () , desc) ; } , MidiStatus :: Corrupt (reason) => { stats . corrupt_files . fetch_add (1 , Ordering :: Relaxed) ; println ! ("âŒ CORRUPT:  {} - {}" , path . display () , reason) ; } , MidiStatus :: NotMidi => { stats . not_midi . fetch_add (1 , Ordering :: Relaxed) ; println ! ("âš ï¸  NOT MIDI: {}" , path . display ()) ; } , } stats . total_files . fetch_add (1 , Ordering :: Relaxed) ; let total = stats . total_files . load (Ordering :: Relaxed) ; if total % 10000 == 0 { println ! ("  Progress: {} files scanned..." , total) ; } }) ; println ! ("âœ“ Diagnosis complete") ; println ! () ; let total_elapsed = start . elapsed () . as_secs_f64 () ; println ! ("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•") ; println ! ("âœ… MIDI DOCTOR COMPLETE!") ; stats . print_progress (total_elapsed) ; println ! () ; let repaired_count = stats . repaired_files . load (Ordering :: Relaxed) ; let corrupt_count = stats . corrupt_files . load (Ordering :: Relaxed) ; if repaired_count > 0 && repair_dir . is_some () { println ! ("ğŸ”§ Repaired files saved to: {}" , repair_dir . unwrap ()) ; } if corrupt_count > 0 { println ! ("âŒ {} files are truly corrupt and cannot be automatically repaired" , corrupt_count) ; println ! ("   These files may need manual inspection or re-downloading") ; } println ! () ; }

- [ ] **Function 'convert_midi_to_mpcpattern' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/midi_to_mpcpattern.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn convert_midi_to_mpcpattern (midi_path : & Path) -> Result < MpcPattern > { let midi_data = fs :: read (midi_path) . with_context (| | format ! ("Failed to read MIDI file: {}" , midi_path . display ())) ? ; let midi_file = parse_midi_file (& midi_data) . context ("Failed to parse MIDI file") ? ; let mut mpc_events = Vec :: new () ; let mut active_notes : HashMap < u8 , ActiveNote > = HashMap :: new () ; mpc_events . push (MpcEvent :: init_event (0 , 0.0)) ; mpc_events . push (MpcEvent :: init_event (32 , 0.0)) ; let init_velocity = 0.787401556968689 ; mpc_events . push (MpcEvent :: init_event (130 , init_velocity)) ; for track in & midi_file . tracks { let mut current_time = 0i64 ; for timed_event in & track . events { current_time += timed_event . delta_ticks as i64 ; let scaled_time = current_time * 2 ; match & timed_event . event { Event :: NoteOn { channel : _ , note , velocity } => { if * velocity > 0 { active_notes . insert (* note , ActiveNote { note : * note , velocity : * velocity , start_time : scaled_time , } ,) ; } else { if let Some (active) = active_notes . remove (note) { let duration = scaled_time - active . start_time ; let normalized_velocity = active . velocity as f64 / 127.0 ; mpc_events . push (MpcEvent :: note_on (active . start_time , duration , * note , normalized_velocity ,)) ; } } } , Event :: NoteOff { channel : _ , note , velocity : _ } => { if let Some (active) = active_notes . remove (note) { let duration = scaled_time - active . start_time ; let normalized_velocity = active . velocity as f64 / 127.0 ; mpc_events . push (MpcEvent :: note_on (active . start_time , duration , * note , normalized_velocity ,)) ; } } , _ => { } , } } } let max_time = mpc_events . iter () . filter (| e | e . event_type == 2) . map (| e | e . time + e . len) . max () . unwrap_or (0) ; for active in active_notes . values () { let duration = max_time - active . start_time ; let normalized_velocity = active . velocity as f64 / 127.0 ; mpc_events . push (MpcEvent :: note_on (active . start_time , duration , active . note , normalized_velocity ,)) ; } mpc_events . sort_by_key (| e | (e . time , e . event_type , e . field1)) ; Ok (MpcPattern { pattern : Pattern { length : i64 :: MAX , events : mpc_events , } , }) }

- [ ] **Function 'convert_file' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/midi_to_mpcpattern.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn convert_file (input : & Path , output : & Path) -> Result < () > { println ! ("Converting: {} -> {}" , input . display () , output . display ()) ; let pattern = convert_midi_to_mpcpattern (input) ? ; let json = serde_json :: to_string_pretty (& pattern) . context ("Failed to serialize pattern to JSON") ? ; fs :: write (output , json) . with_context (| | format ! ("Failed to write output file: {}" , output . display ())) ? ; println ! ("  âœ“ Created {} events" , pattern . pattern . events . len ()) ; Ok (()) }

- [ ] **Function 'batch_convert' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/midi_to_mpcpattern.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn batch_convert (input_dir : & Path , output_dir : & Path , limit : Option < usize >) -> Result < () > { println ! ("Batch converting MIDI files...") ; println ! ("  Input:  {}" , input_dir . display ()) ; println ! ("  Output: {}" , output_dir . display ()) ; if let Some (lim) = limit { println ! ("  Limit:  {} files" , lim) ; } println ! () ; fs :: create_dir_all (output_dir) . with_context (| | { format ! ("Failed to create output directory: {}" , output_dir . display ()) }) ? ; let mut midi_files = Vec :: new () ; for entry in walkdir :: WalkDir :: new (input_dir) . follow_links (true) . into_iter () . filter_map (| e | e . ok ()) { if entry . file_type () . is_file () { let path = entry . path () ; if let Some (ext) = path . extension () { if ext . eq_ignore_ascii_case ("mid") || ext . eq_ignore_ascii_case ("midi") { midi_files . push (path . to_path_buf ()) ; } } } } println ! ("Found {} MIDI files" , midi_files . len ()) ; if let Some (lim) = limit { midi_files . truncate (lim) ; println ! ("Processing first {} files" , midi_files . len ()) ; } println ! () ; let mut success = 0 ; let mut failed = 0 ; for (i , input_path) in midi_files . iter () . enumerate () { let file_stem = input_path . file_stem () . unwrap () . to_string_lossy () ; let output_path = output_dir . join (format ! ("{}.mpcpattern" , file_stem)) ; print ! ("[{}/{}] " , i + 1 , midi_files . len ()) ; match convert_file (input_path , & output_path) { Ok (_) => success += 1 , Err (e) => { println ! ("  âœ— Error: {}" , e) ; failed += 1 ; } , } } println ! () ; println ! ("Conversion complete:") ; println ! ("  Success: {}" , success) ; println ! ("  Failed:  {}" , failed) ; Ok (()) }

- [ ] **Function 'main' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/midi_to_mpcpattern.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn main () -> Result < () > { let args : Vec < String > = std :: env :: args () . collect () ; if args . len () < 3 { eprintln ! ("Usage:") ; eprintln ! ("  {} <input.mid> <output.mpcpattern>" , args [0]) ; eprintln ! ("  {} --batch <input_dir> <output_dir> [limit]" , args [0]) ; std :: process :: exit (1) ; } if args [1] == "--batch" { if args . len () < 4 { eprintln ! ("Batch mode requires input and output directories") ; std :: process :: exit (1) ; } let input_dir = Path :: new (& args [2]) ; let output_dir = Path :: new (& args [3]) ; let limit = args . get (4) . and_then (| s | s . parse :: < usize > () . ok ()) ; batch_convert (input_dir , output_dir , limit) ? ; } else { let input = Path :: new (& args [1]) ; let output = Path :: new (& args [2]) ; convert_file (input , output) ? ; } Ok (()) }

- [ ] **Function 'convert_file_fast' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/midi_to_mpcpattern_parallel.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Convert single file with memory-mapped I/O"] fn convert_file_fast (input : & Path , output : & Path) -> Result < usize > { let file = fs :: File :: open (input) . with_context (| | format ! ("Failed to open: {}" , input . display ())) ? ; let mmap = unsafe { memmap2 :: Mmap :: map (& file) ? } ; let pattern = convert_midi_to_mpcpattern (& mmap) ? ; let event_count = pattern . pattern . events . len () ; let json = serde_json :: to_string_pretty (& pattern) . context ("Failed to serialize") ? ; let mut f = fs :: File :: create (output) . with_context (| | format ! ("Failed to create: {}" , output . display ())) ? ; f . write_all (json . as_bytes ()) ? ; Ok (event_count) }

- [ ] **Function 'batch_convert_parallel' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/midi_to_mpcpattern_parallel.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Parallel batch converter with progress tracking"] fn batch_convert_parallel (input_paths : Vec < PathBuf > , output_dir : & Path , show_progress : bool ,) -> Result < () > { let start = Instant :: now () ; fs :: create_dir_all (output_dir) . with_context (| | format ! ("Failed to create output dir: {}" , output_dir . display ())) ? ; let total = input_paths . len () ; println ! ("\nğŸš€ MAXIMUM SPEED PARALLEL CONVERSION") ; println ! ("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”") ; println ! ("ğŸ“Š Files to process: {}" , total) ; println ! ("ğŸ”§ CPU cores available: {}" , num_cpus :: get ()) ; println ! ("ğŸ’¾ Allocator: jemalloc (high-performance)") ; println ! ("âš¡ Optimizations: rayon + memmap2 + LTO") ; println ! ("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n") ; let progress = if show_progress { let pb = ProgressBar :: new (total as u64) ; pb . set_style (ProgressStyle :: default_bar () . template ("[{elapsed_precise}] [{bar:40.cyan/blue}] {pos}/{len} ({per_sec}) {msg}") . unwrap () . progress_chars ("â–ˆâ–“â–’â–‘ ") ,) ; Some (pb) } else { None } ; let success = Arc :: new (AtomicUsize :: new (0)) ; let failed = Arc :: new (AtomicUsize :: new (0)) ; input_paths . par_iter () . for_each (| input_path | { let file_stem = input_path . file_stem () . unwrap () . to_string_lossy () ; let output_path = output_dir . join (format ! ("{}.mpcpattern" , file_stem)) ; match convert_file_fast (input_path , & output_path) { Ok (_events) => { success . fetch_add (1 , Ordering :: Relaxed) ; } , Err (e) => { eprintln ! ("âŒ Failed: {} - {}" , input_path . display () , e) ; failed . fetch_add (1 , Ordering :: Relaxed) ; } , } if let Some (ref pb) = progress { pb . inc (1) ; } }) ; if let Some (pb) = progress { pb . finish_with_message ("âœ… Complete") ; } let elapsed = start . elapsed () ; let success_count = success . load (Ordering :: Relaxed) ; let failed_count = failed . load (Ordering :: Relaxed) ; let files_per_sec = success_count as f64 / elapsed . as_secs_f64 () ; println ! ("\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”") ; println ! ("âœ… CONVERSION COMPLETE") ; println ! ("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”") ; println ! ("â±ï¸  Total time: {:.2}s" , elapsed . as_secs_f64 ()) ; println ! ("âœ… Success: {}" , success_count) ; println ! ("âŒ Failed: {}" , failed_count) ; println ! ("âš¡ Speed: {:.0} files/sec" , files_per_sec) ; println ! ("ğŸ¯ Throughput: {:.2} MB/s (estimated)" , files_per_sec * 0.005) ; println ! ("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n") ; Ok (()) }

- [ ] **Function 'find_midi_files' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/midi_to_mpcpattern_parallel.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Find all MIDI files in directory (parallel walk)"] fn find_midi_files (input_dir : & Path , limit : Option < usize >) -> Result < Vec < PathBuf > > { use jwalk :: WalkDir ; println ! ("ğŸ” Scanning for MIDI files...") ; let files : Vec < PathBuf > = WalkDir :: new (input_dir) . into_iter () . filter_map (| e | e . ok ()) . filter (| e | e . file_type () . is_file ()) . filter (| e | { e . path () . extension () . map (| ext | ext . eq_ignore_ascii_case ("mid") || ext . eq_ignore_ascii_case ("midi")) . unwrap_or (false) }) . map (| e | e . path ()) . take (limit . unwrap_or (usize :: MAX)) . collect () ; println ! ("âœ… Found {} MIDI files\n" , files . len ()) ; Ok (files) }

- [ ] **Function 'main' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/midi_to_mpcpattern_parallel.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn main () -> Result < () > { let args : Vec < String > = std :: env :: args () . collect () ; if args . len () < 3 { eprintln ! ("MIDI to .mpcpattern Converter (MAXIMUM SPEED EDITION)") ; eprintln ! () ; eprintln ! ("Usage:") ; eprintln ! ("  {} <input.mid> <output.mpcpattern>" , args [0]) ; eprintln ! ("  {} --batch <input_dir> <output_dir> [limit]" , args [0]) ; eprintln ! () ; eprintln ! ("Features:") ; eprintln ! ("  â€¢ Parallel processing (all CPU cores)") ; eprintln ! ("  â€¢ Memory-mapped I/O (zero-copy)") ; eprintln ! ("  â€¢ jemalloc allocator") ; eprintln ! ("  â€¢ 2,000-5,000 files/sec throughput") ; std :: process :: exit (1) ; } if args [1] == "--batch" { if args . len () < 4 { eprintln ! ("Batch mode requires input and output directories") ; std :: process :: exit (1) ; } let input_dir = Path :: new (& args [2]) ; let output_dir = Path :: new (& args [3]) ; let limit = args . get (4) . and_then (| s | s . parse :: < usize > () . ok ()) ; let files = find_midi_files (input_dir , limit) ? ; if files . is_empty () { eprintln ! ("âŒ No MIDI files found in {}" , input_dir . display ()) ; std :: process :: exit (1) ; } batch_convert_parallel (files , output_dir , true) ? ; } else { let input = Path :: new (& args [1]) ; let output = Path :: new (& args [2]) ; println ! ("Converting: {}" , input . display ()) ; let start = Instant :: now () ; let events = convert_file_fast (input , output) ? ; let elapsed = start . elapsed () ; println ! ("âœ… Created {} events in {:.3}s" , events , elapsed . as_secs_f64 ()) ; println ! ("ğŸ“ Output: {}" , output . display ()) ; } Ok (()) }

- [ ] **Function 'calculate_bars' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/mpc_backup.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Calculate number of bars from duration, BPM, and time signature"] fn calculate_bars (duration : f64 , bpm : f64 , time_sig_numerator : i16) -> i32 { let beats_per_bar = time_sig_numerator as f64 ; let seconds_per_beat = 60.0 / bpm ; let seconds_per_bar = seconds_per_beat * beats_per_bar ; let bars = (duration / seconds_per_bar) . round () as i32 ; bars . max (1) . min (999) }

- [ ] **Function 'format_key' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/mpc_backup.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Convert musical key to MPC format"] # [doc = " Examples: \"C\" â†’ \"c+\", \"Cm\" â†’ \"c-\", \"F#\" â†’ \"fs+\", \"F#m\" â†’ \"fs-\""] fn format_key (key : & str) -> String { let is_minor = key . ends_with ('m') ; let note = key . trim_end_matches ('m') . replace ('#' , "s") . replace ('b' , "s") . to_lowercase () ; if is_minor { format ! ("{}-" , note) } else { format ! ("{}+" , note) } }

- [ ] **Function 'extract_folder' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/mpc_backup.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Extract parent folder name from filepath"] fn extract_folder (filepath : & str) -> String { let path = Path :: new (filepath) ; let parent = path . parent () . and_then (| p | p . file_name ()) . and_then (| n | n . to_str ()) . unwrap_or ("Unknown") ; sanitize_camelcase (parent , 20) }

- [ ] **Function 'sanitize_mpc' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/mpc_backup.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Sanitize string to keep only: a-z, A-Z, 0-9, _, -, +"] fn sanitize_mpc (input : & str) -> String { input . chars () . filter (| c | c . is_alphanumeric () || * c == '_' || * c == '-' || * c == '+') . collect () }

- [ ] **Function 'sanitize_camelcase' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/mpc_backup.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Convert to CamelCase and truncate to max_len"] fn sanitize_camelcase (input : & str , max_len : usize) -> String { let words : Vec < String > = input . split (| c : char | ! c . is_alphanumeric ()) . filter (| w | ! w . is_empty ()) . map (| w | { let mut chars = w . to_lowercase () . chars () . collect :: < Vec < _ > > () ; if let Some (first) = chars . first_mut () { * first = first . to_uppercase () . next () . unwrap_or (* first) ; } chars . into_iter () . collect () }) . collect () ; let camelcase = words . join ("") ; let sanitized = sanitize_mpc (& camelcase) ; sanitized . chars () . take (max_len) . collect () }

- [ ] **Function 'generate_mpc_filename' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/mpc_backup.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Generate MPC-compatible filename"] # [doc = " Format: {BARS}{KEY}{BPM}{FOLDER}{FILENAME}.mid"] # [doc = " Example: 8c+80VirusMelodies01.mid"] fn generate_mpc_filename (file : & MidiFileWithMetadata) -> Option < String > { let bpm = file . bpm ? ; let key = file . key_signature . as_ref () ? ; let duration = file . duration_seconds ? ; let time_sig_numerator = file . time_signature_numerator . unwrap_or (4) ; let bars = calculate_bars (duration , bpm , time_sig_numerator) ; let key_formatted = format_key (key) ; let folder = extract_folder (& file . filepath) ; let filename_stem = Path :: new (& file . filename) . file_stem () . and_then (| s | s . to_str ()) . unwrap_or ("Unknown") ; let filename_sanitized = sanitize_mpc (filename_stem) . chars () . take (15) . collect :: < String > () ; let mpc_name = format ! ("{}{}{}{}{}.mid" , bars , key_formatted , bpm . round () as i32 , folder , filename_sanitized) ; Some (mpc_name) }

- [ ] **Function 'get_output_folder' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/mpc_backup.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Determine output folder based on organization strategy"] fn get_output_folder (base_dir : & Path , organize_by : & str , file : & MidiFileWithMetadata) -> PathBuf { match organize_by { "by_bpm" | "bpm" => { let bpm = file . bpm . unwrap_or (120.0) . round () as i32 ; let bpm_range = match bpm { 0 ..= 80 => "000-080" , 81 ..= 100 => "081-100" , 101 ..= 120 => "101-120" , 121 ..= 140 => "121-140" , 141 ..= 160 => "141-160" , _ => "160-999" , } ; base_dir . join (bpm_range) } , "by_key" | "key" => { let key = file . key_signature . as_ref () . map (| k | sanitize_mpc (k)) . unwrap_or_else (| | "Unknown" . to_string ()) ; base_dir . join (key) } , "by_instrument" | "instrument" => { let path_lower = file . filepath . to_lowercase () ; let filename_lower = file . filename . to_lowercase () ; let (group , subgroup) = if file . is_percussive == Some (true) { if filename_lower . contains ("kick") || path_lower . contains ("kick") { ("DRUMS" , "KICKS") } else if filename_lower . contains ("snare") || path_lower . contains ("snare") { ("DRUMS" , "SNARES") } else if filename_lower . contains ("hihat") || filename_lower . contains ("hat") || path_lower . contains ("hihat") || path_lower . contains ("hat") { ("DRUMS" , "HIHATS") } else if filename_lower . contains ("cymbal") || filename_lower . contains ("crash") || filename_lower . contains ("ride") || path_lower . contains ("cymbal") || path_lower . contains ("crash") || path_lower . contains ("ride") { ("DRUMS" , "CYMBALS") } else if filename_lower . contains ("tom") || path_lower . contains ("tom") { ("DRUMS" , "TOMS") } else if filename_lower . contains ("percussion") || filename_lower . contains ("perc") || path_lower . contains ("percussion") || path_lower . contains ("perc") { ("DRUMS" , "PERCUSSION") } else { ("DRUMS" , "OTHER") } } else if file . has_chords == Some (true) { if filename_lower . contains ("piano") || path_lower . contains ("piano") { ("KEYS" , "PIANO") } else if filename_lower . contains ("organ") || path_lower . contains ("organ") { ("KEYS" , "ORGAN") } else if filename_lower . contains ("synth") || path_lower . contains ("synth") { ("KEYS" , "SYNTH") } else { ("KEYS" , "CHORDS") } } else if file . has_melody == Some (true) { if file . is_monophonic == Some (true) { if filename_lower . contains ("bass") || path_lower . contains ("bass") { ("BASS" , "BASS") } else if filename_lower . contains ("lead") || path_lower . contains ("lead") { ("LEADS" , "LEAD") } else { ("LEADS" , "MELODY") } } else { if filename_lower . contains ("arp") || path_lower . contains ("arp") { ("LEADS" , "ARP") } else { ("LEADS" , "POLYPHONIC") } } } else if file . is_monophonic == Some (true) && file . polyphony_avg . unwrap_or (0.0) < 2.0 { if filename_lower . contains ("bass") || path_lower . contains ("bass") { ("BASS" , "BASS") } else { ("BASS" , "MONOPHONIC") } } else if filename_lower . contains ("loop") || path_lower . contains ("loop") { ("LOOPS" , "LOOPS") } else { if filename_lower . contains ("bass") || path_lower . contains ("bass") { ("BASS" , "BASS") } else if filename_lower . contains ("piano") || path_lower . contains ("piano") { ("KEYS" , "PIANO") } else if filename_lower . contains ("synth") || path_lower . contains ("synth") { ("KEYS" , "SYNTH") } else if filename_lower . contains ("organ") || path_lower . contains ("organ") { ("KEYS" , "ORGAN") } else if filename_lower . contains ("lead") || path_lower . contains ("lead") { ("LEADS" , "LEAD") } else if filename_lower . contains ("melody") || path_lower . contains ("melody") { ("LEADS" , "MELODY") } else { ("OTHER" , "OTHER") } } ; let bars = if let (Some (duration) , Some (bpm) , Some (time_sig)) = (file . duration_seconds , file . bpm , file . time_signature_numerator ,) { calculate_bars (duration , bpm , time_sig) } else { 0 } ; let bar_range = match bars { 0 => "000-BARS" , 1 ..= 2 => "001-002-BARS" , 3 ..= 4 => "003-004-BARS" , 5 ..= 8 => "005-008-BARS" , 9 ..= 16 => "009-016-BARS" , 17 ..= 32 => "017-032-BARS" , _ => "033-PLUS-BARS" , } ; let key_folder = file . key_signature . as_ref () . map (| k | format_key (k) . to_uppercase ()) . unwrap_or_else (| | "UNKNOWN" . to_string ()) ; base_dir . join (group) . join (subgroup) . join (bar_range) . join (key_folder) } , _ => base_dir . to_path_buf () , } }

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/mpc_backup.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/mpc_backup.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/mpc_backup.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/mpc_backup.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/mpc_backup.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/mpc_backup.rs`
  - Category: Performance

- [ ] **Function 'normalize_file' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/normalize_filenames.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Normalize a single MIDI file using strict sanitization"] fn normalize_file (path : & Path , stats : & NormalizationStats ,) -> Result < () , Box < dyn std :: error :: Error > > { let parent = path . parent () . ok_or ("No parent directory") ? ; let filename = path . file_name () . ok_or ("No filename") ? . to_string_lossy () ; let new_filename = sanitize_strict (& filename) ; let changed = new_filename != filename . as_ref () ; if changed { if filename . to_lowercase () . ends_with (".midi") || (filename . to_lowercase () . ends_with (".mid") && ! filename . ends_with (".mid")) { stats . extensions_fixed . fetch_add (1 , Ordering :: Relaxed) ; } if filename . contains (' ') { stats . spaces_fixed . fetch_add (1 , Ordering :: Relaxed) ; } if filename . chars () . any (| c | ! c . is_alphanumeric () && c != '_' && c != '-' && c != '.') { stats . encoding_fixed . fetch_add (1 , Ordering :: Relaxed) ; } } if changed { let new_path = parent . join (& new_filename) ; let mut final_path = new_path . clone () ; let mut counter = 1 ; while final_path . exists () && final_path != path { let stem = Path :: new (& new_filename) . file_stem () . unwrap () . to_string_lossy () ; let ext = Path :: new (& new_filename) . extension () . map (| e | e . to_string_lossy ()) . unwrap_or_default () ; final_path = parent . join (format ! ("{}_{}.{}" , stem , counter , ext)) ; counter += 1 ; } if final_path != path { fs :: rename (path , & final_path) ? ; } } stats . total_files . fetch_add (1 , Ordering :: Relaxed) ; Ok (()) }

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/normalize_filenames.rs`
  - Category: Performance

- [ ] **Function 'main' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/normalize_filenames.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn main () { let args : Vec < String > = std :: env :: args () . collect () ; if args . len () < 2 { eprintln ! ("Usage: {} <directory> [workers]" , args [0]) ; eprintln ! ("Example: {} /home/dojevou/tmp 32" , args [0]) ; std :: process :: exit (1) ; } let dir = & args [1] ; let workers = if args . len () > 2 { args [2] . parse :: < usize > () . unwrap_or_else (| _ | { eprintln ! ("Invalid workers count, using default") ; num_cpus :: get () }) } else { num_cpus :: get () } ; println ! ("ğŸ§¹ ULTRA-FAST MIDI FILENAME NORMALIZATION") ; println ! ("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•") ; println ! () ; println ! ("ğŸ“‚ Target directory: {}" , dir) ; println ! ("âš¡ Parallel workers: {}" , workers) ; println ! () ; rayon :: ThreadPoolBuilder :: new () . num_threads (workers) . build_global () . unwrap () ; let start = Instant :: now () ; let stats = NormalizationStats :: default () ; println ! ("ğŸ“Š Scanning for MIDI files...") ; let scan_start = Instant :: now () ; let files : Vec < PathBuf > = WalkDir :: new (dir) . follow_links (false) . into_iter () . filter_map (| e | e . ok ()) . filter (| e | e . file_type () . is_file ()) . filter (| e | { let name = e . file_name () . to_string_lossy () . to_lowercase () ; name . ends_with (".mid") || name . ends_with (".midi") }) . map (| e | e . path () . to_path_buf ()) . collect () ; let scan_elapsed = scan_start . elapsed () . as_secs_f64 () ; println ! ("âœ“ Found {} MIDI files in {:.2}s ({:.0} files/sec)" , files . len () , scan_elapsed , files . len () as f64 / scan_elapsed) ; println ! () ; println ! ("âš¡ Normalizing filenames...") ; let process_start = Instant :: now () ; files . par_iter () . for_each (| path | { if let Err (e) = normalize_file (path , & stats) { eprintln ! ("Error processing {:?}: {}" , path , e) ; stats . errors . fetch_add (1 , Ordering :: Relaxed) ; } }) ; println ! ("âœ“ Processing complete") ; println ! () ; let total_elapsed = start . elapsed () . as_secs_f64 () ; println ! ("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•") ; println ! ("âœ… NORMALIZATION COMPLETE!") ; stats . print_progress (total_elapsed) ; println ! () ; println ! ("All .mid files now have:") ; println ! ("  âœ“ Lowercase .mid extension") ; println ! ("  âœ“ Underscores instead of spaces") ; println ! ("  âœ“ Clean UTF-8 encoding") ; println ! () ; }

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/orchestrator.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/orchestrator.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/orchestrator.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/orchestrator.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/orchestrator.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/orchestrator.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/orchestrator.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/orchestrator.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/orchestrator.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/orchestrator.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/orchestrator.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/orchestrator.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/orchestrator.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/orchestrator.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/orchestrator.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/orchestrator.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/orchestrator.rs`
  - Category: Performance

- [ ] **Function 'spawn_import_phase' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/orchestrator.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn spawn_import_phase (source : PathBuf , pool : Pool < Postgres > , batch_size : usize , stats : Arc < Stats > , shutdown : Arc < AtomicBool > , multi_progress : Arc < MultiProgress > ,) -> JoinHandle < Result < () > > { tokio :: spawn (async move { let pb = multi_progress . add (ProgressBar :: new (0)) ; pb . set_style (ProgressStyle :: default_bar () . template ("[{elapsed_precise}] {bar:40.cyan/blue} {pos}/{len} {msg}") . unwrap () . progress_chars ("=>-") ,) ; pb . set_message ("Importing files...") ; let files = scan_directory (& source) ? ; pb . set_length (files . len () as u64) ; for batch in files . chunks (batch_size) { if shutdown . load (Ordering :: Relaxed) { break ; } import_batch (& pool , batch , & stats , & pb) . await ? ; } pb . finish_with_message ("Import complete") ; Ok (()) }) }

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/orchestrator.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/orchestrator.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/orchestrator.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/orchestrator.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/orchestrator.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/orchestrator.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/orchestrator.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/orchestrator.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/orchestrator.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/orchestrator.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/orchestrator.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/orchestrator.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/orchestrator.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/orchestrator.rs`
  - Category: Performance

- [ ] **Function 'spawn_rename_filesystem_phase' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/orchestrator.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn spawn_rename_filesystem_phase (source : PathBuf , worker_count : usize , stats : Arc < Stats > , shutdown : Arc < AtomicBool > , multi_progress : Arc < MultiProgress > ,) -> JoinHandle < Result < () > > { tokio :: spawn (async move { let pb = multi_progress . add (ProgressBar :: new (0)) ; pb . set_style (ProgressStyle :: default_bar () . template ("[{elapsed_precise}] {bar:40.cyan/blue} {pos}/{len} {msg}") . unwrap () . progress_chars ("=>-") ,) ; pb . set_message ("Scanning and renaming files...") ; let files = scan_directory (& source) ? ; pb . set_length (files . len () as u64) ; use rayon :: prelude :: * ; files . par_iter () . for_each (| filepath | { if shutdown . load (Ordering :: Relaxed) { return ; } match rename_file_filesystem (filepath) { Ok (renamed) => { if renamed { stats . rename_file () ; } pb . inc (1) ; } , Err (e) => { error ! ("Rename failed for {:?}: {}" , filepath , e) ; stats . rename_error () ; pb . inc (1) ; } , } }) ; pb . finish_with_message ("Rename complete") ; Ok (()) }) }

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/orchestrator.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/orchestrator.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/orchestrator.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/orchestrator.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/orchestrator.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/orchestrator.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/orchestrator.rs`
  - Category: Performance

- [ ] **Function 'scan_directory' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/orchestrator.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn scan_directory (path : & Path) -> Result < Vec < PathBuf > > { use jwalk :: WalkDir ; let files : Vec < PathBuf > = WalkDir :: new (path) . into_iter () . filter_map (| entry | entry . ok ()) . filter (| entry | entry . file_type () . is_file ()) . filter (| entry | { entry . path () . extension () . and_then (| e | e . to_str ()) . map (| e | e . eq_ignore_ascii_case ("mid") || e . eq_ignore_ascii_case ("midi")) . unwrap_or (false) }) . map (| entry | entry . path ()) . collect () ; Ok (files) }

- [ ] **Function 'rename_file_filesystem' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/orchestrator.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Rename a file on the filesystem (no database operations)"] # [doc = " Returns true if file was renamed, false if no rename needed"] fn rename_file_filesystem (filepath : & Path) -> Result < bool > { let filename = filepath . file_name () . and_then (| n | n . to_str ()) . ok_or_else (| | anyhow :: anyhow ! ("Invalid filename")) ? ; let mut needs_rename = false ; let mut new_filename = filename . to_string () ; if let Some (ext) = filepath . extension () . and_then (| e | e . to_str ()) { if ext . eq_ignore_ascii_case ("midi") { new_filename = new_filename . replace (".midi" , ".mid") . replace (".MIDI" , ".mid") ; needs_rename = true ; } } if new_filename . contains (' ') { new_filename = new_filename . replace (' ' , "_") ; needs_rename = true ; } if ! needs_rename { return Ok (false) ; } let parent_dir = filepath . parent () . ok_or_else (| | anyhow :: anyhow ! ("Cannot get parent directory")) ? ; let new_filepath = parent_dir . join (& new_filename) ; std :: fs :: rename (filepath , & new_filepath) ? ; Ok (true) }

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/orchestrator.rs`
  - Category: Performance

- [ ] **Function 'sanitize_filename' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/orchestrator.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Sanitize filename component by removing problematic characters"] fn sanitize_filename (s : & str) -> String { s . chars () . map (| c | match c { '/' | '\\' | ':' | '*' | '?' | '"' | '<' | '>' | '|' => '_' , ' ' => '_' , _ => c , }) . collect () }

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/organize_files.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/organize_files.rs`
  - Category: Performance

- [ ] **Function 'extract_zip_archive' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/parallel_extract.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Extract a single ZIP archive using ultra-fast decompression"] fn extract_zip_archive (archive_path : & Path , output_dir : & Path , stats : & Arc < ExtractionStats > , progress : & Option < ProgressBar > ,) -> Result < usize > { let file = File :: open (archive_path) . with_context (| | format ! ("Failed to open archive: {}" , archive_path . display ())) ? ; let mmap = unsafe { Mmap :: map (& file) . with_context (| | format ! ("Failed to mmap archive: {}" , archive_path . display ())) ? } ; let cursor = std :: io :: Cursor :: new (& mmap [..]) ; let mut zip = ZipArchive :: new (cursor) . with_context (| | format ! ("Failed to read ZIP: {}" , archive_path . display ())) ? ; let file_count = zip . len () ; if let Some (pb) = progress { pb . set_length (file_count as u64) ; } let mut extracted = 0 ; for i in 0 .. zip . len () { let mut file = match zip . by_index (i) { Ok (f) => f , Err (e) => { eprintln ! ("âš ï¸  Failed to read entry {}: {}" , i , e) ; stats . error_occurred () ; continue ; } , } ; if file . is_dir () { continue ; } let file_name = file . name () . to_string () ; if ! file_name . ends_with (".mid") && ! file_name . ends_with (".midi") { continue ; } let output_path = output_dir . join (& file_name) ; if let Some (parent) = output_path . parent () { fs :: create_dir_all (parent) . ok () ; } match std :: io :: copy (& mut file , & mut File :: create (& output_path) ?) { Ok (size) => { stats . file_extracted (size) ; extracted += 1 ; if let Some (pb) = progress { pb . inc (1) ; } } , Err (e) => { eprintln ! ("âš ï¸  Failed to extract {}: {}" , file_name , e) ; stats . error_occurred () ; } , } } stats . archive_done () ; Ok (extracted) }

- [ ] **Function 'extract_rar_archive' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/parallel_extract.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Extract RAR archive (basic wrapper around unrar)"] fn extract_rar_archive (archive_path : & Path , output_dir : & Path , stats : & Arc < ExtractionStats > ,) -> Result < usize > { use std :: process :: Command ; let output = Command :: new ("unrar") . arg ("x") . arg ("-o+") . arg ("-inul") . arg (archive_path) . arg (output_dir) . output () ? ; if ! output . status . success () { stats . error_occurred () ; anyhow :: bail ! ("unrar failed for {}" , archive_path . display ()) ; } stats . archive_done () ; let count = walkdir :: WalkDir :: new (output_dir) . into_iter () . filter_map (| e | e . ok ()) . filter (| e | { e . path () . extension () . and_then (| s | s . to_str ()) . map (| ext | ext == "mid" || ext == "midi") . unwrap_or (false) }) . count () ; stats . file_extracted (count as u64) ; Ok (count) }

- [ ] **Function 'extract_7z_archive' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/parallel_extract.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Extract 7z archive (basic wrapper around 7z)"] fn extract_7z_archive (archive_path : & Path , output_dir : & Path , stats : & Arc < ExtractionStats > ,) -> Result < usize > { use std :: process :: Command ; let output = Command :: new ("7z") . arg ("x") . arg (format ! ("-o{}" , output_dir . display ())) . arg ("-y") . arg (archive_path) . output () ? ; if ! output . status . success () { stats . error_occurred () ; anyhow :: bail ! ("7z failed for {}" , archive_path . display ()) ; } stats . archive_done () ; let count = walkdir :: WalkDir :: new (output_dir) . into_iter () . filter_map (| e | e . ok ()) . filter (| e | { e . path () . extension () . and_then (| s | s . to_str ()) . map (| ext | ext == "mid" || ext == "midi") . unwrap_or (false) }) . count () ; stats . file_extracted (count as u64) ; Ok (count) }

- [ ] **Function 'find_archives' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/parallel_extract.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Find all archives in directory"] fn find_archives (dir : & Path) -> Result < Vec < PathBuf > > { let mut archives = Vec :: new () ; for entry in fs :: read_dir (dir) ? { let entry = entry ? ; let path = entry . path () ; if path . is_file () { if let Some (ext) = path . extension () { let ext = ext . to_string_lossy () . to_lowercase () ; if ext == "zip" || ext == "rar" || ext == "7z" { archives . push (path) ; } } } } Ok (archives) }

- [ ] **Function 'main' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/parallel_extract.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn main () -> Result < () > { let args = Args :: parse () ; let start_time = Instant :: now () ; println ! ("ğŸš€ ULTRA-FAST PARALLEL ARCHIVE EXTRACTION") ; println ! ("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•") ; println ! () ; fs :: create_dir_all (& args . output_dir) ? ; let archives = find_archives (& args . archive_dir) ? ; let total_archives = archives . len () ; if total_archives == 0 { println ! ("âŒ No archives found in {}" , args . archive_dir . display ()) ; return Ok (()) ; } println ! ("ğŸ“¦ Found {} archives" , total_archives) ; println ! () ; let max_parallel = args . max_parallel . unwrap_or_else (num_cpus :: get) ; println ! ("âš¡ Using {} parallel extraction threads" , max_parallel) ; println ! () ; rayon :: ThreadPoolBuilder :: new () . num_threads (max_parallel) . build_global () . ok () ; let stats = Arc :: new (ExtractionStats :: new ()) ; let multi_progress = if args . verbose { Some (MultiProgress :: new ()) } else { None } ; archives . par_iter () . for_each (| archive_path | { let filename = archive_path . file_name () . unwrap_or_default () . to_string_lossy () ; let progress_bar = if let Some (ref mp) = multi_progress { let pb = mp . add (ProgressBar :: new (0)) ; pb . set_style (ProgressStyle :: default_bar () . template ("{msg} [{bar:40.cyan/blue}] {pos}/{len} files") . unwrap () . progress_chars ("#>-") ,) ; pb . set_message (filename . to_string ()) ; Some (pb) } else { println ! ("ğŸ”„ Extracting: {}" , filename) ; None } ; let result = if archive_path . extension () . unwrap () . to_string_lossy () == "zip" { extract_zip_archive (archive_path , & args . output_dir , & stats , & progress_bar) } else if archive_path . extension () . unwrap () . to_string_lossy () == "rar" { extract_rar_archive (archive_path , & args . output_dir , & stats) } else { extract_7z_archive (archive_path , & args . output_dir , & stats) } ; match result { Ok (count) => { if let Some (pb) = progress_bar { pb . finish_with_message (format ! ("âœ“ {} ({} files)" , filename , count)) ; } else { println ! ("âœ“ Complete: {} ({} files)" , filename , count) ; } } , Err (e) => { eprintln ! ("âŒ Failed {}: {}" , filename , e) ; stats . error_occurred () ; } , } }) ; println ! () ; println ! ("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•") ; let (archives_done , files , bytes , errors) = stats . report () ; let elapsed = start_time . elapsed () ; println ! ("âœ… Extraction Complete!") ; println ! () ; println ! ("ğŸ“Š Statistics:") ; println ! ("   Archives processed: {}/{}" , archives_done , total_archives) ; println ! ("   MIDI files extracted: {}" , files) ; println ! ("   Total size: {:.2} GB" , bytes as f64 / 1_073_741_824.0) ; println ! ("   Errors: {}" , errors) ; println ! () ; println ! ("â±ï¸  Time: {:.2}s" , elapsed . as_secs_f64 ()) ; println ! ("ğŸš€ Speed: {:.0} files/sec" , files as f64 / elapsed . as_secs_f64 ()) ; println ! () ; println ! ("ğŸ“‚ Output: {}" , args . output_dir . display ()) ; Ok (()) }

- [ ] **Function 'print_usage' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/pipeline-cli.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn print_usage () { println ! ("MIDI Pipeline CLI") ; println ! () ; println ! ("Usage:") ; println ! ("  pipeline-cli import <directory>  - Import MIDI files from directory") ; println ! ("  pipeline-cli analyze             - Analyze all unanalyzed files") ; println ! ("  pipeline-cli stats               - Show database statistics") ; println ! ("  pipeline-cli help                - Show this help message") ; println ! () ; println ! ("Environment Variables:") ; println ! ("  DATABASE_URL - PostgreSQL connection string") ; println ! ("                 Default: postgresql://midiuser:145278963@localhost:5433/midi_library") ; }

- [ ] **Function 'parse_worker_counts' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/pipeline-orchestrator.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Parse custom worker counts from string: \"16,32,16,24,32,8\""] fn parse_worker_counts (workers_str : & str , config : & mut PipelineConfig ,) -> Result < () , Box < dyn std :: error :: Error > > { let counts : Vec < usize > = workers_str . split (',') . map (| s | s . trim () . parse ()) . collect :: < Result < Vec < _ > , _ > > () ? ; if counts . len () != 6 { return Err ("Worker counts must be 6 values: import,sanitize,split,analyze,rename,export" . into () ,) ; } config . import_workers = counts [0] ; config . sanitize_workers = counts [1] ; config . split_workers = counts [2] ; config . analyze_workers = counts [3] ; config . rename_workers = counts [4] ; config . export_workers = counts [5] ; info ! ("Custom worker counts:") ; info ! ("  Import: {}" , counts [0]) ; info ! ("  Sanitize: {}" , counts [1]) ; info ! ("  Split: {}" , counts [2]) ; info ! ("  Analyze: {}" , counts [3]) ; info ! ("  Rename: {}" , counts [4]) ; info ! ("  Export: {}" , counts [5]) ; Ok (()) }

- [ ] **Function 'sanitize_filename' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/split.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Sanitize a filename by removing/replacing invalid characters"] fn sanitize_filename (name : & str) -> String { name . chars () . map (| c | match c { '/' | '\\' | ':' | '*' | '?' | '"' | '<' | '>' | '|' => '_' , c if c . is_control () => '_' , c => c , }) . collect :: < String > () . trim () . to_string () }

- [ ] **Function 'serialize_midi_file' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/split.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Serialize a MIDI file back to bytes"] fn serialize_midi_file (midi_file : & midi_library_shared :: core :: midi :: types :: MidiFile ,) -> Result < Vec < u8 > > { let mut buffer = Vec :: new () ; buffer . extend_from_slice (b"MThd") ; buffer . extend_from_slice (& 6u32 . to_be_bytes ()) ; buffer . extend_from_slice (& midi_file . header . format . to_be_bytes ()) ; buffer . extend_from_slice (& (midi_file . tracks . len () as u16) . to_be_bytes ()) ; buffer . extend_from_slice (& midi_file . header . ticks_per_quarter_note . to_be_bytes ()) ; for track in & midi_file . tracks { let track_data = serialize_track (track) ? ; buffer . extend_from_slice (b"MTrk") ; buffer . extend_from_slice (& (track_data . len () as u32) . to_be_bytes ()) ; buffer . extend_from_slice (& track_data) ; } Ok (buffer) }

- [ ] **Function 'serialize_track' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/split.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Serialize a track to bytes"] fn serialize_track (track : & midi_library_shared :: core :: midi :: types :: Track) -> Result < Vec < u8 > > { use midi_library_shared :: core :: midi :: Event ; let mut buffer = Vec :: new () ; for timed_event in & track . events { write_variable_length (& mut buffer , timed_event . delta_ticks) ; match & timed_event . event { Event :: NoteOn { channel , note , velocity } => { buffer . push (0x90 | channel) ; buffer . push (* note) ; buffer . push (* velocity) ; } , Event :: NoteOff { channel , note , velocity } => { buffer . push (0x80 | channel) ; buffer . push (* note) ; buffer . push (* velocity) ; } , _ => { buffer . push (0xFF) ; buffer . push (0x00) ; buffer . push (0x00) ; } , } } buffer . push (0x00) ; buffer . push (0xFF) ; buffer . push (0x2F) ; buffer . push (0x00) ; Ok (buffer) }

- [ ] **Function 'write_variable_length' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/split.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Write a variable-length quantity (MIDI format)"] fn write_variable_length (buffer : & mut Vec < u8 > , mut value : u32) { let mut bytes = Vec :: new () ; bytes . push ((value & 0x7F) as u8) ; value >>= 7 ; while value > 0 { bytes . push (((value & 0x7F) | 0x80) as u8) ; value >>= 7 ; } for byte in bytes . iter () . rev () { buffer . push (* byte) ; } }

- [ ] **Function 'find_first_note_on' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/trim_split_tracks.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Find the first note-on event in the MIDI file and return its absolute tick position"] fn find_first_note_on (smf : & Smf) -> Option < u32 > { let mut first_note_tick = None ; for track in & smf . tracks { let mut current_tick = 0u32 ; for event in track { current_tick = current_tick . saturating_add (event . delta . as_int ()) ; if let TrackEventKind :: Midi { message , .. } = & event . kind { if let MidiMessage :: NoteOn { vel , .. } = message { if vel . as_int () > 0 { match first_note_tick { None => first_note_tick = Some (current_tick) , Some (tick) => { if current_tick < tick { first_note_tick = Some (current_tick) ; } } , } } } } } } first_note_tick }

- [ ] **Function 'trim_midi_file' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/trim_split_tracks.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Trim the MIDI file by shifting all events back by the given offset"] fn trim_midi_file (smf : & mut Smf , trim_ticks : u32) { for track in & mut smf . tracks { let mut current_tick = 0u32 ; let mut trimmed_events = Vec :: new () ; let mut last_output_tick = 0u32 ; for event in track . iter () { current_tick = current_tick . saturating_add (event . delta . as_int ()) ; let new_tick = current_tick . saturating_sub (trim_ticks) ; let new_delta = new_tick . saturating_sub (last_output_tick) ; let new_event = TrackEvent { delta : midly :: num :: u28 :: new (new_delta) , kind : event . kind . clone () } ; trimmed_events . push (new_event) ; last_output_tick = new_tick ; } * track = trimmed_events ; } }

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/trim_split_tracks.rs`
  - Category: Performance

- [ ] **Function 'process_file' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/trim_split_tracks.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Process a single MIDI file"] fn process_file (path : & Path , args : & Args , stats : & TrimStats) -> Result < () > { stats . files_processed . fetch_add (1 , Ordering :: Relaxed) ; let data = fs :: read (path) . with_context (| | format ! ("Failed to read file: {}" , path . display ())) ? ; let mut smf = Smf :: parse (& data) . with_context (| | format ! ("Failed to parse MIDI: {}" , path . display ())) ? ; let first_note_tick = match find_first_note_on (& smf) { Some (tick) => tick , None => { if args . verbose { eprintln ! ("No note-on events found: {}" , path . display ()) ; } stats . files_skipped . fetch_add (1 , Ordering :: Relaxed) ; return Ok (()) ; } , } ; if first_note_tick < args . min_trim_ticks { if args . verbose { eprintln ! ("Leading silence too small ({} ticks): {}" , first_note_tick , path . display ()) ; } stats . files_skipped . fetch_add (1 , Ordering :: Relaxed) ; return Ok (()) ; } if args . verbose { eprintln ! ("Trimming {} ticks from: {}" , first_note_tick , path . display ()) ; } trim_midi_file (& mut smf , first_note_tick) ; if ! args . dry_run { let mut output = Vec :: new () ; smf . write (& mut output) . map_err (| e | anyhow :: anyhow ! ("Failed to encode MIDI: {} - {}" , path . display () , e)) ? ; fs :: write (path , output) . with_context (| | format ! ("Failed to write file: {}" , path . display ())) ? ; } stats . files_trimmed . fetch_add (1 , Ordering :: Relaxed) ; stats . total_ticks_trimmed . fetch_add (first_note_tick as usize , Ordering :: Relaxed) ; Ok (()) }

- [ ] **Function 'main' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/trim_split_tracks.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn main () -> Result < () > { let args = Args :: parse () ; println ! ("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”") ; println ! ("  MIDI Track Trimming Tool") ; println ! ("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”") ; println ! ("Input directory:  {}" , args . input_dir . display ()) ; println ! ("Workers:          {}" , args . workers) ; println ! ("Min trim ticks:   {}" , args . min_trim_ticks) ; println ! ("Dry run:          {}" , if args . dry_run { "YES" } else { "NO" }) ; println ! () ; rayon :: ThreadPoolBuilder :: new () . num_threads (args . workers) . build_global () . context ("Failed to build thread pool") ? ; println ! ("Scanning for MIDI files...") ; let mut midi_files = Vec :: new () ; for entry in walkdir :: WalkDir :: new (& args . input_dir) . follow_links (false) . into_iter () . filter_map (| e | e . ok ()) { let path = entry . path () ; if path . is_file () { if let Some (ext) = path . extension () { if ext == "mid" || ext == "midi" { midi_files . push (path . to_path_buf ()) ; } } } } let total_files = midi_files . len () ; println ! ("Found {} MIDI files" , total_files) ; println ! () ; if total_files == 0 { println ! ("No MIDI files found!") ; return Ok (()) ; } let stats = TrimStats :: default () ; let start = Instant :: now () ; midi_files . par_iter () . for_each (| path | { if let Err (e) = process_file (path , & args , & stats) { eprintln ! ("Error processing {}: {}" , path . display () , e) ; stats . files_error . fetch_add (1 , Ordering :: Relaxed) ; } stats . print_progress (total_files) ; }) ; let elapsed = start . elapsed () . as_secs_f64 () ; stats . print_final (elapsed) ; Ok (()) }

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/analyze.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/analyze.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/analyze.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/analyze.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/analyze.rs`
  - Category: Performance

- [ ] **Function 'analyze_notes' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/analyze.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Analyze notes in MIDI file"] fn analyze_notes (midi_file : & MidiFile) -> NoteStats { let mut note_count = 0 ; let mut unique_pitch_set = std :: collections :: HashSet :: new () ; let mut min_pitch = 127u8 ; let mut max_pitch = 0u8 ; let mut min_velocity = 127u8 ; let mut max_velocity = 0u8 ; let mut velocity_sum = 0u32 ; let mut active_notes_per_tick : std :: collections :: HashMap < u32 , usize > = std :: collections :: HashMap :: new () ; let mut max_tick = 0u32 ; let mut percussive_note_count = 0 ; for track in & midi_file . tracks { let mut current_tick = 0u32 ; let mut active_notes = std :: collections :: HashSet :: new () ; for timed_event in & track . events { current_tick += timed_event . delta_ticks ; max_tick = max_tick . max (current_tick) ; match & timed_event . event { Event :: NoteOn { note , velocity , channel } if * velocity > 0 => { note_count += 1 ; unique_pitch_set . insert (* note) ; min_pitch = min_pitch . min (* note) ; max_pitch = max_pitch . max (* note) ; min_velocity = min_velocity . min (* velocity) ; max_velocity = max_velocity . max (* velocity) ; velocity_sum += * velocity as u32 ; if * channel == 9 { percussive_note_count += 1 ; } active_notes . insert (* note) ; active_notes_per_tick . insert (current_tick , active_notes . len ()) ; } , Event :: NoteOff { note , .. } | Event :: NoteOn { note , velocity : 0 , .. } => { active_notes . remove (note) ; } , _ => { } , } } } let unique_pitches = if note_count > 0 { Some (unique_pitch_set . len () as i32) } else { None } ; let avg_velocity = if note_count > 0 { Some (velocity_sum as f64 / note_count as f64) } else { None } ; let polyphony_max = active_notes_per_tick . values () . max () . copied () . map (| v | v as i16) ; let polyphony_avg = if ! active_notes_per_tick . is_empty () { let sum : usize = active_notes_per_tick . values () . sum () ; Some (sum as f64 / active_notes_per_tick . len () as f64) } else { None } ; let is_monophonic = polyphony_max == Some (1) ; let is_polyphonic = polyphony_max . map_or (false , | p | p > 1) ; let is_percussive = if note_count > 0 { let drum_ratio = percussive_note_count as f64 / note_count as f64 ; let in_drum_range = min_pitch >= 27 && max_pitch <= 87 ; drum_ratio > 0.5 || in_drum_range } else { false } ; let duration_seconds = if max_tick > 0 { let ticks_per_beat = midi_file . header . ticks_per_quarter_note as f64 ; let seconds_per_beat = 0.5 ; Some ((max_tick as f64 / ticks_per_beat) * seconds_per_beat) } else { None } ; let note_density = if let Some (duration) = duration_seconds { if duration > 0.0 { Some (note_count as f64 / duration) } else { None } } else { None } ; let (pitch_range_low , pitch_range_high , pitch_range_semitones) = if note_count > 0 { let semitones = max_pitch . saturating_sub (min_pitch) as i16 ; (Some (min_pitch as i16) , Some (max_pitch as i16) , Some (semitones) ,) } else { (None , None , None) } ; let (velocity_range_low , velocity_range_high) = if note_count > 0 { (Some (min_velocity as i16) , Some (max_velocity as i16)) } else { (None , None) } ; NoteStats { note_count , unique_pitches , pitch_range_low , pitch_range_high , pitch_range_semitones , avg_velocity , velocity_range_low , velocity_range_high , note_density , polyphony_max , polyphony_avg , is_monophonic , is_polyphonic , is_percussive , } }

- [ ] **Function 'extract_time_signature' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/analyze.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Extract time signature from MIDI file"] fn extract_time_signature (midi_file : & MidiFile) -> (Option < i16 > , Option < i16 >) { for track in & midi_file . tracks { for timed_event in & track . events { if let Event :: TimeSignature { numerator , denominator , .. } = & timed_event . event { let denom_value = 2i16 . pow (* denominator as u32) ; return (Some (* numerator as i16) , Some (denom_value)) ; } } } (Some (4) , Some (4)) }

- [ ] **Function 'calculate_total_ticks' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/analyze.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Calculate total number of ticks in MIDI file"] fn calculate_total_ticks (midi_file : & MidiFile) -> i32 { let mut max_ticks = 0u32 ; for track in & midi_file . tracks { let mut track_ticks = 0u32 ; for timed_event in & track . events { track_ticks += timed_event . delta_ticks ; } max_ticks = max_ticks . max (track_ticks) ; } max_ticks as i32 }

- [ ] **Function 'calculate_duration_seconds' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/analyze.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Calculate duration in seconds"] fn calculate_duration_seconds (midi_file : & MidiFile , bpm : f64) -> Option < f64 > { let total_ticks = calculate_total_ticks (midi_file) as f64 ; let ticks_per_quarter = midi_file . header . ticks_per_quarter_note as f64 ; if total_ticks > 0.0 && ticks_per_quarter > 0.0 && bpm > 0.0 { let quarters = total_ticks / ticks_per_quarter ; let minutes = quarters / bpm ; let seconds = minutes * 60.0 ; Some (seconds) } else { None } }

- [ ] **Function 'extract_instrument_names' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/analyze.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Extract instrument names from MIDI file"] fn extract_instrument_names (midi_file : & MidiFile) -> Vec < String > { let mut instruments = Vec :: new () ; for track in & midi_file . tracks { for timed_event in & track . events { match & timed_event . event { Event :: Text { text_type , text } => { if matches ! (text_type , TextType :: InstrumentName | TextType :: TrackName) && ! instruments . contains (text) { instruments . push (text . clone ()) ; } } , Event :: ProgramChange { program , .. } => { if let Some (instrument_name) = program_to_instrument_name (* program) { if ! instruments . contains (& instrument_name) { instruments . push (instrument_name) ; } } } , _ => { } , } } } instruments }

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/analyze.rs`
  - Category: Performance

- [ ] **Function 'program_to_instrument_name' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/analyze.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Map MIDI General MIDI program number to instrument name"] fn program_to_instrument_name (program : u8) -> Option < String > { match program { 0 ..= 7 => Some ("Piano" . to_string ()) , 8 ..= 15 => Some ("Keys" . to_string ()) , 16 ..= 23 => Some ("Organ" . to_string ()) , 24 ..= 31 => Some ("Guitar" . to_string ()) , 32 ..= 39 => Some ("Bass" . to_string ()) , 40 ..= 47 => Some ("Strings" . to_string ()) , 48 ..= 55 => Some ("Ensemble" . to_string ()) , 56 ..= 63 => Some ("Brass" . to_string ()) , 64 ..= 71 => Some ("Woodwind" . to_string ()) , 72 ..= 79 => Some ("Flute" . to_string ()) , 80 ..= 87 => Some ("Lead" . to_string ()) , 88 ..= 95 => Some ("Pad" . to_string ()) , 96 ..= 103 => Some ("FX" . to_string ()) , 104 ..= 111 => Some ("Ethnic" . to_string ()) , 112 ..= 119 => Some ("Percussion" . to_string ()) , 120 ..= 127 => Some ("FX" . to_string ()) , _ => None , } }

- [ ] **Function 'detect_pitch_bend' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/analyze.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Detect if MIDI file contains pitch bend events"] fn detect_pitch_bend (midi_file : & MidiFile) -> bool { for track in & midi_file . tracks { for timed_event in & track . events { if matches ! (& timed_event . event , Event :: PitchBend { .. }) { return true ; } } } false }

- [ ] **Function 'detect_cc_messages' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/analyze.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Detect if MIDI file contains control change messages"] fn detect_cc_messages (midi_file : & MidiFile) -> bool { for track in & midi_file . tracks { for timed_event in & track . events { if matches ! (& timed_event . event , Event :: ControlChange { .. }) { return true ; } } } false }

- [ ] **Function 'analyze_tracks' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/analyze.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Analyze tracks and extract per-channel instrument information"] fn analyze_tracks (midi_file : & MidiFile) -> Vec < TrackInstrument > { let mut channel_data : std :: collections :: HashMap < u8 , TrackInstrument > = std :: collections :: HashMap :: new () ; for track in & midi_file . tracks { let mut current_programs : std :: collections :: HashMap < u8 , u8 > = std :: collections :: HashMap :: new () ; for timed_event in & track . events { match & timed_event . event { Event :: ProgramChange { channel , program } => { current_programs . insert (* channel , * program) ; } , Event :: NoteOn { channel , note , velocity } if * velocity > 0 => { let program = current_programs . get (channel) . copied () . unwrap_or (0) ; let entry = channel_data . entry (* channel) . or_insert_with (| | { let (name , family , inst_type) = get_instrument_info (program) ; TrackInstrument { channel : * channel as i16 , program_number : program as i16 , program_name : name , instrument_family : family , instrument_type : inst_type , note_count : 0 , avg_velocity : None , pitch_range_low : None , pitch_range_high : None , is_primary : false , } }) ; entry . note_count += 1 ; entry . pitch_range_low = Some (entry . pitch_range_low . map_or (* note as i16 , | l | l . min (* note as i16))) ; entry . pitch_range_high = Some (entry . pitch_range_high . map_or (* note as i16 , | h | h . max (* note as i16))) ; if let Some (avg) = entry . avg_velocity { entry . avg_velocity = Some ((avg * (entry . note_count - 1) as f64 + * velocity as f64) / entry . note_count as f64 ,) ; } else { entry . avg_velocity = Some (* velocity as f64) ; } } , _ => { } , } } } let mut instruments : Vec < TrackInstrument > = channel_data . into_values () . collect () ; if let Some (max_notes) = instruments . iter () . map (| i | i . note_count) . max () { for inst in & mut instruments { if inst . note_count == max_notes { inst . is_primary = true ; break ; } } } instruments }

- [ ] **Function 'extract_tempo_changes' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/analyze.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Extract tempo changes from MIDI meta events"] fn extract_tempo_changes (midi_file : & MidiFile) -> Option < String > { let mut tempo_changes = Vec :: new () ; let mut current_tick = 0u32 ; for track in & midi_file . tracks { let mut track_tick = 0u32 ; for timed_event in & track . events { track_tick += timed_event . delta_ticks ; if let Event :: TempoChange { microseconds_per_quarter } = & timed_event . event { let bpm = 60_000_000.0 / * microseconds_per_quarter as f64 ; tempo_changes . push (serde_json :: json ! ({ "tick" : track_tick , "bpm" : ((bpm * 100.0) as f64) . round () / 100.0 })) ; } } current_tick = current_tick . max (track_tick) ; } if tempo_changes . is_empty () { None } else { Some (serde_json :: to_string (& tempo_changes) . unwrap_or_default ()) } }

- [ ] **Function 'extract_key_changes' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/analyze.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Extract key signature changes from MIDI meta events"] fn extract_key_changes (midi_file : & MidiFile) -> Option < String > { let mut key_changes = Vec :: new () ; let mut current_tick = 0u32 ; for track in & midi_file . tracks { let mut track_tick = 0u32 ; for timed_event in & track . events { track_tick += timed_event . delta_ticks ; if let Event :: KeySignature { sharps_flats , is_minor } = & timed_event . event { let key_name = get_key_name (* sharps_flats , * is_minor) ; key_changes . push (serde_json :: json ! ({ "tick" : track_tick , "key" : key_name })) ; } } current_tick = current_tick . max (track_tick) ; } if key_changes . is_empty () { None } else { Some (serde_json :: to_string (& key_changes) . unwrap_or_default ()) } }

- [ ] **Function 'extract_time_signature_changes' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/analyze.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Extract time signature changes from MIDI meta events"] fn extract_time_signature_changes (midi_file : & MidiFile) -> Option < String > { let mut time_sig_changes = Vec :: new () ; let mut current_tick = 0u32 ; for track in & midi_file . tracks { let mut track_tick = 0u32 ; for timed_event in & track . events { track_tick += timed_event . delta_ticks ; if let Event :: TimeSignature { numerator , denominator , .. } = & timed_event . event { let denom_value = 2i32 . pow (* denominator as u32) ; time_sig_changes . push (serde_json :: json ! ({ "tick" : track_tick , "numerator" : numerator , "denominator" : denom_value })) ; } } current_tick = current_tick . max (track_tick) ; } if time_sig_changes . is_empty () { None } else { Some (serde_json :: to_string (& time_sig_changes) . unwrap_or_default ()) } }

- [ ] **Function 'get_key_name' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/analyze.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Convert sharps/flats to key name"] fn get_key_name (sharps_flats : i8 , is_minor : bool) -> String { let major_keys = ["C" , "G" , "D" , "A" , "E" , "B" , "F#" , "C#" , "F" , "Bb" , "Eb" , "Ab" , "Db" , "Gb" , "Cb" ,] ; let minor_keys = ["Am" , "Em" , "Bm" , "F#m" , "C#m" , "G#m" , "D#m" , "A#m" , "Dm" , "Gm" , "Cm" , "Fm" , "Bbm" , "Ebm" , "Abm" ,] ; let index = if sharps_flats >= 0 { sharps_flats as usize } else { (8 - sharps_flats - 1) as usize } ; if is_minor { minor_keys . get (index) . unwrap_or (& "Unknown") . to_string () } else { major_keys . get (index) . unwrap_or (& "Unknown") . to_string () } }

- [ ] **Function 'analyze_controllers' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/analyze.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Analyze MIDI controller (CC) messages"] fn analyze_controllers (midi_file : & MidiFile) -> Option < String > { use std :: collections :: HashMap ; let mut controller_data : HashMap < u8 , (u32 , u8 , u8 , u64) > = HashMap :: new () ; let priority_controllers = [1 , 2 , 7 , 10 , 11 , 64] ; for track in & midi_file . tracks { for timed_event in & track . events { if let Event :: ControlChange { controller , value , .. } = & timed_event . event { let entry = controller_data . entry (* controller) . or_insert ((0 , 255 , 0 , 0)) ; entry . 0 += 1 ; entry . 1 = entry . 1 . min (* value) ; entry . 2 = entry . 2 . max (* value) ; entry . 3 += * value as u64 ; } } } if controller_data . is_empty () { return None ; } let mut controllers = Vec :: new () ; for & cc in & priority_controllers { if let Some (& (count , min , max , sum)) = controller_data . get (& cc) { let avg = sum as f64 / count as f64 ; controllers . push (serde_json :: json ! ({ "cc" : cc , "name" : get_cc_name (cc) , "count" : count , "min" : min , "max" : max , "avg" : (avg * 100.0) . round () / 100.0 })) ; } } for (& cc , & (count , min , max , sum)) in & controller_data { if ! priority_controllers . contains (& cc) && count > 10 { let avg = sum as f64 / count as f64 ; controllers . push (serde_json :: json ! ({ "cc" : cc , "name" : get_cc_name (cc) , "count" : count , "min" : min , "max" : max , "avg" : (avg * 100.0) . round () / 100.0 })) ; } } if controllers . is_empty () { None } else { Some (serde_json :: to_string (& controllers) . unwrap_or_default ()) } }

- [ ] **Function 'get_cc_name' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/analyze.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Get human-readable name for CC number"] fn get_cc_name (cc : u8) -> & 'static str { match cc { 0 => "Bank Select" , 1 => "Modulation Wheel" , 2 => "Breath Controller" , 4 => "Foot Controller" , 5 => "Portamento Time" , 6 => "Data Entry" , 7 => "Channel Volume" , 8 => "Balance" , 10 => "Pan" , 11 => "Expression" , 64 => "Sustain Pedal" , 65 => "Portamento" , 66 => "Sostenuto" , 67 => "Soft Pedal" , 68 => "Legato Footswitch" , 69 => "Hold 2" , 71 => "Resonance" , 72 => "Release Time" , 73 => "Attack Time" , 74 => "Cutoff Frequency" , 84 => "Portamento Control" , 91 => "Reverb" , 92 => "Tremolo" , 93 => "Chorus" , 94 => "Detune" , 95 => "Phaser" , _ => "Other" , } }

- [ ] **Function 'analyze_articulation' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/analyze.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Analyze articulation and performance characteristics"] fn analyze_articulation (midi_file : & MidiFile , tempo_us_per_qn : u32) -> Option < String > { let tpq = midi_file . header . ticks_per_quarter_note as f64 ; let us_per_tick = tempo_us_per_qn as f64 / tpq ; let ms_per_tick = us_per_tick / 1000.0 ; let mut note_events : std :: collections :: HashMap < (u8 , u8) , (u32 , u8) > = std :: collections :: HashMap :: new () ; let mut note_durations : Vec < f64 > = Vec :: new () ; let mut note_velocities : Vec < u8 > = Vec :: new () ; let mut timing_deviations : Vec < f64 > = Vec :: new () ; let mut legato_count = 0 ; let mut staccato_count = 0 ; let mut total_notes = 0 ; for track in & midi_file . tracks { let mut current_tick = 0u32 ; let mut active_notes : std :: collections :: HashSet < (u8 , u8) > = std :: collections :: HashSet :: new () ; for timed_event in & track . events { current_tick += timed_event . delta_ticks ; match & timed_event . event { Event :: NoteOn { channel , note , velocity } if * velocity > 0 => { if ! active_notes . is_empty () { legato_count += 1 ; } active_notes . insert ((* channel , * note)) ; note_events . insert ((* channel , * note) , (current_tick , * velocity)) ; note_velocities . push (* velocity) ; let grid_size = (tpq / 4.0) as u32 ; let deviation = (current_tick % grid_size) as f64 ; let normalized_deviation = if deviation > grid_size as f64 / 2.0 { grid_size as f64 - deviation } else { deviation } ; timing_deviations . push (normalized_deviation * ms_per_tick) ; total_notes += 1 ; } , Event :: NoteOff { channel , note , .. } | Event :: NoteOn { channel , note , velocity : 0 } => { if let Some ((start_tick , _)) = note_events . remove (& (* channel , * note)) { let duration_ticks = current_tick . saturating_sub (start_tick) ; let duration_ms = duration_ticks as f64 * ms_per_tick ; note_durations . push (duration_ms) ; if duration_ms < 100.0 { staccato_count += 1 ; } } active_notes . remove (& (* channel , * note)) ; } , _ => { } , } } } if total_notes == 0 { return None ; } let legato_percentage = (legato_count as f64 / total_notes as f64) * 100.0 ; let staccato_percentage = (staccato_count as f64 / total_notes as f64) * 100.0 ; let avg_note_duration = note_durations . iter () . sum :: < f64 > () / note_durations . len () . max (1) as f64 ; let avg_timing_deviation = timing_deviations . iter () . sum :: < f64 > () / timing_deviations . len () . max (1) as f64 ; let min_velocity = * note_velocities . iter () . min () . unwrap_or (& 0) ; let max_velocity = * note_velocities . iter () . max () . unwrap_or (& 127) ; let dynamic_range = max_velocity . saturating_sub (min_velocity) ; let avg_velocity = note_velocities . iter () . map (| & v | v as f64) . sum :: < f64 > () / note_velocities . len () . max (1) as f64 ; let velocity_variance = note_velocities . iter () . map (| & v | { let diff = v as f64 - avg_velocity ; diff * diff }) . sum :: < f64 > () / note_velocities . len () . max (1) as f64 ; let result = serde_json :: json ! ({ "legato_percentage" : (legato_percentage * 100.0) . round () / 100.0 , "staccato_percentage" : (staccato_percentage * 100.0) . round () / 100.0 , "avg_note_duration_ms" : (avg_note_duration * 100.0) . round () / 100.0 , "timing_deviation_ms" : (avg_timing_deviation * 100.0) . round () / 100.0 , "dynamic_range" : dynamic_range , "velocity_variance" : (velocity_variance * 100.0) . round () / 100.0 , "is_humanized" : avg_timing_deviation > 2.0 , "is_legato" : legato_percentage > 30.0 , "is_staccato" : staccato_percentage > 50.0 , }) ; Some (serde_json :: to_string (& result) . unwrap_or_default ()) }

- [ ] **Function 'analyze_structure' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/analyze.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Analyze musical structure and form"] fn analyze_structure (midi_file : & MidiFile) -> Option < String > { let tpq = midi_file . header . ticks_per_quarter_note as u32 ; let segment_size = tpq * 16 ; let mut max_tick = 0u32 ; for track in & midi_file . tracks { let mut current_tick = 0u32 ; for event in & track . events { current_tick += event . delta_ticks ; } max_tick = max_tick . max (current_tick) ; } if max_tick < segment_size { return None ; } let num_segments = (max_tick / segment_size) as usize ; let mut segment_hashes : Vec < u64 > = vec ! [0 ; num_segments] ; for track in & midi_file . tracks { let mut current_tick = 0u32 ; for event in & track . events { current_tick += event . delta_ticks ; if let Event :: NoteOn { note , velocity , .. } = & event . event { if * velocity > 0 { let segment_idx = (current_tick / segment_size) as usize ; if segment_idx < num_segments { let position = current_tick % segment_size ; let hash = ((* note as u64) << 32) | position as u64 ; segment_hashes [segment_idx] ^= hash ; } } } } } let mut pattern_map : std :: collections :: HashMap < u64 , Vec < usize > > = std :: collections :: HashMap :: new () ; for (idx , & hash) in segment_hashes . iter () . enumerate () { if hash != 0 { pattern_map . entry (hash) . or_insert_with (Vec :: new) . push (idx) ; } } let mut repeated_sections : Vec < (usize , usize) > = Vec :: new () ; let mut pattern_id = 0 ; for (_hash , positions) in pattern_map . iter () { if positions . len () >= 2 { repeated_sections . push ((pattern_id , positions . len ())) ; pattern_id += 1 ; } } let total_repeated : usize = repeated_sections . iter () . map (| (_ , count) | count) . sum () ; let repetition_percentage = if num_segments > 0 { (total_repeated as f64 / num_segments as f64) * 100.0 } else { 0.0 } ; let num_unique = pattern_map . len () ; let estimated_form = if num_unique <= 2 { "Simple (AA or AB)" } else if num_unique <= 4 { "Song Form (AABA or ABAB)" } else if num_unique <= 6 { "Complex (ABABCB or similar)" } else { "Through-composed" } ; let result = serde_json :: json ! ({ "num_segments" : num_segments , "num_unique_patterns" : num_unique , "num_repeated_patterns" : repeated_sections . len () , "repetition_percentage" : (repetition_percentage * 100.0) . round () / 100.0 , "estimated_form" : estimated_form , "has_repetition" : repetition_percentage > 20.0 , "is_through_composed" : num_unique > 6 , }) ; Some (serde_json :: to_string (& result) . unwrap_or_default ()) }

- [ ] **Function 'get_instrument_info' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/analyze.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Get instrument information from GM program number"] fn get_instrument_info (program : u8) -> (String , String , String) { match program { 0 ..= 7 => ("Piano" . to_string () , "Keyboard" . to_string () , "Acoustic Piano" . to_string () ,) , 8 ..= 15 => ("Chromatic Percussion" . to_string () , "Keyboard" . to_string () , "Celesta/Glockenspiel" . to_string () ,) , 16 ..= 23 => ("Organ" . to_string () , "Keyboard" . to_string () , "Drawbar Organ" . to_string () ,) , 24 ..= 31 => ("Guitar" . to_string () , "Strings" . to_string () , "Acoustic Guitar" . to_string () ,) , 32 ..= 39 => ("Bass" . to_string () , "Strings" . to_string () , "Electric Bass" . to_string () ,) , 40 ..= 47 => ("Strings" . to_string () , "Strings" . to_string () , "Violin/Viola" . to_string () ,) , 48 ..= 55 => ("Ensemble" . to_string () , "Ensemble" . to_string () , "String Ensemble" . to_string () ,) , 56 ..= 63 => ("Brass" . to_string () , "Brass" . to_string () , "Trumpet/Trombone" . to_string () ,) , 64 ..= 71 => ("Reed" . to_string () , "Reed" . to_string () , "Saxophone" . to_string () ,) , 72 ..= 79 => ("Pipe" . to_string () , "Pipe" . to_string () , "Flute/Piccolo" . to_string () ,) , 80 ..= 87 => ("Synth Lead" . to_string () , "Synth" . to_string () , "Lead Synth" . to_string () ,) , 88 ..= 95 => ("Synth Pad" . to_string () , "Synth" . to_string () , "Pad Synth" . to_string () ,) , 96 ..= 103 => ("Synth Effects" . to_string () , "Synth" . to_string () , "FX Synth" . to_string () ,) , 104 ..= 111 => ("Ethnic" . to_string () , "Ethnic" . to_string () , "Sitar/Shamisen" . to_string () ,) , 112 ..= 119 => ("Percussive" . to_string () , "Percussion" . to_string () , "Timpani/Taiko" . to_string () ,) , 120 ..= 127 => ("Sound Effects" . to_string () , "SFX" . to_string () , "Sound Effect" . to_string () ,) , _ => ("Unknown" . to_string () , "Unknown" . to_string () , "Unknown" . to_string () ,) , } }

- [ ] **Function 'calculate_complexity_score' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/analyze.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Calculate complexity score based on various factors"] fn calculate_complexity_score (note_stats : & NoteStats , midi_file : & MidiFile) -> Option < f64 > { if note_stats . note_count == 0 { return Some (0.0) ; } let mut score = 0.0 ; let duration_est = calculate_total_ticks (midi_file) as f64 / (midi_file . header . ticks_per_quarter_note as f64 * 2.0) ; if duration_est > 0.0 { let note_density = note_stats . note_count as f64 / duration_est ; score += (note_density / 10.0) . min (30.0) ; } if let Some (semitones) = note_stats . pitch_range_semitones { score += (semitones as f64 / 2.0) . min (20.0) ; } if let Some (polyphony) = note_stats . polyphony_max { score += (polyphony as f64 * 5.0) . min (25.0) ; } let track_count = midi_file . tracks . len () as f64 ; score += (track_count * 2.0) . min (15.0) ; if let (Some (low) , Some (high)) = (note_stats . velocity_range_low , note_stats . velocity_range_high ,) { let velocity_range = (high - low) as f64 ; score += (velocity_range / 10.0) . min (10.0) ; } Some (score . min (100.0)) }

- [ ] **Function 'cleanup_temp_dir' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/archive_import.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Helper function to cleanup temp directories with proper error logging"] fn cleanup_temp_dir (path : & Path) { if let Err (e) = std :: fs :: remove_dir_all (path) { eprintln ! ("WARNING: Failed to cleanup temp directory {}: {}" , path . display () , e) ; eprintln ! ("  This may lead to disk space accumulation - manual cleanup may be required") ; } }

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/archive_import.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/archive_import.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/archive_import.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/archive_import.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/archive_import.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/file_import.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/file_import.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/file_import.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/file_import.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/file_import.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/file_import.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/file_import.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/file_import.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/file_import.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/file_import.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/file_import.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/file_import.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/file_import.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/file_import.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/file_import.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/file_import.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/file_import.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/file_import.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/file_import.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/file_import.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/file_import.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/file_import.rs`
  - Category: Performance

- [ ] **Function 'extract_instrument_names' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/file_import.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Extract instrument names from MIDI file for tag extraction"] fn extract_instrument_names (midi : & midi_library_shared :: core :: midi :: types :: MidiFile ,) -> Vec < String > { use midi_library_shared :: core :: midi :: types :: { Event , TextType } ; let mut instruments = Vec :: new () ; for track in & midi . tracks { for timed_event in & track . events { match & timed_event . event { Event :: Text { text_type , text } => { if matches ! (text_type , TextType :: InstrumentName | TextType :: TrackName) { instruments . push (text . clone ()) ; } } , Event :: ProgramChange { program , .. } => { if let Some (instrument_name) = program_to_instrument_name (* program) { instruments . push (instrument_name) ; } } , _ => { } , } } } instruments }

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/file_import.rs`
  - Category: Performance

- [ ] **Function 'extract_time_signature' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/file_import.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Extract time signature from MIDI file events"] # [doc = " Returns format like \"4-4\" for 4/4 time, or None if not found"] fn extract_time_signature (midi : & midi_library_shared :: core :: midi :: types :: MidiFile ,) -> Option < String > { use midi_library_shared :: core :: midi :: types :: Event ; for track in & midi . tracks { for timed_event in & track . events { if let Event :: TimeSignature { numerator , denominator , .. } = & timed_event . event { let denom_value = 2_u8 . pow (* denominator as u32) ; return Some (format ! ("{}-{}" , numerator , denom_value)) ; } } } None }

- [ ] **Function 'program_to_instrument_name' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/file_import.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Map MIDI General MIDI program number to instrument name"] fn program_to_instrument_name (program : u8) -> Option < String > { match program { 0 ..= 7 => Some ("Piano" . to_string ()) , 8 ..= 15 => Some ("Keys" . to_string ()) , 16 ..= 23 => Some ("Organ" . to_string ()) , 24 ..= 31 => Some ("Guitar" . to_string ()) , 32 ..= 39 => Some ("Bass" . to_string ()) , 40 ..= 47 => Some ("Strings" . to_string ()) , 48 ..= 55 => Some ("Ensemble" . to_string ()) , 56 ..= 63 => Some ("Brass" . to_string ()) , 64 ..= 71 => Some ("Woodwind" . to_string ()) , 72 ..= 79 => Some ("Flute" . to_string ()) , 80 ..= 87 => Some ("Lead" . to_string ()) , 88 ..= 95 => Some ("Pad" . to_string ()) , 96 ..= 103 => Some ("FX" . to_string ()) , 104 ..= 111 => Some ("Ethnic" . to_string ()) , 112 ..= 119 => Some ("Percussion" . to_string ()) , 120 ..= 127 => Some ("FX" . to_string ()) , _ => None , } }

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/file_import.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/file_import.rs`
  - Category: Performance

- [ ] **Function 'find_midi_files_recursive' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/file_import.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Recursively collect all MIDI files in a directory"] fn find_midi_files_recursive (dir : & Path) -> Result < Vec < PathBuf > , std :: io :: Error > { let mut files = Vec :: new () ; for entry in std :: fs :: read_dir (dir) ? { let entry = entry ? ; let path = entry . path () ; if path . is_dir () { match find_midi_files_recursive (& path) { Ok (subfiles) => files . extend (subfiles) , Err (e) => { eprintln ! ("Warning: Failed to read directory {}: {}" , path . display () , e) ; } , } } else if is_midi_file (& path) { files . push (path) ; } } Ok (files) }

- [ ] **Function 'find_midi_files_shallow' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/file_import.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Finds MIDI files in directory (non-recursive)"] fn find_midi_files_shallow (dir : & Path) -> Result < Vec < PathBuf > , std :: io :: Error > { let mut files = Vec :: new () ; for entry in std :: fs :: read_dir (dir) ? { let entry = entry ? ; let path = entry . path () ; if path . is_file () && is_midi_file (& path) { files . push (path) ; } } Ok (files) }

- [ ] **Function 'is_midi_file' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/file_import.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Check if a file is a MIDI file based on extension"] fn is_midi_file (path : & Path) -> bool { path . extension () . and_then (| ext | ext . to_str ()) . map (| ext | ext . eq_ignore_ascii_case ("mid") || ext . eq_ignore_ascii_case ("midi")) . unwrap_or (false) }

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/progress.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/progress.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/split_file.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/split_file.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/split_file.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/split_file.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/split_file.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/split_file.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/split_file.rs`
  - Category: Performance

- [ ] **Function 'generate_split_filename' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/split_file.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Generate a filename for a split track based on metadata."] # [doc = ""] # [doc = " Format: `{base}_track_{num:02}_{instrument}.mid`"] # [doc = ""] # [doc = " If instrument is not available, uses track name. If neither available,"] # [doc = " uses just track number."] # [doc = ""] # [doc = " Sanitizes all components to ensure valid filenames."] # [doc = ""] # [doc = " # Arguments"] # [doc = ""] # [doc = " * `base_filename` - Base filename from the parent file (without extension)"] # [doc = " * `split_track` - Metadata about the split track"] # [doc = ""] # [doc = " # Returns"] # [doc = ""] # [doc = " Sanitized filename with .mid extension"] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " ```"] # [doc = " use pipeline::commands::split_file::generate_split_filename;"] # [doc = " use pipeline::core::splitting::track_splitter::SplitTrack;"] # [doc = ""] # [doc = " let track = SplitTrack {"] # [doc = "     track_number: 1,"] # [doc = "     track_name: Some(\"Piano\".to_string()),"] # [doc = "     channel: Some(0),"] # [doc = "     instrument: Some(\"Acoustic Grand Piano\".to_string()),"] # [doc = "     note_count: 100,"] # [doc = "     midi_bytes: vec![],"] # [doc = " };"] # [doc = ""] # [doc = " let filename = generate_split_filename(\"my_song\", &track);"] # [doc = " assert_eq!(filename, \"my_song_track_01_Acoustic_Grand_Piano.mid\");"] # [doc = " ```"] pub fn generate_split_filename (base_filename : & str , split_track : & SplitTrack) -> String { let base = sanitize_filename (base_filename) ; let track_num = format ! ("{:02}" , split_track . track_number) ; let suffix = if let Some (ref instrument) = split_track . instrument { sanitize_filename (instrument) } else if let Some (ref track_name) = split_track . track_name { sanitize_filename (track_name) } else { String :: new () } ; if suffix . is_empty () { format ! ("{}_track_{}.mid" , base , track_num) } else { format ! ("{}_track_{}_{}.mid" , base , track_num , suffix) } }

- [ ] **Function 'sanitize_filename' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/split_file.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Sanitize a string to be used as a filename component."] # [doc = ""] # [doc = " Removes or replaces problematic characters:"] # [doc = " - Replaces spaces with underscores"] # [doc = " - Removes: / \\ : * ? \" < > | (filesystem-unsafe characters)"] # [doc = " - Removes: control characters, non-ASCII if problematic"] # [doc = " - Collapses multiple underscores to single underscore"] # [doc = " - Trims underscores from start and end"] # [doc = ""] # [doc = " # Arguments"] # [doc = ""] # [doc = " * `name` - String to sanitize"] # [doc = ""] # [doc = " # Returns"] # [doc = ""] # [doc = " Sanitized string safe for use in filenames"] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " ```"] # [doc = " use pipeline::commands::split_file::sanitize_filename;"] # [doc = ""] # [doc = " assert_eq!(sanitize_filename(\"Piano Track\"), \"Piano_Track\");"] # [doc = " assert_eq!(sanitize_filename(\"Track: 1 (Lead)\"), \"Track_1_Lead\");"] # [doc = " assert_eq!(sanitize_filename(\"Bass/Guitar\"), \"BassGuitar\");"] # [doc = " assert_eq!(sanitize_filename(\"  Piano  \"), \"Piano\");"] # [doc = " ```"] pub fn sanitize_filename (name : & str) -> String { name . chars () . map (| c | match c { ' ' => '_' , '/' | '\\' | ':' | '*' | '?' | '"' | '<' | '>' | '|' => '_' , c if c . is_alphanumeric () || c == '_' || c == '-' || c == '.' || c == '(' || c == ')' => c , _ => '_' , }) . collect :: < String > () . split ('_') . filter (| s | ! s . is_empty ()) . collect :: < Vec < _ > > () . join ("_") }

- [ ] **Function 'extract_time_signature_from_midi' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/split_file.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Extract time signature from MIDI file events"] # [doc = " Returns format like \"4-4\" for 4/4 time, or None if not found"] fn extract_time_signature_from_midi (midi : & midi_library_shared :: core :: midi :: types :: MidiFile ,) -> Option < String > { use midi_library_shared :: core :: midi :: types :: Event ; for track in & midi . tracks { for timed_event in & track . events { if let Event :: TimeSignature { numerator , denominator , .. } = & timed_event . event { let denom_value = 2_u8 . pow (* denominator as u32) ; return Some (format ! ("{}-{}" , numerator , denom_value)) ; } } } None }

- [ ] **Function 'create_minimal_midi' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/arena_midi.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn create_minimal_midi () -> Vec < u8 > { vec ! [b'M' , b'T' , b'h' , b'd' , 0 , 0 , 0 , 6 , 0 , 0 , 0 , 1 , 0 , 96 , b'M' , b'T' , b'r' , b'k' , 0 , 0 , 0 , 4 , 0x00 , 0xFF , 0x2F , 0x00 ,] }

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/auto_tagger.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/auto_tagger.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/auto_tagger.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/auto_tagger.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/auto_tagger.rs`
  - Category: Performance

- [ ] **Function 'detect_bpm' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/bpm_detector.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Detects BPM from a parsed MIDI file using tempo events"] # [doc = ""] # [doc = " This is the legacy tempo-event-based detection. For SIMD-accelerated"] # [doc = " onset detection, use `detect_bpm_with_onsets` or `detect_bpm_hybrid`."] # [doc = ""] # [doc = " # Arguments"] # [doc = " * `midi_file` - Parsed MIDI file structure"] # [doc = ""] # [doc = " # Returns"] # [doc = " * `BpmDetectionResult` - Detection result with confidence and metadata"] # [doc = ""] # [doc = " # Examples"] # [doc = " ```no_run"] # [doc = " use pipeline::core::analysis::bpm_detector::detect_bpm;"] # [doc = " use pipeline::core::midi::types::MidiFile;"] # [doc = ""] # [doc = " # fn example() -> Result<(), Box<dyn std::error::Error>> {"] # [doc = " # let midi_file = MidiFile {"] # [doc = " #     header: pipeline::core::midi::types::Header {"] # [doc = " #         format: 1,"] # [doc = " #         num_tracks: 1,"] # [doc = " #         ticks_per_quarter_note: 480,"] # [doc = " #     },"] # [doc = " #     tracks: vec![],"] # [doc = " # };"] # [doc = " let result = detect_bpm(&midi_file);"] # [doc = " println!(\"Detected BPM: {:.2}\", result.bpm);"] # [doc = " # Ok(())"] # [doc = " # }"] # [doc = " ```"] pub fn detect_bpm (midi_file : & MidiFile) -> BpmDetectionResult { let tempo_events = extract_tempo_events (midi_file) ; if tempo_events . is_empty () { return BpmDetectionResult { bpm : DEFAULT_BPM , confidence : 0.3 , method : BpmDetectionMethod :: DefaultTempo , metadata : BpmMetadata { tempo_changes : vec ! [] , is_constant : true , tempo_range : None } , onset_result : None , } ; } let tempo_changes : Vec < TempoChange > = tempo_events . into_iter () . map (| (tick , microseconds_per_quarter) | TempoChange { tick , bpm : microseconds_to_bpm (microseconds_per_quarter) , }) . collect () ; let is_constant = tempo_changes . len () == 1 ; let bpms : Vec < f64 > = tempo_changes . iter () . map (| tc | tc . bpm) . collect () ; let total_ticks = calculate_total_ticks (midi_file) ; let avg_bpm = calculate_weighted_average (& tempo_changes , total_ticks) ; let tempo_range = if tempo_changes . len () > 1 { let min = bpms . iter () . cloned () . fold (f64 :: INFINITY , f64 :: min) ; let max = bpms . iter () . cloned () . fold (f64 :: NEG_INFINITY , f64 :: max) ; Some ((min , max)) } else { None } ; let confidence = calculate_confidence (& tempo_changes) ; let method = if tempo_changes . len () == 1 { BpmDetectionMethod :: SingleTempo } else { BpmDetectionMethod :: WeightedAverage } ; BpmDetectionResult { bpm : avg_bpm , confidence , method , metadata : BpmMetadata { tempo_changes , is_constant , tempo_range } , onset_result : None , } }

- [ ] **Function 'detect_bpm_with_onsets' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/bpm_detector.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Detects BPM using SIMD-accelerated onset detection only"] # [doc = ""] # [doc = " This function uses SIMD-optimized onset detection to analyze rhythmic patterns"] # [doc = " and calculate BPM. It's faster than tempo-event analysis and works even when"] # [doc = " no tempo events are present in the MIDI file."] # [doc = ""] # [doc = " # Arguments"] # [doc = " * `midi_file` - Parsed MIDI file structure"] # [doc = ""] # [doc = " # Returns"] # [doc = " * `Option<BpmDetectionResult>` - Detection result, or None if insufficient onsets"] # [doc = ""] # [doc = " # Performance"] # [doc = " - Uses SIMD vectorization for 2-4x speedup"] # [doc = " - Processes 32 velocities per SIMD operation"] # [doc = " - Optimized for files with many note events"] # [doc = ""] # [doc = " # Examples"] # [doc = " ```no_run"] # [doc = " use pipeline::core::analysis::bpm_detector::detect_bpm_with_onsets;"] # [doc = " use midi_library_shared::core::midi::types::MidiFile;"] # [doc = ""] # [doc = " # fn example(midi_file: MidiFile) -> Result<(), Box<dyn std::error::Error>> {"] # [doc = " if let Some(result) = detect_bpm_with_onsets(&midi_file) {"] # [doc = "     println!(\"Onset-based BPM: {:.2} (confidence: {:.2})\", result.bpm, result.confidence);"] # [doc = " }"] # [doc = " # Ok(())"] # [doc = " # }"] # [doc = " ```"] pub fn detect_bpm_with_onsets (midi_file : & MidiFile) -> Option < BpmDetectionResult > { let onset_result = detect_bpm_from_onsets (midi_file) ? ; Some (BpmDetectionResult { bpm : onset_result . bpm , confidence : onset_result . confidence , method : BpmDetectionMethod :: OnsetDetection , metadata : BpmMetadata { tempo_changes : vec ! [] , is_constant : false , tempo_range : None } , onset_result : Some (onset_result) , }) }

- [ ] **Function 'detect_bpm_hybrid' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/bpm_detector.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Hybrid BPM detection combining tempo events and SIMD onset analysis"] # [doc = ""] # [doc = " This function uses both tempo event analysis and SIMD-accelerated onset detection,"] # [doc = " then combines the results using weighted averaging based on confidence scores."] # [doc = " This provides the most robust BPM detection across different MIDI file types."] # [doc = ""] # [doc = " # Arguments"] # [doc = " * `midi_file` - Parsed MIDI file structure"] # [doc = ""] # [doc = " # Returns"] # [doc = " * `BpmDetectionResult` - Combined detection result with highest confidence"] # [doc = ""] # [doc = " # Strategy"] # [doc = " - If tempo events exist with high confidence: use tempo-based BPM"] # [doc = " - If onsets detected with high confidence: use onset-based BPM"] # [doc = " - If both available: weighted average based on confidence scores"] # [doc = " - Fallback to default if neither method succeeds"] # [doc = ""] # [doc = " # Performance"] # [doc = " - SIMD-optimized onset detection: 2-4x speedup"] # [doc = " - Minimal overhead when combining methods"] # [doc = ""] # [doc = " # Examples"] # [doc = " ```no_run"] # [doc = " use pipeline::core::analysis::bpm_detector::detect_bpm_hybrid;"] # [doc = " use midi_library_shared::core::midi::types::MidiFile;"] # [doc = ""] # [doc = " # fn example(midi_file: MidiFile) -> Result<(), Box<dyn std::error::Error>> {"] # [doc = " let result = detect_bpm_hybrid(&midi_file);"] # [doc = " println!(\"Hybrid BPM: {:.2} (confidence: {:.2})\", result.bpm, result.confidence);"] # [doc = " # Ok(())"] # [doc = " # }"] # [doc = " ```"] pub fn detect_bpm_hybrid (midi_file : & MidiFile) -> BpmDetectionResult { let tempo_result = detect_bpm (midi_file) ; let onset_result_opt = detect_bpm_from_onsets (midi_file) ; match onset_result_opt { Some (onset_result) => { let tempo_confidence = tempo_result . confidence ; let onset_confidence = onset_result . confidence ; if matches ! (tempo_result . method , BpmDetectionMethod :: DefaultTempo) { return BpmDetectionResult { bpm : onset_result . bpm , confidence : onset_result . confidence , method : BpmDetectionMethod :: OnsetDetection , metadata : tempo_result . metadata , onset_result : Some (onset_result) , } ; } let total_confidence = tempo_confidence + onset_confidence ; let weighted_bpm = if total_confidence > 0.0 { (tempo_result . bpm * tempo_confidence + onset_result . bpm * onset_confidence) / total_confidence } else { (tempo_result . bpm + onset_result . bpm) / 2.0 } ; let combined_confidence = tempo_confidence . max (onset_confidence) ; BpmDetectionResult { bpm : weighted_bpm . clamp (MIN_BPM , MAX_BPM) , confidence : combined_confidence , method : BpmDetectionMethod :: Hybrid , metadata : tempo_result . metadata , onset_result : Some (onset_result) , } } , None => { tempo_result } , } }

- [ ] **Function 'extract_tempo_events' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/bpm_detector.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Extracts tempo events from all tracks in the MIDI file"] fn extract_tempo_events (midi_file : & MidiFile) -> Vec < (u32 , u32) > { let mut tempo_events = Vec :: new () ; for track in & midi_file . tracks { let mut current_tick = 0u32 ; for timed_event in & track . events { current_tick += timed_event . delta_ticks ; if let Event :: TempoChange { microseconds_per_quarter } = timed_event . event { tempo_events . push ((current_tick , microseconds_per_quarter)) ; } } } tempo_events . sort_by_key (| (tick , _) | * tick) ; tempo_events }

- [ ] **Function 'calculate_total_ticks' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/bpm_detector.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Calculates the total number of ticks in the MIDI file"] fn calculate_total_ticks (midi_file : & MidiFile) -> u32 { let mut max_ticks = 0u32 ; for track in & midi_file . tracks { let mut track_ticks = 0u32 ; for timed_event in & track . events { track_ticks += timed_event . delta_ticks ; } max_ticks = max_ticks . max (track_ticks) ; } max_ticks }

- [ ] **Function 'microseconds_to_bpm' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/bpm_detector.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Converts microseconds per quarter note to BPM"] fn microseconds_to_bpm (microseconds_per_quarter : u32) -> f64 { let bpm = 60_000_000.0 / microseconds_per_quarter as f64 ; bpm . clamp (MIN_BPM , MAX_BPM) }

- [ ] **Function 'calculate_weighted_average' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/bpm_detector.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Calculates weighted average BPM based on duration each tempo is active"] fn calculate_weighted_average (tempo_changes : & [TempoChange] , total_ticks : u32) -> f64 { if tempo_changes . is_empty () { return DEFAULT_BPM ; } if tempo_changes . len () == 1 { return tempo_changes [0] . bpm ; } let mut weighted_sum = 0.0 ; let mut total_weight = 0.0 ; for (i , tempo_change) in tempo_changes . iter () . enumerate () { let duration = if i + 1 < tempo_changes . len () { tempo_changes [i + 1] . tick - tempo_change . tick } else { total_ticks . saturating_sub (tempo_change . tick) } ; let weight = duration as f64 ; weighted_sum += tempo_change . bpm * weight ; total_weight += weight ; } if total_weight > 0.0 { weighted_sum / total_weight } else { tempo_changes [0] . bpm } }

- [ ] **Function 'calculate_confidence' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/bpm_detector.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Calculates confidence score based on tempo consistency"] fn calculate_confidence (tempo_changes : & [TempoChange]) -> f64 { if tempo_changes . is_empty () { return 0.3 ; } if tempo_changes . len () == 1 { return 1.0 ; } let bpms : Vec < f64 > = tempo_changes . iter () . map (| tc | tc . bpm) . collect () ; let mean = bpms . iter () . sum :: < f64 > () / bpms . len () as f64 ; let variance = bpms . iter () . map (| bpm | (bpm - mean) . powi (2)) . sum :: < f64 > () / bpms . len () as f64 ; let std_dev = variance . sqrt () ; let cv = std_dev / mean ; (1.0 - cv) . clamp (0.5 , 1.0) }

- [ ] **Function 'analyze_chords' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/chord_analyzer.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Main chord analysis function"] pub fn analyze_chords (midi_file : & MidiFile , ticks_per_quarter : u32) -> ChordAnalysis { let note_events = extract_note_events (midi_file) ; if note_events . is_empty () { return ChordAnalysis { progression : Vec :: new () , types : Vec :: new () , has_sevenths : false , has_extended : false , change_rate : None , complexity_score : 0.0 , } ; } let window_size = ticks_per_quarter / 2 ; let chords = detect_chords_in_windows (& note_events , window_size) ; let progression : Vec < String > = chords . iter () . map (| c | c . name . clone ()) . collect () ; let types : Vec < String > = chords . iter () . map (| c | c . chord_type . clone ()) . collect () ; let has_sevenths = chords . iter () . any (| c | c . is_seventh) ; let has_extended = chords . iter () . any (| c | c . is_extended) ; let ticks_per_measure = ticks_per_quarter * 4 ; let total_ticks = note_events . last () . map (| (t , _ , _) | * t) . unwrap_or (0) ; let total_measures = if total_ticks > 0 { (total_ticks as f32 / ticks_per_measure as f32) . max (1.0) } else { 1.0 } ; let change_rate = if chords . len () > 1 { Some (chords . len () as f32 / total_measures) } else { None } ; let complexity_score = calculate_complexity (& chords) ; ChordAnalysis { progression , types , has_sevenths , has_extended , change_rate , complexity_score } }

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/chord_analyzer.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/chord_analyzer.rs`
  - Category: Performance

- [ ] **Function 'extract_note_events' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/chord_analyzer.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Extract all note-on events with timing and channel"] fn extract_note_events (midi_file : & MidiFile) -> Vec < (u32 , u8 , u8) > { let mut events = Vec :: new () ; let mut cumulative_tick = 0u32 ; for track in & midi_file . tracks { let mut track_tick = 0u32 ; for event in & track . events { track_tick += event . delta_ticks ; match & event . event { Event :: NoteOn { channel , note , velocity } if * velocity > 0 => { events . push ((track_tick , * note , * channel)) ; } , _ => { } , } } cumulative_tick = cumulative_tick . max (track_tick) ; } events . sort_by_key (| (tick , _ , _) | * tick) ; events }

- [ ] **Function 'detect_chords_in_windows' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/chord_analyzer.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Group notes into time windows and detect chords"] fn detect_chords_in_windows (note_events : & [(u32 , u8 , u8)] , window_size : u32) -> Vec < DetectedChord > { let mut chords : Vec < DetectedChord > = Vec :: new () ; let mut current_window_start = 0u32 ; let mut current_notes = Vec :: new () ; for (tick , note , channel) in note_events { if * channel == 9 { continue ; } while * tick >= current_window_start + window_size { if current_notes . len () >= 3 { if let Some (chord) = identify_chord (& current_notes) { if chords . is_empty () || chords . last () . unwrap () . name != chord . name { chords . push (chord) ; } } } current_notes . clear () ; current_window_start += window_size ; } current_notes . push (* note) ; } if current_notes . len () >= 3 { if let Some (chord) = identify_chord (& current_notes) { if chords . is_empty () || chords . last () . unwrap () . name != chord . name { chords . push (chord) ; } } } chords }

- [ ] **Function 'identify_chord' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/chord_analyzer.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Identify chord from a collection of MIDI notes"] fn identify_chord (notes : & [u8]) -> Option < DetectedChord > { if notes . len () < 3 { return None ; } let unique_notes : Vec < u8 > = { let set : HashSet < u8 > = notes . iter () . map (| n | n % 12) . collect () ; let mut vec : Vec < u8 > = set . into_iter () . collect () ; vec . sort () ; vec } ; if unique_notes . len () < 3 { return None ; } match identify_chord_type (& unique_notes) { Some ((root , chord_type , is_seventh , is_extended)) => { let name = format ! ("{}{}" , root , chord_type) ; Some (DetectedChord { tick : 0 , notes : notes . to_vec () , name , chord_type , is_seventh , is_extended , }) } , None => None , } }

- [ ] **Function 'identify_chord_type' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/chord_analyzer.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Identify chord type from pitch classes"] fn identify_chord_type (pitch_classes : & [u8]) -> Option < (String , String , bool , bool) > { if pitch_classes . len () < 3 { return None ; } let root = pitch_classes [0] ; let root_name = note_name_from_pitch (root) ; let intervals : Vec < u8 > = pitch_classes . iter () . map (| & p | (p + 12 - root) % 12) . collect () ; let (chord_type , is_seventh , is_extended) = match intervals . as_slice () { [0 , 4 , 7] => ("" . to_string () , false , false) , [0 , 3 , 7] => ("m" . to_string () , false , false) , [0 , 3 , 6] => ("dim" . to_string () , false , false) , [0 , 4 , 8] => ("aug" . to_string () , false , false) , [0 , 4 , 7 , 11] => ("maj7" . to_string () , true , false) , [0 , 3 , 7 , 10] => ("m7" . to_string () , true , false) , [0 , 4 , 7 , 10] => ("7" . to_string () , true , false) , [0 , 3 , 6 , 9] => ("dim7" . to_string () , true , false) , [0 , 3 , 6 , 10] => ("m7b5" . to_string () , true , false) , [0 , 4 , 7 , 11 , 2] | [0 , 2 , 4 , 7 , 11] => ("maj9" . to_string () , true , true) , [0 , 3 , 7 , 10 , 2] | [0 , 2 , 3 , 7 , 10] => ("m9" . to_string () , true , true) , [0 , 4 , 7 , 10 , 2] | [0 , 2 , 4 , 7 , 10] => ("9" . to_string () , true , true) , _ => { let has_major_third = intervals . contains (& 4) ; let has_minor_third = intervals . contains (& 3) ; let has_seventh = intervals . contains (& 10) || intervals . contains (& 11) ; let has_ninth = intervals . contains (& 2) ; let has_eleventh = intervals . contains (& 5) ; let has_thirteenth = intervals . contains (& 9) ; let quality = if has_major_third { "" . to_string () } else if has_minor_third { "m" . to_string () } else { return None ; } ; let is_extended = has_ninth || has_eleventh || has_thirteenth ; (quality , has_seventh , is_extended) } , } ; Some ((root_name , chord_type , is_seventh , is_extended)) }

- [ ] **Function 'note_name_from_pitch' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/chord_analyzer.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Convert MIDI pitch (0-11) to note name"] fn note_name_from_pitch (pitch : u8) -> String { let names = ["C" , "C#" , "D" , "D#" , "E" , "F" , "F#" , "G" , "G#" , "A" , "A#" , "B"] ; names [(pitch % 12) as usize] . to_string () }

- [ ] **Function 'calculate_complexity' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/chord_analyzer.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Calculate complexity score based on chord types"] fn calculate_complexity (chords : & [DetectedChord]) -> f32 { if chords . is_empty () { return 0.0 ; } let mut total_score = 0.0 ; for chord in chords { let score = if chord . is_extended { 1.0 } else if chord . is_seventh { 0.6 } else { 0.3 } ; total_score += score ; } (total_score / chords . len () as f32) . min (1.0) }

- [ ] **Function 'analyze_drum_midi' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/drum_analyzer.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Analyze MIDI file for drum-specific characteristics"] # [doc = ""] # [doc = " **Trusty Module**: Pure function, no I/O, no side effects"] pub fn analyze_drum_midi (midi_file : & MidiFile) -> DrumAnalysis { let drum_channel_detected = has_drum_channel (midi_file) ; let drum_notes = extract_drum_notes (midi_file) ; let cymbal_types = detect_cymbal_types (& drum_notes) ; let time_signature = extract_time_signature_from_meta (midi_file) ; let techniques = detect_techniques (midi_file , & drum_notes) ; DrumAnalysis { is_drum_file : drum_channel_detected || ! drum_notes . is_empty () , drum_channel_detected , drum_notes , pattern_type : None , rhythmic_feel : None , time_signature , bpm : None , cymbal_types , techniques , song_structure : None , } }

- [ ] **Function 'has_drum_channel' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/drum_analyzer.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Check if MIDI file uses channel 10 (GM drum channel)"] # [doc = ""] # [doc = " **Trusty Module**: Pure function"] pub fn has_drum_channel (midi_file : & MidiFile) -> bool { for track in & midi_file . tracks { for timed_event in & track . events { match timed_event . event { Event :: NoteOn { channel , .. } | Event :: NoteOff { channel , .. } => { if channel == 9 { return true ; } } , _ => { } , } } } false }

- [ ] **Function 'extract_drum_notes' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/drum_analyzer.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Extract all GM drum notes and their frequencies"] # [doc = ""] # [doc = " **Trusty Module**: Pure function"] pub fn extract_drum_notes (midi_file : & MidiFile) -> HashMap < DrumNote , usize > { let mut note_counts = HashMap :: new () ; for track in & midi_file . tracks { for timed_event in & track . events { if let Event :: NoteOn { channel , note , velocity } = timed_event . event { if (channel == 9 || (35 ..= 81) . contains (& note)) && velocity > 0 { if let Some (drum_note) = note_to_drum_type (note) { * note_counts . entry (drum_note) . or_insert (0) += 1 ; } } } } } note_counts }

- [ ] **Function 'note_to_drum_type' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/drum_analyzer.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Map MIDI note number to GM drum type"] # [doc = ""] # [doc = " **Trusty Module**: Pure function"] pub fn note_to_drum_type (note : u8) -> Option < DrumNote > { match note { 35 => Some (DrumNote :: AcousticBassDrum) , 36 => Some (DrumNote :: BassDrum1) , 37 => Some (DrumNote :: SideStick) , 38 => Some (DrumNote :: AcousticSnare) , 39 => Some (DrumNote :: HandClap) , 40 => Some (DrumNote :: ElectricSnare) , 41 => Some (DrumNote :: LowFloorTom) , 42 => Some (DrumNote :: ClosedHiHat) , 43 => Some (DrumNote :: HighFloorTom) , 44 => Some (DrumNote :: PedalHiHat) , 45 => Some (DrumNote :: LowTom) , 46 => Some (DrumNote :: OpenHiHat) , 47 => Some (DrumNote :: LowMidTom) , 48 => Some (DrumNote :: HighMidTom) , 49 => Some (DrumNote :: CrashCymbal1) , 50 => Some (DrumNote :: HighTom) , 51 => Some (DrumNote :: RideCymbal1) , 52 => Some (DrumNote :: ChineseCymbal) , 53 => Some (DrumNote :: RideBell) , 54 => Some (DrumNote :: Tambourine) , 55 => Some (DrumNote :: SplashCymbal) , 56 => Some (DrumNote :: Cowbell) , 57 => Some (DrumNote :: CrashCymbal2) , 59 => Some (DrumNote :: RideCymbal2) , 60 => Some (DrumNote :: HighBongo) , 61 => Some (DrumNote :: LowBongo) , 62 => Some (DrumNote :: MuteHighConga) , 63 => Some (DrumNote :: OpenHighConga) , 64 => Some (DrumNote :: LowConga) , 65 => Some (DrumNote :: HighTimbale) , 66 => Some (DrumNote :: LowTimbale) , 67 => Some (DrumNote :: HighAgogo) , 68 => Some (DrumNote :: LowAgogo) , 69 => Some (DrumNote :: Cabasa) , 70 => Some (DrumNote :: Maracas) , 71 => Some (DrumNote :: ShortWhistle) , 72 => Some (DrumNote :: LongWhistle) , 73 => Some (DrumNote :: ShortGuiro) , 74 => Some (DrumNote :: LongGuiro) , 75 => Some (DrumNote :: Claves) , 76 => Some (DrumNote :: HighWoodBlock) , 77 => Some (DrumNote :: LowWoodBlock) , 78 => Some (DrumNote :: MuteCuica) , 79 => Some (DrumNote :: OpenCuica) , 80 => Some (DrumNote :: MuteTriangle) , 81 => Some (DrumNote :: OpenTriangle) , _ => None , } }

- [ ] **Function 'detect_cymbal_types' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/drum_analyzer.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Detect cymbal types from drum notes"] # [doc = ""] # [doc = " **Trusty Module**: Pure function"] pub fn detect_cymbal_types (drum_notes : & HashMap < DrumNote , usize >) -> Vec < CymbalType > { let mut cymbals = Vec :: new () ; if drum_notes . contains_key (& DrumNote :: ClosedHiHat) { cymbals . push (CymbalType :: ClosedHat) ; } if drum_notes . contains_key (& DrumNote :: PedalHiHat) { cymbals . push (CymbalType :: PedalHat) ; } if drum_notes . contains_key (& DrumNote :: OpenHiHat) { cymbals . push (CymbalType :: OpenHat) ; } if drum_notes . contains_key (& DrumNote :: RideCymbal1) || drum_notes . contains_key (& DrumNote :: RideCymbal2) { cymbals . push (CymbalType :: Ride) ; } if drum_notes . contains_key (& DrumNote :: RideBell) { cymbals . push (CymbalType :: RideBell) ; } if drum_notes . contains_key (& DrumNote :: CrashCymbal1) || drum_notes . contains_key (& DrumNote :: CrashCymbal2) { cymbals . push (CymbalType :: Crash) ; } if drum_notes . contains_key (& DrumNote :: ChineseCymbal) { cymbals . push (CymbalType :: China) ; } if drum_notes . contains_key (& DrumNote :: SplashCymbal) { cymbals . push (CymbalType :: Splash) ; } cymbals }

- [ ] **Function 'extract_time_signature_from_meta' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/drum_analyzer.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Extract time signature from MIDI meta events"] # [doc = ""] # [doc = " **Trusty Module**: Pure function"] pub fn extract_time_signature_from_meta (midi_file : & MidiFile) -> Option < TimeSignature > { for track in & midi_file . tracks { for timed_event in & track . events { if let Event :: TimeSignature { numerator , denominator , .. } = timed_event . event { return Some (TimeSignature { numerator , denominator : 2u8 . saturating_pow (denominator as u32) , }) ; } } } None }

- [ ] **Function 'detect_techniques' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/drum_analyzer.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Detect drum techniques from note patterns"] # [doc = ""] # [doc = " **Trusty Module**: Pure function"] pub fn detect_techniques (midi_file : & MidiFile , drum_notes : & HashMap < DrumNote , usize > ,) -> Vec < DrumTechnique > { let mut techniques = Vec :: new () ; if has_ghost_notes (midi_file) { techniques . push (DrumTechnique :: GhostNotes) ; } let kick_count_1 = drum_notes . get (& DrumNote :: BassDrum1) . copied () . unwrap_or (0) ; let kick_count_2 = drum_notes . get (& DrumNote :: AcousticBassDrum) . copied () . unwrap_or (0) ; let kick_count = kick_count_1 + kick_count_2 ; if kick_count > 100 { techniques . push (DrumTechnique :: DoubleBass) ; } techniques }

- [ ] **Function 'has_ghost_notes' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/drum_analyzer.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Check for ghost notes (low-velocity snare hits)"] # [doc = ""] # [doc = " **Trusty Module**: Pure function"] fn has_ghost_notes (midi_file : & MidiFile) -> bool { let mut ghost_count = 0 ; let mut total_snare = 0 ; for track in & midi_file . tracks { for timed_event in & track . events { if let Event :: NoteOn { note , velocity , .. } = timed_event . event { if note == 38 || note == 40 { total_snare += 1 ; if velocity > 0 && velocity < 40 { ghost_count += 1 ; } } } } } total_snare > 0 && (ghost_count as f64 / total_snare as f64) >= 0.3 }

- [ ] **Function 'extract_time_signature_from_path' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/drum_analyzer.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Extract time signature from filename or path"] # [doc = ""] # [doc = " **Trusty Module**: Pure function"] # [doc = ""] # [doc = " Patterns:"] # [doc = " - \"9-8 Straight Kick.mid\""] # [doc = " - \"Jazz Parts 2/12-8 Swing/...\""] # [doc = " - \"6-8_groove.mid\""] pub fn extract_time_signature_from_path (file_path : & str , file_name : & str) -> Option < TimeSignature > { let combined = format ! ("{}/{}" , file_path , file_name) ; let patterns = [("12-8" , (12 , 8)) , ("12/8" , (12 , 8)) , ("9-8" , (9 , 8)) , ("9/8" , (9 , 8)) , ("6-8" , (6 , 8)) , ("6/8" , (6 , 8)) , ("7-8" , (7 , 8)) , ("7/8" , (7 , 8)) , ("11-8" , (11 , 8)) , ("11/8" , (11 , 8)) , ("15-8" , (15 , 8)) , ("15/8" , (15 , 8)) , ("7-4" , (7 , 4)) , ("7/4" , (7 , 4)) , ("5-4" , (5 , 4)) , ("5/4" , (5 , 4)) , ("3-4" , (3 , 4)) , ("3/4" , (3 , 4)) , ("4-4" , (4 , 4)) , ("4/4" , (4 , 4)) , ("2-4" , (2 , 4)) , ("2/4" , (2 , 4)) ,] ; for (pattern , (num , denom)) in & patterns { if combined . contains (pattern) { return Some (TimeSignature { numerator : * num , denominator : * denom }) ; } } None }

- [ ] **Function 'extract_bpm_from_filename' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/drum_analyzer.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Extract BPM from filename"] # [doc = ""] # [doc = " **Trusty Module**: Pure function"] # [doc = ""] # [doc = " Patterns:"] # [doc = " - \"174_Gmin_Bass.mid\""] # [doc = " - \"140bpm_Kick.mid\""] # [doc = " - \"120 BPM Groove.mid\""] # [doc = " - \"jazz_136_swing.mid\""] pub fn extract_bpm_from_filename (file_name : & str) -> Option < f64 > { let name_lower = file_name . to_lowercase () ; if let Some (pos) = name_lower . find ("bpm") { let before_bpm = & name_lower [.. pos] . trim () ; if let Some (num_start) = before_bpm . rfind (| c : char | ! c . is_ascii_digit ()) { if let Ok (bpm) = before_bpm [num_start + 1 ..] . parse :: < f64 > () { if (40.0 ..= 220.0) . contains (& bpm) { return Some (bpm) ; } } } } if file_name . len () >= 4 && file_name . chars () . nth (3) == Some ('_') { if let Ok (bpm) = file_name [.. 3] . parse :: < f64 > () { if (40.0 ..= 220.0) . contains (& bpm) { return Some (bpm) ; } } } if file_name . len () >= 4 && file_name . chars () . nth (3) == Some (' ') { if let Ok (bpm) = file_name [.. 3] . parse :: < f64 > () { if (40.0 ..= 220.0) . contains (& bpm) { return Some (bpm) ; } } } for segment in file_name . split ('_') { if segment . len () == 3 && segment . chars () . all (| c | c . is_ascii_digit ()) { if let Ok (bpm) = segment . parse :: < f64 > () { if (40.0 ..= 220.0) . contains (& bpm) { return Some (bpm) ; } } } } None }

- [ ] **Function 'extract_pattern_type' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/drum_analyzer.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Extract pattern type from filename/path"] # [doc = ""] # [doc = " **Trusty Module**: Pure function"] pub fn extract_pattern_type (file_path : & str , file_name : & str) -> Option < PatternType > { let combined = format ! ("{}/{}" , file_path , file_name) . to_lowercase () ; if combined . contains ("groove") || combined . contains (" gr ") { Some (PatternType :: Groove) } else if combined . contains ("fill") { Some (PatternType :: Fill) } else if combined . contains ("intro") { Some (PatternType :: Intro) } else if combined . contains ("ending") || combined . contains ("outro") { Some (PatternType :: Ending) } else if combined . contains ("breakdown") || combined . contains ("bkdn") { Some (PatternType :: Breakdown) } else if combined . contains ("turnaround") || combined . contains (" ta ") { Some (PatternType :: Turnaround) } else if combined . contains ("sequence") || combined . contains (" seq ") { Some (PatternType :: Sequence) } else if combined . contains ("one-shot") || combined . contains ("oneshot") { Some (PatternType :: OneShot) } else { None } }

- [ ] **Function 'extract_rhythmic_feel' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/drum_analyzer.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Extract rhythmic feel from filename/path"] # [doc = ""] # [doc = " **Trusty Module**: Pure function"] pub fn extract_rhythmic_feel (file_path : & str , file_name : & str) -> Option < RhythmicFeel > { let combined = format ! ("{}/{}" , file_path , file_name) . to_lowercase () ; if combined . contains ("swing") { Some (RhythmicFeel :: Swing) } else if combined . contains ("shuffle") { Some (RhythmicFeel :: Shuffle) } else if combined . contains ("straight") { Some (RhythmicFeel :: Straight) } else if combined . contains ("triplet") { Some (RhythmicFeel :: Triplet) } else if combined . contains ("half-time") || combined . contains ("halftime") { Some (RhythmicFeel :: Half) } else if combined . contains ("double-time") || combined . contains ("doubletime") { Some (RhythmicFeel :: Double) } else if combined . contains ("pocket") { Some (RhythmicFeel :: Pocket) } else { None } }

- [ ] **Function 'extract_song_structure' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/drum_analyzer.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Extract song structure from filename/path"] # [doc = ""] # [doc = " **Trusty Module**: Pure function"] pub fn extract_song_structure (file_path : & str , file_name : & str) -> Option < SongStructure > { let combined = format ! ("{}/{}" , file_path , file_name) . to_lowercase () ; if combined . contains ("verse") { Some (SongStructure :: Verse) } else if combined . contains ("chorus") { Some (SongStructure :: Chorus) } else if combined . contains ("bridge") { Some (SongStructure :: Bridge) } else if combined . contains ("intro") { Some (SongStructure :: Intro) } else if combined . contains ("outro") { Some (SongStructure :: Outro) } else if combined . contains ("pre-chorus") || combined . contains ("prechorus") { Some (SongStructure :: PreChorus) } else if combined . contains ("breakdown") { Some (SongStructure :: Breakdown) } else if combined . contains ("turnaround") { Some (SongStructure :: Turnaround) } else if combined . contains ("middle-8") || combined . contains ("mid-8") { Some (SongStructure :: MiddleEight) } else { None } }

- [ ] **Function 'drum_note_to_tag' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/drum_analyzer.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn drum_note_to_tag (drum_note : DrumNote) -> (& 'static str , & 'static str) { match drum_note { DrumNote :: AcousticBassDrum | DrumNote :: BassDrum1 => ("kick" , "instrument") , DrumNote :: AcousticSnare | DrumNote :: ElectricSnare => ("snare" , "instrument") , DrumNote :: ClosedHiHat | DrumNote :: OpenHiHat | DrumNote :: PedalHiHat => { ("hihat" , "instrument") } , DrumNote :: LowFloorTom | DrumNote :: HighFloorTom | DrumNote :: LowTom | DrumNote :: LowMidTom | DrumNote :: HighMidTom | DrumNote :: HighTom => ("toms" , "instrument") , DrumNote :: CrashCymbal1 | DrumNote :: CrashCymbal2 => ("crash" , "instrument") , DrumNote :: RideCymbal1 | DrumNote :: RideCymbal2 => ("ride" , "instrument") , DrumNote :: ChineseCymbal => ("china" , "instrument") , DrumNote :: SplashCymbal => ("splash" , "instrument") , DrumNote :: RideBell => ("ride-bell" , "instrument") , DrumNote :: SideStick => ("sidestick" , "instrument") , DrumNote :: HandClap => ("clap" , "instrument") , DrumNote :: Cowbell => ("cowbell" , "instrument") , DrumNote :: Tambourine => ("tambourine" , "instrument") , DrumNote :: HighBongo | DrumNote :: LowBongo => ("bongo" , "instrument") , DrumNote :: MuteHighConga | DrumNote :: OpenHighConga | DrumNote :: LowConga => { ("conga" , "instrument") } , _ => ("percussion" , "instrument") , } }

- [ ] **Function 'cymbal_to_tag_name' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/drum_analyzer.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn cymbal_to_tag_name (cymbal : & CymbalType) -> & 'static str { match cymbal { CymbalType :: ClosedHat => "closed-hat" , CymbalType :: PedalHat => "pedal-hat" , CymbalType :: OpenHat => "open-hat" , CymbalType :: Ride => "ride" , CymbalType :: RideBell => "ride-bell" , CymbalType :: Crash => "crash" , CymbalType :: China => "china" , CymbalType :: Splash => "splash" , } }

- [ ] **Function 'pattern_type_to_tag' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/drum_analyzer.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn pattern_type_to_tag (pattern : & PatternType) -> & 'static str { match pattern { PatternType :: Groove => "groove" , PatternType :: Fill => "fill" , PatternType :: Intro => "intro" , PatternType :: Ending => "ending" , PatternType :: Breakdown => "breakdown" , PatternType :: Turnaround => "turnaround" , PatternType :: Sequence => "sequence" , PatternType :: OneShot => "one-shot" , } }

- [ ] **Function 'rhythmic_feel_to_tag' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/drum_analyzer.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn rhythmic_feel_to_tag (feel : & RhythmicFeel) -> & 'static str { match feel { RhythmicFeel :: Straight => "straight" , RhythmicFeel :: Swing => "swing" , RhythmicFeel :: Shuffle => "shuffle" , RhythmicFeel :: Triplet => "triplet" , RhythmicFeel :: Half => "half-time" , RhythmicFeel :: Double => "double-time" , RhythmicFeel :: Pocket => "pocket" , } }

- [ ] **Function 'song_structure_to_tag' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/drum_analyzer.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn song_structure_to_tag (structure : & SongStructure) -> & 'static str { match structure { SongStructure :: Verse => "verse" , SongStructure :: Chorus => "chorus" , SongStructure :: Bridge => "bridge" , SongStructure :: Intro => "intro" , SongStructure :: Outro => "outro" , SongStructure :: PreChorus => "pre-chorus" , SongStructure :: Breakdown => "breakdown" , SongStructure :: Turnaround => "turnaround" , SongStructure :: MiddleEight => "middle-8" , } }

- [ ] **Function 'technique_to_tag_name' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/drum_analyzer.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn technique_to_tag_name (technique : & DrumTechnique) -> & 'static str { match technique { DrumTechnique :: GhostNotes => "ghost-notes" , DrumTechnique :: Linear => "linear" , DrumTechnique :: DoubleBass => "double-bass" , DrumTechnique :: BlastBeat => "blast-beat" , DrumTechnique :: Paradiddle => "paradiddle" , DrumTechnique :: Flam => "flam" , DrumTechnique :: Roll => "roll" , } }

- [ ] **Function 'generate_drum_tags' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/drum_analyzer.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Generate drum-specific tags from analysis results"] # [doc = ""] # [doc = " **Trusty Module**: Pure function"] # [doc = ""] # [doc = " Returns tags compatible with AutoTagger Tag structure"] pub fn generate_drum_tags (analysis : & DrumAnalysis , file_path : & str , file_name : & str) -> Vec < Tag > { let mut tags = Vec :: new () ; if analysis . is_drum_file { tags . push (Tag :: with_metadata ("drums" . to_string () , Some ("instrument" . to_string ()) , 0.90 , 20 , "midi_channel_10" . to_string () ,)) ; } for (drum_note , count) in & analysis . drum_notes { if * count > 5 { let (tag_name , category) = drum_note_to_tag (* drum_note) ; tags . push (Tag :: with_metadata (tag_name . to_string () , Some (category . to_string ()) , 0.85 , 20 , "midi_drum_notes" . to_string () ,)) ; } } for cymbal in & analysis . cymbal_types { tags . push (Tag :: with_metadata (cymbal_to_tag_name (cymbal) . to_string () , Some ("cymbal-type" . to_string ()) , 0.85 , 25 , "midi_drum_notes" . to_string () ,)) ; } if let Some (ref time_sig) = analysis . time_signature { let ts_tag = format ! ("{}-{}" , time_sig . numerator , time_sig . denominator) ; tags . push (Tag :: with_metadata (ts_tag , Some ("time-signature" . to_string ()) , 0.90 , 35 , "midi_meta_event" . to_string () ,)) ; if [6 , 9 , 12] . contains (& time_sig . numerator) && time_sig . denominator == 8 { tags . push (Tag :: with_metadata ("compound-meter" . to_string () , Some ("rhythm-style" . to_string ()) , 0.80 , 40 , "time_sig_derived" . to_string () ,)) ; } } if let Some (pattern) = extract_pattern_type (file_path , file_name) { tags . push (Tag :: with_metadata (pattern_type_to_tag (& pattern) . to_string () , Some ("pattern-type" . to_string ()) , 0.85 , 30 , "filename_exact" . to_string () ,)) ; } if let Some (feel) = extract_rhythmic_feel (file_path , file_name) { tags . push (Tag :: with_metadata (rhythmic_feel_to_tag (& feel) . to_string () , Some ("rhythm-feel" . to_string ()) , 0.85 , 40 , "filename_exact" . to_string () ,)) ; } if let Some (structure) = extract_song_structure (file_path , file_name) { tags . push (Tag :: with_metadata (song_structure_to_tag (& structure) . to_string () , Some ("structure" . to_string ()) , 0.85 , 80 , "filename_exact" . to_string () ,)) ; } if let Some (bpm) = extract_bpm_from_filename (file_name) { let bpm_rounded = bpm . round () as i32 ; tags . push (Tag :: with_metadata (bpm_rounded . to_string () , Some ("tempo" . to_string ()) , 0.85 , 50 , "filename_bpm" . to_string () ,)) ; } for technique in & analysis . techniques { tags . push (Tag :: with_metadata (technique_to_tag_name (technique) . to_string () , Some ("technique" . to_string ()) , 0.75 , 45 , "midi_pattern_analysis" . to_string () ,)) ; } tags }

- [ ] **Function 'get_bpm_regex' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/filename_metadata.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn get_bpm_regex () -> & 'static Regex { BPM_REGEX . get_or_init (| | { Regex :: new (r"(?i)([0-9]{2,3})[\s_]*(bpm|beats|tempo)|(?:^|_|\s|-|/)([0-9]{2,3})(?:_|\s|-|/|\.)" ,) . expect ("BPM regex should be valid") }) }

- [ ] **Function 'extract_bpm_from_filename' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/filename_metadata.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Extracts BPM value from filename"] # [doc = ""] # [doc = " Recognizes patterns:"] # [doc = " - Explicit: \"120_BPM_house_loop.mid\", \"Drums_140bpm.mid\""] # [doc = " - Implicit: \"house_120.mid\", \"bass_140.mid\""] # [doc = ""] # [doc = " Valid range: 40-220 BPM"] # [doc = ""] # [doc = " # Examples"] # [doc = " ```"] # [doc = " use pipeline::core::analysis::filename_metadata::extract_bpm_from_filename;"] # [doc = ""] # [doc = " assert_eq!(extract_bpm_from_filename(\"house_120_loop.mid\"), Some(120.0));"] # [doc = " assert_eq!(extract_bpm_from_filename(\"140bpm_trap.mid\"), Some(140.0));"] # [doc = " assert_eq!(extract_bpm_from_filename(\"drums_128_beats.mid\"), Some(128.0));"] # [doc = " assert_eq!(extract_bpm_from_filename(\"no_bpm_here.mid\"), None);"] # [doc = " ```"] pub fn extract_bpm_from_filename (filename : & str) -> Option < f64 > { let regex = get_bpm_regex () ; for caps in regex . captures_iter (filename) { if let Some (m) = caps . get (1) { if let Ok (bpm) = m . as_str () . parse :: < f64 > () { if (40.0 ..= 220.0) . contains (& bpm) { return Some (bpm) ; } } } } for caps in regex . captures_iter (filename) { if let Some (m) = caps . get (3) { if let Ok (bpm) = m . as_str () . parse :: < f64 > () { if (40.0 ..= 220.0) . contains (& bpm) { return Some (bpm) ; } } } } None }

- [ ] **Function 'get_key_regex' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/filename_metadata.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn get_key_regex () -> & 'static Regex { KEY_REGEX . get_or_init (| | { Regex :: new (r"(?i)(?:^|_|\s|-|/)([A-G](?:#|b)?m?)(?:_|\s|-|/|\.)|([A-G]\s?(maj|min|major|minor))" ,) . expect ("Key regex should be valid") }) }

- [ ] **Function 'get_key_map' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/filename_metadata.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn get_key_map () -> & 'static HashMap < & 'static str , & 'static str > { KEY_NORMALIZATION_MAP . get_or_init (| | { HashMap :: from ([("amin" , "Am") , ("am" , "Am") , ("bmin" , "Bm") , ("bm" , "Bm") , ("cmin" , "Cm") , ("cm" , "Cm") , ("dmin" , "Dm") , ("dm" , "Dm") , ("emin" , "Em") , ("em" , "Em") , ("fmin" , "Fm") , ("fm" , "Fm") , ("gmin" , "Gm") , ("gm" , "Gm") , ("amaj" , "A") , ("cmaj" , "C") , ("dmaj" , "D") , ("emaj" , "E") , ("fmaj" , "F") , ("gmaj" , "G") , ("bmaj" , "B") , ("bb" , "Bb") , ("a#" , "A#") , ("c#" , "C#") , ("d#" , "D#") , ("f#" , "F#") , ("g#" , "G#") , ("ab" , "Ab") , ("db" , "Db") , ("eb" , "Eb") , ("gb" , "Gb") , ("a" , "A") , ("b" , "B") , ("c" , "C") , ("d" , "D") , ("e" , "E") , ("f" , "F") , ("g" , "G") ,]) }) }

- [ ] **Function 'normalize_key_signature' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/filename_metadata.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Normalizes raw key signature to canonical form"] # [doc = ""] # [doc = " # Examples"] # [doc = " ```"] # [doc = " use pipeline::core::analysis::filename_metadata::normalize_key_signature;"] # [doc = ""] # [doc = " assert_eq!(normalize_key_signature(\"amin\"), Some(\"Am\".to_string()));"] # [doc = " assert_eq!(normalize_key_signature(\"Cmaj\"), Some(\"C\".to_string()));"] # [doc = " assert_eq!(normalize_key_signature(\"f#\"), Some(\"F#\".to_string()));"] # [doc = " assert_eq!(normalize_key_signature(\"a\"), Some(\"A\".to_string()));"] # [doc = " ```"] pub fn normalize_key_signature (raw_key : & str) -> Option < String > { get_key_map () . get (raw_key . to_lowercase () . as_str ()) . map (| & s | s . to_string ()) }

- [ ] **Function 'extract_key_from_filename' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/filename_metadata.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Extracts key signature from filename and normalizes it"] # [doc = ""] # [doc = " # Examples"] # [doc = " ```"] # [doc = " use pipeline::core::analysis::filename_metadata::extract_key_from_filename;"] # [doc = ""] # [doc = " assert_eq!(extract_key_from_filename(\"Cm_bass.mid\"), Some(\"Cm\".to_string()));"] # [doc = " assert_eq!(extract_key_from_filename(\"16_Dm_Bass.mid\"), Some(\"Dm\".to_string()));"] # [doc = " assert_eq!(extract_key_from_filename(\"melody_in_A_major.mid\"), Some(\"A\".to_string()));"] # [doc = " ```"] pub fn extract_key_from_filename (filename : & str) -> Option < String > { get_key_regex () . captures (filename) . and_then (| caps | caps . get (1) . or_else (| | caps . get (3))) . and_then (| m | normalize_key_signature (m . as_str ())) }

- [ ] **Function 'get_genre_regex' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/filename_metadata.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn get_genre_regex () -> & 'static Regex { GENRE_REGEX . get_or_init (| | { Regex :: new (r"(?i)(house|techno|trance|hip.?hop|trap|dubstep|dnb|drum.?n.?bass|jazz|funk|soul|rock|pop|edm|ambient|downtempo|break|jungle|garage|electro|acid|minimal|deep|progressive)" ,) . expect ("Genre regex should be valid") }) }

- [ ] **Function 'normalize_genre' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/filename_metadata.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Normalizes genre variants to canonical form"] fn normalize_genre (raw : & str) -> String { match raw { "hip hop" | "hiphop" | "hip-hop" => "hip-hop" . to_string () , "dnb" | "drum n bass" | "drum and bass" | "drum-n-bass" | "drum_n_bass" => { "dnb" . to_string () } , genre => genre . to_string () , } }

- [ ] **Function 'extract_genres_from_filename' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/filename_metadata.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Extracts genre tags from filename"] # [doc = ""] # [doc = " # Examples"] # [doc = " ```"] # [doc = " use pipeline::core::analysis::filename_metadata::extract_genres_from_filename;"] # [doc = ""] # [doc = " let genres = extract_genres_from_filename(\"deep_house_120.mid\");"] # [doc = " assert!(genres.contains(&\"deep\".to_string()));"] # [doc = " assert!(genres.contains(&\"house\".to_string()));"] # [doc = ""] # [doc = " let genres = extract_genres_from_filename(\"drum_n_bass_170.mid\");"] # [doc = " assert!(genres.contains(&\"dnb\".to_string()));"] # [doc = " ```"] pub fn extract_genres_from_filename (filename : & str) -> Vec < String > { get_genre_regex () . find_iter (filename) . map (| m | m . as_str () . to_lowercase ()) . map (| g | normalize_genre (& g)) . collect () }

- [ ] **Function 'get_structure_regex' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/filename_metadata.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn get_structure_regex () -> & 'static Regex { STRUCTURE_REGEX . get_or_init (| | { Regex :: new (r"(?i)(verse|chorus|bridge|intro|outro|drop|build|breakdown|fill|loop|one.?shot|sample|melody|hook|riff|lick|main|full|short|long)" ,) . expect ("Structure regex should be valid") }) }

- [ ] **Function 'normalize_structure_tag' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/filename_metadata.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Normalizes structure tag variants"] fn normalize_structure_tag (raw : & str) -> String { match raw { "one shot" | "one-shot" | "oneshot" => "oneshot" . to_string () , tag => tag . to_string () , } }

- [ ] **Function 'extract_structure_tags' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/filename_metadata.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Extracts structure tags from filename"] # [doc = ""] # [doc = " # Examples"] # [doc = " ```"] # [doc = " use pipeline::core::analysis::filename_metadata::extract_structure_tags;"] # [doc = ""] # [doc = " let tags = extract_structure_tags(\"drum_fill_120bpm.mid\");"] # [doc = " assert!(tags.contains(&\"fill\".to_string()));"] # [doc = ""] # [doc = " let tags = extract_structure_tags(\"verse_melody_loop.mid\");"] # [doc = " assert!(tags.contains(&\"verse\".to_string()));"] # [doc = " assert!(tags.contains(&\"melody\".to_string()));"] # [doc = " assert!(tags.contains(&\"loop\".to_string()));"] # [doc = " ```"] pub fn extract_structure_tags (filename : & str) -> Vec < String > { get_structure_regex () . find_iter (filename) . map (| m | m . as_str () . to_lowercase ()) . map (| s | normalize_structure_tag (& s)) . collect () }

- [ ] **Function 'get_leading_number_regex' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/filename_metadata.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn get_leading_number_regex () -> & 'static Regex { LEADING_NUMBER_REGEX . get_or_init (| | Regex :: new (r"^([0-9]+)") . expect ("Leading number regex should be valid")) }

- [ ] **Function 'extract_leading_number' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/filename_metadata.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Extracts leading number from filename"] # [doc = ""] # [doc = " Common uses:"] # [doc = " - Track ordering (01-99)"] # [doc = " - Kit numbers (001-999)"] # [doc = " - Version numbers (v1, v2, v3)"] # [doc = ""] # [doc = " # Examples"] # [doc = " ```"] # [doc = " use pipeline::core::analysis::filename_metadata::extract_leading_number;"] # [doc = ""] # [doc = " assert_eq!(extract_leading_number(\"01_kick.mid\"), Some(1));"] # [doc = " assert_eq!(extract_leading_number(\"125_melody.mid\"), Some(125));"] # [doc = " assert_eq!(extract_leading_number(\"kick_01.mid\"), None);"] # [doc = " ```"] pub fn extract_leading_number (filename : & str) -> Option < u32 > { get_leading_number_regex () . captures (filename) . and_then (| caps | caps . get (1)) . and_then (| m | m . as_str () . parse :: < u32 > () . ok ()) }

- [ ] **Function 'classify_leading_number' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/filename_metadata.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Classifies the purpose of a leading number"] # [doc = ""] # [doc = " # Examples"] # [doc = " ```"] # [doc = " use pipeline::core::analysis::filename_metadata::{classify_leading_number, NumberType};"] # [doc = ""] # [doc = " assert_eq!(classify_leading_number(1), NumberType::TrackNumber);"] # [doc = " assert_eq!(classify_leading_number(42), NumberType::TrackNumber);"] # [doc = " assert_eq!(classify_leading_number(120), NumberType::PossibleBPM);"] # [doc = " assert_eq!(classify_leading_number(500), NumberType::Unknown);"] # [doc = " ```"] pub fn classify_leading_number (num : u32) -> NumberType { match num { 1 ..= 99 => NumberType :: TrackNumber , 100 ..= 220 => NumberType :: PossibleBPM , _ => NumberType :: Unknown , } }

- [ ] **Function 'validate_key_signature' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/filename_metadata.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Cross-validates key signature from analysis and filename"] # [doc = ""] # [doc = " # Examples"] # [doc = " ```"] # [doc = " use pipeline::core::analysis::filename_metadata::{validate_key_signature, KeyValidationResult};"] # [doc = ""] # [doc = " // Agreement - validated"] # [doc = " match validate_key_signature(Some(\"Cm\"), Some(\"Cm\")) {"] # [doc = "     KeyValidationResult::Validated(key) => assert_eq!(key, \"Cm\"),"] # [doc = "     _ => panic!(\"Expected validated\"),"] # [doc = " }"] # [doc = ""] # [doc = " // Conflict"] # [doc = " match validate_key_signature(Some(\"Cm\"), Some(\"Dm\")) {"] # [doc = "     KeyValidationResult::Conflict { analyzed, filename } => {"] # [doc = "         assert_eq!(analyzed, \"Cm\");"] # [doc = "         assert_eq!(filename, \"Dm\");"] # [doc = "     }"] # [doc = "     _ => panic!(\"Expected conflict\"),"] # [doc = " }"] # [doc = " ```"] pub fn validate_key_signature (analyzed_key : Option < & str > , filename_key : Option < & str > ,) -> KeyValidationResult { match (analyzed_key , filename_key) { (Some (a) , Some (f)) if a == f => KeyValidationResult :: Validated (a . to_string ()) , (Some (a) , Some (f)) => { KeyValidationResult :: Conflict { analyzed : a . to_string () , filename : f . to_string () } } , (Some (a) , None) => KeyValidationResult :: AnalyzedOnly (a . to_string ()) , (None , Some (f)) => KeyValidationResult :: FilenameOnly (f . to_string ()) , (None , None) => KeyValidationResult :: Unknown , } }

- [ ] **Function 'validate_bpm' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/filename_metadata.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Validates BPM from analysis against filename metadata"] # [doc = ""] # [doc = " Tolerance: Â±5 BPM (accounts for detection variance)"] # [doc = ""] # [doc = " # Examples"] # [doc = " ```"] # [doc = " use pipeline::core::analysis::filename_metadata::validate_bpm;"] # [doc = ""] # [doc = " assert!(validate_bpm(Some(120.0), Some(120.0)));  // Exact match"] # [doc = " assert!(validate_bpm(Some(120.0), Some(123.0)));  // Within tolerance"] # [doc = " assert!(!validate_bpm(Some(120.0), Some(140.0))); // Out of tolerance"] # [doc = " ```"] pub fn validate_bpm (analyzed_bpm : Option < f32 > , filename_bpm : Option < f32 >) -> bool { match (analyzed_bpm , filename_bpm) { (Some (a) , Some (f)) => (a - f) . abs () <= 5.0 , _ => false , } }

- [ ] **Function 'validate_bpm_for_genre' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/filename_metadata.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Genre-specific BPM range validation"] # [doc = ""] # [doc = " # Examples"] # [doc = " ```"] # [doc = " use pipeline::core::analysis::filename_metadata::validate_bpm_for_genre;"] # [doc = ""] # [doc = " assert!(validate_bpm_for_genre(120.0, \"house\"));   // House: 120-128 BPM"] # [doc = " assert!(!validate_bpm_for_genre(80.0, \"house\"));   // Too slow for house"] # [doc = " assert!(validate_bpm_for_genre(170.0, \"dnb\"));     // DNB: 160-180 BPM"] # [doc = " ```"] pub fn validate_bpm_for_genre (bpm : f32 , genre : & str) -> bool { let ranges : HashMap < & str , (f32 , f32) > = [("house" , (120.0 , 128.0)) , ("techno" , (125.0 , 135.0)) , ("trance" , (128.0 , 140.0)) , ("dubstep" , (138.0 , 142.0)) , ("dnb" , (160.0 , 180.0)) , ("drum-n-bass" , (160.0 , 180.0)) , ("trap" , (135.0 , 145.0)) , ("hip-hop" , (70.0 , 100.0)) , ("funk" , (90.0 , 120.0)) , ("rock" , (100.0 , 140.0)) , ("pop" , (100.0 , 130.0)) ,] . iter () . cloned () . collect () ; ranges . get (genre) . map (| & (min , max) | bpm >= min && bpm <= max) . unwrap_or (true) }

- [ ] **Function 'detect_key' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/key_detector.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Detects the musical key from a parsed MIDI file"] # [doc = ""] # [doc = " # Arguments"] # [doc = " * `midi_file` - Parsed MIDI file structure"] # [doc = ""] # [doc = " # Returns"] # [doc = " * `KeyDetectionResult` - Detection result with confidence and alternatives"] # [doc = ""] # [doc = " # Algorithm"] # [doc = " Uses Krumhansl-Schmuckler key-finding algorithm:"] # [doc = " 1. Extract all notes and build pitch class histogram"] # [doc = " 2. Normalize histogram to probability distribution"] # [doc = " 3. Correlate with all 24 key profiles (12 major + 12 minor)"] # [doc = " 4. Return key with highest correlation"] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " ```"] # [doc = " use pipeline::core::midi::types::MidiFile;"] # [doc = " use pipeline::core::analysis::key_detector::detect_key;"] # [doc = ""] # [doc = " // Assuming you have a parsed MIDI file"] # [doc = " // let midi_file = parse_midi_file(&data)?;"] # [doc = " // let result = detect_key(&midi_file);"] # [doc = " // println!(\"Detected key: {} ({})\", result.key, result.scale_type);"] # [doc = " ```"] pub fn detect_key (midi_file : & MidiFile) -> KeyDetectionResult { let pitch_class_counts = build_pitch_class_histogram (midi_file) ; let pitch_class_distribution = normalize_histogram (& pitch_class_counts) ; let mut correlations = Vec :: new () ; for pitch_class in 0 .. 12 { let major_correlation = calculate_correlation (& pitch_class_distribution , & rotate_profile (& MAJOR_PROFILE , pitch_class) ,) ; correlations . push ((pitch_class , ScaleType :: Major , major_correlation)) ; let minor_correlation = calculate_correlation (& pitch_class_distribution , & rotate_profile (& MINOR_PROFILE , pitch_class) ,) ; correlations . push ((pitch_class , ScaleType :: Minor , minor_correlation)) ; } correlations . sort_by (| a , b | b . 2 . partial_cmp (& a . 2) . unwrap_or (std :: cmp :: Ordering :: Equal)) ; let (best_pitch_class , best_scale_type , _best_correlation) = correlations [0] ; let key_name = format_key_name (best_pitch_class , best_scale_type) ; let confidence = calculate_confidence (& correlations) ; let alternatives : Vec < KeyAlternative > = correlations [1 .. 4] . iter () . map (| (pc , st , corr) | KeyAlternative { key : format_key_name (* pc , * st) , scale_type : * st , correlation : * corr , }) . collect () ; KeyDetectionResult { key : key_name , scale_type : best_scale_type , confidence , alternatives , pitch_class_distribution , } }

- [ ] **Function 'build_pitch_class_histogram' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/key_detector.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Builds a histogram of pitch class occurrences"] fn build_pitch_class_histogram (midi_file : & MidiFile) -> [u32 ; 12] { let mut histogram = [0u32 ; 12] ; for track in & midi_file . tracks { for timed_event in & track . events { if let Event :: NoteOn { note , velocity , .. } = timed_event . event { if velocity > 0 { let pitch_class = (note % 12) as usize ; histogram [pitch_class] += 1 ; } } } } histogram }

- [ ] **Function 'normalize_histogram' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/key_detector.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Normalizes histogram to probability distribution"] fn normalize_histogram (histogram : & [u32 ; 12]) -> [f64 ; 12] { let total : u32 = histogram . iter () . sum () ; if total == 0 { return [0.0 ; 12] ; } let mut normalized = [0.0 ; 12] ; for i in 0 .. 12 { normalized [i] = histogram [i] as f64 / total as f64 ; } normalized }

- [ ] **Function 'rotate_profile' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/key_detector.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Rotates a key profile to a different tonic"] # [doc = ""] # [doc = " Takes a profile defined for C (pitch class 0) and rotates it to be"] # [doc = " defined for a different pitch class. The rotation shifts the profile"] # [doc = " so that the tonic weight appears at the target pitch class."] fn rotate_profile (profile : & [f64 ; 12] , rotation : usize) -> [f64 ; 12] { let mut rotated = [0.0 ; 12] ; for i in 0 .. 12 { rotated [i] = profile [(i + 12 - rotation) % 12] ; } rotated }

- [ ] **Function 'calculate_correlation' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/key_detector.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Calculates Pearson correlation coefficient between two distributions"] fn calculate_correlation (distribution : & [f64 ; 12] , profile : & [f64 ; 12]) -> f64 { let mean_dist = distribution . iter () . sum :: < f64 > () / 12.0 ; let mean_prof = profile . iter () . sum :: < f64 > () / 12.0 ; let mut covariance = 0.0 ; let mut var_dist = 0.0 ; let mut var_prof = 0.0 ; for i in 0 .. 12 { let diff_dist = distribution [i] - mean_dist ; let diff_prof = profile [i] - mean_prof ; covariance += diff_dist * diff_prof ; var_dist += diff_dist * diff_dist ; var_prof += diff_prof * diff_prof ; } let std_dist = var_dist . sqrt () ; let std_prof = var_prof . sqrt () ; if std_dist == 0.0 || std_prof == 0.0 { return 0.0 ; } covariance / (std_dist * std_prof) }

- [ ] **Function 'calculate_confidence' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/key_detector.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Calculates confidence based on separation between best and second-best keys"] fn calculate_confidence (correlations : & [(usize , ScaleType , f64)]) -> f64 { if correlations . len () < 2 { return 0.5 ; } let best = correlations [0] . 2 ; let second_best = correlations [1] . 2 ; let gap = best - second_best ; let confidence = 0.5 + (gap * 2.5) . min (0.5) ; confidence . clamp (0.5 , 1.0) }

- [ ] **Function 'format_key_name' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/key_detector.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Formats key name based on pitch class and scale type"] fn format_key_name (pitch_class : usize , scale_type : ScaleType) -> String { let base_name = pitch_class_to_key_name (pitch_class) ; match scale_type { ScaleType :: Major => base_name . to_string () , ScaleType :: Minor => format ! ("{}m" , base_name) , } }

- [ ] **Function 'create_test_midi_with_notes' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/key_detector.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Create a MIDI file with specific notes"] # [doc = " Each note is (pitch, velocity) - velocity 0 means note off"] fn create_test_midi_with_notes (notes : Vec < (u8 , u8) >) -> MidiFile { let mut events : Vec < TimedEvent > = Vec :: new () ; for (pitch , velocity) in notes { events . push (TimedEvent { delta_ticks : 10 , event : Event :: NoteOn { note : pitch , velocity , channel : 0 } , }) ; } events . push (TimedEvent { delta_ticks : 0 , event : Event :: EndOfTrack }) ; MidiFile { header : Header { format : 1 , num_tracks : 1 , ticks_per_quarter_note : 480 } , tracks : vec ! [Track { events }] , } }

- [ ] **Function 'create_major_scale' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/key_detector.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Create a major scale starting from a given root note"] fn create_major_scale (root : u8) -> Vec < u8 > { let intervals = [0 , 2 , 4 , 5 , 7 , 9 , 11 , 12] ; intervals . iter () . map (| & i | root + i) . collect () }

- [ ] **Function 'create_minor_scale' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/key_detector.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Create a minor scale starting from a given root note"] fn create_minor_scale (root : u8) -> Vec < u8 > { let intervals = [0 , 2 , 3 , 5 , 7 , 8 , 10 , 12] ; intervals . iter () . map (| & i | root + i) . collect () }

- [ ] **Function 'create_chromatic_scale' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/key_detector.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Create chromatic scale (all 12 pitches)"] fn create_chromatic_scale (root : u8) -> Vec < u8 > { (0 .. 12) . map (| i | root + i) . collect () }

- [ ] **Function 'assert_correlation_approx' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/key_detector.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Assert correlation is within tolerance"] # [allow (dead_code)] fn assert_correlation_approx (actual : f64 , expected : f64 , tolerance : f64) { assert ! ((actual - expected) . abs () < tolerance , "Correlation mismatch: expected {}, got {} (tolerance: {})" , expected , actual , tolerance) ; }

- [ ] **Function 'pitch_class_to_key_name' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/key_profiles.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Maps pitch class to key name"] pub fn pitch_class_to_key_name (pitch_class : usize) -> & 'static str { match pitch_class { 0 => "C" , 1 => "C#" , 2 => "D" , 3 => "D#" , 4 => "E" , 5 => "F" , 6 => "F#" , 7 => "G" , 8 => "G#" , 9 => "A" , 10 => "A#" , 11 => "B" , _ => "UNKNOWN" , } }

- [ ] **Function 'pitch_class_to_minor_key_name' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/key_profiles.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Returns the minor key name for a given pitch class"] pub fn pitch_class_to_minor_key_name (pitch_class : usize) -> String { format ! ("{}m" , pitch_class_to_key_name (pitch_class)) }

- [ ] **Function 'analyze_file_mmap' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/optimized_analyzer.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Phase 2: Memory-mapped file analysis (zero-copy)"] # [doc = ""] # [doc = " Uses standard heap allocation for MIDI events. For files with 10K+ events,"] # [doc = " consider using `analyze_file_arena()` for 5-15% better performance."] pub fn analyze_file_mmap (file : & FileToAnalyze) -> Result < AnalysisResult > { let file_handle = File :: open (& file . filepath) ? ; let mmap = unsafe { Mmap :: map (& file_handle) ? } ; let midi_file = parse_midi_file (& mmap) ? ; let bpm_result = detect_bpm (& midi_file) ; let bpm = if bpm_result . confidence > 0.3 { Some (bpm_result . bpm) } else { None } ; let has_tempo_changes = ! bpm_result . metadata . is_constant ; let key_result = detect_key (& midi_file) ; let ticks_per_quarter = midi_file . header . ticks_per_quarter_note as u32 ; let chord_analysis = analyze_chords (& midi_file , ticks_per_quarter) ; let chord_progression = if ! chord_analysis . progression . is_empty () { Some (serde_json :: json ! (chord_analysis . progression)) } else { None } ; let duration_seconds = Some (midi_file . duration_seconds (120.0)) ; Ok (AnalysisResult { file_id : file . id , bpm , bpm_confidence : Some (bpm_result . confidence) , has_tempo_changes , detected_key : key_result . key , key_confidence : Some (key_result . confidence) , duration_seconds , chord_progression , chord_types : chord_analysis . types , has_seventh_chords : chord_analysis . has_sevenths , has_extended_chords : chord_analysis . has_extended , chord_change_rate : chord_analysis . change_rate , chord_complexity_score : Some (chord_analysis . complexity_score as f64) , }) }

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/optimized_analyzer.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/optimized_analyzer.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/optimized_analyzer.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/optimized_analyzer.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/optimized_analyzer.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/optimized_analyzer.rs`
  - Category: Performance

- [ ] **Function 'detect_bpm_from_onsets' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/simd_bpm.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Detects BPM from note onsets using SIMD-optimized velocity analysis"] # [doc = ""] # [doc = " This function analyzes note-on events to detect rhythmic patterns and calculate BPM."] # [doc = " It uses SIMD vectorization for fast velocity threshold checks."] # [doc = ""] # [doc = " # Arguments"] # [doc = " * `midi_file` - Parsed MIDI file structure"] # [doc = ""] # [doc = " # Returns"] # [doc = " * `Option<OnsetBpmResult>` - Detection result, or None if insufficient onsets found"] # [doc = ""] # [doc = " # Examples"] # [doc = " ```no_run"] # [doc = " use pipeline::core::analysis::simd_bpm::detect_bpm_from_onsets;"] # [doc = " use midi_library_shared::core::midi::types::MidiFile;"] # [doc = ""] # [doc = " # fn example(midi_file: MidiFile) -> Result<(), Box<dyn std::error::Error>> {"] # [doc = " if let Some(result) = detect_bpm_from_onsets(&midi_file) {"] # [doc = "     println!(\"Onset-based BPM: {:.2} (confidence: {:.2})\", result.bpm, result.confidence);"] # [doc = " }"] # [doc = " # Ok(())"] # [doc = " # }"] # [doc = " ```"] pub fn detect_bpm_from_onsets (midi_file : & MidiFile) -> Option < OnsetBpmResult > { let onsets = extract_onsets_simd (midi_file) ; if onsets . len () < 8 { return None ; } let iois = calculate_inter_onset_intervals (& onsets) ; if iois . is_empty () { return None ; } let avg_ioi = calculate_mean (& iois) ; let std_dev = calculate_std_dev (& iois , avg_ioi) ; let ticks_per_quarter = midi_file . header . ticks_per_quarter_note as f64 ; let bpm = ticks_to_bpm (avg_ioi , ticks_per_quarter) ; let confidence = calculate_ioi_confidence (& iois , avg_ioi , std_dev) ; let bpm = bpm . clamp (MIN_BPM , MAX_BPM) ; Some (OnsetBpmResult { bpm , confidence , onset_count : onsets . len () , avg_ioi_ticks : avg_ioi , ioi_std_dev : std_dev , }) }

- [ ] **Function 'extract_onsets_simd' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/simd_bpm.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Extracts onsets from MIDI file using SIMD-optimized velocity processing"] # [doc = ""] # [doc = " This function processes note-on events and uses compiler auto-vectorization"] # [doc = " hints to optimize velocity threshold checks."] # [doc = ""] # [doc = " # Arguments"] # [doc = " * `midi_file` - Parsed MIDI file structure"] # [doc = ""] # [doc = " # Returns"] # [doc = " * `Vec<Onset>` - List of detected onsets sorted by tick position"] pub fn extract_onsets_simd (midi_file : & MidiFile) -> Vec < Onset > { let mut onsets = Vec :: new () ; for track in & midi_file . tracks { let mut current_tick = 0u32 ; for timed_event in & track . events { current_tick = current_tick . saturating_add (timed_event . delta_ticks) ; if let Event :: NoteOn { channel , velocity , .. } = timed_event . event { if velocity >= ONSET_THRESHOLD { onsets . push (Onset { tick : current_tick , velocity , channel }) ; } } } } onsets . sort_by_key (| onset | onset . tick) ; onsets }

- [ ] **Function 'calculate_inter_onset_intervals' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/simd_bpm.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Calculates inter-onset intervals (IOIs) from a list of onsets"] # [doc = ""] # [doc = " IOIs represent the time difference between consecutive onsets,"] # [doc = " which form the basis for rhythmic pattern analysis."] # [doc = ""] # [doc = " # Arguments"] # [doc = " * `onsets` - Sorted list of onsets by tick position"] # [doc = ""] # [doc = " # Returns"] # [doc = " * `Vec<f64>` - List of IOIs in ticks, filtered by minimum threshold"] fn calculate_inter_onset_intervals (onsets : & [Onset]) -> Vec < f64 > { let mut iois = Vec :: with_capacity (onsets . len () . saturating_sub (1)) ; for window in onsets . windows (2) { let ioi = window [1] . tick . saturating_sub (window [0] . tick) ; if ioi >= MIN_IOI_TICKS { iois . push (ioi as f64) ; } } iois }

- [ ] **Function 'ticks_to_bpm' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/simd_bpm.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Converts average inter-onset interval to BPM"] # [doc = ""] # [doc = " # Arguments"] # [doc = " * `avg_ioi_ticks` - Average inter-onset interval in ticks"] # [doc = " * `ticks_per_quarter` - MIDI file ticks per quarter note"] # [doc = ""] # [doc = " # Returns"] # [doc = " * `f64` - Calculated BPM"] fn ticks_to_bpm (avg_ioi_ticks : f64 , ticks_per_quarter : f64) -> f64 { if avg_ioi_ticks <= 0.0 || ticks_per_quarter <= 0.0 { return 120.0 ; } let beats_per_tick = ticks_per_quarter / avg_ioi_ticks ; beats_per_tick * 60.0 }

- [ ] **Function 'calculate_ioi_confidence' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/simd_bpm.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Calculates confidence score based on IOI consistency"] # [doc = ""] # [doc = " Higher consistency (lower coefficient of variation) yields higher confidence."] # [doc = ""] # [doc = " # Arguments"] # [doc = " * `iois` - List of inter-onset intervals"] # [doc = " * `mean` - Mean IOI value"] # [doc = " * `std_dev` - Standard deviation of IOIs"] # [doc = ""] # [doc = " # Returns"] # [doc = " * `f64` - Confidence score (0.0 to 1.0)"] fn calculate_ioi_confidence (iois : & [f64] , mean : f64 , std_dev : f64) -> f64 { if iois . is_empty () || mean <= 0.0 { return 0.0 ; } let cv = std_dev / mean ; (1.0 - cv . min (1.0)) . max (0.3) }

- [ ] **Function 'calculate_mean' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/simd_bpm.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Calculates mean of a slice of f64 values"] fn calculate_mean (values : & [f64]) -> f64 { if values . is_empty () { return 0.0 ; } let sum : f64 = values . iter () . sum () ; sum / values . len () as f64 }

- [ ] **Function 'calculate_std_dev' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/simd_bpm.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Calculates standard deviation of a slice of f64 values"] fn calculate_std_dev (values : & [f64] , mean : f64) -> f64 { if values . is_empty () { return 0.0 ; } let variance : f64 = values . iter () . map (| & v | (v - mean) . powi (2)) . sum :: < f64 > () / values . len () as f64 ; variance . sqrt () }

- [ ] **Function 'batch_detect_onsets_simd' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/simd_bpm.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " SIMD-accelerated batch onset detection for multiple MIDI files"] # [doc = ""] # [doc = " Processes velocity arrays in parallel using compiler vectorization,"] # [doc = " optimized for batch operations."] # [doc = ""] # [doc = " # Arguments"] # [doc = " * `velocity_arrays` - Vector of velocity arrays from different MIDI files"] # [doc = ""] # [doc = " # Returns"] # [doc = " * `Vec<Vec<usize>>` - Onset indices for each input array"] pub fn batch_detect_onsets_simd (velocity_arrays : & [Vec < u8 >]) -> Vec < Vec < usize > > { velocity_arrays . iter () . map (| vels | detect_onsets_simd_vectorized (vels)) . collect () }

- [ ] **Function 'create_test_midi_file' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/simd_bpm.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn create_test_midi_file (note_ticks : Vec < (u32 , u8) >) -> MidiFile { let mut events = Vec :: new () ; for (tick , velocity) in note_ticks { events . push (TimedEvent { delta_ticks : tick , event : Event :: NoteOn { channel : 0 , note : 60 , velocity } , }) ; } MidiFile { header : Header { format : 1 , num_tracks : 1 , ticks_per_quarter_note : 480 } , tracks : vec ! [Track { events }] , } }

- [ ] **Function 'calculate_content_hash' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/hash/blake3.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Calculate BLAKE3 hash of byte content."] # [doc = ""] # [doc = " This is a **pure function** with no side effects (TRUSTY MODULE pattern)."] # [doc = ""] # [doc = " # Arguments"] # [doc = ""] # [doc = " * `data` - Byte slice to hash"] # [doc = ""] # [doc = " # Returns"] # [doc = ""] # [doc = " 32-byte BLAKE3 hash"] # [doc = ""] # [doc = " # Performance"] # [doc = ""] # [doc = " - Single-threaded: ~3,000 MB/s"] # [doc = " - For data larger than 128 KB, BLAKE3 automatically uses parallel tree hashing"] # [doc = " - Significantly faster than SHA-256 (~400 MB/s)"] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " ```rust"] # [doc = " use pipeline::core::hash::blake3::calculate_content_hash;"] # [doc = ""] # [doc = " let data = b\"MIDI file content\";"] # [doc = " let hash = calculate_content_hash(data);"] # [doc = " assert_eq!(hash.len(), 32);"] # [doc = " ```"] pub fn calculate_content_hash (data : & [u8]) -> [u8 ; 32] { blake3 :: hash (data) . into () }

- [ ] **Function 'calculate_file_hash' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/hash/blake3.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Calculate BLAKE3 hash of a file."] # [doc = ""] # [doc = " This is a **convenience wrapper** that performs file I/O."] # [doc = " For pure hashing logic, use `calculate_content_hash()`."] # [doc = ""] # [doc = " # Arguments"] # [doc = ""] # [doc = " * `path` - Path to file to hash"] # [doc = ""] # [doc = " # Returns"] # [doc = ""] # [doc = " 32-byte BLAKE3 hash or error if file cannot be read"] # [doc = ""] # [doc = " # Errors"] # [doc = ""] # [doc = " - `HashError::IoError` - File cannot be opened or read"] # [doc = " - `HashError::InvalidPath` - Path is invalid or does not exist"] # [doc = ""] # [doc = " # Performance"] # [doc = ""] # [doc = " For large files (>10 MB), consider using memory-mapped files for better performance."] # [doc = " This implementation reads the file into memory, which is optimal for files <100 MB."] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " ```rust,no_run"] # [doc = " use std::path::Path;"] # [doc = " use pipeline::core::hash::blake3::calculate_file_hash;"] # [doc = ""] # [doc = " let path = Path::new(\"test.mid\");"] # [doc = " let hash = calculate_file_hash(path)?;"] # [doc = " # Ok::<(), Box<dyn std::error::Error>>(())"] # [doc = " ```"] pub fn calculate_file_hash (path : & Path) -> Result < [u8 ; 32] > { if ! path . exists () { return Err (HashError :: InvalidPath (format ! ("File does not exist: {}" , path . display ()))) ; } if ! path . is_file () { return Err (HashError :: InvalidPath (format ! ("Path is not a file: {}" , path . display ()))) ; } let mut file = File :: open (path) ? ; let mut buffer = Vec :: new () ; file . read_to_end (& mut buffer) ? ; Ok (calculate_content_hash (& buffer)) }

- [ ] **Function 'hash_to_hex' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/hash/blake3.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Convert 32-byte hash to hexadecimal string."] # [doc = ""] # [doc = " This is a **pure function** with no side effects (TRUSTY MODULE pattern)."] # [doc = ""] # [doc = " # Arguments"] # [doc = ""] # [doc = " * `hash` - 32-byte hash to convert"] # [doc = ""] # [doc = " # Returns"] # [doc = ""] # [doc = " 64-character lowercase hexadecimal string"] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " ```rust"] # [doc = " use pipeline::core::hash::blake3::{calculate_content_hash, hash_to_hex};"] # [doc = ""] # [doc = " let data = b\"test\";"] # [doc = " let hash = calculate_content_hash(data);"] # [doc = " let hex = hash_to_hex(&hash);"] # [doc = ""] # [doc = " assert_eq!(hex.len(), 64); // 32 bytes = 64 hex characters"] # [doc = " assert!(hex.chars().all(|c| c.is_ascii_hexdigit()));"] # [doc = " ```"] pub fn hash_to_hex (hash : & [u8 ; 32]) -> String { blake3 :: Hash :: from (* hash) . to_hex () . to_string () }

- [ ] **Function 'hex_to_hash' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/hash/blake3.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Convert hexadecimal string back to 32-byte hash."] # [doc = ""] # [doc = " This is a **pure function** with no side effects (TRUSTY MODULE pattern)."] # [doc = ""] # [doc = " # Arguments"] # [doc = ""] # [doc = " * `hex` - 64-character hexadecimal string"] # [doc = ""] # [doc = " # Returns"] # [doc = ""] # [doc = " 32-byte hash or error if hex string is invalid"] # [doc = ""] # [doc = " # Errors"] # [doc = ""] # [doc = " Returns error if:"] # [doc = " - String is not exactly 64 characters"] # [doc = " - String contains non-hexadecimal characters"] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " ```rust"] # [doc = " use pipeline::core::hash::blake3::{hash_to_hex, hex_to_hash};"] # [doc = ""] # [doc = " let original = [0u8; 32];"] # [doc = " let hex = hash_to_hex(&original);"] # [doc = " let decoded = hex_to_hash(&hex)?;"] # [doc = " assert_eq!(original, decoded);"] # [doc = " # Ok::<(), Box<dyn std::error::Error>>(())"] # [doc = " ```"] pub fn hex_to_hash (hex : & str) -> Result < [u8 ; 32] > { if hex . len () != 64 { return Err (HashError :: InvalidPath (format ! ("Hex string must be exactly 64 characters, got {}" , hex . len ()))) ; } let mut hash = [0u8 ; 32] ; for i in 0 .. 32 { let byte_str = & hex [i * 2 .. i * 2 + 2] ; hash [i] = u8 :: from_str_radix (byte_str , 16) . map_err (| _ | { HashError :: InvalidPath (format ! ("Invalid hex character in string: {}" , byte_str)) }) ? ; } Ok (hash) }

- [ ] **Function 'generate_filename' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/naming/generator.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Generates a new filename from metadata"] # [doc = ""] # [doc = " # Arguments"] # [doc = " * `metadata` - File metadata"] # [doc = " * `config` - Naming configuration"] # [doc = ""] # [doc = " # Returns"] # [doc = " * Generated filename with .mid extension"] # [doc = ""] # [doc = " # Examples"] # [doc = " ```"] # [doc = " use pipeline::core::naming::generator::*;"] # [doc = ""] # [doc = " let metadata = FileMetadata {"] # [doc = "     category: \"BASS\".to_string(),"] # [doc = "     bpm: 140.0,"] # [doc = "     key: \"Cm\".to_string(),"] # [doc = "     description: Some(\"Deep Rolling\".to_string()),"] # [doc = "     file_id: \"001\".to_string(),"] # [doc = " };"] # [doc = ""] # [doc = " let filename = generate_filename(&metadata, &NamingConfig::default());"] # [doc = " // Result: \"BASS_Cm_140BPM_Deep_Rolling_001.mid\""] # [doc = " ```"] pub fn generate_filename (metadata : & FileMetadata , config : & NamingConfig) -> String { let category = sanitizer :: sanitize_filename (& metadata . category . to_uppercase ()) ; let key = sanitizer :: sanitize_filename (& metadata . key) ; let description = if config . include_description { process_description (& metadata . description , config . max_description_length) } else { String :: new () } ; let filename_base = templates :: apply_template (& config . template , & category , & key , metadata . bpm , & description , & metadata . file_id ,) ; let sanitized = sanitizer :: sanitize_filename (& filename_base) ; sanitizer :: ensure_mid_extension (& sanitized) }

- [ ] **Function 'process_description' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/naming/generator.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Processes description text"] fn process_description (description : & Option < String > , max_length : usize) -> String { match description { None => String :: new () , Some (desc) => { let sanitized = sanitizer :: sanitize_filename (desc) ; let cleaned = sanitizer :: clean_description (& sanitized) ; if cleaned . len () > max_length { cleaned [.. max_length] . to_string () } else { cleaned } } , } }

- [ ] **Function 'generate_from_analysis' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/naming/generator.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Generates filename from analysis results (convenience function)"] # [doc = ""] # [doc = " # Arguments"] # [doc = " * `category` - File category (BASS, KICK, etc.)"] # [doc = " * `bpm_result` - BPM detection result"] # [doc = " * `key_result` - Key detection result"] # [doc = " * `original_filename` - Original filename to extract description from"] # [doc = " * `file_id` - Unique file identifier"] # [doc = " * `config` - Naming configuration"] # [doc = ""] # [doc = " # Returns"] # [doc = " * Generated filename with .mid extension"] pub fn generate_from_analysis (category : & str , bpm_result : & BpmDetectionResult , key_result : & KeyDetectionResult , original_filename : & str , file_id : & str , config : & NamingConfig ,) -> String { let description = extract_useful_description (original_filename) ; let metadata = FileMetadata { category : category . to_string () , bpm : bpm_result . bpm , key : key_result . key . clone () , description , file_id : file_id . to_string () , } ; generate_filename (& metadata , config) }

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/naming/generator.rs`
  - Category: Performance

- [ ] **Function 'generate_production_filename' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/naming/generator.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Generates production filename with pack name and original filename"] # [doc = ""] # [doc = " # Arguments"] # [doc = " * `category` - File category"] # [doc = " * `bpm` - Beats per minute"] # [doc = " * `key` - Musical key"] # [doc = " * `file_id` - Zero-padded file ID (e.g., \"000001\")"] # [doc = " * `timesig` - Time signature (e.g., \"4-4\", \"6-8\")"] # [doc = " * `pack_name` - Name of the pack/folder"] # [doc = " * `original_name` - Original filename (cleaned)"] # [doc = ""] # [doc = " # Returns"] # [doc = " * Formatted filename: {CATEGORY}_{TIMESIG}_{BPM}BPM_{KEY}_{ID}_{PACK}_{ORIGINAL}.mid"] # [doc = ""] # [doc = " # Examples"] # [doc = " ```"] # [doc = " use pipeline::core::naming::generator::generate_production_filename;"] # [doc = ""] # [doc = " let filename = generate_production_filename("] # [doc = "     \"KICK\","] # [doc = "     120.0,"] # [doc = "     \"C\","] # [doc = "     \"000001\","] # [doc = "     \"4-4\","] # [doc = "     \"DrumPack2024\","] # [doc = "     \"Heavy_Boom\""] # [doc = " );"] # [doc = " assert_eq!(filename, \"KICK_4-4_120BPM_C_000001_DrumPack2024_Heavy_Boom.mid\");"] # [doc = " ```"] pub fn generate_production_filename (category : & str , bpm : f64 , key : & str , file_id : & str , timesig : & str , pack_name : & str , original_name : & str ,) -> String { let sanitized_category = sanitizer :: sanitize_filename (& category . to_uppercase ()) ; let sanitized_key = sanitizer :: sanitize_filename (key) ; let sanitized_pack = sanitizer :: sanitize_filename (pack_name) ; let sanitized_original = sanitizer :: sanitize_filename (original_name) ; let filename_base = templates :: apply_template_extended (& templates :: NamingTemplate :: Production , & sanitized_category , & sanitized_key , bpm , "" , file_id , Some (timesig) , Some (& sanitized_pack) , Some (& sanitized_original) , None ,) ; sanitizer :: ensure_mid_extension (& filename_base) }

- [ ] **Function 'generate_production_layer_filename' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/naming/generator.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Generates production filename for split/layer files"] # [doc = ""] # [doc = " # Arguments"] # [doc = " * `category` - File category"] # [doc = " * `bpm` - Beats per minute"] # [doc = " * `key` - Musical key"] # [doc = " * `file_id` - Zero-padded file ID"] # [doc = " * `timesig` - Time signature"] # [doc = " * `pack_name` - Name of the pack/folder"] # [doc = " * `layer_name` - Name of the layer (e.g., \"OpenHat\", \"ClosedHat\")"] # [doc = " * `layer_number` - Layer number (1-based)"] # [doc = ""] # [doc = " # Returns"] # [doc = " * Formatted filename: {CATEGORY}_{TIMESIG}_{BPM}BPM_{KEY}_{ID}_{PACK}_{LAYER}_L{NUM}.mid"] # [doc = ""] # [doc = " # Examples"] # [doc = " ```"] # [doc = " use pipeline::core::naming::generator::generate_production_layer_filename;"] # [doc = ""] # [doc = " let filename = generate_production_layer_filename("] # [doc = "     \"HIHAT\","] # [doc = "     140.0,"] # [doc = "     \"Am\","] # [doc = "     \"000123\","] # [doc = "     \"6-8\","] # [doc = "     \"VintageDrums\","] # [doc = "     \"OpenHat\","] # [doc = "     1"] # [doc = " );"] # [doc = " assert_eq!(filename, \"HIHAT_6-8_140BPM_Am_000123_VintageDrums_OpenHat_L01.mid\");"] # [doc = " ```"] pub fn generate_production_layer_filename (category : & str , bpm : f64 , key : & str , file_id : & str , timesig : & str , pack_name : & str , layer_name : & str , layer_number : usize ,) -> String { let sanitized_category = sanitizer :: sanitize_filename (& category . to_uppercase ()) ; let sanitized_key = sanitizer :: sanitize_filename (key) ; let sanitized_pack = sanitizer :: sanitize_filename (pack_name) ; let sanitized_layer = sanitizer :: sanitize_filename (layer_name) ; let filename_base = templates :: apply_template_extended (& templates :: NamingTemplate :: Production , & sanitized_category , & sanitized_key , bpm , "" , file_id , Some (timesig) , Some (& sanitized_pack) , None , Some ((& sanitized_layer , layer_number)) ,) ; sanitizer :: ensure_mid_extension (& filename_base) }

- [ ] **Function 'extract_useful_description' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/naming/generator.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Extracts useful parts from original filename"] fn extract_useful_description (original_filename : & str) -> Option < String > { let without_ext = original_filename . trim_end_matches (".mid") . trim_end_matches (".MID") ; let prefixes = ["MIDI_" , "Track_" , "File_" , "Song_"] ; let mut cleaned = without_ext . to_string () ; for prefix in & prefixes { if cleaned . starts_with (prefix) { cleaned = cleaned [prefix . len () ..] . to_string () ; } } if ! cleaned . is_empty () && cleaned . len () > 3 { Some (cleaned) } else { None } }

- [ ] **Function 'resolve_naming_conflict' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/naming/generator.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Handles naming conflicts by appending counter"] # [doc = ""] # [doc = " # Arguments"] # [doc = " * `base_filename` - The desired filename"] # [doc = " * `existing_files` - List of existing filenames to check against"] # [doc = ""] # [doc = " # Returns"] # [doc = " * Unique filename that doesn't conflict with existing files"] pub fn resolve_naming_conflict (base_filename : & str , existing_files : & [String]) -> String { let without_ext = base_filename . trim_end_matches (".mid") ; if ! existing_files . contains (& base_filename . to_string ()) { return base_filename . to_string () ; } for i in 1 .. 1000 { let candidate = format ! ("{}_v{}.mid" , without_ext , i) ; if ! existing_files . contains (& candidate) { return candidate ; } } let timestamp = std :: time :: SystemTime :: now () . duration_since (std :: time :: UNIX_EPOCH) . unwrap_or_else (| _ | std :: time :: Duration :: from_secs (0)) . as_secs () ; format ! ("{}_{}.mid" , without_ext , timestamp) }

- [ ] **Function 'sanitize_filename' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/naming/sanitizer.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Filename Sanitization"] # [doc = ""] # [doc = " Ensures filenames are valid across all operating systems."] # [doc = " Sanitizes a string for use in filenames"] # [doc = ""] # [doc = " # Rules"] # [doc = " - Removes/replaces invalid characters"] # [doc = " - Limits length to 255 characters"] # [doc = " - Removes leading/trailing spaces"] # [doc = " - Converts to ASCII where possible"] # [doc = ""] # [doc = " # Arguments"] # [doc = " * `input` - String to sanitize"] # [doc = ""] # [doc = " # Returns"] # [doc = " * Sanitized string safe for filenames"] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " ```"] # [doc = " use pipeline::core::naming::sanitizer::sanitize_filename;"] # [doc = ""] # [doc = " let sanitized = sanitize_filename(\"my file<name>\");"] # [doc = " assert_eq!(sanitized, \"my_file_name_\");"] # [doc = " ```"] pub fn sanitize_filename (input : & str) -> String { let mut sanitized = input . to_string () ; sanitized = sanitized . chars () . map (| c | match c { '<' | '>' | ':' | '"' | '/' | '\\' | '|' | '?' | '*' => '_' , c if c . is_control () => '_' , c => c , }) . collect () ; sanitized = sanitized . trim () . to_string () ; while sanitized . contains ("  ") { sanitized = sanitized . replace ("  " , " ") ; } sanitized = sanitized . replace (' ' , "_") ; while sanitized . contains ("__") { sanitized = sanitized . replace ("__" , "_") ; } if sanitized . len () > 250 { sanitized . truncate (250) ; } sanitized = sanitized . trim_matches ('_') . to_string () ; if sanitized . is_empty () { sanitized = "untitled" . to_string () ; } sanitized }

- [ ] **Function 'clean_description' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/naming/sanitizer.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Removes common filler words from descriptions"] # [doc = ""] # [doc = " # Arguments"] # [doc = " * `description` - Description text to clean"] # [doc = ""] # [doc = " # Returns"] # [doc = " * Description with filler words removed"] pub fn clean_description (description : & str) -> String { let filler_words = ["untitled" , "new" , "midi" , "file" , "song" , "track" , "the" , "a" , "an" , "and" , "or" , "but" ,] ; let words : Vec < & str > = description . split ('_') . filter (| word | { let lower = word . to_lowercase () ; ! filler_words . contains (& lower . as_str ()) && ! lower . is_empty () }) . collect () ; words . join ("_") }

- [ ] **Function 'ensure_mid_extension' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/naming/sanitizer.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Ensures filename has .mid extension (converts .midi to .mid)"] # [doc = ""] # [doc = " # Arguments"] # [doc = " * `filename` - Filename to check"] # [doc = ""] # [doc = " # Returns"] # [doc = " * Filename with .mid extension"] pub fn ensure_mid_extension (filename : & str) -> String { if filename . to_lowercase () . ends_with (".mid") { filename . to_string () } else if filename . to_lowercase () . ends_with (".midi") { let stem = & filename [.. filename . len () - 5] ; format ! ("{}.mid" , stem) } else { format ! ("{}.mid" , filename) } }

- [ ] **Function 'sanitize_strict' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/naming/sanitizer.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Phase 0 Sanitization: Strict filename cleaning for post-extraction"] # [doc = ""] # [doc = " This is the FIRST renaming phase, applied immediately after archive extraction."] # [doc = " Rules:"] # [doc = " - Replace spaces with underscores"] # [doc = " - Convert .midi to .mid"] # [doc = " - Convert .MID to .mid (force lowercase)"] # [doc = " - Keep ONLY: letters, numbers, underscores, hyphens"] # [doc = " - Remove all other special characters"] # [doc = ""] # [doc = " # Arguments"] # [doc = " * `filename` - Original filename from archive"] # [doc = ""] # [doc = " # Returns"] # [doc = " * Sanitized filename safe for filesystem operations"] # [doc = ""] # [doc = " # Examples"] # [doc = " ```"] # [doc = " use pipeline::core::naming::sanitizer::sanitize_strict;"] # [doc = ""] # [doc = " assert_eq!(sanitize_strict(\"My Song (2023).midi\"), \"My_Song_2023.mid\");"] # [doc = " assert_eq!(sanitize_strict(\"My Song (2023).MID\"), \"My_Song_2023.mid\");"] # [doc = " assert_eq!(sanitize_strict(\"bass & lead!.mid\"), \"bass_lead.mid\");"] # [doc = " assert_eq!(sanitize_strict(\"file#1@test.mid\"), \"file1test.mid\");"] # [doc = " ```"] pub fn sanitize_strict (filename : & str) -> String { let (name , ext) = if let Some (pos) = filename . rfind ('.') { (& filename [.. pos] , & filename [pos ..]) } else { (filename , "") } ; let mut sanitized = name . replace (' ' , "_") ; sanitized = sanitized . chars () . filter (| c | c . is_alphanumeric () || * c == '_' || * c == '-' || * c == '.') . collect () ; loop { let before = sanitized . clone () ; sanitized = sanitized . replace ("__" , "_") ; sanitized = sanitized . replace ("--" , "-") ; sanitized = sanitized . replace (".." , ".") ; sanitized = sanitized . replace ("_-" , "_") ; sanitized = sanitized . replace ("-_" , "_") ; sanitized = sanitized . replace ("_." , "_") ; sanitized = sanitized . replace ("._" , "_") ; sanitized = sanitized . replace ("-." , "-") ; sanitized = sanitized . replace (".-" , "-") ; if before == sanitized { break ; } } sanitized = sanitized . trim_matches (| c | c == '_' || c == '-') . to_string () ; if sanitized . len () > 250 { sanitized . truncate (250) ; sanitized = sanitized . trim_matches (| c | c == '_' || c == '-') . to_string () ; } if sanitized . is_empty () { sanitized = "untitled" . to_string () ; } let final_ext = if ext . to_lowercase () == ".midi" || ext . to_lowercase () == ".mid" { ".mid" } else if ! ext . is_empty () { ext } else { ".mid" } ; format ! ("{}{}" , sanitized , final_ext) }

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/naming/sanitizer.rs`
  - Category: Performance

- [ ] **Function 'apply_template' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/naming/templates.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Applies template to metadata"] # [doc = ""] # [doc = " # Arguments"] # [doc = " * `template` - The naming template to use"] # [doc = " * `category` - File category (e.g., BASS, KICK, CHORD)"] # [doc = " * `key` - Musical key (e.g., C, Am, F#)"] # [doc = " * `bpm` - Beats per minute"] # [doc = " * `description` - Optional description text"] # [doc = " * `id` - File identifier"] # [doc = ""] # [doc = " # Returns"] # [doc = " * Formatted filename string (without extension)"] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " ```"] # [doc = " use pipeline::core::naming::templates::{NamingTemplate, apply_template};"] # [doc = ""] # [doc = " let result = apply_template("] # [doc = "     &NamingTemplate::Standard,"] # [doc = "     \"BASS\","] # [doc = "     \"Cm\","] # [doc = "     140.0,"] # [doc = "     \"Deep_Rolling\","] # [doc = "     \"001\""] # [doc = " );"] # [doc = " assert_eq!(result, \"BASS_Cm_140BPM_Deep_Rolling_001\");"] # [doc = " ```"] pub fn apply_template (template : & NamingTemplate , category : & str , key : & str , bpm : f64 , description : & str , id : & str ,) -> String { apply_template_extended (template , category , key , bpm , description , id , None , None , None , None ,) }

- [ ] **Function 'apply_template_extended' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/naming/templates.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Extended template application with additional metadata"] # [doc = ""] # [doc = " # Arguments"] # [doc = " * `template` - The naming template to use"] # [doc = " * `category` - File category"] # [doc = " * `key` - Musical key"] # [doc = " * `bpm` - Beats per minute"] # [doc = " * `description` - Optional description"] # [doc = " * `id` - File identifier"] # [doc = " * `timesig` - Optional time signature (e.g., \"4-4\", \"6-8\")"] # [doc = " * `pack` - Optional pack/folder name"] # [doc = " * `original` - Optional original filename"] # [doc = " * `layer_info` - Optional (layer_name, layer_number) for split files"] # [doc = ""] # [doc = " # Returns"] # [doc = " * Formatted filename string (without extension)"] pub fn apply_template_extended (template : & NamingTemplate , category : & str , key : & str , bpm : f64 , description : & str , id : & str , timesig : Option < & str > , pack : Option < & str > , original : Option < & str > , layer_info : Option < (& str , usize) > ,) -> String { match template { NamingTemplate :: Standard => { format ! ("{}_{}_{:.0}BPM_{}_{}" , category , key , bpm , description , id) } , NamingTemplate :: Compact => { format ! ("{}_{}_{:.0}BPM_{}" , category , key , bpm , id) } , NamingTemplate :: BpmFirst => { format ! ("{:.0}BPM_{}_{}_{}" , bpm , key , category , description) } , NamingTemplate :: Production => { let timesig_str = timesig . unwrap_or ("4-4") ; let pack_str = pack . unwrap_or ("Unknown") ; let mut result = format ! ("{}_{}_{:.0}BPM_{}_{}_{}" , category , timesig_str , bpm , key , id , pack_str) ; if let Some ((layer_name , layer_num)) = layer_info { result . push_str (& format ! ("_{}_L{:02}" , layer_name , layer_num)) ; } else if let Some (orig) = original { result . push_str (& format ! ("_{}" , orig)) ; } result } , NamingTemplate :: Custom (template_str) => template_str . replace ("{CATEGORY}" , category) . replace ("{KEY}" , key) . replace ("{BPM}" , & format ! ("{:.0}" , bpm)) . replace ("{DESCRIPTION}" , description) . replace ("{ID}" , id) . replace ("{TIMESIG}" , timesig . unwrap_or ("4-4")) . replace ("{PACK}" , pack . unwrap_or ("Unknown")) . replace ("{ORIGINAL}" , original . unwrap_or ("")) , } }

- [ ] **Function 'sanitize_mpc_compatible' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/normalization/filename.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Sanitize filename to MPC-compatible characters only"] # [doc = ""] # [doc = " MPC ONE/Live/X allowed characters:"] # [doc = " - Letters: A-Z, a-z"] # [doc = " - Numbers: 0-9"] # [doc = " - Hyphens: -"] # [doc = " - Underscores: _"] # [doc = " - Periods: . (for extension only)"] # [doc = ""] # [doc = " All other characters (parentheses, brackets, symbols, etc.) are replaced with underscores"] fn sanitize_mpc_compatible (s : & str) -> String { s . chars () . map (| c | { if c . is_ascii_alphanumeric () || c == '-' || c == '_' || c == '.' { c } else { '_' } }) . collect () }

- [ ] **Function 'normalize_file' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/normalization/filename.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Normalize a single MIDI file on disk"] fn normalize_file (path : & Path , stats : & NormalizationStats ,) -> Result < () , Box < dyn std :: error :: Error > > { let parent = path . parent () . ok_or ("No parent directory") ? ; let filename = path . file_name () . ok_or ("No filename") ? . to_string_lossy () ; let mut new_filename = filename . to_string () ; let mut changed = false ; let lowercase = filename . to_lowercase () ; if filename . ends_with (".MIDI") { new_filename = filename [.. filename . len () - 5] . to_string () + ".mid" ; changed = true ; stats . extensions_fixed . fetch_add (1 , Ordering :: Relaxed) ; } else if filename . ends_with (".MID") && ! lowercase . ends_with (".mid") { new_filename = filename [.. filename . len () - 4] . to_string () + ".mid" ; changed = true ; stats . extensions_fixed . fetch_add (1 , Ordering :: Relaxed) ; } else if filename . ends_with (".midi") && filename != lowercase { new_filename = filename [.. filename . len () - 5] . to_string () + ".mid" ; changed = true ; stats . extensions_fixed . fetch_add (1 , Ordering :: Relaxed) ; } else if filename . ends_with (".MiD") || filename . ends_with (".Midi") { let stem_len = if filename . ends_with (".MiD") { 4 } else { 5 } ; new_filename = filename [.. filename . len () - stem_len] . to_string () + ".mid" ; changed = true ; stats . extensions_fixed . fetch_add (1 , Ordering :: Relaxed) ; } if new_filename . contains (' ') { new_filename = new_filename . replace (' ' , "_") ; changed = true ; stats . spaces_fixed . fetch_add (1 , Ordering :: Relaxed) ; } let sanitized = sanitize_mpc_compatible (& new_filename) ; if sanitized != new_filename { new_filename = sanitized ; changed = true ; stats . encoding_fixed . fetch_add (1 , Ordering :: Relaxed) ; } if changed { let mut final_path = parent . join (& new_filename) ; let mut counter = 1 ; while final_path . exists () && final_path != path { let stem = Path :: new (& new_filename) . file_stem () . unwrap () . to_string_lossy () ; let ext = Path :: new (& new_filename) . extension () . map (| e | e . to_string_lossy ()) . unwrap_or_default () ; final_path = parent . join (format ! ("{}_{}.{}" , stem , counter , ext)) ; counter += 1 ; } if final_path != path { fs :: rename (path , & final_path) ? ; } } stats . total_files . fetch_add (1 , Ordering :: Relaxed) ; Ok (()) }

- [ ] **Function 'normalize_directory' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/normalization/filename.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Normalize all MIDI files in a directory (recursive)"] # [doc = ""] # [doc = " # Arguments"] # [doc = " * `dir` - Directory to normalize"] # [doc = " * `workers` - Number of parallel workers (0 = auto-detect CPU cores)"] # [doc = ""] # [doc = " # Returns"] # [doc = " * `NormalizationStats` - Statistics about the normalization"] pub fn normalize_directory (dir : & Path , workers : usize ,) -> Result < NormalizationStats , Box < dyn std :: error :: Error > > { if workers > 0 { rayon :: ThreadPoolBuilder :: new () . num_threads (workers) . build_global () . ok () ; } let stats = NormalizationStats :: default () ; let files : Vec < PathBuf > = WalkDir :: new (dir) . follow_links (false) . into_iter () . filter_map (| e | e . ok ()) . filter (| e | e . file_type () . is_file ()) . filter (| e | { let name = e . file_name () . to_string_lossy () . to_lowercase () ; name . ends_with (".mid") || name . ends_with (".midi") }) . map (| e | e . path () . to_path_buf ()) . collect () ; files . par_iter () . for_each (| path | { if let Err (e) = normalize_file (path , & stats) { eprintln ! ("  âš ï¸  Error normalizing {:?}: {}" , path , e) ; stats . errors . fetch_add (1 , Ordering :: Relaxed) ; } }) ; Ok (stats) }

- [ ] **Function 'detect_system_resources' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/performance/concurrency.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Automatically detect system resources."] # [doc = ""] # [doc = " This function queries the operating system to determine:"] # [doc = " - CPU core count (logical cores including hyperthreading)"] # [doc = " - Available system memory"] # [doc = " - Primary disk type (SSD vs HDD)"] # [doc = ""] # [doc = " # Returns"] # [doc = ""] # [doc = " A `SystemResources` struct with detected values."] # [doc = ""] # [doc = " # Fallback Behavior"] # [doc = ""] # [doc = " If detection fails:"] # [doc = " - CPU cores: Falls back to 4"] # [doc = " - Memory: Falls back to 8.0 GB"] # [doc = " - SSD: Assumes true (conservative for performance)"] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " ```"] # [doc = " use pipeline::core::performance::concurrency::detect_system_resources;"] # [doc = ""] # [doc = " let resources = detect_system_resources();"] # [doc = " println!(\"Detected {} CPU cores\", resources.cpu_cores);"] # [doc = " println!(\"Available memory: {:.2} GB\", resources.available_memory_gb);"] # [doc = " println!(\"SSD: {}\", resources.is_ssd);"] # [doc = " ```"] pub fn detect_system_resources () -> SystemResources { let cpu_cores = thread :: available_parallelism () . map (| n | n . get ()) . unwrap_or (4) ; let sys = System :: new_all () ; let total_memory_bytes = sys . total_memory () ; let available_memory_gb = (total_memory_bytes as f64) / (1024.0 * 1024.0 * 1024.0) ; let is_ssd = true ; SystemResources { cpu_cores , available_memory_gb , is_ssd } }

- [ ] **Function 'calculate_optimal_concurrency' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/performance/concurrency.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Calculate the optimal concurrency limit based on system resources."] # [doc = ""] # [doc = " This function implements a multi-factor formula to determine the ideal"] # [doc = " number of concurrent file processing workers."] # [doc = ""] # [doc = " # Algorithm"] # [doc = ""] # [doc = " 1. Start with CPU-based baseline: `cpu_cores Ã— 2`"] # [doc = " 2. Apply memory constraints:"] # [doc = "    - If RAM < 4GB: divide by 4"] # [doc = "    - If RAM < 6GB: divide by 2"] # [doc = "    - If RAM >= 8GB: no reduction"] # [doc = " 3. Apply storage type cap:"] # [doc = "    - HDD: cap at 50"] # [doc = "    - SSD: cap at 100"] # [doc = " 4. Clamp to absolute bounds [10, 100]"] # [doc = ""] # [doc = " # Arguments"] # [doc = ""] # [doc = " * `resources` - System resource information"] # [doc = ""] # [doc = " # Returns"] # [doc = ""] # [doc = " Optimal concurrency limit (10-100)"] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " ```"] # [doc = " use pipeline::core::performance::concurrency::{SystemResources, calculate_optimal_concurrency};"] # [doc = ""] # [doc = " // High-end system: 16 cores, 32GB RAM, SSD"] # [doc = " let resources = SystemResources::new(16, 32.0, true);"] # [doc = " let concurrency = calculate_optimal_concurrency(&resources);"] # [doc = " assert_eq!(concurrency, 32); // 16 Ã— 2, no constraints"] # [doc = ""] # [doc = " // Low-end system: 4 cores, 4GB RAM, HDD"] # [doc = " let resources = SystemResources::new(4, 4.0, false);"] # [doc = " let concurrency = calculate_optimal_concurrency(&resources);"] # [doc = " assert_eq!(concurrency, 10); // Limited by memory and minimum bound"] # [doc = " ```"] pub fn calculate_optimal_concurrency (resources : & SystemResources) -> usize { let mut concurrency = resources . cpu_cores * 2 ; if resources . available_memory_gb < 4.0 { concurrency /= 4 ; } else if resources . available_memory_gb < 6.0 { concurrency /= 2 ; } let storage_cap = if resources . is_ssd { 100 } else { 50 } ; concurrency = concurrency . min (storage_cap) ; concurrency . clamp (10 , 100) }

- [ ] **Function 'calculate_database_pool_size' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/performance/concurrency.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Calculate the optimal database connection pool size."] # [doc = ""] # [doc = " The pool size should support concurrent operations plus some overhead"] # [doc = " for connection management and potential contention."] # [doc = ""] # [doc = " # Formula"] # [doc = ""] # [doc = " `pool_size = (concurrency Ã— 1.5).clamp(20, 200)`"] # [doc = ""] # [doc = " - 1.5Ã— multiplier: Provides headroom for connection recycling"] # [doc = " - Minimum 20: Ensures adequate connections even on small systems"] # [doc = " - Maximum 200: Prevents PostgreSQL connection exhaustion"] # [doc = ""] # [doc = " # Arguments"] # [doc = ""] # [doc = " * `concurrency` - Target concurrency limit"] # [doc = ""] # [doc = " # Returns"] # [doc = ""] # [doc = " Optimal database connection pool size (20-200)"] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " ```"] # [doc = " use pipeline::core::performance::concurrency::calculate_database_pool_size;"] # [doc = ""] # [doc = " let pool_size = calculate_database_pool_size(50);"] # [doc = " assert_eq!(pool_size, 75); // 50 Ã— 1.5"] # [doc = ""] # [doc = " let pool_size = calculate_database_pool_size(10);"] # [doc = " assert_eq!(pool_size, 20); // Clamped to minimum"] # [doc = ""] # [doc = " let pool_size = calculate_database_pool_size(150);"] # [doc = " assert_eq!(pool_size, 200); // Clamped to maximum"] # [doc = " ```"] pub fn calculate_database_pool_size (concurrency : usize) -> usize { let pool_size = (concurrency as f64 * 1.5) as usize ; pool_size . clamp (20 , 200) }

- [ ] **Function 'calculate_batch_size' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/performance/concurrency.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Calculate the optimal batch size for database operations."] # [doc = ""] # [doc = " Larger batches reduce transaction overhead but increase memory usage"] # [doc = " and potential lock contention. The optimal size balances these factors."] # [doc = ""] # [doc = " # Formula"] # [doc = ""] # [doc = " `batch_size = (concurrency Ã— 100).clamp(500, 10000)`"] # [doc = ""] # [doc = " - 100Ã— multiplier: Each worker can handle ~100 records per batch"] # [doc = " - Minimum 500: Ensures meaningful batch performance improvement"] # [doc = " - Maximum 10,000: Prevents excessive memory usage and lock duration"] # [doc = ""] # [doc = " # Arguments"] # [doc = ""] # [doc = " * `concurrency` - Target concurrency limit"] # [doc = ""] # [doc = " # Returns"] # [doc = ""] # [doc = " Optimal batch size for database inserts (500-10,000)"] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " ```"] # [doc = " use pipeline::core::performance::concurrency::calculate_batch_size;"] # [doc = ""] # [doc = " let batch_size = calculate_batch_size(50);"] # [doc = " assert_eq!(batch_size, 5000); // 50 Ã— 100"] # [doc = ""] # [doc = " let batch_size = calculate_batch_size(10);"] # [doc = " assert_eq!(batch_size, 1000); // 10 Ã— 100"] # [doc = ""] # [doc = " let batch_size = calculate_batch_size(150);"] # [doc = " assert_eq!(batch_size, 10000); // Clamped to maximum"] # [doc = " ```"] pub fn calculate_batch_size (concurrency : usize) -> usize { let batch_size = concurrency * 100 ; batch_size . clamp (500 , 10_000) }

- [ ] **Function 'calculate_all_settings' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/performance/concurrency.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Calculate all performance settings in one call."] # [doc = ""] # [doc = " This is a convenience function that calculates optimal concurrency,"] # [doc = " database pool size, and batch size based on detected system resources."] # [doc = ""] # [doc = " # Returns"] # [doc = ""] # [doc = " Tuple of (concurrency, pool_size, batch_size)"] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " ```"] # [doc = " use pipeline::core::performance::concurrency::calculate_all_settings;"] # [doc = ""] # [doc = " let (concurrency, pool_size, batch_size) = calculate_all_settings();"] # [doc = " println!(\"Concurrency: {}\", concurrency);"] # [doc = " println!(\"DB Pool: {}\", pool_size);"] # [doc = " println!(\"Batch Size: {}\", batch_size);"] # [doc = " ```"] pub fn calculate_all_settings () -> (usize , usize , usize) { let resources = detect_system_resources () ; let concurrency = calculate_optimal_concurrency (& resources) ; let pool_size = calculate_database_pool_size (concurrency) ; let batch_size = calculate_batch_size (concurrency) ; (concurrency , pool_size , batch_size) }

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/pipeline/orchestrator.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/pipeline/orchestrator.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/pipeline/orchestrator.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/pipeline/orchestrator.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/pipeline/orchestrator.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/pipeline/orchestrator.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/pipeline/orchestrator.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/pipeline/orchestrator.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/pipeline/orchestrator.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/pipeline/workers/analyze.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/pipeline/workers/export.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/pipeline/workers/export.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/pipeline/workers/export.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/pipeline/workers/import.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/pipeline/workers/import.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/pipeline/workers/import.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/pipeline/workers/import.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/pipeline/workers/rename.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/pipeline/workers/sanitize.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/pipeline/workers/sanitize.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/pipeline/workers/split.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/pipeline/workers/split.rs`
  - Category: Performance

- [ ] **Function 'split_tracks_with_repair' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/splitting/auto_repair.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Split tracks with automatic repair on failure."] # [doc = ""] # [doc = " This function attempts to split MIDI tracks, and if that fails due to"] # [doc = " corruption, it automatically attempts to repair the file and retry the split."] # [doc = ""] # [doc = " # Workflow"] # [doc = " 1. Try to split tracks normally"] # [doc = " 2. If split fails, attempt to repair the file"] # [doc = " 3. If repair succeeds, retry the split operation"] # [doc = " 4. Return split tracks with repair information"] # [doc = ""] # [doc = " # Arguments"] # [doc = ""] # [doc = " * `midi_bytes` - Complete MIDI file as byte slice"] # [doc = ""] # [doc = " # Returns"] # [doc = ""] # [doc = " `Ok((tracks, repair_result))` with the split tracks and repair status"] # [doc = " `Err(AutoRepairError)` if the file is corrupt and unrepairable"] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " ```"] # [doc = " use pipeline::core::splitting::auto_repair::split_tracks_with_repair;"] # [doc = ""] # [doc = " let midi_bytes = include_bytes!(\"test_data/corrupt.mid\");"] # [doc = " match split_tracks_with_repair(midi_bytes) {"] # [doc = "     Ok((tracks, repair_result)) => {"] # [doc = "         println!(\"Split {} tracks\", tracks.len());"] # [doc = "         match repair_result {"] # [doc = "             RepairResult::Valid => println!(\"File was valid\"),"] # [doc = "             RepairResult::Repaired { fix_description, .. } => {"] # [doc = "                 println!(\"Repaired: {}\", fix_description);"] # [doc = "             },"] # [doc = "             _ => {}"] # [doc = "         }"] # [doc = "     },"] # [doc = "     Err(e) => eprintln!(\"Failed to split: {}\", e),"] # [doc = " }"] # [doc = " # Ok::<(), pipeline::core::splitting::auto_repair::AutoRepairError>(())"] # [doc = " ```"] pub fn split_tracks_with_repair (midi_bytes : & [u8] ,) -> Result < (Vec < SplitTrack > , RepairResult) , AutoRepairError > { match split_tracks (midi_bytes) { Ok (tracks) => Ok ((tracks , RepairResult :: Valid)) , Err (original_error) => { match attempt_repair (midi_bytes) { Ok ((repaired_bytes , fix_description)) => { match split_tracks (& repaired_bytes) { Ok (tracks) => Ok ((tracks , RepairResult :: Repaired { fix_description : fix_description . clone () , repaired_bytes : repaired_bytes . clone () , } ,)) , Err (repair_split_error) => Err (AutoRepairError :: RepairFailed (format ! ("Original error: {}. Repair attempted: {}. Post-repair error: {}" , original_error , fix_description , repair_split_error))) , } } , Err (repair_error) => Err (AutoRepairError :: UnrepairableCorruption (format ! ("Original error: {}. Repair error: {}" , original_error , repair_error))) , } } , } }

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/splitting/auto_repair.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/splitting/auto_repair.rs`
  - Category: Performance

- [ ] **Function 'attempt_repair' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/splitting/auto_repair.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Attempt to repair common MIDI file corruption issues."] # [doc = ""] # [doc = " Applies the following fixes in order:"] # [doc = " 1. Add missing End-of-Track markers (0xFF 0x2F 0x00)"] # [doc = " 2. Trim trailing garbage data after the last track"] # [doc = ""] # [doc = " # Arguments"] # [doc = ""] # [doc = " * `data` - Original MIDI file bytes"] # [doc = ""] # [doc = " # Returns"] # [doc = ""] # [doc = " `Ok((repaired_bytes, fix_description))` if repair was successful"] # [doc = " `Err(reason)` if no repair was needed or possible"] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " ```"] # [doc = " use pipeline::core::splitting::auto_repair::attempt_repair;"] # [doc = ""] # [doc = " let corrupt_midi = b\"MThd...\"; // Corrupt MIDI bytes"] # [doc = " match attempt_repair(corrupt_midi) {"] # [doc = "     Ok((repaired, desc)) => println!(\"Fixed: {}\", desc),"] # [doc = "     Err(e) => println!(\"Cannot repair: {}\", e),"] # [doc = " }"] # [doc = " ```"] pub fn attempt_repair (data : & [u8]) -> Result < (Vec < u8 > , String) , String > { let mut repaired = data . to_vec () ; let mut fixes = Vec :: new () ; if repaired . len () < 14 { return Err (format ! ("File too small ({} bytes, need 14+)" , repaired . len ())) ; } if & repaired [0 .. 4] != b"MThd" { return Err ("Not a MIDI file (missing MThd header)" . to_string ()) ; } if repaired . len () >= 14 { if & repaired [0 .. 4] == b"MThd" { let mut pos = 14 ; while pos < repaired . len () { if pos + 8 > repaired . len () { break ; } if & repaired [pos .. pos + 4] == b"MTrk" { let track_len = u32 :: from_be_bytes ([repaired [pos + 4] , repaired [pos + 5] , repaired [pos + 6] , repaired [pos + 7] ,]) as usize ; let track_end = pos + 8 + track_len ; if track_end <= repaired . len () { let has_eot = if track_end >= 3 { & repaired [track_end - 3 .. track_end] == & [0xFF , 0x2F , 0x00] } else { false } ; if ! has_eot && track_end < repaired . len () { repaired . splice (track_end .. track_end , [0xFF , 0x2F , 0x00] . iter () . cloned ()) ; let new_len = track_len + 3 ; let len_bytes = (new_len as u32) . to_be_bytes () ; repaired [pos + 4] = len_bytes [0] ; repaired [pos + 5] = len_bytes [1] ; repaired [pos + 6] = len_bytes [2] ; repaired [pos + 7] = len_bytes [3] ; fixes . push ("Added missing End-of-Track marker" . to_string ()) ; } pos = track_end ; } else { break ; } } else { pos += 1 ; } } } } if repaired . len () > 14 && & repaired [0 .. 4] == b"MThd" { let header_len = u32 :: from_be_bytes ([repaired [4] , repaired [5] , repaired [6] , repaired [7]]) as usize ; if header_len == 6 { let num_tracks = u16 :: from_be_bytes ([repaired [10] , repaired [11]]) as usize ; let mut expected_size = 14 ; let mut pos = 14 ; for _ in 0 .. num_tracks { if pos + 8 > repaired . len () { break ; } if & repaired [pos .. pos + 4] == b"MTrk" { let track_len = u32 :: from_be_bytes ([repaired [pos + 4] , repaired [pos + 5] , repaired [pos + 6] , repaired [pos + 7] ,]) as usize ; expected_size = pos + 8 + track_len ; pos = expected_size ; } else { break ; } } if expected_size < repaired . len () { let trimmed = repaired . len () - expected_size ; repaired . truncate (expected_size) ; fixes . push (format ! ("Trimmed {} bytes of trailing garbage" , trimmed)) ; } } } if fixes . is_empty () { Err ("No repairs needed or possible" . to_string ()) } else { Ok ((repaired , fixes . join (", "))) } }

- [ ] **Function 'split_tracks' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/splitting/track_splitter.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Split multi-track MIDI file into individual single-track files."] # [doc = ""] # [doc = " Parses a MIDI file and creates separate Format 0 (single-track) MIDI files"] # [doc = " for each music track. Skips tempo-only tracks (Track 0 in Format 1 files)."] # [doc = " Preserves tempo, time signature, and key signature from the original file."] # [doc = ""] # [doc = " # Arguments"] # [doc = ""] # [doc = " * `original_midi_bytes` - Complete MIDI file as byte slice"] # [doc = ""] # [doc = " # Returns"] # [doc = ""] # [doc = " Vector of `SplitTrack` structs, one for each music track found."] # [doc = " Returns error if parsing fails or no music tracks exist."] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " ```"] # [doc = " use pipeline::core::splitting::track_splitter::split_tracks;"] # [doc = ""] # [doc = " // Parse multi-track MIDI"] # [doc = " let midi_bytes = include_bytes!(\"test_data/multitrack.mid\");"] # [doc = " let tracks = split_tracks(midi_bytes)?;"] # [doc = ""] # [doc = " for track in tracks {"] # [doc = "     println!(\"Track {}: {} notes\", track.track_number, track.note_count);"] # [doc = "     if let Some(name) = track.track_name {"] # [doc = "         println!(\"  Name: {}\", name);"] # [doc = "     }"] # [doc = " }"] # [doc = " # Ok::<(), pipeline::core::splitting::track_splitter::SplitError>(())"] # [doc = " ```"] pub fn split_tracks (original_midi_bytes : & [u8]) -> Result < Vec < SplitTrack > , SplitError > { let smf = Smf :: parse (original_midi_bytes) . map_err (| e | SplitError :: ParseError (format ! ("midly parse error: {}" , e))) ? ; if smf . header . format == Format :: SingleTrack { let track = & smf . tracks [0] ; let note_count = count_notes (track) ; if note_count == 0 { return Err (SplitError :: NoTracksToSplit) ; } return Ok (vec ! [SplitTrack { track_number : 0 , track_name : extract_track_name (track) , channel : extract_primary_channel (track) , instrument : extract_instrument (track) , note_count , midi_bytes : original_midi_bytes . to_vec () , }]) ; } let mut split_tracks = Vec :: new () ; for (idx , track) in smf . tracks . iter () . enumerate () { if is_tempo_track (track) { continue ; } let note_count = count_notes (track) ; if note_count == 0 { continue ; } let midi_bytes = create_single_track_midi (& smf , track , idx) ? ; split_tracks . push (SplitTrack { track_number : idx , track_name : extract_track_name (track) , channel : extract_primary_channel (track) , instrument : extract_instrument (track) , note_count , midi_bytes , }) ; } if split_tracks . is_empty () { return Err (SplitError :: NoTracksToSplit) ; } Ok (split_tracks) }

- [ ] **Function 'is_tempo_track' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/splitting/track_splitter.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Check if a track is a tempo-only track."] # [doc = ""] # [doc = " Tempo tracks contain only meta events (tempo, time signature, key signature)"] # [doc = " and no note events. Common in Format 1 MIDI files as Track 0."] # [doc = ""] # [doc = " # Arguments"] # [doc = ""] # [doc = " * `track` - MIDI track to analyze"] # [doc = ""] # [doc = " # Returns"] # [doc = ""] # [doc = " `true` if track contains only meta events, `false` otherwise"] pub fn is_tempo_track (track : & Track) -> bool { let mut has_meta_events = false ; let mut has_note_events = false ; for event in track . iter () { match event . kind { TrackEventKind :: Meta (_) => has_meta_events = true , TrackEventKind :: Midi { message , .. } => { use midly :: MidiMessage ; match message { MidiMessage :: NoteOn { .. } | MidiMessage :: NoteOff { .. } => { has_note_events = true ; break ; } , _ => { } , } } , _ => { } , } } has_meta_events && ! has_note_events }

- [ ] **Function 'create_single_track_midi' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/splitting/track_splitter.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Create a Format 0 (single-track) MIDI file from a single track."] # [doc = ""] # [doc = " Merges tempo/time signature/key signature events from Track 0 (if Format 1)"] # [doc = " with the music events from the specified track. Creates a valid Format 0 MIDI file."] # [doc = ""] # [doc = " # Arguments"] # [doc = ""] # [doc = " * `original` - Original parsed MIDI file"] # [doc = " * `track` - Track to extract"] # [doc = " * `track_idx` - Index of the track (for reference)"] # [doc = ""] # [doc = " # Returns"] # [doc = ""] # [doc = " Complete Format 0 MIDI file as bytes"] pub fn create_single_track_midi (original : & Smf , track : & Track , track_idx : usize ,) -> Result < Vec < u8 > , SplitError > { let new_header = Header { format : Format :: SingleTrack , timing : original . header . timing } ; let mut new_track_events = Vec :: new () ; if original . header . format == Format :: Parallel && track_idx > 0 && ! original . tracks . is_empty () { let track_0 = & original . tracks [0] ; for event in track_0 . iter () { match event . kind { TrackEventKind :: Meta (MetaMessage :: Tempo (_)) | TrackEventKind :: Meta (MetaMessage :: TimeSignature (..)) | TrackEventKind :: Meta (MetaMessage :: KeySignature (..)) => { new_track_events . push (* event) ; } , _ => { } , } } } new_track_events . extend (track . iter () . cloned ()) ; let has_end_of_track = new_track_events . iter () . any (| e | matches ! (e . kind , TrackEventKind :: Meta (MetaMessage :: EndOfTrack))) ; if ! has_end_of_track { new_track_events . push (TrackEvent { delta : 0 . into () , kind : TrackEventKind :: Meta (MetaMessage :: EndOfTrack) , }) ; } let new_smf = Smf { header : new_header , tracks : vec ! [new_track_events] } ; let mut bytes = Vec :: new () ; new_smf . write_std (& mut bytes) . map_err (| e | SplitError :: WriteError (format ! ("midly write error: {}" , e))) ? ; Ok (bytes) }

- [ ] **Function 'extract_track_name' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/splitting/track_splitter.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Extract track name from meta events."] # [doc = ""] # [doc = " Searches for TrackName or InstrumentName meta events."] # [doc = ""] # [doc = " # Arguments"] # [doc = ""] # [doc = " * `track` - MIDI track to analyze"] # [doc = ""] # [doc = " # Returns"] # [doc = ""] # [doc = " Track name if found, `None` otherwise"] pub fn extract_track_name (track : & Track) -> Option < String > { for event in track . iter () { if let TrackEventKind :: Meta (MetaMessage :: TrackName (name) | MetaMessage :: InstrumentName (name) ,) = & event . kind { if let Ok (name_str) = String :: from_utf8 (name . to_vec ()) { let trimmed = name_str . trim () ; if ! trimmed . is_empty () { return Some (trimmed . to_string ()) ; } } } } None }

- [ ] **Function 'extract_primary_channel' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/splitting/track_splitter.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Extract the primary MIDI channel used by this track."] # [doc = ""] # [doc = " Analyzes all MIDI messages and returns the most frequently used channel."] # [doc = ""] # [doc = " # Arguments"] # [doc = ""] # [doc = " * `track` - MIDI track to analyze"] # [doc = ""] # [doc = " # Returns"] # [doc = ""] # [doc = " Most frequently used channel (0-15), or `None` if no MIDI messages found"] pub fn extract_primary_channel (track : & Track) -> Option < u8 > { let mut channel_counts = [0u32 ; 16] ; for event in track . iter () { if let TrackEventKind :: Midi { channel , .. } = event . kind { channel_counts [channel . as_int () as usize] += 1 ; } } let max_channel = channel_counts . iter () . enumerate () . max_by_key (| (_ , & count) | count) ? ; if max_channel . 1 > & 0 { Some (max_channel . 0 as u8) } else { None } }

- [ ] **Function 'extract_instrument' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/splitting/track_splitter.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Extract instrument name from Program Change events."] # [doc = ""] # [doc = " Searches for the first Program Change event and maps to General MIDI instrument name."] # [doc = ""] # [doc = " # Arguments"] # [doc = ""] # [doc = " * `track` - MIDI track to analyze"] # [doc = ""] # [doc = " # Returns"] # [doc = ""] # [doc = " General MIDI instrument name, or `None` if no Program Change found"] pub fn extract_instrument (track : & Track) -> Option < String > { for event in track . iter () { if let TrackEventKind :: Midi { message , .. } = & event . kind { use midly :: MidiMessage ; if let MidiMessage :: ProgramChange { program } = message { return Some (get_instrument_name (program . as_int ())) ; } } } None }

- [ ] **Function 'count_notes' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/splitting/track_splitter.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Count note-on events in a track."] # [doc = ""] # [doc = " # Arguments"] # [doc = ""] # [doc = " * `track` - MIDI track to analyze"] # [doc = ""] # [doc = " # Returns"] # [doc = ""] # [doc = " Number of note-on events with velocity > 0"] pub fn count_notes (track : & Track) -> usize { let mut count = 0 ; for event in track . iter () { if let TrackEventKind :: Midi { message , .. } = & event . kind { use midly :: MidiMessage ; if let MidiMessage :: NoteOn { vel , .. } = message { if vel . as_int () > 0 { count += 1 ; } } } } count }

- [ ] **Function 'get_instrument_name' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/splitting/track_splitter.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Get General MIDI instrument name from program number."] # [doc = ""] # [doc = " Maps GM program numbers (0-127) to standard instrument names."] # [doc = ""] # [doc = " # Arguments"] # [doc = ""] # [doc = " * `program` - GM program number (0-127)"] # [doc = ""] # [doc = " # Returns"] # [doc = ""] # [doc = " General MIDI instrument name"] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " ```"] # [doc = " use pipeline::core::splitting::track_splitter::get_instrument_name;"] # [doc = ""] # [doc = " assert_eq!(get_instrument_name(0), \"Acoustic Grand Piano\");"] # [doc = " assert_eq!(get_instrument_name(25), \"Acoustic Guitar (nylon)\");"] # [doc = " assert_eq!(get_instrument_name(127), \"Gunshot\");"] # [doc = " ```"] pub fn get_instrument_name (program : u8) -> String { match program { 0 => "Acoustic Grand Piano" , 1 => "Bright Acoustic Piano" , 2 => "Electric Grand Piano" , 3 => "Honky-tonk Piano" , 4 => "Electric Piano 1" , 5 => "Electric Piano 2" , 6 => "Harpsichord" , 7 => "Clavinet" , 8 => "Celesta" , 9 => "Glockenspiel" , 10 => "Music Box" , 11 => "Vibraphone" , 12 => "Marimba" , 13 => "Xylophone" , 14 => "Tubular Bells" , 15 => "Dulcimer" , 16 => "Drawbar Organ" , 17 => "Percussive Organ" , 18 => "Rock Organ" , 19 => "Church Organ" , 20 => "Reed Organ" , 21 => "Accordion" , 22 => "Harmonica" , 23 => "Tango Accordion" , 24 => "Acoustic Guitar (nylon)" , 25 => "Acoustic Guitar (steel)" , 26 => "Electric Guitar (jazz)" , 27 => "Electric Guitar (clean)" , 28 => "Electric Guitar (muted)" , 29 => "Overdriven Guitar" , 30 => "Distortion Guitar" , 31 => "Guitar Harmonics" , 32 => "Acoustic Bass" , 33 => "Electric Bass (finger)" , 34 => "Electric Bass (pick)" , 35 => "Fretless Bass" , 36 => "Slap Bass 1" , 37 => "Slap Bass 2" , 38 => "Synth Bass 1" , 39 => "Synth Bass 2" , 40 => "Violin" , 41 => "Viola" , 42 => "Cello" , 43 => "Contrabass" , 44 => "Tremolo Strings" , 45 => "Pizzicato Strings" , 46 => "Orchestral Harp" , 47 => "Timpani" , 48 => "String Ensemble 1" , 49 => "String Ensemble 2" , 50 => "Synth Strings 1" , 51 => "Synth Strings 2" , 52 => "Choir Aahs" , 53 => "Voice Oohs" , 54 => "Synth Voice" , 55 => "Orchestra Hit" , 56 => "Trumpet" , 57 => "Trombone" , 58 => "Tuba" , 59 => "Muted Trumpet" , 60 => "French Horn" , 61 => "Brass Section" , 62 => "Synth Brass 1" , 63 => "Synth Brass 2" , 64 => "Soprano Sax" , 65 => "Alto Sax" , 66 => "Tenor Sax" , 67 => "Baritone Sax" , 68 => "Oboe" , 69 => "English Horn" , 70 => "Bassoon" , 71 => "Clarinet" , 72 => "Piccolo" , 73 => "Flute" , 74 => "Recorder" , 75 => "Pan Flute" , 76 => "Blown Bottle" , 77 => "Shakuhachi" , 78 => "Whistle" , 79 => "Ocarina" , 80 => "Lead 1 (square)" , 81 => "Lead 2 (sawtooth)" , 82 => "Lead 3 (calliope)" , 83 => "Lead 4 (chiff)" , 84 => "Lead 5 (charang)" , 85 => "Lead 6 (voice)" , 86 => "Lead 7 (fifths)" , 87 => "Lead 8 (bass + lead)" , 88 => "Pad 1 (new age)" , 89 => "Pad 2 (warm)" , 90 => "Pad 3 (polysynth)" , 91 => "Pad 4 (choir)" , 92 => "Pad 5 (bowed)" , 93 => "Pad 6 (metallic)" , 94 => "Pad 7 (halo)" , 95 => "Pad 8 (sweep)" , 96 => "FX 1 (rain)" , 97 => "FX 2 (soundtrack)" , 98 => "FX 3 (crystal)" , 99 => "FX 4 (atmosphere)" , 100 => "FX 5 (brightness)" , 101 => "FX 6 (goblins)" , 102 => "FX 7 (echoes)" , 103 => "FX 8 (sci-fi)" , 104 => "Sitar" , 105 => "Banjo" , 106 => "Shamisen" , 107 => "Koto" , 108 => "Kalimba" , 109 => "Bag pipe" , 110 => "Fiddle" , 111 => "Shanai" , 112 => "Tinkle Bell" , 113 => "Agogo" , 114 => "Steel Drums" , 115 => "Woodblock" , 116 => "Taiko Drum" , 117 => "Melodic Tom" , 118 => "Synth Drum" , 119 => "Reverse Cymbal" , 120 => "Guitar Fret Noise" , 121 => "Breath Noise" , 122 => "Seashore" , 123 => "Bird Tweet" , 124 => "Telephone Ring" , 125 => "Helicopter" , 126 => "Applause" , 127 => "Gunshot" , _ => "Unknown Instrument" , } . to_string () }

- [ ] **Function 'create_test_track' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/splitting/track_splitter.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn create_test_track (events : Vec < TrackEvent >) -> Track { events }

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/database/batch_insert.rs`
  - Category: Performance

- [ ] **Function 'calculate_optimal_batch_size' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/database/batch_insert.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Calculate optimal batch size based on system memory"] # [doc = ""] # [doc = " This function provides a dynamically calculated batch size based on"] # [doc = " detected system resources (CPU cores, RAM, storage type)."] # [doc = ""] # [doc = " # Returns"] # [doc = ""] # [doc = " Recommended batch size (between 500 and 10,000)"] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " ```rust"] # [doc = " let batch_size = calculate_optimal_batch_size();"] # [doc = " let inserter = BatchInserter::new(pool, batch_size);"] # [doc = " ```"] pub fn calculate_optimal_batch_size () -> usize { let (_ , _ , batch_size) = calculate_all_settings () ; batch_size }

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/database/mod.rs`
  - Category: Performance

- [ ] **Function 'is_transient_error' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/database/mod.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Check if error is transient and can be retried"] # [doc = ""] # [doc = " Transient errors are temporary failures that may succeed on retry."] # [doc = " Non-transient errors are permanent failures that won't change on retry."] # [doc = ""] # [doc = " # Arguments"] # [doc = ""] # [doc = " * `error` - Database error to check"] # [doc = ""] # [doc = " # Returns"] # [doc = ""] # [doc = " * `bool` - True if error is transient and should be retried"] fn is_transient_error (error : & sqlx :: Error) -> bool { match error { sqlx :: Error :: PoolTimedOut => true , sqlx :: Error :: PoolClosed => true , sqlx :: Error :: Io (_) => true , _ => false , } }

- [ ] **Function 'is_connection_error' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/database/mod.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Check if error is a connection error that requires reconnection"] # [doc = ""] # [doc = " Connection errors indicate the database connection is broken and"] # [doc = " needs to be re-established before operations can continue."] # [doc = ""] # [doc = " # Arguments"] # [doc = ""] # [doc = " * `error` - Database error to check"] # [doc = ""] # [doc = " # Returns"] # [doc = ""] # [doc = " * `bool` - True if error indicates connection loss"] fn is_connection_error (error : & sqlx :: Error) -> bool { match error { sqlx :: Error :: PoolClosed => true , sqlx :: Error :: Io (_) => true , sqlx :: Error :: Database (db_err) => { let code = db_err . code () . unwrap_or_default () ; matches ! (code . as_ref () , "08000" | "08003" | "08006" | "57P01" | "57P02" | "57P03") } , _ => false , } }

- [ ] **Function 'bigdecimal_to_f64' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/db/models.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Convert BigDecimal to f64"] pub fn bigdecimal_to_f64 (bd : Option < BigDecimal >) -> Option < f64 > { bd . and_then (| b | b . to_f64 ()) }

- [ ] **Function 'f64_to_bigdecimal' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/db/models.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Convert f64 to BigDecimal"] pub fn f64_to_bigdecimal (val : Option < f64 >) -> Option < BigDecimal > { use num_traits :: FromPrimitive ; val . and_then (BigDecimal :: from_f64) }

- [ ] **Function 'extract_archive' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/io/decompressor/extractor.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Extracts MIDI files from an archive"] # [doc = ""] # [doc = " # Arguments"] # [doc = " * `archive_path` - Path to archive file"] # [doc = " * `output_dir` - Where to extract files"] # [doc = " * `config` - Extraction configuration"] # [doc = ""] # [doc = " # Returns"] # [doc = " * `ExtractionResult` - List of extracted MIDI files"] # [doc = ""] # [doc = " # Examples"] # [doc = " ```no_run"] # [doc = " use std::path::Path;"] # [doc = " use pipeline::io::decompressor::extractor::*;"] # [doc = ""] # [doc = " let config = ExtractionConfig::default();"] # [doc = " let result = extract_archive("] # [doc = "     Path::new(\"samples.zip\"),"] # [doc = "     Path::new(\"/output\"),"] # [doc = "     &config"] # [doc = " ).unwrap();"] # [doc = ""] # [doc = " println!(\"Extracted {} MIDI files\", result.midi_files.len());"] # [doc = " ```"] pub fn extract_archive (archive_path : & Path , output_dir : & Path , config : & ExtractionConfig ,) -> Result < ExtractionResult > { let format = formats :: detect_format (archive_path) . ok_or_else (| | IoError :: UnsupportedFormat { path : archive_path . to_path_buf () }) ? ; let mut result = ExtractionResult { midi_files : Vec :: new () , archives_processed : 0 , errors : Vec :: new () } ; extract_recursive (archive_path , output_dir , config , 0 , & mut result , format) ? ; Ok (result) }

- [ ] **Function 'extract_recursive' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/io/decompressor/extractor.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Internal recursive extraction function"] fn extract_recursive (archive_path : & Path , output_dir : & Path , config : & ExtractionConfig , current_depth : usize , result : & mut ExtractionResult , format : formats :: ArchiveFormat ,) -> Result < () > { if current_depth >= config . max_depth { result . errors . push (format ! ("Max depth reached at: {}" , archive_path . display ())) ; return Ok (()) ; } result . archives_processed += 1 ; match format { formats :: ArchiveFormat :: Zip => { extract_zip (archive_path , output_dir , config , current_depth , result) ? ; } , _ => { result . errors . push (format ! ("Format {:?} not yet implemented" , format)) ; } , } Ok (()) }

- [ ] **Function 'extract_zip' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/io/decompressor/extractor.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Extracts ZIP archive"] fn extract_zip (archive_path : & Path , output_dir : & Path , config : & ExtractionConfig , current_depth : usize , result : & mut ExtractionResult ,) -> Result < () > { let file = File :: open (archive_path) ? ; let mut archive = ZipArchive :: new (file) ? ; fs :: create_dir_all (output_dir) ? ; for i in 0 .. archive . len () { let mut file = archive . by_index (i) ? ; let outpath = match file . enclosed_name () { Some (path) => output_dir . join (path) , None => continue , } ; if file . name () . ends_with ('/') { fs :: create_dir_all (& outpath) ? ; } else { if let Some (parent) = outpath . parent () { fs :: create_dir_all (parent) ? ; } let mut outfile = File :: create (& outpath) ? ; io :: copy (& mut file , & mut outfile) ? ; if is_target_file (& outpath , & config . target_extensions) { result . midi_files . push (outpath . clone ()) ; } if config . recursive && formats :: is_archive (& outpath) { if let Some (nested_format) = formats :: detect_format (& outpath) { let nested_dir = if let Some (stem) = outpath . file_stem () { output_dir . join (format ! ("{}_extracted" , stem . to_string_lossy ())) } else { output_dir . join (format ! ("nested_{}" , current_depth + 1)) } ; let _ = extract_recursive (& outpath , & nested_dir , config , current_depth + 1 , result , nested_format ,) ; } } } } Ok (()) }

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/io/decompressor/extractor.rs`
  - Category: Performance

- [ ] **Function 'is_target_file' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/io/decompressor/extractor.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Checks if file has target extension"] fn is_target_file (path : & Path , target_extensions : & [String]) -> bool { path . extension () . and_then (| ext | ext . to_str ()) . map (| ext_str | { let ext_lower = ext_str . to_lowercase () ; target_extensions . iter () . any (| target | target == & ext_lower) }) . unwrap_or (false) }

- [ ] **Function 'extract_to_temp' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/io/decompressor/extractor.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Convenience function for extracting to temporary directory"] # [doc = ""] # [doc = " # Arguments"] # [doc = " * `archive_path` - Path to archive file"] # [doc = " * `config` - Extraction configuration"] # [doc = ""] # [doc = " # Returns"] # [doc = " * `(ExtractionResult, PathBuf)` - Extraction result and temp directory path"] pub fn extract_to_temp (archive_path : & Path , config : & ExtractionConfig ,) -> Result < (ExtractionResult , PathBuf) > { let mut temp_mgr = temp_manager :: TempManager :: new () ? ; let temp_dir = temp_mgr . create_temp_dir () ? ; let result = extract_archive (archive_path , & temp_dir , config) ? ; std :: mem :: forget (temp_mgr) ; Ok ((result , temp_dir)) }

- [ ] **Function 'detect_format' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/io/decompressor/formats.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Detects archive format from file extension"] # [doc = ""] # [doc = " # Arguments"] # [doc = " * `path` - Path to check"] # [doc = ""] # [doc = " # Returns"] # [doc = " * `Some(ArchiveFormat)` if recognized, `None` otherwise"] pub fn detect_format (path : & Path) -> Option < ArchiveFormat > { let filename = path . file_name () ? . to_str () ? . to_lowercase () ; if filename . ends_with (".zip") { Some (ArchiveFormat :: Zip) } else if filename . ends_with (".rar") { Some (ArchiveFormat :: Rar) } else if filename . ends_with (".7z") { Some (ArchiveFormat :: SevenZip) } else if filename . ends_with (".tar.gz") || filename . ends_with (".tgz") { Some (ArchiveFormat :: TarGz) } else if filename . ends_with (".tar") { Some (ArchiveFormat :: Tar) } else { None } }

- [ ] **Function 'is_archive' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/io/decompressor/formats.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Checks if file is a supported archive"] # [doc = ""] # [doc = " # Arguments"] # [doc = " * `path` - Path to check"] # [doc = ""] # [doc = " # Returns"] # [doc = " * `true` if file is a recognized archive format"] pub fn is_archive (path : & Path) -> bool { detect_format (path) . is_some () }

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/io/decompressor/temp_manager.rs`
  - Category: Performance

- [ ] **Function 'init_logging' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/main.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Initialize logging/tracing system"] fn init_logging () { let log_dir = std :: env :: var ("LOG_DIR") . unwrap_or_else (| _ | "./logs" . to_string ()) ; std :: fs :: create_dir_all (& log_dir) . ok () ; let file_appender = tracing_appender :: rolling :: daily (log_dir , "pipeline.log") ; let (non_blocking , _guard) = tracing_appender :: non_blocking (file_appender) ; tracing_subscriber :: registry () . with (tracing_subscriber :: EnvFilter :: try_from_default_env () . unwrap_or_else (| _ | "info,midi_pipeline=debug" . into ()) ,) . with (tracing_subscriber :: fmt :: layer () . with_writer (std :: io :: stdout)) . with (tracing_subscriber :: fmt :: layer () . with_writer (non_blocking)) . init () ; }

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/windows/manager.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/windows/manager.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/windows/manager.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/windows/manager.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/windows/manager.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/windows/manager.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/windows/manager.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/windows/manager.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/windows/manager.rs`
  - Category: Performance

- [ ] **Function 'create_windows_menu' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/windows/menu.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Create the Windows menu (for menu bar)"] pub fn create_windows_menu () -> Submenu { Submenu :: new ("Windows" , Menu :: new () . add_item (CustomMenuItem :: new ("show_pipeline" , "Show Pipeline")) . add_item (CustomMenuItem :: new ("show_daw" , "Show DAW")) . add_item (CustomMenuItem :: new ("show_database" , "Show Database")) . add_item (CustomMenuItem :: new ("show_settings" , "Show Settings")) . add_native_item (MenuItem :: Separator) . add_item (CustomMenuItem :: new ("arrange_tile_h" , "Tile Horizontally")) . add_item (CustomMenuItem :: new ("arrange_tile_v" , "Tile Vertically")) . add_item (CustomMenuItem :: new ("arrange_cascade" , "Cascade")) . add_native_item (MenuItem :: Separator) . add_item (CustomMenuItem :: new ("save_layout" , "Save Layout...")) . add_item (CustomMenuItem :: new ("load_layout" , "Load Layout...")) . add_item (CustomMenuItem :: new ("manage_layouts" , "Manage Layouts...")) ,) }

- [ ] **Function 'create_view_menu' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/windows/menu.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Create View menu with window controls"] pub fn create_view_menu () -> Submenu { Submenu :: new ("View" , Menu :: new () . add_item (CustomMenuItem :: new ("toggle_sidebar" , "Toggle Sidebar")) . add_item (CustomMenuItem :: new ("toggle_inspector" , "Toggle Inspector")) . add_native_item (MenuItem :: Separator) . add_item (CustomMenuItem :: new ("zoom_in" , "Zoom In")) . add_item (CustomMenuItem :: new ("zoom_out" , "Zoom Out")) . add_item (CustomMenuItem :: new ("zoom_reset" , "Reset Zoom")) ,) }

- [ ] **Function 'setup_window_shortcuts' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/windows/shortcuts.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Setup window management global shortcuts"] # [doc = ""] # [doc = " Shortcuts:"] # [doc = " - Cmd/Ctrl+1: Show Pipeline"] # [doc = " - Cmd/Ctrl+2: Show DAW"] # [doc = " - Cmd/Ctrl+3: Show Database"] # [doc = " - Cmd/Ctrl+`: Cycle windows (next)"] # [doc = " - Cmd/Ctrl+Shift+`: Cycle windows (prev)"] pub fn setup_window_shortcuts (app : & AppHandle) -> Result < () , String > { let mut manager = app . global_shortcut_manager () ; { let app_handle = app . clone () ; manager . register ("CmdOrCtrl+1" , move | | { let _ = app_handle . emit_all ("command:show-pipeline" , ()) ; }) . map_err (| e | format ! ("Failed to register Cmd+1: {}" , e)) ? ; } { let app_handle = app . clone () ; manager . register ("CmdOrCtrl+2" , move | | { let _ = app_handle . emit_all ("command:show-daw" , ()) ; }) . map_err (| e | format ! ("Failed to register Cmd+2: {}" , e)) ? ; } { let app_handle = app . clone () ; manager . register ("CmdOrCtrl+3" , move | | { let _ = app_handle . emit_all ("command:show-database" , ()) ; }) . map_err (| e | format ! ("Failed to register Cmd+3: {}" , e)) ? ; } { let app_handle = app . clone () ; manager . register ("CmdOrCtrl+grave" , move | | { let _ = app_handle . emit_all ("command:cycle-windows" , ()) ; }) . map_err (| e | format ! ("Failed to register Cmd+`: {}" , e)) ? ; } { let app_handle = app . clone () ; manager . register ("CmdOrCtrl+Shift+grave" , move | | { let _ = app_handle . emit_all ("command:cycle-windows-back" , ()) ; }) . map_err (| e | format ! ("Failed to register Cmd+Shift+`: {}" , e)) ? ; } { let app_handle = app . clone () ; manager . register ("CmdOrCtrl+b" , move | | { let _ = app_handle . emit ("command:toggle-sidebar" , ()) ; }) . map_err (| e | format ! ("Failed to register Cmd+B: {}" , e)) ? ; } { let app_handle = app . clone () ; manager . register ("CmdOrCtrl+Alt+i" , move | | { let _ = app_handle . emit ("command:toggle-inspector" , ()) ; }) . map_err (| e | format ! ("Failed to register Cmd+Alt+I: {}" , e)) ? ; } info ! ("âœ… Window shortcuts registered") ; Ok (()) }

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/windows/shortcuts.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/windows/shortcuts.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/windows/shortcuts.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/windows/shortcuts.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/windows/shortcuts.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/windows/shortcuts.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/windows/shortcuts.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/windows/state.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/windows/state.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/windows/state.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/scripts/import-tool/src/main.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/scripts/import-tool/src/main.rs`
  - Category: Performance

- [ ] **Function 'get_bpm_regex' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/scripts/import-tool/src/main.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn get_bpm_regex () -> & 'static Regex { BPM_REGEX . get_or_init (| | { Regex :: new (r"(?i)([0-9]{2,3})[\s_]*(bpm|beats|tempo)|(?:^|_|\s|-|/)([0-9]{2,3})(?:_|\s|-|/|\.)" ,) . unwrap () }) }

- [ ] **Function 'extract_bpm_from_filename' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/scripts/import-tool/src/main.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn extract_bpm_from_filename (filename : & str) -> Option < f32 > { let regex = get_bpm_regex () ; for caps in regex . captures_iter (filename) { if let Some (m) = caps . get (1) { if let Ok (bpm) = m . as_str () . parse :: < f32 > () { if (30.0 ..= 300.0) . contains (& bpm) { return Some (bpm) ; } } } } for caps in regex . captures_iter (filename) { if let Some (m) = caps . get (3) { if let Ok (bpm) = m . as_str () . parse :: < f32 > () { if (30.0 ..= 300.0) . contains (& bpm) { return Some (bpm) ; } } } } None }

- [ ] **Function 'get_key_regex' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/scripts/import-tool/src/main.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn get_key_regex () -> & 'static Regex { KEY_REGEX . get_or_init (| | Regex :: new (r"(?i)(?:^|_|\s|-|/)([A-G](?:#|b)?m?)(?:_|\s|-|/|\.)") . unwrap ()) }

- [ ] **Function 'get_key_map' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/scripts/import-tool/src/main.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn get_key_map () -> & 'static HashMap < & 'static str , & 'static str > { KEY_NORMALIZATION_MAP . get_or_init (| | { HashMap :: from ([("amin" , "Am") , ("am" , "Am") , ("bmin" , "Bm") , ("bm" , "Bm") , ("cmin" , "Cm") , ("cm" , "Cm") , ("dmin" , "Dm") , ("dm" , "Dm") , ("emin" , "Em") , ("em" , "Em") , ("fmin" , "Fm") , ("fm" , "Fm") , ("gmin" , "Gm") , ("gm" , "Gm") , ("amaj" , "A") , ("cmaj" , "C") , ("dmaj" , "D") , ("emaj" , "E") , ("fmaj" , "F") , ("gmaj" , "G") , ("bmaj" , "B") , ("bb" , "Bb") , ("a#" , "A#") , ("c#" , "C#") , ("d#" , "D#") , ("f#" , "F#") , ("g#" , "G#") , ("ab" , "Ab") , ("db" , "Db") , ("eb" , "Eb") , ("gb" , "Gb") , ("a" , "A") , ("b" , "B") , ("c" , "C") , ("d" , "D") , ("e" , "E") , ("f" , "F") , ("g" , "G") ,]) }) }

- [ ] **Function 'normalize_key_signature' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/scripts/import-tool/src/main.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn normalize_key_signature (raw_key : & str) -> Option < String > { get_key_map () . get (raw_key . to_lowercase () . as_str ()) . map (| & s | s . to_string ()) }

- [ ] **Function 'extract_key_from_filename' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/scripts/import-tool/src/main.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn extract_key_from_filename (filename : & str) -> Option < String > { get_key_regex () . captures (filename) . and_then (| caps | caps . get (1)) . and_then (| m | normalize_key_signature (m . as_str ())) }

- [ ] **Function 'get_genre_regex' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/scripts/import-tool/src/main.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn get_genre_regex () -> & 'static Regex { GENRE_REGEX . get_or_init (| | { Regex :: new (r"(?i)(house|techno|trance|hip.?hop|trap|dubstep|dnb|drum.?n.?bass|jazz|funk|soul|rock|pop|edm|ambient|downtempo|break|jungle|garage|electro|acid|minimal|deep|progressive)") . unwrap () }) }

- [ ] **Function 'normalize_genre' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/scripts/import-tool/src/main.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn normalize_genre (raw : & str) -> String { match raw { "hip hop" | "hiphop" | "hip-hop" => "hip-hop" . to_string () , "dnb" | "drum n bass" | "drum and bass" | "drum-n-bass" | "drum_n_bass" => { "dnb" . to_string () } , genre => genre . to_string () , } }

- [ ] **Function 'extract_genres_from_filename' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/scripts/import-tool/src/main.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn extract_genres_from_filename (filename : & str) -> Vec < String > { get_genre_regex () . find_iter (filename) . map (| m | m . as_str () . to_lowercase ()) . map (| g | normalize_genre (& g)) . collect () }

- [ ] **Function 'get_structure_regex' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/scripts/import-tool/src/main.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn get_structure_regex () -> & 'static Regex { STRUCTURE_REGEX . get_or_init (| | { Regex :: new (r"(?i)(verse|chorus|bridge|intro|outro|drop|build|breakdown|fill|loop|one.?shot|sample|melody|hook|riff|lick|main|full|short|long)") . unwrap () }) }

- [ ] **Function 'normalize_structure_tag' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/scripts/import-tool/src/main.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn normalize_structure_tag (raw : & str) -> String { match raw { "one shot" | "one-shot" | "oneshot" => "oneshot" . to_string () , tag => tag . to_string () , } }

- [ ] **Function 'extract_structure_tags' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/scripts/import-tool/src/main.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn extract_structure_tags (filename : & str) -> Vec < String > { get_structure_regex () . find_iter (filename) . map (| m | m . as_str () . to_lowercase ()) . map (| s | normalize_structure_tag (& s)) . collect () }

- [ ] **Function 'get_leading_number_regex' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/scripts/import-tool/src/main.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn get_leading_number_regex () -> & 'static Regex { LEADING_NUMBER_REGEX . get_or_init (| | Regex :: new (r"^([0-9]+)") . unwrap ()) }

- [ ] **Function 'extract_leading_number' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/scripts/import-tool/src/main.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn extract_leading_number (filename : & str) -> Option < i32 > { get_leading_number_regex () . captures (filename) . and_then (| caps | caps . get (1)) . and_then (| m | m . as_str () . parse :: < i32 > () . ok ()) }

- [ ] **Function 'calculate_metadata_source' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/scripts/import-tool/src/main.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Calculate metadata source based on what data is available"] fn calculate_metadata_source (filename_bpm : Option < f32 > , filename_key : Option < & str > , filename_genres : & [String] , structure_tags : & [String] ,) -> & 'static str { let has_filename_metadata = filename_bpm . is_some () || filename_key . is_some () || ! filename_genres . is_empty () || ! structure_tags . is_empty () ; if has_filename_metadata { "filename" } else { "none" } }

- [ ] **Function 'parse_midi_basic' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/scripts/import-tool/src/main.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Parse basic MIDI info (tracks and TPPQ)"] fn parse_midi_basic (data : & [u8]) -> (i16 , i32) { if data . len () < 14 || & data [0 .. 4] != b"MThd" { return (1 , 480) ; } let num_tracks = i16 :: from_be_bytes ([data [10] , data [11]]) ; let ticks = u16 :: from_be_bytes ([data [12] , data [13]]) ; (num_tracks , ticks as i32) }

- [ ] **Function 'count_notes' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/scripts/test-midi-files/src/main.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn count_notes (midi_file : & MidiFile) -> usize { midi_file . tracks . iter () . flat_map (| track | & track . events) . filter (| event | matches ! (event . event , Event :: NoteOn { .. })) . count () }

- [ ] **Function 'get_duration_ticks' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/scripts/test-midi-files/src/main.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn get_duration_ticks (midi_file : & MidiFile) -> u32 { midi_file . tracks . iter () . flat_map (| track | & track . events) . map (| event | event . delta_ticks) . sum () }

- [ ] **Function 'analyze_file' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/scripts/test-midi-files/src/main.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn analyze_file (file_path : & Path) -> Result < TestResult > { let start = Instant :: now () ; let file_name = file_path . file_name () . and_then (| n | n . to_str ()) . unwrap_or ("unknown") . to_string () ; println ! ("\nğŸ“„ Analyzing: {}" , file_name) ; let data = fs :: read (file_path) . context ("Failed to read file") ? ; let file_size = data . len () as u64 ; println ! ("  ğŸ“¦ Size: {} bytes" , file_size) ; let midi_file = parse_midi_file (& data) . context ("Failed to parse MIDI") ? ; println ! ("  âœ… Parse successful") ; let track_count = midi_file . tracks . len () ; let note_count = count_notes (& midi_file) ; let duration_ticks = get_duration_ticks (& midi_file) ; println ! ("  ğŸµ Tracks: {}" , track_count) ; println ! ("  ğŸ¹ Notes: {}" , note_count) ; let bpm_result = detect_bpm (& midi_file) ; let bpm = if bpm_result . confidence > 0.5 { Some (bpm_result . bpm) } else { None } ; if let Some (bpm_value) = bpm { println ! ("  â±ï¸  BPM: {:.1} (confidence: {:.1}%)" , bpm_value , bpm_result . confidence * 100.0) ; } else { println ! ("  âš ï¸  BPM: Not detected") ; } use midi_library_shared :: core :: analysis :: key_detector :: detect_key ; let key = detect_key (& midi_file) ; if let Some (ref key_str) = key { println ! ("  ğŸ¹ Key: {}" , key_str) ; } else { println ! ("  âš ï¸  Key: Unable to detect (low confidence or insufficient notes)") ; } let parse_time = start . elapsed () ; println ! ("  â±ï¸  Processing time: {}ms" , parse_time . as_millis ()) ; Ok (TestResult { file_path : file_path . to_string_lossy () . to_string () , file_name , success : true , error : None , file_size , parse_time_ms : parse_time . as_millis () , bpm , key , duration_ms : Some ((duration_ticks as u64 * 500) / 1000) , track_count : Some (track_count) , note_count : Some (note_count) , }) }

- [ ] **Function 'main' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/scripts/test-midi-files/src/main.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn main () -> Result < () > { let args : Vec < String > = env :: args () . collect () ; if args . len () < 2 { eprintln ! ("Usage: {} <midi_file1> [midi_file2] ..." , args [0]) ; eprintln ! ("       {} <directory>" , args [0]) ; std :: process :: exit (1) ; } let mut results = Vec :: new () ; let mut total_files = 0 ; let mut successful = 0 ; let mut failed = 0 ; let mut bpm_detected = 0 ; let mut key_detected = 0 ; let mut total_time_ms = 0u128 ; println ! ("ğŸµ MIDI Pipeline Real-World Testing") ; println ! ("====================================\n") ; for arg in & args [1 ..] { let path = Path :: new (arg) ; let files : Vec < _ > = if path . is_dir () { walkdir :: WalkDir :: new (path) . into_iter () . filter_map (| e | e . ok ()) . filter (| e | { e . path () . extension () . and_then (| s | s . to_str ()) . map (| s | s . eq_ignore_ascii_case ("mid") || s . eq_ignore_ascii_case ("midi")) . unwrap_or (false) }) . map (| e | e . path () . to_path_buf ()) . collect () } else { vec ! [path . to_path_buf ()] } ; for file_path in files { total_files += 1 ; match analyze_file (& file_path) { Ok (result) => { successful += 1 ; total_time_ms += result . parse_time_ms ; if result . bpm . is_some () { bpm_detected += 1 ; } if result . key . is_some () { key_detected += 1 ; } results . push (result) ; } , Err (e) => { failed += 1 ; println ! ("\nâŒ Error: {}" , e) ; results . push (TestResult { file_path : file_path . to_string_lossy () . to_string () , file_name : file_path . file_name () . and_then (| n | n . to_str ()) . unwrap_or ("unknown") . to_string () , success : false , error : Some (e . to_string ()) , file_size : 0 , parse_time_ms : 0 , bpm : None , key : None , duration_ms : None , track_count : None , note_count : None , }) ; } , } } } println ! ("\n") ; println ! ("ğŸ“Š SUMMARY") ; println ! ("====================================") ; println ! ("âœ… Files tested: {}" , total_files) ; println ! ("âœ… Successful parses: {} ({:.1}%)" , successful , (successful as f64 / total_files as f64) * 100.0) ; println ! ("âŒ Failed parses: {} ({:.1}%)" , failed , (failed as f64 / total_files as f64) * 100.0) ; println ! ("â±ï¸  BPM detection rate: {}/{} ({:.1}%)" , bpm_detected , total_files , (bpm_detected as f64 / total_files as f64) * 100.0) ; println ! ("ğŸ¼ Key detection rate: {}/{} ({:.1}%)" , key_detected , total_files , (key_detected as f64 / total_files as f64) * 100.0) ; if total_files > 0 { let avg_time = total_time_ms / total_files as u128 ; println ! ("â±ï¸  Average processing time: {}ms/file" , avg_time) ; println ! ("â±ï¸  Total processing time: {}ms" , total_time_ms) ; } println ! ("\n") ; println ! ("ğŸ¯ PRODUCTION READINESS ASSESSMENT") ; println ! ("====================================") ; let success_rate = (successful as f64 / total_files as f64) * 100.0 ; if success_rate >= 95.0 { println ! ("âœ… Parse success rate: EXCELLENT ({:.1}%)" , success_rate) ; } else if success_rate >= 85.0 { println ! ("âš ï¸  Parse success rate: ACCEPTABLE ({:.1}%)" , success_rate) ; } else { println ! ("âŒ Parse success rate: NEEDS IMPROVEMENT ({:.1}%)" , success_rate) ; } if total_files > 0 { let avg_time = total_time_ms / total_files as u128 ; if avg_time <= 100 { println ! ("âœ… Performance: EXCELLENT ({}ms avg)" , avg_time) ; } else if avg_time <= 500 { println ! ("âœ… Performance: GOOD ({}ms avg)" , avg_time) ; } else { println ! ("âš ï¸  Performance: NEEDS OPTIMIZATION ({}ms avg)" , avg_time) ; } } let results_json = serde_json :: to_string_pretty (& results) ? ; fs :: write ("/tmp/midi_test_results.json" , results_json) ? ; println ! ("\nğŸ“„ Detailed results written to: /tmp/midi_test_results.json") ; Ok (()) }

- [ ] **Function 'generate_tags' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/shared/rust/src/core/analysis/auto_tagger.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Auto-tagging functionality wrapper"] # [doc = ""] # [doc = " This is a simplified wrapper for the shared library."] # [doc = " The full implementation lives in the Pipeline component at"] # [doc = " `pipeline/src-tauri/src/core/analysis/auto_tagger.rs`"] # [doc = ""] # [doc = " Generates tags based on MIDI file content analysis including:"] # [doc = " - Instrument detection from GM program changes"] # [doc = " - Note density and patterns"] # [doc = " - Tempo characteristics (if BPM detected)"] # [doc = " - Channel usage patterns"] # [doc = ""] # [doc = " # Arguments"] # [doc = " * `midi_file` - Parsed MIDI file structure"] # [doc = ""] # [doc = " # Returns"] # [doc = " * `Vec<String>` - List of detected tags (e.g., \"drums\", \"piano\", \"fast\", \"melodic\")"] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " ```"] # [doc = " use midi_library_shared::core::midi::MidiFile;"] # [doc = " use midi_library_shared::core::analysis::auto_tagger::generate_tags;"] # [doc = ""] # [doc = " // let midi_file = MidiFile::parse(&data)?;"] # [doc = " // let tags = generate_tags(&midi_file);"] # [doc = " // println!(\"Tags: {:?}\", tags);"] # [doc = " ```"] pub fn generate_tags (midi_file : & crate :: core :: midi :: MidiFile) -> Vec < String > { let mut tags = Vec :: new () ; let mut instruments_seen = std :: collections :: HashSet :: new () ; let mut note_count = 0u32 ; for track in midi_file . tracks . iter () { for timed_event in & track . events { match & timed_event . event { crate :: core :: midi :: Event :: ProgramChange { channel , program } => { if * channel == 9 { instruments_seen . insert ("drums") ; } else { let instrument = map_gm_program_to_instrument (* program) ; instruments_seen . insert (instrument) ; } } , crate :: core :: midi :: Event :: NoteOn { channel , .. } => { if * channel == 9 { instruments_seen . insert ("drums") ; } note_count = note_count . saturating_add (1) ; } , crate :: core :: midi :: Event :: Text { text_type : _ , text } => { let text_lower = text . to_lowercase () ; if text_lower . contains ("rock") { tags . push ("rock" . to_string ()) ; } if text_lower . contains ("jazz") { tags . push ("jazz" . to_string ()) ; } if text_lower . contains ("classical") { tags . push ("classical" . to_string ()) ; } if text_lower . contains ("electronic") { tags . push ("electronic" . to_string ()) ; } } , _ => { } , } } } for instrument in instruments_seen { tags . push (instrument . to_string ()) ; } if note_count > 1000 { tags . push ("dense" . to_string ()) ; } else if note_count > 500 { tags . push ("moderate" . to_string ()) ; } else if note_count > 0 { tags . push ("sparse" . to_string ()) ; } let track_count = midi_file . tracks . len () ; if track_count > 10 { tags . push ("multi-track" . to_string ()) ; } else if track_count > 1 { tags . push ("layered" . to_string ()) ; } else { tags . push ("single-track" . to_string ()) ; } if let Some (tempo) = detect_average_tempo (midi_file) { if tempo > 140.0 { tags . push ("fast" . to_string ()) ; } else if tempo > 100.0 { tags . push ("moderate-tempo" . to_string ()) ; } else if tempo > 60.0 { tags . push ("slow" . to_string ()) ; } } tags }

- [ ] **Function 'map_gm_program_to_instrument' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/shared/rust/src/core/analysis/auto_tagger.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Map GM program numbers to instrument names"] fn map_gm_program_to_instrument (program : u8) -> & 'static str { match program { 0 ..= 7 => "piano" , 8 ..= 15 => "chromatic-percussion" , 16 ..= 23 => "organ" , 24 ..= 31 => "guitar" , 32 ..= 39 => "bass" , 40 ..= 47 => "strings" , 48 ..= 55 => "ensemble" , 56 ..= 63 => "brass" , 64 ..= 71 => "reed" , 72 ..= 79 => "pipe" , 80 ..= 87 => "synth-lead" , 88 ..= 95 => "synth-pad" , 96 ..= 103 => "synth-effects" , 104 ..= 111 => "ethnic" , 112 ..= 119 => "percussive" , 120 ..= 127 => "sound-effects" , _ => "unknown" , } }

- [ ] **Function 'detect_average_tempo' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/shared/rust/src/core/analysis/auto_tagger.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Detect average tempo from MIDI tempo events"] fn detect_average_tempo (midi_file : & crate :: core :: midi :: MidiFile) -> Option < f64 > { let mut tempo_sum = 0.0 ; let mut tempo_count = 0 ; for track in & midi_file . tracks { for timed_event in & track . events { if let crate :: core :: midi :: Event :: TempoChange { microseconds_per_quarter } = & timed_event . event { let bpm = 60_000_000.0 / (* microseconds_per_quarter as f64) ; tempo_sum += bpm ; tempo_count += 1 ; } } } if tempo_count > 0 { Some (tempo_sum / tempo_count as f64) } else { None } }

- [ ] **Function 'detect_bpm' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/shared/rust/src/core/analysis/bpm_detector.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Detects BPM from a parsed MIDI file"] # [doc = ""] # [doc = " # Arguments"] # [doc = " * `midi_file` - Parsed MIDI file structure"] # [doc = ""] # [doc = " # Returns"] # [doc = " * `BpmDetectionResult` - Detection result with confidence and metadata"] # [doc = ""] # [doc = " # Examples"] # [doc = " ```ignore"] # [doc = " use midi_library_shared::core::analysis::bpm_detector::detect_bpm;"] # [doc = " use midi_library_shared::core::midi::types::MidiFile;"] # [doc = ""] # [doc = " let result = detect_bpm(&midi_file);"] # [doc = " println!(\"Detected BPM: {:.2}\", result.bpm);"] # [doc = " ```"] pub fn detect_bpm (midi_file : & MidiFile) -> BpmDetectionResult { let tempo_events = extract_tempo_events (midi_file) ; if tempo_events . is_empty () { return BpmDetectionResult { bpm : DEFAULT_BPM , confidence : 0.3 , method : BpmDetectionMethod :: DefaultTempo , metadata : BpmMetadata { tempo_changes : vec ! [] , is_constant : true , tempo_range : None } , } ; } let tempo_changes : Vec < TempoChange > = tempo_events . into_iter () . map (| (tick , microseconds_per_quarter) | TempoChange { tick , bpm : microseconds_to_bpm (microseconds_per_quarter) , }) . collect () ; let is_constant = tempo_changes . len () == 1 ; let bpms : Vec < f64 > = tempo_changes . iter () . map (| tc | tc . bpm) . collect () ; let total_ticks = calculate_total_ticks (midi_file) ; let avg_bpm = calculate_weighted_average (& tempo_changes , total_ticks) ; let tempo_range = if tempo_changes . len () > 1 { let min = bpms . iter () . cloned () . fold (f64 :: INFINITY , f64 :: min) ; let max = bpms . iter () . cloned () . fold (f64 :: NEG_INFINITY , f64 :: max) ; Some ((min , max)) } else { None } ; let confidence = calculate_confidence (& tempo_changes) ; let method = if tempo_changes . len () == 1 { BpmDetectionMethod :: SingleTempo } else { BpmDetectionMethod :: WeightedAverage } ; BpmDetectionResult { bpm : avg_bpm , confidence , method , metadata : BpmMetadata { tempo_changes , is_constant , tempo_range } , } }

- [ ] **Function 'extract_tempo_events' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/shared/rust/src/core/analysis/bpm_detector.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Extracts tempo events from all tracks in the MIDI file"] fn extract_tempo_events (midi_file : & MidiFile) -> Vec < (u32 , u32) > { let mut tempo_events = Vec :: new () ; for track in & midi_file . tracks { let mut current_tick = 0u32 ; for timed_event in & track . events { current_tick = current_tick . saturating_add (timed_event . delta_ticks) ; if let Event :: TempoChange { microseconds_per_quarter } = timed_event . event { tempo_events . push ((current_tick , microseconds_per_quarter)) ; } } } tempo_events . sort_by_key (| (tick , _) | * tick) ; tempo_events }

- [ ] **Function 'calculate_total_ticks' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/shared/rust/src/core/analysis/bpm_detector.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Calculates the total number of ticks in the MIDI file"] fn calculate_total_ticks (midi_file : & MidiFile) -> u32 { let mut max_ticks = 0u32 ; for track in & midi_file . tracks { let mut track_ticks = 0u32 ; for timed_event in & track . events { track_ticks = track_ticks . saturating_add (timed_event . delta_ticks) ; } max_ticks = max_ticks . max (track_ticks) ; } max_ticks }

- [ ] **Function 'microseconds_to_bpm' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/shared/rust/src/core/analysis/bpm_detector.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Converts microseconds per quarter note to BPM"] fn microseconds_to_bpm (microseconds_per_quarter : u32) -> f64 { if microseconds_per_quarter == 0 { return DEFAULT_BPM ; } let bpm = 60_000_000.0 / microseconds_per_quarter as f64 ; bpm . clamp (MIN_BPM , MAX_BPM) }

- [ ] **Function 'calculate_weighted_average' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/shared/rust/src/core/analysis/bpm_detector.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Calculates weighted average BPM based on duration each tempo is active"] fn calculate_weighted_average (tempo_changes : & [TempoChange] , total_ticks : u32) -> f64 { if tempo_changes . is_empty () { return DEFAULT_BPM ; } if tempo_changes . len () == 1 { return tempo_changes [0] . bpm ; } let mut weighted_sum = 0.0 ; let mut total_weight = 0.0 ; for (i , tempo_change) in tempo_changes . iter () . enumerate () { let duration = if i + 1 < tempo_changes . len () { tempo_changes [i + 1] . tick - tempo_change . tick } else { total_ticks . saturating_sub (tempo_change . tick) } ; let weight = duration as f64 ; weighted_sum += tempo_change . bpm * weight ; total_weight += weight ; } if total_weight > 0.0 { weighted_sum / total_weight } else { tempo_changes [0] . bpm } }

- [ ] **Function 'calculate_confidence' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/shared/rust/src/core/analysis/bpm_detector.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Calculates confidence score based on tempo consistency"] fn calculate_confidence (tempo_changes : & [TempoChange]) -> f64 { if tempo_changes . is_empty () { return 0.3 ; } if tempo_changes . len () == 1 { return 1.0 ; } let bpms : Vec < f64 > = tempo_changes . iter () . map (| tc | tc . bpm) . collect () ; let mean = bpms . iter () . sum :: < f64 > () / bpms . len () as f64 ; let variance = bpms . iter () . map (| bpm | (bpm - mean) . powi (2)) . sum :: < f64 > () / bpms . len () as f64 ; let std_dev = variance . sqrt () ; let cv = std_dev / mean ; (1.0 - cv) . clamp (0.5 , 1.0) }

- [ ] **Function 'create_test_midi_with_tempos' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/shared/rust/src/core/analysis/bpm_detector.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Create a MIDI file with specific tempo events"] # [doc = " Each tuple is (tick, microseconds_per_quarter)"] # [doc = " If total_ticks is Some(n), extends file to n ticks with EndOfTrack"] fn create_test_midi_with_tempos (tempos : Vec < (u32 , u32) > , total_ticks : Option < u32 >) -> MidiFile { let mut events : Vec < TimedEvent > = Vec :: new () ; let mut last_tick = 0u32 ; for (tick , microseconds) in tempos { let delta = tick - last_tick ; events . push (TimedEvent { delta_ticks : delta , event : Event :: TempoChange { microseconds_per_quarter : microseconds } , }) ; last_tick = tick ; } let eot_delta = if let Some (total) = total_ticks { total . saturating_sub (last_tick) } else { 0 } ; events . push (TimedEvent { delta_ticks : eot_delta , event : Event :: EndOfTrack }) ; MidiFile { header : Header { format : 1 , num_tracks : 1 , ticks_per_quarter_note : 480 } , tracks : vec ! [Track { events }] , } }

- [ ] **Function 'create_midi_no_tempo' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/shared/rust/src/core/analysis/bpm_detector.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Create a MIDI file with no tempo events"] fn create_midi_no_tempo (num_tracks : u16) -> MidiFile { let mut tracks = Vec :: new () ; for _ in 0 .. num_tracks { tracks . push (Track { events : vec ! [TimedEvent { delta_ticks : 1000 , event : Event :: EndOfTrack }] , }) ; } MidiFile { header : Header { format : 1 , num_tracks , ticks_per_quarter_note : 480 } , tracks } }

- [ ] **Function 'create_midi_with_length' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/shared/rust/src/core/analysis/bpm_detector.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Create a MIDI file with specific length (total ticks)"] fn create_midi_with_length (total_ticks : u32) -> MidiFile { MidiFile { header : Header { format : 1 , num_tracks : 1 , ticks_per_quarter_note : 480 } , tracks : vec ! [Track { events : vec ! [TimedEvent { delta_ticks : total_ticks , event : Event :: EndOfTrack }] , }] , } }

- [ ] **Function 'assert_bpm_approx_eq' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/shared/rust/src/core/analysis/bpm_detector.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Assert BPM is approximately equal (floating point tolerance)"] fn assert_bpm_approx_eq (actual : f64 , expected : f64 , tolerance : f64) { assert ! ((actual - expected) . abs () < tolerance , "BPM mismatch: expected {}, got {} (tolerance: {})" , expected , actual , tolerance) ; }

- [ ] **Function 'detect_key' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/shared/rust/src/core/analysis/key_detector.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Key detection wrapper"] # [doc = ""] # [doc = " This is a simplified wrapper for the shared library."] # [doc = " The full implementation lives in the Pipeline component at"] # [doc = " `pipeline/src-tauri/src/core/analysis/key_detector.rs`"] # [doc = ""] # [doc = " Returns the detected key as a string (e.g., \"C\", \"Am\", \"F#\")"] # [doc = " or None if detection confidence is too low."] # [doc = ""] # [doc = " # Arguments"] # [doc = " * `midi_file` - Parsed MIDI file structure"] # [doc = ""] # [doc = " # Returns"] # [doc = " * `Some(String)` - Detected key (e.g., \"C major\", \"A minor\")"] # [doc = " * `None` - No clear key detected (confidence < 0.5)"] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " ```"] # [doc = " use midi_library_shared::core::midi::MidiFile;"] # [doc = " use midi_library_shared::core::analysis::key_detector::detect_key;"] # [doc = ""] # [doc = " // let midi_file = MidiFile::parse(&data)?;"] # [doc = " // if let Some(key) = detect_key(&midi_file) {"] # [doc = " //     println!(\"Detected key: {}\", key);"] # [doc = " // }"] # [doc = " ```"] pub fn detect_key (midi_file : & crate :: core :: midi :: MidiFile) -> Option < String > { let mut pitch_class_counts = [0u32 ; 12] ; for track in & midi_file . tracks { for timed_event in & track . events { if let crate :: core :: midi :: Event :: NoteOn { note , .. } = & timed_event . event { let pitch_class = (note % 12) as usize ; pitch_class_counts [pitch_class] = pitch_class_counts [pitch_class] . saturating_add (1) ; } } } let total_notes : u32 = pitch_class_counts . iter () . sum () ; if total_notes < 10 { return None ; } let mut pitch_class_dist = [0.0 ; 12] ; for (i , & count) in pitch_class_counts . iter () . enumerate () { pitch_class_dist [i] = count as f64 / total_notes as f64 ; } const MAJOR_PROFILE : [f64 ; 12] = [6.35 , 2.23 , 3.48 , 2.33 , 4.38 , 4.09 , 2.52 , 5.19 , 2.39 , 3.66 , 2.29 , 2.88] ; const MINOR_PROFILE : [f64 ; 12] = [6.33 , 2.68 , 3.52 , 5.38 , 2.60 , 3.53 , 2.54 , 4.75 , 3.98 , 2.69 , 3.34 , 3.17] ; let mut best_correlation = - 1.0 ; let mut best_key = String :: new () ; const NOTE_NAMES : [& str ; 12] = ["C" , "C#" , "D" , "D#" , "E" , "F" , "F#" , "G" , "G#" , "A" , "A#" , "B"] ; for (root , note_name) in NOTE_NAMES . iter () . enumerate () { let major_corr = calculate_correlation (& pitch_class_dist , & MAJOR_PROFILE , root) ; if major_corr > best_correlation { best_correlation = major_corr ; best_key = format ! ("{} major" , note_name) ; } let minor_corr = calculate_correlation (& pitch_class_dist , & MINOR_PROFILE , root) ; if minor_corr > best_correlation { best_correlation = minor_corr ; best_key = format ! ("{} minor" , note_name) ; } } if best_correlation > 0.5 { Some (best_key) } else { None } }

- [ ] **Function 'calculate_correlation' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/shared/rust/src/core/analysis/key_detector.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Calculate Pearson correlation between pitch class distribution and key profile"] fn calculate_correlation (distribution : & [f64 ; 12] , profile : & [f64 ; 12] , rotation : usize) -> f64 { let mut rotated = [0.0 ; 12] ; for i in 0 .. 12 { rotated [i] = profile [(i + rotation) % 12] ; } let dist_mean : f64 = distribution . iter () . sum :: < f64 > () / 12.0 ; let prof_mean : f64 = rotated . iter () . sum :: < f64 > () / 12.0 ; let mut numerator = 0.0 ; let mut dist_sq_sum = 0.0 ; let mut prof_sq_sum = 0.0 ; for i in 0 .. 12 { let dist_diff = distribution [i] - dist_mean ; let prof_diff = rotated [i] - prof_mean ; numerator += dist_diff * prof_diff ; dist_sq_sum += dist_diff * dist_diff ; prof_sq_sum += prof_diff * prof_diff ; } let denominator = (dist_sq_sum * prof_sq_sum) . sqrt () ; if denominator > 0.0 { numerator / denominator } else { 0.0 } }

- [ ] **Function 'rotate_profile' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/shared/rust/src/core/analysis/key_profiles.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Rotate a profile array by the specified number of semitones."] # [doc = ""] # [doc = " This is used to test different key centers by rotating the profile"] # [doc = " so that each pitch class can become the tonic."] # [doc = ""] # [doc = " # Arguments"] # [doc = " * `profile` - The base profile array (length 12)"] # [doc = " * `rotation` - Number of semitones to rotate (0-11)"] # [doc = ""] # [doc = " # Returns"] # [doc = " Rotated profile array"] pub fn rotate_profile (profile : & [f64 ; 12] , rotation : usize) -> [f64 ; 12] { let mut rotated = [0.0 ; 12] ; for i in 0 .. 12 { rotated [i] = profile [(i + rotation) % 12] ; } rotated }

- [ ] **Function 'get_profiles_for_genre' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/shared/rust/src/core/analysis/key_profiles.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Get the appropriate profile for a given genre and scale type."] # [doc = ""] # [doc = " Returns a tuple of (major_profile, minor_profile) for the genre."] # [doc = " If the genre is not recognized, returns the standard Krumhansl profiles."] pub fn get_profiles_for_genre (genre : & str) -> (& 'static [f64 ; 12] , & 'static [f64 ; 12]) { match genre . to_lowercase () . as_str () { "techno" | "house" | "edm" | "electronic" | "dance" => { (& EDM_PROFILE , & EDM_PROFILE) } , "drum and bass" | "dnb" | "jungle" => (& DRUM_AND_BASS_PROFILE , & DRUM_AND_BASS_PROFILE) , "trance" | "progressive" | "progressive house" => (& TRANCE_PROFILE , & TRANCE_PROFILE) , "hiphop" | "hip-hop" | "trap" | "rap" => (& HIPHOP_PROFILE , & HIPHOP_PROFILE) , "ambient" | "chillout" | "downtempo" => (& AMBIENT_PROFILE , & AMBIENT_PROFILE) , "blues" | "rock" | "rock and roll" => (& BLUES_PROFILE , & BLUES_PROFILE) , "jazz" | "fusion" | "bebop" => (& JAZZ_MAJOR_PROFILE , & JAZZ_MINOR_PROFILE) , "classical" | "romantic" | "baroque" => (& CLASSICAL_PROFILE , & CLASSICAL_PROFILE) , "pop" | "popular" | "top 40" => (& POP_PROFILE , & POP_PROFILE) , _ => { (& KRUMHANSL_MAJOR_PROFILE , & KRUMHANSL_MINOR_PROFILE) } , } }

- [ ] **Function 'get_all_profiles' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/shared/rust/src/core/analysis/key_profiles.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Get all available profile types as a vector of (name, major_profile, minor_profile)."] pub fn get_all_profiles () -> Vec < (& 'static str , & 'static [f64 ; 12] , & 'static [f64 ; 12]) > { vec ! [("Krumhansl" , & KRUMHANSL_MAJOR_PROFILE , & KRUMHANSL_MINOR_PROFILE ,) , ("Temperley" , & TEMPERLEY_MAJOR_PROFILE , & TEMPERLEY_MINOR_PROFILE ,) , ("Simple" , & SIMPLE_MAJOR_PROFILE , & SIMPLE_MINOR_PROFILE) , ("EDM" , & EDM_PROFILE , & EDM_PROFILE) , ("Drum & Bass" , & DRUM_AND_BASS_PROFILE , & DRUM_AND_BASS_PROFILE ,) , ("Trance" , & TRANCE_PROFILE , & TRANCE_PROFILE) , ("Hip-Hop" , & HIPHOP_PROFILE , & HIPHOP_PROFILE) , ("Ambient" , & AMBIENT_PROFILE , & AMBIENT_PROFILE) , ("Blues" , & BLUES_PROFILE , & BLUES_PROFILE) , ("Jazz" , & JAZZ_MAJOR_PROFILE , & JAZZ_MINOR_PROFILE) , ("Classical" , & CLASSICAL_PROFILE , & CLASSICAL_PROFILE) , ("Pop" , & POP_PROFILE , & POP_PROFILE) ,] }

- [ ] **Function 'normalize_profile' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/shared/rust/src/core/analysis/key_profiles.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Normalize a profile so that its values sum to 1.0."] # [doc = ""] # [doc = " This is useful for converting profile weights to probability distributions."] pub fn normalize_profile (profile : & [f64 ; 12]) -> [f64 ; 12] { let sum : f64 = profile . iter () . sum () ; if sum . abs () < f64 :: EPSILON { return [1.0 / 12.0 ; 12] ; } let mut normalized = [0.0 ; 12] ; for i in 0 .. 12 { normalized [i] = profile [i] / sum ; } normalized }

- [ ] **Function 'combine_profiles' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/shared/rust/src/core/analysis/key_profiles.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Create a weighted combination of multiple profiles."] # [doc = ""] # [doc = " Useful for creating custom profiles that blend characteristics"] # [doc = " of multiple base profiles."] # [doc = ""] # [doc = " # Arguments"] # [doc = " * `profiles` - Slice of profile arrays"] # [doc = " * `weights` - Corresponding weights for each profile"] # [doc = ""] # [doc = " # Returns"] # [doc = " Combined profile array"] pub fn combine_profiles (profiles : & [& [f64 ; 12]] , weights : & [f64]) -> [f64 ; 12] { assert_eq ! (profiles . len () , weights . len () , "Profiles and weights must have same length") ; let mut combined = [0.0 ; 12] ; let weight_sum : f64 = weights . iter () . sum () ; for i in 0 .. 12 { for (profile_idx , & profile) in profiles . iter () . enumerate () { combined [i] += profile [i] * weights [profile_idx] ; } if weight_sum . abs () > f64 :: EPSILON { combined [i] /= weight_sum ; } } combined }

- [ ] **Function 'calculate_profile_strength' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/shared/rust/src/core/analysis/key_profiles.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Calculate the \"profile strength\" - how strongly a profile defines a key."] # [doc = ""] # [doc = " Returns a value between 0.0 and 1.0 where higher values indicate"] # [doc = " profiles that give more unambiguous key predictions."] pub fn calculate_profile_strength (profile : & [f64 ; 12]) -> f64 { let normalized = normalize_profile (profile) ; let max_weight = normalized . iter () . fold (f64 :: NEG_INFINITY , | a , & b | a . max (b)) ; let min_weight = normalized . iter () . fold (f64 :: INFINITY , | a , & b | a . min (b)) ; (max_weight - min_weight) . clamp (0.0 , 1.0) }

- [ ] **Function 'get_scale_degree_weights' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/shared/rust/src/core/analysis/key_profiles.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Get the scale degree weights for a profile at a specific key."] # [doc = ""] # [doc = " Returns an array where index 0 is the tonic weight, index 1 is the minor 2nd, etc."] # [doc = " Rotated appropriately for the specified key."] pub fn get_scale_degree_weights (profile : & [f64 ; 12] , tonic_pitch_class : usize) -> [f64 ; 12] { rotate_profile (profile , tonic_pitch_class) }

- [ ] **Function 'detect_profile_type' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/shared/rust/src/core/analysis/key_profiles.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Detect the most likely profile type for a given pitch distribution."] # [doc = ""] # [doc = " Compares the distribution against all known profiles and returns"] # [doc = " the best match along with a confidence score."] pub fn detect_profile_type (pitch_distribution : & [f64 ; 12]) -> (ProfileType , f64) { let profile_groups = [(ProfileType :: Major , & KRUMHANSL_MAJOR_PROFILE) , (ProfileType :: Minor , & KRUMHANSL_MINOR_PROFILE) , (ProfileType :: Blues , & BLUES_PROFILE) , (ProfileType :: Jazz , & JAZZ_MAJOR_PROFILE) , (ProfileType :: Electronic , & EDM_PROFILE) , (ProfileType :: Classical , & CLASSICAL_PROFILE) , (ProfileType :: Pop , & POP_PROFILE) ,] ; let mut best_match = ProfileType :: Major ; let mut best_correlation = f64 :: NEG_INFINITY ; for (profile_type , profile) in profile_groups { let correlation = calculate_profile_correlation (pitch_distribution , profile) ; if correlation > best_correlation { best_correlation = correlation ; best_match = profile_type ; } } (best_match , best_correlation) }

- [ ] **Function 'calculate_profile_correlation' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/shared/rust/src/core/analysis/key_profiles.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Calculate Pearson correlation between a pitch distribution and a profile."] # [doc = ""] # [doc = " Helper function used by `detect_profile_type`."] pub fn calculate_profile_correlation (distribution : & [f64 ; 12] , profile : & [f64 ; 12]) -> f64 { let dist_mean : f64 = distribution . iter () . sum :: < f64 > () / 12.0 ; let prof_mean : f64 = profile . iter () . sum :: < f64 > () / 12.0 ; let mut numerator = 0.0 ; let mut dist_sq_sum = 0.0 ; let mut prof_sq_sum = 0.0 ; for i in 0 .. 12 { let dist_diff = distribution [i] - dist_mean ; let prof_diff = profile [i] - prof_mean ; numerator += dist_diff * prof_diff ; dist_sq_sum += dist_diff * dist_diff ; prof_sq_sum += prof_diff * prof_diff ; } let denominator = (dist_sq_sum * prof_sq_sum) . sqrt () ; if denominator > 0.0 { numerator / denominator } else { 0.0 } }

- [ ] **Function 'create_key_profile' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/shared/rust/src/core/analysis/key_profiles.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Create a KeyProfile struct from raw weights."] pub fn create_key_profile (name : & str , weights : [f64 ; 12] , profile_type : ProfileType) -> KeyProfile { KeyProfile { name : name . to_string () , weights , description : match profile_type { ProfileType :: Major => Some ("Standard major key profile" . to_string ()) , ProfileType :: Minor => Some ("Standard minor key profile" . to_string ()) , ProfileType :: Blues => Some ("Blues/rock profile emphasizing blue notes" . to_string ()) , ProfileType :: Jazz => Some ("Jazz profile with extended harmonies" . to_string ()) , ProfileType :: Electronic => { Some ("Electronic music profile with strong root/fifth" . to_string ()) } , ProfileType :: Classical => Some ("Classical/romantic era profile" . to_string ()) , ProfileType :: Pop => Some ("Contemporary pop music profile" . to_string ()) , ProfileType :: Custom => Some ("Custom user-defined profile" . to_string ()) , } , profile_type , } }

- [ ] **Function 'get_default_profile' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/shared/rust/src/core/analysis/key_profiles.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Get the default Krumhansl key profile."] pub fn get_default_profile () -> KeyProfile { create_key_profile ("Krumhansl Major" , KRUMHANSL_MAJOR_PROFILE , ProfileType :: Major ,) }

- [ ] **Function 'approx_eq' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/shared/rust/src/core/analysis/key_profiles.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Helper function to check if two floats are approximately equal"] fn approx_eq (a : f64 , b : f64 , epsilon : f64) -> bool { (a - b) . abs () < epsilon }

- [ ] **Function 'parse_midi_file' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/shared/rust/src/core/midi/parser.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Parse a MIDI file from raw bytes"] # [doc = ""] # [doc = " This is the main entry point for MIDI parsing. It accepts raw file bytes"] # [doc = " and returns a structured MidiFile or an error."] # [doc = ""] # [doc = " # Examples"] # [doc = " ```ignore"] # [doc = " use midi_library_shared::core::midi::parse_midi_file;"] # [doc = ""] # [doc = " let data = std::fs::read(\"song.mid\").unwrap();"] # [doc = " let midi_file = parse_midi_file(&data)?;"] # [doc = " println!(\"Format: {}, Tracks: {}\", midi_file.header.format, midi_file.header.num_tracks);"] # [doc = " # Ok::<(), Box<dyn std::error::Error>>(())"] # [doc = " ```"] pub fn parse_midi_file (data : & [u8]) -> Result < MidiFile > { if data . len () < 14 { return Err (MidiParseError :: IncompleteData { expected : 14 , actual : data . len () }) ; } let header = parse_header (& data [0 .. 14]) ? ; let mut tracks = Vec :: with_capacity (header . num_tracks as usize) ; let mut pos = 14 ; for track_num in 0 .. header . num_tracks { let (track , bytes_read) = parse_track (& data [pos ..]) . map_err (| e | match e { MidiParseError :: InvalidTrack { position , reason } => MidiParseError :: InvalidTrack { position : pos + position , reason : format ! ("Track {}: {}" , track_num , reason) , } , e => e , }) ? ; tracks . push (track) ; pos += bytes_read ; } Ok (MidiFile { header , tracks }) }

- [ ] **Function 'parse_header' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/shared/rust/src/core/midi/parser.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Parse MIDI header chunk (MThd)"] fn parse_header (data : & [u8]) -> Result < Header > { if & data [0 .. 4] != b"MThd" { return Err (MidiParseError :: InvalidHeader (format ! ("Expected 'MThd', got {:?}" , & data [0 .. 4]))) ; } let length = u32 :: from_be_bytes ([data [4] , data [5] , data [6] , data [7]]) ; if length != 6 { return Err (MidiParseError :: InvalidHeader (format ! ("Expected header length 6, got {}" , length))) ; } let format = u16 :: from_be_bytes ([data [8] , data [9]]) ; let num_tracks = u16 :: from_be_bytes ([data [10] , data [11]]) ; let ticks_per_quarter_note = u16 :: from_be_bytes ([data [12] , data [13]]) ; if format > 2 { return Err (MidiParseError :: UnsupportedFormat (format)) ; } Ok (Header { format , num_tracks , ticks_per_quarter_note }) }

- [ ] **Function 'parse_track' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/shared/rust/src/core/midi/parser.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Parse a single MIDI track (MTrk)"] # [doc = " Returns (Track, bytes_consumed)"] fn parse_track (data : & [u8]) -> Result < (Track , usize) > { if data . len () < 8 { return Err (MidiParseError :: InvalidTrack { position : 0 , reason : "Track too short" . to_string () , }) ; } if & data [0 .. 4] != b"MTrk" { return Err (MidiParseError :: InvalidTrack { position : 0 , reason : format ! ("Expected 'MTrk', got {:?}" , & data [0 .. 4]) , }) ; } let track_length = u32 :: from_be_bytes ([data [4] , data [5] , data [6] , data [7]]) as usize ; if data . len () < 8 + track_length { return Err (MidiParseError :: InvalidTrack { position : 0 , reason : format ! ("Track data incomplete: expected {} bytes, got {}" , track_length , data . len () - 8) , }) ; } let track_data = & data [8 .. 8 + track_length] ; let events = parse_track_events (track_data) ? ; Ok ((Track { events } , 8 + track_length)) }

- [ ] **Function 'parse_track_events' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/shared/rust/src/core/midi/parser.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Parse all events within a track"] fn parse_track_events (data : & [u8]) -> Result < Vec < TimedEvent > > { let mut events = Vec :: new () ; let mut pos = 0 ; let mut running_status : Option < u8 > = None ; while pos < data . len () { let (delta_ticks , delta_bytes) = read_var_len (& data [pos ..]) . ok_or (MidiParseError :: InvalidVarLen (pos)) ? ; pos += delta_bytes ; let (event , event_bytes , new_running_status) = parse_event (& data [pos ..] , running_status) . map_err (| e | match e { MidiParseError :: InvalidEvent { position , reason } => { MidiParseError :: InvalidEvent { position : pos + position , reason } } , e => e , }) ? ; pos += event_bytes ; running_status = new_running_status ; events . push (TimedEvent { delta_ticks , event }) ; if matches ! (events . last () , Some (TimedEvent { event : Event :: EndOfTrack , .. })) { break ; } } Ok (events) }

- [ ] **Function 'parse_event' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/shared/rust/src/core/midi/parser.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Parse a single MIDI event"] # [doc = " Returns (Event, bytes_consumed, new_running_status)"] fn parse_event (data : & [u8] , running_status : Option < u8 >) -> Result < (Event , usize , Option < u8 >) > { if data . is_empty () { return Err (MidiParseError :: InvalidEvent { position : 0 , reason : "No data for event" . to_string () , }) ; } let mut status = data [0] ; let mut pos = 1 ; if status < 0x80 { if let Some (rs) = running_status { status = rs ; pos = 0 ; } else { return Err (MidiParseError :: InvalidEvent { position : 0 , reason : "Data byte without running status" . to_string () , }) ; } } let event_type = status & 0xF0 ; let channel = status & 0x0F ; match event_type { 0x80 => { if data . len () < pos + 2 { return Err (MidiParseError :: IncompleteData { expected : pos + 2 , actual : data . len () , }) ; } Ok ((Event :: NoteOff { channel , note : data [pos] , velocity : data [pos + 1] } , pos + 2 , Some (status) ,)) } , 0x90 => { if data . len () < pos + 2 { return Err (MidiParseError :: IncompleteData { expected : pos + 2 , actual : data . len () , }) ; } Ok ((Event :: NoteOn { channel , note : data [pos] , velocity : data [pos + 1] } , pos + 2 , Some (status) ,)) } , 0xA0 => { if data . len () < pos + 2 { return Err (MidiParseError :: IncompleteData { expected : pos + 2 , actual : data . len () , }) ; } Ok ((Event :: Aftertouch { channel , note : data [pos] , pressure : data [pos + 1] } , pos + 2 , Some (status) ,)) } , 0xB0 => { if data . len () < pos + 2 { return Err (MidiParseError :: IncompleteData { expected : pos + 2 , actual : data . len () , }) ; } Ok ((Event :: ControlChange { channel , controller : data [pos] , value : data [pos + 1] } , pos + 2 , Some (status) ,)) } , 0xC0 => { if data . len () < pos + 1 { return Err (MidiParseError :: IncompleteData { expected : pos + 1 , actual : data . len () , }) ; } Ok ((Event :: ProgramChange { channel , program : data [pos] } , pos + 1 , Some (status) ,)) } , 0xD0 => { if data . len () < pos + 1 { return Err (MidiParseError :: IncompleteData { expected : pos + 1 , actual : data . len () , }) ; } Ok ((Event :: ChannelAftertouch { channel , pressure : data [pos] } , pos + 1 , Some (status) ,)) } , 0xE0 => { if data . len () < pos + 2 { return Err (MidiParseError :: IncompleteData { expected : pos + 2 , actual : data . len () , }) ; } let lsb = data [pos] as i16 ; let msb = data [pos + 1] as i16 ; let value = ((msb << 7) | lsb) - 8192 ; Ok ((Event :: PitchBend { channel , value } , pos + 2 , Some (status))) } , 0xF0 => { parse_meta_or_sysex (& data [pos - 1 ..]) } , _ => Err (MidiParseError :: InvalidEvent { position : 0 , reason : format ! ("Unknown event type: 0x{:02X}" , status) , }) , } }

- [ ] **Function 'parse_meta_or_sysex' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/shared/rust/src/core/midi/parser.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Parse meta events and SysEx"] fn parse_meta_or_sysex (data : & [u8]) -> Result < (Event , usize , Option < u8 >) > { let status = data [0] ; match status { 0xFF => { if data . len () < 2 { return Err (MidiParseError :: IncompleteData { expected : 2 , actual : data . len () }) ; } let meta_type = data [1] ; let (length , len_bytes) = read_var_len (& data [2 ..]) . ok_or (MidiParseError :: InvalidVarLen (2)) ? ; let data_start = 2 + len_bytes ; let data_end = data_start + length as usize ; if data . len () < data_end { return Err (MidiParseError :: IncompleteData { expected : data_end , actual : data . len () , }) ; } let event_data = & data [data_start .. data_end] ; let event = match meta_type { 0x2F => Event :: EndOfTrack , 0x51 => { if event_data . len () != 3 { return Err (MidiParseError :: InvalidEvent { position : 0 , reason : "Tempo event must be 3 bytes" . to_string () , }) ; } let microseconds_per_quarter = u32 :: from_be_bytes ([0 , event_data [0] , event_data [1] , event_data [2]]) ; Event :: TempoChange { microseconds_per_quarter } } , 0x58 => { if event_data . len () != 4 { return Err (MidiParseError :: InvalidEvent { position : 0 , reason : "Time signature event must be 4 bytes" . to_string () , }) ; } Event :: TimeSignature { numerator : event_data [0] , denominator : event_data [1] , clocks_per_click : event_data [2] , thirty_seconds_per_quarter : event_data [3] , } } , 0x59 => { if event_data . len () != 2 { return Err (MidiParseError :: InvalidEvent { position : 0 , reason : "Key signature event must be 2 bytes" . to_string () , }) ; } Event :: KeySignature { sharps_flats : event_data [0] as i8 , is_minor : event_data [1] != 0 , } } , 0x01 ..= 0x0F => { let text = String :: from_utf8_lossy (event_data) . to_string () ; let text_type = match meta_type { 0x01 => TextType :: Text , 0x02 => TextType :: Copyright , 0x03 => TextType :: TrackName , 0x04 => TextType :: InstrumentName , 0x05 => TextType :: Lyric , 0x06 => TextType :: Marker , 0x07 => TextType :: CuePoint , _ => TextType :: Text , } ; Event :: Text { text_type , text } } , _ => Event :: Unknown { status , data : event_data . to_vec () } , } ; Ok ((event , data_end , None)) } , 0xF0 | 0xF7 => { let (length , len_bytes) = read_var_len (& data [1 ..]) . ok_or (MidiParseError :: InvalidVarLen (1)) ? ; let data_start = 1 + len_bytes ; let data_end = data_start + length as usize ; if data . len () < data_end { return Err (MidiParseError :: IncompleteData { expected : data_end , actual : data . len () , }) ; } Ok ((Event :: SysEx { data : data [data_start .. data_end] . to_vec () } , data_end , None ,)) } , _ => Err (MidiParseError :: InvalidEvent { position : 0 , reason : format ! ("Unknown system event: 0x{:02X}" , status) , }) , } }

- [ ] **Function 'read_var_len' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/shared/rust/src/core/midi/parser.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Read a MIDI variable-length quantity"] # [doc = " Returns (value, bytes_consumed) or None if invalid"] fn read_var_len (data : & [u8]) -> Option < (u32 , usize) > { let mut value = 0u32 ; let mut bytes_read = 0 ; for (i , & byte) in data . iter () . enumerate () { if i >= 4 { return None ; } value = (value << 7) | (byte & 0x7F) as u32 ; bytes_read += 1 ; if byte & 0x80 == 0 { return Some ((value , bytes_read)) ; } } None }

- [ ] **Function 'encode_vlq' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/shared/rust/src/core/midi/parser.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn encode_vlq (mut value : u32) -> Vec < u8 > { if value == 0 { return vec ! [0] ; } let mut bytes = Vec :: new () ; let mut buffer = value & 0x7F ; value >>= 7 ; while value > 0 { buffer <<= 8 ; buffer |= (value & 0x7F) | 0x80 ; value >>= 7 ; } loop { bytes . push ((buffer & 0xFF) as u8) ; if buffer & 0x80 == 0 { break ; } buffer >>= 8 ; } bytes }

- [ ] **Function 'minimal_track_with_eot' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/shared/rust/src/core/midi/parser.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [allow (dead_code)] fn minimal_track_with_eot () -> Vec < u8 > { vec ! [0x00 , 0xFF , 0x2F , 0x00 ,] }

- [ ] **Function 'create_test_midi_with_text' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/shared/rust/src/core/midi/text_metadata.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn create_test_midi_with_text () -> MidiFile { MidiFile { header : Header { format : 1 , num_tracks : 2 , ticks_per_quarter_note : 480 } , tracks : vec ! [Track { events : vec ! [TimedEvent { delta_ticks : 0 , event : Event :: Text { text_type : TextType :: TrackName , text : "Piano Track" . to_string () , } , } , TimedEvent { delta_ticks : 0 , event : Event :: Text { text_type : TextType :: Copyright , text : "2025 Test Artist" . to_string () , } , } , TimedEvent { delta_ticks : 100 , event : Event :: Text { text_type : TextType :: Marker , text : "Verse 1" . to_string () , } , } ,] , } , Track { events : vec ! [TimedEvent { delta_ticks : 0 , event : Event :: Text { text_type : TextType :: TrackName , text : "Bass Track" . to_string () , } , } , TimedEvent { delta_ticks : 0 , event : Event :: Text { text_type : TextType :: InstrumentName , text : "Electric Bass" . to_string () , } , } ,] , } ,] , } }

- [ ] **Function 'create_basic_midi' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/shared/rust/src/core/midi/types.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Helper function to create a basic MIDI file for testing"] fn create_basic_midi () -> MidiFile { MidiFile { header : Header { format : 1 , num_tracks : 1 , ticks_per_quarter_note : 480 } , tracks : vec ! [Track { events : vec ! [] }] , } }

- [ ] **Function 'create_midi_with_notes' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/shared/rust/src/core/midi/types.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Helper function to create a MIDI file with notes"] fn create_midi_with_notes () -> MidiFile { MidiFile { header : Header { format : 1 , num_tracks : 1 , ticks_per_quarter_note : 480 } , tracks : vec ! [Track { events : vec ! [TimedEvent { delta_ticks : 0 , event : Event :: NoteOn { channel : 0 , note : 60 , velocity : 100 } , } , TimedEvent { delta_ticks : 480 , event : Event :: NoteOff { channel : 0 , note : 60 , velocity : 0 } , } , TimedEvent { delta_ticks : 0 , event : Event :: NoteOn { channel : 1 , note : 64 , velocity : 80 } , } ,] , }] , } }

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/shared/rust/src/db/models/midi_file.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/shared/rust/src/db/repositories/search_repository.rs`
  - Category: Performance

- [ ] **Function 'extract_function_name' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/verification/src/categories/api_commands.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Extract function name from a line like \"pub async fn foo_bar(...)\""] fn extract_function_name (line : & str) -> Option < String > { let line = line . trim () ; if let Some (fn_pos) = line . find ("fn ") { let after_fn = & line [fn_pos + 3 ..] ; if let Some (paren_pos) = after_fn . find ('(') { let name = after_fn [.. paren_pos] . trim () ; if ! name . is_empty () { return Some (name . to_string ()) ; } } } None }

- [ ] **Function 'types_compatible' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/verification/src/categories/database_sync.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Check if two PostgreSQL types are compatible"] fn types_compatible (expected : & str , actual : & str) -> bool { let expected_lower = expected . to_lowercase () ; let actual_lower = actual . to_lowercase () ; if expected_lower == actual_lower { return true ; } let aliases : Vec < (& str , & [& str]) > = vec ! [("bigint" , & ["bigint" , "int8" , "bigserial"]) , ("integer" , & ["integer" , "int" , "int4" , "serial"]) , ("text" , & ["text" , "character varying" , "varchar"]) , ("double precision" , & ["double precision" , "float8" , "real"]) , ("timestamp with time zone" , & ["timestamp with time zone" , "timestamptz"] ,) , ("boolean" , & ["boolean" , "bool"]) ,] ; for (canonical , variations) in & aliases { if (expected_lower . contains (canonical) || variations . contains (& expected_lower . as_str ())) && (actual_lower . contains (canonical) || variations . contains (& actual_lower . as_str ())) { return true ; } } false }

- [ ] **Function 'scan_for_patterns_recursive' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/verification/src/categories/performance.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Recursively scan for code patterns"] fn scan_for_patterns_recursive (dir : & str , patterns : & [(& str , & str)] , findings : & mut Vec < String >) { if let Ok (entries) = fs :: read_dir (dir) { for entry in entries . flatten () { let path = entry . path () ; if path . is_dir () { let dir_name = path . file_name () . unwrap_or_default () . to_string_lossy () ; if ! ["target" , ".git" , "node_modules"] . contains (& dir_name . as_ref ()) { scan_for_patterns_recursive (& path . to_string_lossy () , patterns , findings) ; } } else if path . is_file () && path . extension () . is_some_and (| e | e == "rs") { let path_str = path . to_string_lossy () ; if path_str . contains ("test") || path_str . contains ("fixture") { continue ; } if let Ok (content) = fs :: read_to_string (& path) { for (line_num , line) in content . lines () . enumerate () { for (pattern , description) in patterns { if line . contains (pattern) { findings . push (format ! ("{}:{} - {}" , path . display () , line_num + 1 , description)) ; } } } } } } } }

- [ ] **Function 'scan_directory_recursive' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/verification/src/categories/security.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Recursively scan directory for secrets"] fn scan_directory_recursive (dir : & str , patterns : & [(& str , & str)] , findings : & mut Vec < String >) { if let Ok (entries) = fs :: read_dir (dir) { for entry in entries . flatten () { let path = entry . path () ; if path . is_dir () { let dir_name = path . file_name () . unwrap_or_default () . to_string_lossy () ; if ! ["target" , "node_modules" , ".git" , "dist" , "build"] . contains (& dir_name . as_ref ()) { scan_directory_recursive (& path . to_string_lossy () , patterns , findings) ; } } else if path . is_file () { scan_file_for_secrets (& path , patterns , findings) ; } } } }

- [ ] **Function 'scan_file_for_secrets' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/verification/src/categories/security.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Scan a single file for secret patterns"] fn scan_file_for_secrets (path : & Path , patterns : & [(& str , & str)] , findings : & mut Vec < String >) { let ext = path . extension () . and_then (| e | e . to_str ()) . unwrap_or ("") ; if ! ["rs" , "ts" , "js" , "json" , "toml" , "yaml" , "yml" , "env"] . contains (& ext) { return ; } let path_str = path . to_string_lossy () ; if path_str . contains ("test") || path_str . contains ("fixture") || path_str . contains ("mock") { return ; } if let Ok (content) = fs :: read_to_string (path) { for (line_num , line) in content . lines () . enumerate () { let line_lower = line . to_lowercase () ; for (pattern , description) in patterns { if line_lower . contains (pattern) { if line . contains ("env::var") || line . contains ("std::env") { continue ; } if line . trim () . starts_with ("//") || line . trim () . starts_with ('#') { continue ; } if line . contains ('=') && (line . contains ('"') || line . contains ('\'')) { findings . push (format ! ("{}:{} - {}: {}" , path . display () , line_num + 1 , description , line . trim ())) ; } } } } } }

- [ ] **Function 'scan_for_unsafe_recursive' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/verification/src/categories/security.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Recursively scan for unsafe blocks"] fn scan_for_unsafe_recursive (dir : & str , findings : & mut Vec < String >) { if let Ok (entries) = fs :: read_dir (dir) { for entry in entries . flatten () { let path = entry . path () ; if path . is_dir () { let dir_name = path . file_name () . unwrap_or_default () . to_string_lossy () ; if ! ["target" , ".git"] . contains (& dir_name . as_ref ()) { scan_for_unsafe_recursive (& path . to_string_lossy () , findings) ; } } else if path . is_file () && path . extension () . is_some_and (| e | e == "rs") { if let Ok (content) = fs :: read_to_string (& path) { for (line_num , line) in content . lines () . enumerate () { if line . contains ("unsafe {") || line . contains ("unsafe fn") { findings . push (format ! ("{}:{} - {}" , path . display () , line_num + 1 , line . trim ())) ; } } } } } } }

- [ ] **Function 'print_header' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/verification/src/main.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn print_header (name : & str) { println ! ("â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”") ; println ! ("â”‚ Verifying: {:<50} â”‚" , name) ; println ! ("â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜") ; }

- [ ] **Function 'get_git_commit' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/verification/src/shared/types.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn get_git_commit () -> String { get_command_output ("git" , & ["rev-parse" , "--short" , "HEAD"]) }

- [ ] **Function 'get_command_output' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/verification/src/shared/types.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn get_command_output (cmd : & str , args : & [& str]) -> String { std :: process :: Command :: new (cmd) . args (args) . output () . ok () . and_then (| o | String :: from_utf8 (o . stdout) . ok ()) . map (| s | s . trim () . to_string ()) . unwrap_or_else (| | "unknown" . to_string ()) }

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/components/WindowBase.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/components/WindowBase.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/components/WindowBase.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/components/FileBrowser.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/components/FileBrowser.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/components/TagCloud.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/components/VUMeter.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/components/VUMeter.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/components/Toolbar.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/components/MenuBar.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/components/MenuBar.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/components/MenuBar.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/components/MenuBar.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/components/MenuBar.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/components/MenuBar.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/components/VirtualKeyboard.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/components/VirtualKeyboard.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/CommandPaletteWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/TagEditorWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/TagEditorWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/TagEditorWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/TagEditorWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/TagEditorWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/TagEditorWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/TagEditorWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/TagEditorWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/TagEditorWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/TagEditorWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/TagEditorWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/TagEditorWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/TagEditorWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/AutomationWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/AutomationWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/AutomationWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/AutomationWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/AutomationWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/AutomationWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/AutomationWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/AutomationWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/AutomationWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/PipelineWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/PipelineWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/PipelineWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/PipelineWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/PipelineWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/PipelineWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/PipelineWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/PipelineWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/PipelineWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/PipelineWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/LoopBrowserWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/LoopBrowserWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/LoopBrowserWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/LoopBrowserWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/LoopBrowserWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/LoopBrowserWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/LoopBrowserWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/LoopBrowserWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/LoopBrowserWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/LoopBrowserWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/LoopBrowserWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/LoopBrowserWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/LoopBrowserWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/LoopBrowserWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/LoopBrowserWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/LoopBrowserWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/MixerWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/MixerWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/MixerWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/MixerWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/MixerWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/MixerWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/MixerWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/ProjectBrowserWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/ProjectBrowserWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/ProjectBrowserWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/ProjectBrowserWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/ProjectBrowserWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/ProjectBrowserWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/ProjectBrowserWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/ProjectBrowserWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/ProjectBrowserWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/ProjectBrowserWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/ProjectBrowserWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/ProjectBrowserWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/ProjectBrowserWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/ProjectBrowserWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/ProjectBrowserWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/ProjectBrowserWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/ProjectBrowserWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/ProjectBrowserWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/ProjectBrowserWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/ProjectBrowserWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/FavoritesWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/FavoritesWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/FavoritesWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/FavoritesWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/FavoritesWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/FavoritesWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/FavoritesWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/FavoritesWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/FavoritesWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/FavoritesWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/FavoritesWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/FavoritesWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/FavoritesWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/FavoritesWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/DAWWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/DAWWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/DAWWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/DAWWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/DAWWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/DAWWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/DAWWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/VelocityEditorWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/VelocityEditorWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/VelocityEditorWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/VelocityEditorWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/VelocityEditorWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/VelocityEditorWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/VelocityEditorWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/VelocityEditorWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/VelocityEditorWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/SettingsWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/SettingsWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/SettingsWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/SettingsWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/SettingsWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/SettingsWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/SettingsWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/SettingsWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/SettingsWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/SettingsWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/SettingsWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/SettingsWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/SettingsWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/SettingsWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/ExportWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/ExportWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/ExportWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/ExportWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/ExportWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/ExportWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/ExportWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/ExportWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/DatabaseWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/DatabaseWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/DatabaseWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/DatabaseWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/DatabaseWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/DatabaseWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/DatabaseWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/DatabaseWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/DatabaseWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/DatabaseWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/FileDetailsWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/FileDetailsWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/FileDetailsWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/FileDetailsWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/FileDetailsWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/FileDetailsWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/FileDetailsWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/FileDetailsWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/FileDetailsWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/FileDetailsWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/FileDetailsWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/FileDetailsWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/FileDetailsWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/FileDetailsWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/MIDIDeviceWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/MIDIDeviceWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/MIDIDeviceWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/MIDIDeviceWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/MIDIDeviceWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/MIDIDeviceWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/MIDIDeviceWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/MIDIDeviceWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/MIDIDeviceWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/MIDIDeviceWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/MIDIDeviceWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/MIDIDeviceWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/MIDIDeviceWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/MIDIDeviceWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/MIDIDeviceWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/MIDIDeviceWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/MIDIDeviceWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/MIDIDeviceWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/PianoRollWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Best practice: Consider adding 'set -e' or 'set -euo pipefail' at top of script**
  - 
  - File: `/home/dojevou/projects/midi-software-center/app/launch-cpu-only.sh`
  - Category: Documentation
  - Suggested fix:
Add 'set -euo pipefail' after shebang for safer scripts

- [ ] **Best practice: Consider adding 'set -e' or 'set -euo pipefail' at top of script**
  - 
  - File: `/home/dojevou/projects/midi-software-center/scripts/check-progress.sh`
  - Category: Documentation
  - Suggested fix:
Add 'set -euo pipefail' after shebang for safer scripts

- [ ] **Best practice: Consider adding 'set -e' or 'set -euo pipefail' at top of script**
  - 
  - File: `/home/dojevou/projects/midi-software-center/scripts/launch/frontend.sh`
  - Category: Documentation
  - Suggested fix:
Add 'set -euo pipefail' after shebang for safer scripts

- [ ] **Best practice: Consider adding 'set -e' or 'set -euo pipefail' at top of script**
  - 
  - File: `/home/dojevou/projects/midi-software-center/scripts/launch/status.sh`
  - Category: Documentation
  - Suggested fix:
Add 'set -euo pipefail' after shebang for safer scripts

- [ ] **Best practice: Consider adding 'set -e' or 'set -euo pipefail' at top of script**
  - 
  - File: `/home/dojevou/projects/midi-software-center/scripts/launch/launch-daw.sh`
  - Category: Documentation
  - Suggested fix:
Add 'set -euo pipefail' after shebang for safer scripts

- [ ] **Best practice: Consider adding 'set -e' or 'set -euo pipefail' at top of script**
  - 
  - File: `/home/dojevou/projects/midi-software-center/scripts/launch/launch-pipeline.sh`
  - Category: Documentation
  - Suggested fix:
Add 'set -euo pipefail' after shebang for safer scripts

- [ ] **Best practice: Consider adding 'set -e' or 'set -euo pipefail' at top of script**
  - 
  - File: `/home/dojevou/projects/midi-software-center/scripts/pgo-build.sh`
  - Category: Documentation
  - Suggested fix:
Add 'set -euo pipefail' after shebang for safer scripts

- [ ] **Best practice: Consider adding 'set -e' or 'set -euo pipefail' at top of script**
  - 
  - File: `/home/dojevou/projects/midi-software-center/scripts/monitor-pipeline.sh`
  - Category: Documentation
  - Suggested fix:
Add 'set -euo pipefail' after shebang for safer scripts

- [ ] **Best practice: Consider adding 'set -e' or 'set -euo pipefail' at top of script**
  - 
  - File: `/home/dojevou/projects/midi-software-center/scripts/monitor-import.sh`
  - Category: Documentation
  - Suggested fix:
Add 'set -euo pipefail' after shebang for safer scripts

- [ ] **Best practice: Consider adding 'set -e' or 'set -euo pipefail' at top of script**
  - 
  - File: `/home/dojevou/projects/midi-software-center/scripts/benchmark-comparison.sh`
  - Category: Documentation
  - Suggested fix:
Add 'set -euo pipefail' after shebang for safer scripts

- [ ] **Best practice: Consider adding 'set -e' or 'set -euo pipefail' at top of script**
  - 
  - File: `/home/dojevou/projects/midi-software-center/scripts/monitor-and-continue.sh`
  - Category: Documentation
  - Suggested fix:
Add 'set -euo pipefail' after shebang for safer scripts

- [ ] **Best practice: Consider adding 'set -e' or 'set -euo pipefail' at top of script**
  - 
  - File: `/home/dojevou/projects/midi-software-center/scripts/verify-split-relationships.sh`
  - Category: Documentation
  - Suggested fix:
Add 'set -euo pipefail' after shebang for safer scripts

- [ ] **Best practice: Consider adding 'set -e' or 'set -euo pipefail' at top of script**
  - 
  - File: `/home/dojevou/projects/midi-software-center/scripts/wait-for-import.sh`
  - Category: Documentation
  - Suggested fix:
Add 'set -euo pipefail' after shebang for safer scripts

- [ ] **Best practice: Consider adding 'set -e' or 'set -euo pipefail' at top of script**
  - 
  - File: `/home/dojevou/projects/midi-software-center/scripts/verify-database-files.sh`
  - Category: Documentation
  - Suggested fix:
Add 'set -euo pipefail' after shebang for safer scripts

- [ ] **Best practice: Consider adding 'set -e' or 'set -euo pipefail' at top of script**
  - 
  - File: `/home/dojevou/projects/midi-software-center/scripts/monitor-dedup.sh`
  - Category: Documentation
  - Suggested fix:
Add 'set -euo pipefail' after shebang for safer scripts

- [ ] **Best practice: Consider adding 'set -e' or 'set -euo pipefail' at top of script**
  - 
  - File: `/home/dojevou/projects/midi-software-center/scripts/convert_midian_format_5.sh`
  - Category: Documentation
  - Suggested fix:
Add 'set -euo pipefail' after shebang for safer scripts

- [ ] **Best practice: Consider adding 'set -e' or 'set -euo pipefail' at top of script**
  - 
  - File: `/home/dojevou/projects/midi-software-center/scripts/convert_test_5_fixed.sh`
  - Category: Documentation
  - Suggested fix:
Add 'set -euo pipefail' after shebang for safer scripts

- [ ] **Best practice: Consider adding 'set -e' or 'set -euo pipefail' at top of script**
  - 
  - File: `/home/dojevou/projects/midi-software-center/scripts/convert_test_100.sh`
  - Category: Documentation
  - Suggested fix:
Add 'set -euo pipefail' after shebang for safer scripts

- [ ] **Best practice: Consider adding 'set -e' or 'set -euo pipefail' at top of script**
  - 
  - File: `/home/dojevou/projects/midi-software-center/scripts/populate-codememory.sh`
  - Category: Documentation
  - Suggested fix:
Add 'set -euo pipefail' after shebang for safer scripts

- [ ] **Best practice: Consider adding 'set -e' or 'set -euo pipefail' at top of script**
  - 
  - File: `/home/dojevou/projects/midi-software-center/scripts/organization/organize-files.sh`
  - Category: Documentation
  - Suggested fix:
Add 'set -euo pipefail' after shebang for safer scripts

- [ ] **Best practice: Consider adding 'set -e' or 'set -euo pipefail' at top of script**
  - 
  - File: `/home/dojevou/projects/midi-software-center/scripts/fixes/fix_workflows_manually.sh`
  - Category: Documentation
  - Suggested fix:
Add 'set -euo pipefail' after shebang for safer scripts

- [ ] **Best practice: Consider adding 'set -e' or 'set -euo pipefail' at top of script**
  - 
  - File: `/home/dojevou/projects/midi-software-center/scripts/fixes/fix_e0308_calls.sh`
  - Category: Documentation
  - Suggested fix:
Add 'set -euo pipefail' after shebang for safer scripts

- [ ] **Best practice: Consider adding 'set -e' or 'set -euo pipefail' at top of script**
  - 
  - File: `/home/dojevou/projects/midi-software-center/scripts/fixes/fix_lint.sh`
  - Category: Documentation
  - Suggested fix:
Add 'set -euo pipefail' after shebang for safer scripts

- [ ] **Best practice: Consider adding 'set -e' or 'set -euo pipefail' at top of script**
  - 
  - File: `/home/dojevou/projects/midi-software-center/scripts/fixes/fix_workflows_imports.sh`
  - Category: Documentation
  - Suggested fix:
Add 'set -euo pipefail' after shebang for safer scripts

- [ ] **Best practice: Consider adding 'set -e' or 'set -euo pipefail' at top of script**
  - 
  - File: `/home/dojevou/projects/midi-software-center/scripts/setup/setup-project-structure.sh`
  - Category: Documentation
  - Suggested fix:
Add 'set -euo pipefail' after shebang for safer scripts

- [ ] **Best practice: Consider adding 'set -e' or 'set -euo pipefail' at top of script**
  - 
  - File: `/home/dojevou/projects/midi-software-center/run_all_analysis.sh`
  - Category: Documentation
  - Suggested fix:
Add 'set -euo pipefail' after shebang for safer scripts

- [ ] **Best practice: Consider adding 'set -e' or 'set -euo pipefail' at top of script**
  - 
  - File: `/home/dojevou/projects/midi-software-center/rust_analyzer/create_docs.sh`
  - Category: Documentation
  - Suggested fix:
Add 'set -euo pipefail' after shebang for safer scripts

- [ ] **Performance: Consider adding index on foreign key columns (line 14)**
  - 
  - File: `/home/dojevou/projects/midi-software-center/database/migrations/006_track_splits.sql`
  - Category: Performance
  - Suggested fix:
Add CREATE INDEX for frequently queried columns



# AI-Powered Fix Recommendations

Generated using Grok-4-Fast-Reasoning

Total Recommendations: 257

---

## Issue #1: Unsafe unwrap() call in project_browser.rs

**Confidence:** High | **Estimated Time:** 5 minutes

### Analysis
The unwrap() method on Option or Result types forces extraction of the inner value, panicking on None or Err variants. This violates Rust's ownership and error handling principles by not propagating errors or handling absence explicitly, potentially leading to runtime panics instead of graceful degradation. In a Tauri context, this can crash the entire application thread, undermining memory safety guarantees.

### Fix Steps
1. Locate the unwrap() call in /home/dojevou/projects/midi-software-center/daw/src-tauri/src/browsers/project_browser.rs.
2. Determine if the expression returns Option<T> or Result<T, E>; prefer propagating errors with ? if the enclosing function returns Result.
3. If error propagation isn't possible, use match or if let for explicit handling, or expect() with a descriptive message if the unwrap is logically safe (e.g., due to prior checks).

### Code Example
```rust
// BEFORE:
let value = some_option.unwrap();

// AFTER:
let value = match some_option {
    Some(v) => v,
    None => {
        // Handle error, e.g., return Err("Expected value") or default
        return Err("Project not found".into());
    }
};
```

---

## Issue #2: Unsafe unwrap() call in project_browser.rs

**Confidence:** High | **Estimated Time:** 5 minutes

### Analysis
Similar to issue #1, unwrap() discards error information and risks panicking, contravening Rust's type system emphasis on explicit error handling via Result and Option. In browser-related code, this might occur during file I/O or parsing, where failures (e.g., invalid project data) should be reported to the UI rather than crashing.

### Fix Steps
1. Identify the specific unwrap() in the same file, likely on a different Option/Result (e.g., from a get() or parse() call).
2. Replace with ? operator if in an async or Result-returning context, ensuring proper lifetimes if borrowing is involved.
3. Add logging or user-facing errors using Tauri's event system if applicable, avoiding silent failures.

### Code Example
```rust
// BEFORE:
let path = env::var("PROJECT_PATH").unwrap();

// AFTER:
let path = env::var("PROJECT_PATH").map_err(|e| anyhow::anyhow!("Failed to get project path: {}", e))?;
```

---

## Issue #3: Unsafe unwrap() call in command_palette.rs

**Confidence:** High | **Estimated Time:** 3 minutes

### Analysis
unwrap() bypasses Rust's sum types (Option/Result), ignoring the possibility of errors which is central to safe ownership transfer and resource management. In a command palette, this could stem from UI state queries or command resolution, where failing to handle None/Err leads to undefined behavior instead of fallback UI states.

### Fix Steps
1. Scan command_palette.rs for the unwrap(), possibly on a find() or query result.
2. Use combinators like ok_or() or unwrap_or_default() for simple cases, or full match for complex logic.
3. Ensure the fix aligns with async patterns if the palette involves futures, using .await? instead.

### Code Example
```rust
// BEFORE:
let command = palette.commands.get(&input).unwrap();

// AFTER:
let command = palette.commands.get(&input).cloned().ok_or("Command not found")?;
```

---

## Issue #4: Unsafe unwrap() call in commands/daw.rs

**Confidence:** High | **Estimated Time:** 5 minutes

### Analysis
In DAW command handling, unwrap() on Results from audio/MIDI operations ignores potential I/O or parsing errors, conflicting with Rust's Drop semantics and real-time constraints where panics can corrupt state. This promotes unsafe error suppression over idiomatic propagation, risking data loss in production.

### Fix Steps
1. Examine daw.rs for unwrap() in command execution, e.g., on file loading or state updates.
2. Refactor to return Result from the command function, using ? for propagation; use thiserror for custom DAW errors.
3. Consider lock-free structures if in hot paths, but prioritize error handling first.

### Code Example
```rust
// BEFORE:
let state = daw_state.lock().unwrap().get_current_project();

// AFTER:
let state = daw_state.lock().map_err(|e| anyhow::anyhow!("Failed to lock DAW state: {}", e))?.get_current_project().ok_or("No current project")?;
```

---

## Issue #5: Unsafe unwrap() call in commands/daw.rs

**Confidence:** High | **Estimated Time:** 4 minutes

### Analysis
Another instance of unwrap() in DAW commands likely on a different operation (e.g., MIDI event processing), where Rust's ownership model expects explicit handling to prevent invalid states. Panics here could interrupt real-time audio, violating no-allocation hot path best practices by introducing exception overhead.

### Fix Steps
1. Locate the second unwrap() in daw.rs, perhaps in a different method like save() or load().
2. Opt for expect() if prior invariants guarantee success, with a comment explaining why; otherwise, use match for exhaustive handling.
3. Integrate with async/await if the command is asynchronous, ensuring futures don't panic unexpectedly.

### Code Example
```rust
// BEFORE:
let project = daw.load_project().unwrap();

// AFTER:
let project = daw.load_project().map_err(|e| {
    log::error!("Failed to load project: {}", e);
    // Return default or notify user
    Err(e.into())
})?;
```

---

## Issue #1: Safety - Unsafe unwrap() call detected

**Confidence:** High | **Estimated Time:** 5 minutes

### Analysis
The unwrap() method on Result or Option types forces the extraction of the inner value, panicking on Err or None variants. This violates Rust's safety guarantees by potentially causing runtime panics, which can crash the application. In the context of Rust's ownership model, unwrap() discards error information without proper handling, ignoring the type system's emphasis on explicit error propagation via Result<T, E>. For Tauri commands in a DAW application, this is particularly risky in real-time audio/MIDI contexts where panics could disrupt lock-free operations or cause audio glitches. The issue likely stems from assuming infallible operations, but Rust's API design (e.g., I/O, parsing) returns Results to enforce error checking.

### Fix Steps
1. Identify the unwrap() call on a Result<T, E> or Option<T>.
2. If the function can propagate errors, change the return type to Result and use the ? operator to early-return on Err/None.
3. If error propagation isn't feasible (e.g., in a hot path), use match or if let for exhaustive handling, logging errors with tracing or log crate.
4. For documentation, replace with expect('detailed reason why this cannot fail') if truly infallible, but prefer proper handling.
5. Ensure imports for error types like anyhow::Result if using anyhow for simplified error chaining.

### Code Example
```rust
// BEFORE:
let value = some_fallible_operation().unwrap();

// AFTER:
let value = match some_fallible_operation() {
    Ok(v) => v,
    Err(e) => {
        log::error!("Operation failed: {}", e);
        return Err(anyhow::anyhow!("Failed to get value: {}", e));
    }
};
```

---

## Issue #2: Safety - Unsafe unwrap() call detected

**Confidence:** High | **Estimated Time:** 3 minutes

### Analysis
Similar to other instances, unwrap() on Result or Option bypasses Rust's type system for safe error handling, leading to panics that violate memory safety principles. In async Tauri contexts (using tokio), unwrap() can unwind the stack, potentially leaking resources or breaking async executors. Rust's lifetimes and borrowing rules ensure values are handled explicitly, but unwrap() ignores this by assuming success, which is unsafe for production code handling MIDI/audio where allocations or locks must be avoided in hot paths.

### Fix Steps
1. Locate the specific unwrap() in the DAW command handler.
2. Refactor to use Option/Result combinators like .ok_or() or .map_err() for chaining.
3. In async functions, propagate with ? to maintain non-panicking execution.
4. Add tracing spans for error contexts if using the tracing crate.
5. Consider custom error types with thiserror for domain-specific errors in MIDI processing.

### Code Example
```rust
// BEFORE:
let config = load_config().unwrap();

// AFTER:
use anyhow::Result;

let config = load_config().map_err(|e| anyhow::anyhow!("Config load error: {}", e))?;
```

---

## Issue #3: Safety - Unsafe unwrap() call detected

**Confidence:** High | **Estimated Time:** 4 minutes

### Analysis
unwrap() extracts values unsafely, conflicting with Rust's ownership semantics where errors represent ownership transfer of failure states. In a systems-level DAW app, this could lead to undefined behavior in FFI boundaries (e.g., MIDI libs) or unsafe blocks if panics occur during Drop. The type system enforces handling via traits like Error, but unwrap() short-circuits this, making code non-idiomatic and prone to crashes under load, especially in performance-critical paths without allocations.

### Fix Steps
1. Replace unwrap() with a match expression for explicit branching.
2. If in a Result-returning function, use ? for propagation.
3. For Options from parsing (common in config/MIDI), use unwrap_or_default() or unwrap_or_else() with cloning if needed.
4. Document with expect() only if invariants guarantee success, e.g., after prior checks.
5. Test edge cases like invalid MIDI data to ensure no panics.

### Code Example
```rust
// BEFORE:
let port = get_midi_port().unwrap();

// AFTER:
let port = get_midi_port().ok_or_else(|| anyhow::anyhow!("No MIDI port available"))?;
```

---

## Issue #4: Safety - Unsafe unwrap() call detected

**Confidence:** High | **Estimated Time:** 5 minutes

### Analysis
By panicking on failure, unwrap() undermines Rust's zero-cost abstractions and error handling idioms, potentially causing issues in generic code with trait bounds like IntoIterator or Debug. In async/await patterns (tokio in Tauri), panics can poison futures, leading to broader failures. This issue highlights a mismatch between assumed infallible APIs and Rust's reality-based design, where operations like file I/O or JSON parsing return Results to preserve safety without runtime checks.

### Fix Steps
1. Audit the unwrap() context: is it on a Result from serde_json or std::fs?
2. Convert to proper handling: use .expect('reason') for panics with docs, but prefer ? or match.
3. In real-time MIDI code, avoid panics entirely by using non-panicking APIs or fallbacks.
4. Integrate with existing error types, e.g., derive Error for a DawError enum.
5. Profile to ensure the fix doesn't introduce allocations in hot paths.

### Code Example
```rust
// BEFORE:
let data: Vec<u8> = read_midi_data().unwrap();

// AFTER:
use std::io;

let data: Vec<u8> = read_midi_data().map_err(|e| io::Error::new(io::ErrorKind::Other, e))?;
```

---

## Issue #5: Safety - Unsafe unwrap() call detected

**Confidence:** High | **Estimated Time:** 3 minutes

### Analysis
unwrap() is a footgun in Rust's macro system and procedural code, where it can hide type mismatches or lifetime issues until runtime. For DAW software with lock-free structures, panics disrupt cache-friendly data access or SIMD operations. The root cause is often lazy error handling, ignoring Rust's preference for compile-time safety via lifetimes and borrow checker, leading to ownership violations if panics occur mid-borrow.

### Fix Steps
1. Use clippy lints (e.g., #![warn(clippy::unwrap_used)] ) to catch these proactively.
2. Refactor to propagate errors, adjusting the async fn signature to async fn command() -> Result<JsValue, InvokeError>.
3. For Options, chain with and_then() or or_else() to handle fallbacks idiomatically.
4. In FFI/unsafe contexts, ensure no unwinding across boundaries by using catch_unwind if needed, but prefer safe handling.
5. Add unit tests for the Err/None paths to verify behavior.

### Code Example
```rust
// BEFORE:
let session = create_audio_session().unwrap();

// AFTER:
let session = create_audio_session()
    .map_err(|e| {
        tracing::error!("Audio session creation failed: {}", e);
        e
    })?;
```

---

## Issue #1: Safety - Unsafe unwrap() call detected

**Confidence:** High | **Estimated Time:** 3 minutes

### Analysis
The unwrap() method on Option or Result types panics at runtime if the value is None or Err, violating Rust's safety guarantees by potentially crashing the program instead of handling errors gracefully. This occurs because unwrap() assumes the operation always succeeds, ignoring Rust's ownership and error propagation model which encourages explicit error handling via Result<T, E> or Option<T> to maintain memory safety and predictable control flow. In a real-time MIDI/audio context, such panics could disrupt lock-free operations or cause audio glitches.

### Fix Steps
1. Identify the unwrap() call on a Result or Option.
2. Replace with proper error handling: use ? operator if in a function returning Result, or match/expect() for documentation.
3. If the unwrap is justified (e.g., invariant guaranteed by prior checks), use expect() with a descriptive message.
4. Propagate errors using anyhow::Result for simplicity in application code, ensuring no panics in hot paths.

### Code Example
```rust
// BEFORE:
let config = load_midi_config().unwrap();

// AFTER:
use anyhow::Result;

fn load_daw_config() -> Result<MidiConfig, anyhow::Error> {
    let config = load_midi_config()?;
    Ok(config)
}

// In calling code:
let config = load_daw_config().context("Failed to load MIDI config")?; // Propagates error
```

---

## Issue #2: Safety - Unsafe unwrap() call detected

**Confidence:** High | **Estimated Time:** 4 minutes

### Analysis
unwrap() discards error information and forces a panic, contravening Rust's type system which uses enums like Result to enforce handling of fallible operations at compile time. In async MIDI command handling (e.g., with tokio), this can lead to task panics that poison futures, breaking the async/await ownership model where errors should be awaited and handled explicitly to avoid resource leaks or deadlocks in real-time constraints.

### Fix Steps
1. Locate the unwrap() in an async context, likely on a future's output.
2. Use .await? to propagate errors in async functions returning impl Future<Output = Result<T, E>>.
3. For non-propagating cases, use if let Some(value) = option.await { ... } else { handle_error() }.
4. Consider custom error types with thiserror for MIDI-specific errors, avoiding generic anyhow in performance-critical paths.

### Code Example
```rust
// BEFORE:
let device = find_midi_device().await.unwrap();

// AFTER:
use thiserror::Error;

#[derive(Error, Debug)]
#[error("MIDI device not found")]
struct MidiError;

type MidiResult<T> = Result<T, MidiError>;

async fn find_device() -> MidiResult<MidiDevice> {
    let device = find_midi_device().await?;
    Ok(device)
}

// Usage:
let device = find_device().await.map_err(|_| /* handle */)?;
```

---

## Issue #3: Safety - Unsafe unwrap() call detected

**Confidence:** High | **Estimated Time:** 5 minutes

### Analysis
By using unwrap(), the code bypasses Rust's borrow checker and lifetime enforcement, as panics can occur mid-borrow, leading to undefined behavior if Drop traits aren't invoked properly. In MIDI software with lock-free data structures, this exacerbates issues in hot paths where allocations are forbidden, potentially causing memory unsafety if the panic interrupts ongoing borrows or futures.

### Fix Steps
1. Examine the unwrap() context for borrowing patterns.
2. Replace with pattern matching: match result { Ok(v) => v, Err(e) => return Err(e.into()) }.
3. Use unwrap_or_else() for default values without panicking, or expect() if safety is provably guaranteed (e.g., via prior assertions).
4. In real-time audio, prefer non-panicking alternatives like get_or_insert_with() on Option to avoid any runtime crashes.

### Code Example
```rust
// BEFORE:
let buffer = audio_buffer.lock().unwrap().data();

// AFTER:
use std::sync::MutexGuard;

let guard: MutexGuard<'_, AudioBuffer> = audio_buffer.lock().map_err(|poison| {
    // Log poisoned lock, perhaps recover or panic with context
    eprintln!("Audio buffer poisoned");
    std::process::exit(1);
})?;
let buffer = &guard.data; // Borrow from guard, no unwrap needed
```

---

## Issue #4: Safety - Unsafe unwrap() call detected

**Confidence:** High | **Estimated Time:** 2 minutes

### Analysis
unwrap() ignores the Err variant of Result, which in Rust's ownership model means potential loss of resources (e.g., file handles in MIDI config loading) if not dropped properly on panic. For trait designs in generic MIDI processing, this can violate trait bounds like Fallible, leading to non-idiomatic code that doesn't compose well with other error-handling abstractions.

### Fix Steps
1. Determine if the unwrap is on a parsing or I/O operation common in DAW commands.
2. Refactor to use combinators like .ok_or() or .context() from anyhow for chained errors.
3. If in a generic context, add trait bounds like E: std::error::Error to ensure proper error types.
4. For performance, avoid match if possible, but prioritize safety over micro-optimizations in non-hot paths.

### Code Example
```rust
// BEFORE:
let parsed = parse_midi_event(raw_data).unwrap();

// AFTER:
use anyhow::{Context, Result};

let parsed: MidiEvent = parse_midi_event(raw_data)
    .context("Failed to parse MIDI event from raw data")?;
```

---

## Issue #5: Safety - Unsafe unwrap() call detected

**Confidence:** High | **Estimated Time:** 6 minutes

### Analysis
In the context of FFI or unsafe MIDI interfaces, unwrap() can mask errors from C bindings, leading to unsoundness if invalid states are assumed. Rust's macro system or procedural generation might generate such calls, but the core issue is failing to uphold the contract of safe wrappers around unsafe code, potentially violating memory safety invariants.

### Fix Steps
1. Check if unwrap() follows an unsafe block or FFI call.
2. Wrap in a safe function that returns Result, using std::result::Result::from() for conversion.
3. Document assumptions with expect() if the error case is impossible due to invariants (e.g., validated inputs).
4. For real-time constraints, use non-allocating error handling like custom enums to avoid heap usage in hot paths.

### Code Example
```rust
// BEFORE:
unsafe {
    let handle = midi_open_device().unwrap();
}

// AFTER:
use std::ffi::CStr;

#[derive(Debug)]
enum MidiOpenError {
    NullPtr,
    Other(&'static str),
}

fn open_midi_device() -> Result<MidiHandle, MidiOpenError> {
    unsafe {
        let ptr = midi_open_device();
        if ptr.is_null() {
            return Err(MidiOpenError::NullPtr);
        }
        Ok(MidiHandle::from_ptr(ptr))
    }
}

// Usage:
let handle = open_midi_device().map_err(|e| /* log */)?;
```

---

## Issue #1: Safety - Unsafe unwrap() call detected

**Confidence:** High | **Estimated Time:** 5 minutes

### Analysis
In Rust, `unwrap()` is a method on `Option<T>` and `Result<T, E>` that extracts the value assuming success, but panics on `None` or `Err`. This violates Rust's ownership and error handling model by not propagating errors, potentially crashing the program in production. In the context of Tauri commands (async functions in `daw.rs`), this ignores the `Result` from operations like file I/O or MIDI handling, contravening the type system's emphasis on explicit error management via traits like `std::error::Error`. Proper handling ensures memory safety and reliability, especially in real-time audio/MIDI contexts where panics could disrupt lock-free paths.

### Fix Steps
1. Identify the `unwrap()` call, likely on a `Result` from an API like `serde_json::from_str` or Tauri invocation.
2. If the enclosing function returns `Result<(), SomeError>`, replace `unwrap()` with the `?` operator to propagate the error idiomatically.
3. If error propagation isn't feasible, use `expect("descriptive message")` to document the assumption of success, or handle with `match` for custom logic.
4. Ensure the function signature supports `Result` returns; update if necessary using `thiserror` for custom errors.
5. Add imports for error types if needed, e.g., `use anyhow::Result;` for simplified propagation.

### Code Example
```rust
// BEFORE:
let value = some_result.unwrap();

// AFTER:
let value = some_result?;
// Assuming the function now returns Result<T, E>
```

---

## Issue #2: Safety - Unsafe unwrap() call detected

**Confidence:** High | **Estimated Time:** 5 minutes

### Analysis
Rust's `unwrap()` extracts from `Option` or `Result` without checking, leading to runtime panics that bypass the compiler's borrow checker and lifetime guarantees. In `daw.rs`, this likely occurs in command handlers processing MIDI data or async tasks, where failures (e.g., from `tokio::fs` or JSON parsing) should be handled explicitly to maintain program invariants. This anti-pattern ignores Rust's preference for combinators like `map`, `and_then`, or `?` over panicking, especially in async contexts where panics can unwind stacks unexpectedly.

### Fix Steps
1. Locate the specific `unwrap()` , possibly on an `Option` from a hashmap lookup or MIDI event parsing.
2. Replace with `?` if in a `Result`-returning function, or use `ok_or_else(|| MyError::new())` to convert `Option` to `Result`.
3. For guaranteed success cases (rare), use `expect()` with a message explaining why it's safe, e.g., based on prior validation.
4. Consider wrapping in a custom error type with `thiserror` for better diagnostics in audio/MIDI flows.
5. Test edge cases like invalid input to ensure no hidden panics remain.

### Code Example
```rust
// BEFORE:
let opt_value = some_option.unwrap();

// AFTER:
let opt_value = some_option.ok_or(MyError::MissingValue)?;
```

---

## Issue #3: Safety - Unsafe unwrap() call detected

**Confidence:** High | **Estimated Time:** 5 minutes

### Analysis
The `unwrap()` method discards error information, conflicting with Rust's type system that enforces handling via `Result` and `Option` enums. In the Tauri `daw.rs` file, this could stem from unsafe assumptions in async MIDI processing or state management, where ownership transfer (e.g., via `Arc` or channels) expects error propagation to avoid data races or lost events. Panics here undermine memory safety, as unwinding can invalidate borrows in concurrent audio threads.

### Fix Steps
1. Examine the `unwrap()` context, e.g., on a `Result` from `tokio::spawn` or serialization.
2. Propagate with `?` operator, ensuring the function trait bounds include `E: std::error::Error`.
3. If handling locally, use `if let Err(e) = result { log::error!("{}", e); return Ok(default); }` for graceful degradation.
4. In real-time paths, prefer non-panicking alternatives like `unwrap_or_default()` for `Option`, avoiding allocations.
5. Import `anyhow` or `thiserror` if not present for ergonomic error chaining.

### Code Example
```rust
// BEFORE:
let data = parse_midi().unwrap();

// AFTER:
let data = parse_midi().map_err(|e| anyhow::anyhow!("MIDI parse failed: {}", e))?;
```

---

## Issue #4: Safety - Unsafe unwrap() call detected

**Confidence:** High | **Estimated Time:** 5 minutes

### Analysis
Rust encourages explicit error handling to leverage the type system's safety guarantees; `unwrap()` short-circuits this by panicking, which can propagate unexpectedly in async runtimes like Tokio. In `daw.rs`, this issue likely arises from deserializing command payloads or accessing shared state, ignoring potential `Err` variants that represent invalid MIDI/software center data, thus risking ownership violations if panics occur mid-borrow.

### Fix Steps
1. Pinpoint the `unwrap()`, perhaps on JSON deserialization or a future's output.
2. Use `?` for propagation if the command is marked `async fn` returning `Result<serde_json::Value, _>`.
3. For Options, chain with `unwrap_or_else(|| default_value())` to avoid panics without allocation in hot paths.
4. Document with `expect()` only if logically impossible to fail, e.g., after invariants are checked.
5. Ensure error types implement `Debug` and `Display` for logging in production.

### Code Example
```rust
// BEFORE:
let config = json::from_str(&input).unwrap();

// AFTER:
let config: Config = serde_json::from_str(&input).map_err(|e| Error::Parse(e))?;
```

---

## Issue #5: Safety - Unsafe unwrap() call detected

**Confidence:** High | **Estimated Time:** 5 minutes

### Analysis
By design, Rust's `Option` and `Result` types force error consideration at compile time; `unwrap()` evades this, introducing runtime fragility. Within Tauri's `daw.rs`, this probably occurs in event handling or state queries for the MIDI software center, where failing to handle `Err` (e.g., from lock-free queues or FFI) could lead to dropped events or unsafe memory access if panics unwind across threads, clashing with Rust's Drop semantics and lifetime rules.

### Fix Steps
1. Identify the instance, likely an `unwrap()` on a channel receive or config load.
2. Replace with `?` in `Result`-returning contexts, using turbofish if generic: `result?`.
3. Handle explicitly with `match` for complex logic: `match result { Ok(v) => v, Err(e) => { /* log and return */ } }`.
4. In performance-critical MIDI paths, use zero-cost abstractions like `Result::unwrap_unchecked()` only with `unsafe` and proofs, but prefer safe combinators.
5. Add unit tests for the error path to validate the fix.

### Code Example
```rust
// BEFORE:
let event = receiver.recv().await.unwrap();

// AFTER:
let event = receiver.recv().await.map_err(|_| Error::ChannelClosed)?;
```

---

## Issue #1: Safety - Unsafe unwrap() call detected

**Confidence:** High | **Estimated Time:** 3 minutes

### Analysis
The use of unwrap() on an Option or Result assumes the value is always Some or Ok, which violates Rust's ownership and error handling semantics. If the assumption fails (e.g., due to unexpected input, I/O failure, or concurrent access in a MIDI/DAW context), it triggers a panic, potentially crashing the Tauri command handler. This ignores Rust's type system encouragement for explicit error propagation via Result or Option combinators, leading to unsafe runtime behavior instead of compile-time safety.

### Fix Steps
1. Identify the unwrap() call in the Tauri command handler.
2. Determine the context: if the enclosing function returns Result, replace with the ? operator to propagate the error.
3. If error propagation isn't suitable (e.g., in a hot path for real-time audio/MIDI), use expect() with a descriptive message to document the invariant, or handle via match/if let for edge cases.
4. Ensure the Tauri command's return type is serde_json::Value or similar, wrapping the Result appropriately.

### Code Example
```rust
// BEFORE:
let value = some_option.unwrap();

// AFTER:
let value = some_option.expect("Expected Some value from MIDI device query, indicating a configuration error");
```

---

## Issue #2: Safety - Unsafe unwrap() call detected

**Confidence:** High | **Estimated Time:** 4 minutes

### Analysis
unwrap() discards the error variant of Result or None of Option without handling, contravening Rust's sum types and pattern matching principles. In a DAW context with async Tauri commands (likely using tokio), this can mask failures from async operations like device I/O or MIDI parsing, leading to undefined behavior or panics under load, rather than leveraging lifetimes and borrowing for safe resource management.

### Fix Steps
1. Locate the specific unwrap() in the daw.rs command.
2. If it's on a Result from an async call (e.g., tokio::fs or MIDI lib), use .await? to propagate.
3. For Options from collections or configs, use methods like ok_or() to convert to Result, then ?.
4. Add logging (e.g., via tracing or log crate) for handled errors to aid debugging in production.

### Code Example
```rust
// BEFORE:
let data = async_operation().await.unwrap();

// AFTER:
let data = async_operation().await.map_err(|e| { /* log error */ format!("MIDI async failure: {}", e) })?;
```

---

## Issue #3: Safety - Unsafe unwrap() call detected

**Confidence:** High | **Estimated Time:** 3 minutes

### Analysis
Rust's ownership model promotes explicit handling of fallible operations to prevent resource leaks or invalid states. unwrap() bypasses this by panicking on failure, which is non-idiomatic and unsafe for production code, especially in real-time MIDI/DAW systems where panics could disrupt audio processing. It ignores trait bounds like FallibleIterator or error traits, potentially hiding borrow checker violations.

### Fix Steps
1. Examine the unwrap() context: likely on a parse or query Result.
2. Replace with match expression for fine-grained control, or unwrap_or_default() if a default is semantically correct.
3. In Tauri, ensure errors are returned to the frontend via the command's Result type.
4. Consider custom error types with thiserror for domain-specific handling (e.g., MidiError).

### Code Example
```rust
// BEFORE:
let parsed = parse_midi_data(input).unwrap();

// AFTER:
let parsed = match parse_midi_data(input) {
    Ok(p) => p,
    Err(e) => return Err(serde_json::json!({ "error": e.to_string() })),
};
```

---

## Issue #4: Safety - Unsafe unwrap() call detected

**Confidence:** High | **Estimated Time:** 2 minutes

### Analysis
By using unwrap(), the code assumes infallible execution, which conflicts with Rust's compile-time guarantees via generics and lifetimes. In async/await patterns (tokio in Tauri), this can propagate panics across await points, violating no-panic guarantees in hot paths for audio/MIDI. Better to use combinators like and_then() or map_err() to maintain type safety and ownership transfer.

### Fix Steps
1. Pinpoint the unwrap() in the command logic.
2. If on an Option from a HashMap or config lookup, use get() -> as_ref() -> cloned() chain.
3. For Results, chain with context using anyhow's context() for better diagnostics.
4. Test the fix with simulated failures to ensure no regressions in MIDI handling.

### Code Example
```rust
// BEFORE:
let config = configs.get("device").unwrap().to_owned();

// AFTER:
let config = configs.get("device").cloned().ok_or_else(|| "Missing device config")?;
```

---

## Issue #5: Safety - Unsafe unwrap() call detected

**Confidence:** High | **Estimated Time:** 3 minutes

### Analysis
unwrap() undermines Rust's error monad-like handling in Result/Option, leading to runtime crashes instead of safe unwinding. In a systems-level DAW with FFI or unsafe MIDI libs, this exacerbates risks at boundaries. Idiomatic Rust favors propagation or recovery to preserve memory safety and avoid violating Drop semantics on panic.

### Fix Steps
1. Review the final unwrap() instance in daw.rs.
2. Use expect() if the unwrap is justified (e.g., post-validation invariant), with a comment explaining why it's safe.
3. Otherwise, integrate with the function's Result return type using ?.
4. For performance in real-time paths, ensure handling avoids allocations (e.g., use &str over String where possible).

### Code Example
```rust
// BEFORE:
let result = final_computation().unwrap();

// AFTER:
let result = final_computation().expect("Invariant: computation always succeeds after prior checks"); // Documented safety
```

---

## Issue #1: Unsafe unwrap() call in daw.rs

**Confidence:** High | **Estimated Time:** 3 minutes

### Analysis
The unwrap() method on a Result or Option type forces the program to panic if the value is Err or None, violating Rust's ownership and error handling principles. This occurs because unwrap() consumes the value and assumes success, but in Rust's type system, Results and Options are designed to propagate errors explicitly via lifetimes and trait bounds like ? operator compatibility. In a Tauri command context, this can lead to unhandled panics during async operations, potentially crashing the entire application instead of returning a proper error to the frontend.

### Fix Steps
1. Identify the unwrap() call on a Result<T, E> or Option<T>.
2. If the enclosing function returns Result, replace with the ? operator to propagate the error.
3. If error propagation isn't possible, use .expect('detailed reason why this should not fail') to document the assumption.
4. Ensure the function signature includes proper error types, e.g., using anyhow::Result for simplicity in commands.

### Code Example
```rust
// BEFORE:
let value = some_result.unwrap();

// AFTER:
let value = some_result?;
// Or if not propagating:
let value = some_result.expect("Operation should succeed due to prior validation");
```

---

## Issue #2: Unsafe unwrap() call in daw.rs

**Confidence:** High | **Estimated Time:** 3 minutes

### Analysis
Similar to other unwrap() issues, this call ignores Rust's emphasis on safe error handling through the Result type, which encodes success/failure at the type level. Borrowing semantics are unaffected, but the panic can invalidate assumptions about program state, especially in concurrent DAW operations where ownership transfers might be involved. In async Tauri contexts, this bypasses proper await error propagation via futures::Future trait bounds.

### Fix Steps
1. Locate the specific unwrap() in the DAW command logic.
2. Replace with ? if the function can return an error, leveraging Rust's early return pattern.
3. For infallible cases (e.g., after checks), use expect() with a descriptive message.
4. Consider wrapping in anyhow::Context for chained errors if using anyhow crate.

### Code Example
```rust
// BEFORE:
let config = load_config().unwrap();

// AFTER:
let config = load_config()?;
// Add at top: use anyhow::Result; // if using anyhow
```

---

## Issue #3: Unsafe unwrap() call in mixer.rs

**Confidence:** High | **Estimated Time:** 4 minutes

### Analysis
unwrap() on Results in mixer commands discards error information, contravening Rust's ownership model where errors should be owned and handled explicitly. In real-time audio/MIDI contexts, panics from unwrap() can cause audio dropouts or unsafe states, as they interrupt lock-free paths. The type system prevents silent failures, but unwrap() enforces a panic, ignoring Option/Result combinators like map or unwrap_or_else.

### Fix Steps
1. Examine the unwrap() in mixer state access or audio ops.
2. Use ? for propagation in async mixer commands.
3. If safe to assume success (e.g., validated inputs), document with expect().
4. For performance-critical paths, consider fallbacks like unwrap_or_default() if Option<T>.

### Code Example
```rust
// BEFORE:
let track = mixer.get_track(id).unwrap();

// AFTER:
let track = mixer.get_track(id)?;
// Ensure function returns Result<Track, MixerError>
```

---

## Issue #4: Unsafe unwrap() call in mixer.rs

**Confidence:** High | **Estimated Time:** 3 minutes

### Analysis
This instance likely involves assuming a successful operation in mixer adjustments, but Rust's lifetimes ensure borrowed data is valid only if errors are handled. unwrap() can lead to use-after-free-like panics in concurrent mixer threads, violating Send/Sync bounds. Proper use of as_ref() or borrowing could avoid ownership transfer issues leading to unwrap().

### Fix Steps
1. Replace unwrap() with pattern matching or combinators for clarity.
2. Prefer ? in Result-returning functions to leverage Rust's monadic error handling.
3. Add expect() if the call is post-validation, explaining the safety.
4. Review for async contexts; ensure .await? if on futures.

### Code Example
```rust
// BEFORE:
let volume = get_volume().unwrap();

// AFTER:
let volume = get_volume().map_err(|e| anyhow::anyhow!("Failed to get volume: {}", e))?;
// Or simply: let volume = get_volume()?;
```

---

## Issue #5: Unsafe unwrap() call in mixer.rs

**Confidence:** High | **Estimated Time:** 4 minutes

### Analysis
In the mixer module, unwrap() undermines error resilience in potentially hot paths for audio processing. Rust's Drop semantics ensure cleanup on panic, but proactive handling via Result prevents it. This could relate to trait bounds where methods return Results, and unwrap() ignores the associated type requirements for error handling.

### Fix Steps
1. Identify and contextualize the unwrap() (e.g., on a parse or load).
2. Convert to ? operator for idiomatic propagation.
3. Use match for complex handling if ? isn't suitable.
4. Document with expect() only if truly infallible, e.g., after runtime checks.

### Code Example
```rust
// BEFORE:
let parsed = parse_midi_event(data).unwrap();

// AFTER:
let parsed = parse_midi_event(data).context("MIDI parsing failed")?;
// Requires: use anyhow::{Context, Result};
```

---

## Issue #1: Unsafe unwrap() call detected in mixer.rs

**Confidence:** High | **Estimated Time:** 3 minutes

### Analysis
The unwrap() method on Option<T> or Result<T, E> forces extraction of the inner value, panicking on None or Err variants. This violates Rust's ownership and error handling principles by not propagating errors or providing fallbacks, potentially leading to runtime crashes. In the context of Tauri commands for MIDI/audio processing, panics can disrupt real-time operations. Rust's type system encourages explicit error handling via combinators (? operator, match) or documented assumptions (expect) to maintain memory safety and composability.

### Fix Steps
1. Locate the unwrap() call, likely on a Result from an API like serde_json or a Tauri invoke.
2. If the function returns Result, replace with the ? operator to propagate the error.
3. If propagation isn't possible, use expect('Detailed reason why this should not fail') for documentation, or handle with match/if let for graceful degradation.
4. Ensure the surrounding function signature includes proper error types, e.g., using anyhow::Result for simplicity in commands.

### Code Example
```rust
// BEFORE:
let value = some_result.unwrap();

// AFTER:
let value = some_result.expect("Configuration loading must succeed in mixer init");
```

---

## Issue #2: Unsafe unwrap() call detected in mixer.rs

**Confidence:** High | **Estimated Time:** 3 minutes

### Analysis
unwrap() bypasses Rust's sum types (Option/Result), ignoring the Err/None case and triggering a panic, which contravenes the language's emphasis on exhaustive pattern matching and error propagation. In async Tauri contexts with MIDI constraints, this can cause allocation-free hot paths to fail catastrophically. Lifetimes and borrowing are unaffected, but it undermines the safety guarantees of the type system by assuming infallible operations.

### Fix Steps
1. Identify the specific unwrap(), possibly on a parsed JSON or channel receive in the mixer command.
2. For Option<T>, use unwrap_or(default) or if let Some(v) = opt { ... } else { handle fallback }.
3. For Result<T, E>, prefer ? if in an async fn returning Result, or map_err to convert errors.
4. Add imports like use anyhow::Result; if using anyhow for error chaining.

### Code Example
```rust
// BEFORE:
let channel = receiver.recv().unwrap();

// AFTER:
let channel = receiver.recv().expect("Mixer channel must be available during setup");
```

---

## Issue #3: Unsafe unwrap() call detected in mixer.rs

**Confidence:** High | **Estimated Time:** 4 minutes

### Analysis
By using unwrap(), the code discards the discriminant of Result or Option, leading to undefined behavior on failure via panic. Rust's ownership model ensures values are handled explicitly, and unwrap() shortcuts this, risking memory unsafety in edge cases like concurrent MIDI access. In real-time audio, panics can introduce latency or drops, violating lock-free best practices.

### Fix Steps
1. Scan for unwrap() in mixer logic, e.g., on Vec or String conversions.
2. Replace with appropriate combinator: for Vec, use .ok_or('Error msg')?.into_iter() if needing to propagate.
3. Use expect() with a context-specific message to assert safety invariants without full handling.
4. Consider wrapping in a custom error type with thiserror for better diagnostics.

### Code Example
```rust
// BEFORE:
let tracks: Vec<Track> = json::from_value(value).unwrap();

// AFTER:
let tracks: Vec<Track> = json::from_value(value).map_err(|e| anyhow::anyhow!("Invalid track JSON: {}", e))?; 
```

---

## Issue #4: Unsafe unwrap() call detected in mixer.rs

**Confidence:** High | **Estimated Time:** 3 minutes

### Analysis
unwrap() enforces a total function where the type indicates partiality (Option/Result), conflicting with Rust's trait bounds and generic programming paradigms that favor monadic error handling. In FFI or async boundaries common in Tauri/MIDI, this can mask lifetime issues or borrow checker violations, leading to subtle bugs under load.

### Fix Steps
1. Target the unwrap(), perhaps on a state access or config load in mixer.rs.
2. If safe to assume success (e.g., internal invariant), use expect('Invariant: mixer state always initialized').
3. Otherwise, implement full handling: match result { Ok(v) => v, Err(e) => log::error!("{}", e); default_value }.
4. For performance in hot paths, prefer zero-cost abstractions like unwrap_or_else(|| compute_fallback()) avoiding allocations.

### Code Example
```rust
// BEFORE:
let state = mixer_state.lock().unwrap().get_track(id);

// AFTER:
let state = mixer_state.lock().map_err(|e| anyhow::anyhow!("Poisoned lock: {}", e))?;
let track = state.get_track(id).cloned().unwrap_or_default();
```

---

## Issue #5: Unsafe unwrap() call detected in mixer.rs

**Confidence:** High | **Estimated Time:** 3 minutes

### Analysis
The unwrap() call ignores Rust's error monad design, where Result/Option encourage composition via and_then/map over panicking. This is particularly hazardous in macro-expanded code or trait implementations for audio processing, as it can propagate panics across async boundaries, violating Drop semantics and potentially leaking resources in MIDI event loops.

### Fix Steps
1. Find the final unwrap() instance, likely in response serialization or event emission.
2. Convert to proper handling: use .ok()? or .context('Mixer command failed')? with anyhow.
3. For production readiness, integrate with tracing or log crate for error logging without panicking.
4. Ensure no allocations in hot paths by using &str/&[u8] where possible instead of owned types post-unwrap.

### Code Example
```rust
// BEFORE:
let response = build_response(data).unwrap();

// AFTER:
let response = build_response(data).context("Failed to build mixer response")?;
Ok(response)
```

---

## Issue #1: Unsafe unwrap() call detected in mixer.rs

**Confidence:** High | **Estimated Time:** 3 minutes

### Analysis
The unwrap() method on Option<T> or Result<T, E> forces the extraction of the inner value, panicking at runtime if the variant is None or Err. This violates Rust's emphasis on explicit error handling and memory safety principles, as panics can lead to abrupt program termination without graceful degradation. In the context of ownership, unwrap() consumes the Option/Result but doesn't address the borrow checker or lifetime issues directly; instead, it introduces a potential DoS vector in production code, especially in a Tauri command handler where user input (e.g., JSON deserialization) might fail. Rust encourages using combinators like map, and_then, or the ? operator to propagate errors idiomatically, aligning with the type system's flow-sensitive analysis.

### Fix Steps
1. Identify the unwrap() call, likely on a Result from an API like serde_json::from_value or a file I/O operation in the mixer context.
2. If the enclosing function returns Result, replace unwrap() with the ? operator to propagate the error.
3. If error propagation isn't feasible (e.g., in a hot path), use expect('detailed reason why this cannot fail') to document safety, but prefer handling for production readiness.
4. Update the function signature if needed to return Result<(), Box<dyn std::error::Error>> or use anyhow::Result for simplicity in Tauri commands.

### Code Example
```rust
// BEFORE:
let config: MixerConfig = serde_json::from_value(value).unwrap();

// AFTER:
use anyhow::Result;

let config: MixerConfig = serde_json::from_value(value).map_err(|e| anyhow::anyhow!('Failed to deserialize mixer config: {}', e))?; // Assuming anyhow is used for error handling
```

---

## Issue #2: Unsafe unwrap() call detected in mixer.rs

**Confidence:** High | **Estimated Time:** 4 minutes

### Analysis
Similar to other unwrap issues, this call discards error information from a Result or Option, potentially from an async operation like a Tokio channel receive or MIDI event parsing. Rust's async/await model relies on explicit error propagation to maintain composability; unwrap() short-circuits this by panicking, which can corrupt real-time audio/MIDI processing threads. In terms of lifetimes, if the unwrap is on a borrowed value, it might mask lifetime mismatches, but the core issue is runtime safetyâ€”panics bypass Rust's no-exceptions guarantee, leading to unsafe state in lock-free data structures common in audio mixers.

### Fix Steps
1. Locate the unwrap(), possibly on a future's await like some_async_fn().await.unwrap().
2. In async contexts, use .await? to propagate errors up the call stack.
3. For Options from MIDI buffer reads, use if let Some(val) = opt { ... } else { handle_missing() } to avoid unwrap.
4. Consider custom error types with thiserror for domain-specific errors in the mixer module.

### Code Example
```rust
// BEFORE:
let event = receiver.recv().await.unwrap();

// AFTER:
use anyhow::Result;

let event = receiver.recv().await.map_err(|e| anyhow::anyhow!('Failed to receive mixer event: {}', e))?; // Propagates JoinError or similar
```

---

## Issue #3: Unsafe unwrap() call detected in mixer.rs

**Confidence:** High | **Estimated Time:** 2 minutes

### Analysis
This unwrap likely stems from assuming success in a fallible operation, such as parsing mixer state from user input or querying a shared audio resource. Rust's ownership model ensures compile-time safety, but unwrap() introduces runtime unsafety by not respecting the Result's Err branch, which could represent I/O failures or invalid MIDI data. In generic programming, if this is within a trait impl (e.g., for MixerTrait), it might violate trait bounds expecting proper error handling, leading to non-idiomatic code that doesn't leverage combinators like ok_or_else() for zero-cost abstractions.

### Fix Steps
1. Replace unwrap() with a match expression for explicit handling if propagation isn't suitable.
2. Use unwrap_or_default() or unwrap_or_else(|| default_value) for Options where a sensible default exists, avoiding panics.
3. In performance-critical mixer code, prefer early returns with ? to minimize branching in hot paths.
4. Add logging (e.g., via tracing) for errors to aid debugging without panicking.

### Code Example
```rust
// BEFORE:
let volume = parse_volume(input).unwrap();

// AFTER:
let volume = match parse_volume(input) {
    Ok(v) => v,
    Err(e) => {
        tracing::warn!('Invalid volume input {}: {}', input, e);
        0.0 // or default
    }
};
```

---

## Issue #4: Unsafe unwrap() call detected in mixer.rs

**Confidence:** High | **Estimated Time:** 5 minutes

### Analysis
Unwrap() here probably ignores potential failures in resource acquisition, like locking a Mutex for mixer state, where poisoning (from prior panics) returns Err. Rust's Drop trait and RAII ensure cleanup, but unwrap on poisoned locks can propagate instability. In FFI boundaries (possible with MIDI libs), this exacerbates unsafe code risks by masking errors that could lead to memory leaks or invalid borrows. The type system flags this as unsafe because it bypasses exhaustive pattern matching, a core Rust concept for reliability.

### Fix Steps
1. For Mutex::lock(), use lock().map_err(|poisoned| poisoned.into_inner())? to recover from poisoning safely.
2. If it's an Option from a get() on a HashMap (e.g., mixer channels), use entry API or get_or_insert to handle missing keys idiomatically.
3. Profile the fix for performance; in real-time audio, avoid allocations in error paths.
4. Use expect() only if logically impossible to fail, with a comment explaining why.

### Code Example
```rust
// BEFORE:
let guard = mixer_state.lock().unwrap();

// AFTER:
use std::sync::{MutexGuard, LockResult};

let guard: MutexGuard<_> = mixer_state.lock().map_err(|e| {
    // Recover from poison
    e.into_inner()
}).expect('Mixer state poisoned - application inconsistency'); // Or propagate if possible
```

---

## Issue #5: Unsafe unwrap() call detected in mixer.rs

**Confidence:** High | **Estimated Time:** 3 minutes

### Analysis
The final unwrap in this file likely relates to serialization or response building in Tauri, such as to_value() on a struct returning Result. This ignores serde errors, which could arise from cyclic references or unserializable types in mixer data (e.g., closures in audio graphs). Rust's trait design (Serialize/Deserialize) expects error propagation to maintain API contracts; unwrap() undermines this, potentially causing silent failures or panics during JSON emission. In async contexts, it compounds with Send/Sync bounds, risking data races if errors are not handled.

### Fix Steps
1. Replace with .map_err(|e| format!('Serialization failed: {}', e))? for stringly-typed errors in Tauri.
2. Use unwrap_or(serde_json::Value::Null) for graceful degradation in responses.
3. Ensure all mixer structs derive Serialize/Debug, and use #[serde(deny_unknown_fields)] for input validation.
4. For production, integrate with a global error handler in Tauri config.

### Code Example
```rust
// BEFORE:
let response = mixer_data.to_value().unwrap();

// AFTER:
let response = mixer_data.to_value().map_err(|e| {
    tauri::api::Error::Serialization(e.to_string())
})?; // Assuming Tauri command context
```

---

## Issue #1: Unsafe unwrap() call detected in mixer.rs

**Confidence:** High | **Estimated Time:** 3 minutes

### Analysis
The unwrap() method on Option<T> or Result<T, E> forces the program to panic at runtime if the value is None or Err, respectively. This violates Rust's emphasis on explicit error handling and memory safety principles, as panics can lead to abrupt program termination without graceful degradation. In the context of a Tauri command handler (likely involving async operations or FFI with JavaScript), this can crash the entire application thread. Rust's ownership model encourages propagating errors via Result types rather than suppressing them, allowing callers to handle failures idiomatically without runtime crashes.

### Fix Steps
1. Identify the unwrap() call on a Result or Option.
2. Replace with .expect('detailed error message') if the operation is guaranteed to succeed due to prior invariants (e.g., checked inputs), providing documentation for why it's safe.
3. For production code, propagate the error by changing the function return type to Result<T, E> and returning the Err variant, using ? operator for concise error propagation.
4. If in an async context (common in Tauri), ensure the error type implements std::error::Error for compatibility with anyhow or thiserror.

### Code Example
```rust
// BEFORE:
let value = some_result.unwrap();

// AFTER:
let value = some_result.expect("Failed to load mixer state: invalid configuration"); // Or use ? if function returns Result
```

---

## Issue #2: Unsafe unwrap() call detected in mixer.rs

**Confidence:** High | **Estimated Time:** 4 minutes

### Analysis
unwrap() discards error information and panics, contravening Rust's type system which uses Result and Option to enforce compile-time checks for potential failures. In audio/MIDI processing contexts like a mixer, unwrap() on operations such as parsing MIDI events or accessing shared state can lead to undefined behavior under load, especially in real-time constraints where panics disrupt lock-free paths. Lifetimes and borrowing rules in Rust promote safe access; unwrap() bypasses this by assuming success, risking ownership violations if not handled.

### Fix Steps
1. Locate the specific unwrap() in the mixer command logic, likely on a parse or I/O operation.
2. Use pattern matching (match or if let) to handle both Ok and Err cases explicitly, logging errors with tracing or log crate for debugging.
3. Refactor to use combinators like .ok_or() or .map_err() to convert to a custom error type, ensuring zero-allocation in hot paths for performance.
4. Add necessary imports for error types, e.g., use anyhow::Result for simplified propagation.

### Code Example
```rust
// BEFORE:
let config = json::parse(&input).unwrap();

// AFTER:
use anyhow::Result;

let config: Result<serde_json::Value, anyhow::Error> = serde_json::from_str(&input).map_err(anyhow::Error::msg);
let config = config?; // Propagates error if in a Result-returning function
```

---

## Issue #3: Unsafe unwrap() call detected in mixer.rs

**Confidence:** High | **Estimated Time:** 3 minutes

### Analysis
Rust's error model treats errors as values to be handled, not exceptions; unwrap() inverts this by converting a compile-time opportunity for handling into a runtime panic. In a systems-level context like Tauri with potential async MIDI I/O, this can violate Drop semantics if panics occur during ownership transfer, leading to resource leaks (e.g., uncleaned audio buffers). Trait bounds like IntoIterator or AsRef could be used instead to avoid unwraps on optional conversions.

### Fix Steps
1. Examine the unwrap() context, possibly on an Option from a HashMap get or similar in mixer state management.
2. Replace with .unwrap_or_default() or .cloned() for Options if a default is semantically correct, avoiding panics while respecting ownership.
3. For Results, use .context('operation description') from anyhow to enrich errors before propagation.
4. Ensure thread-safety if in a multi-threaded mixer; consider Arc<Mutex<T>> but prefer lock-free alternatives like crossbeam for real-time audio.

### Code Example
```rust
// BEFORE:
let track = mixer_tracks.get(&id).unwrap();

// AFTER:
let track = mixer_tracks.get(&id).cloned().unwrap_or_else(|| Track::default()); // Or propagate if needed: .ok_or(MyError::TrackNotFound(id))?;
```

---

## Issue #4: Unsafe unwrap() call detected in mixer.rs

**Confidence:** High | **Estimated Time:** 5 minutes

### Analysis
The use of unwrap() ignores Rust's borrow checker and lifetime guarantees, potentially masking lifetime mismatches that could lead to use-after-free if the unwrapped value's lifetime ends prematurely. In async/await patterns (tokio in Tauri), unwrap() on futures' poll results can deadlock or panic in hot paths, conflicting with no-allocation requirements for real-time audio/MIDI where jitter from panics is unacceptable.

### Fix Steps
1. Pinpoint the unwrap(), likely in an async block or future resolution within the mixer command.
2. Convert to async error handling with .await? on Results, ensuring the enclosing function is async and returns impl Future<Output = Result<T, E>>.
3. Use expect() only if backed by invariants (e.g., 'index always valid due to prior bounds check'), but prefer full handling.
4. Import tokio::try_join! or similar for composing async operations without unwraps.

### Code Example
```rust
// BEFORE:
let data = some_async_fn().await.unwrap();

// AFTER:
use anyhow::Result;

let data = some_async_fn().await?; // Assumes function returns Result<impl Future<Output = Result<T, E>>, E>
```

---

## Issue #5: Unsafe unwrap() call detected in mixer.rs

**Confidence:** High | **Estimated Time:** 4 minutes

### Analysis
unwrap() undermines Rust's generic programming model by not leveraging trait bounds like Debug or Display for errors, making debugging harder. In FFI boundaries (Tauri to Rust), unwrap() can propagate panics across boundaries, crashing the renderer process. For performance-critical code like mixers, it introduces non-deterministic behavior, violating cache-friendly and SIMD optimization assumptions by potentially skipping error paths that are allocation-free.

### Fix Steps
1. Identify the final unwrap() in the chain, perhaps on a serialization step for returning mixer state to Tauri.
2. Refactor to use serde's error handling with Result, employing .map_err(|e| anyhow::anyhow!('Serialization failed: {}', e)) for context.
3. If safe due to validation, use unwrap_unchecked() only in unsafe blocks with justifications, but avoid for safety.
4. Test edge cases: empty inputs, invalid MIDI data, to ensure no panics.

### Code Example
```rust
// BEFORE:
let response = mixer_state.to_json().unwrap();

// AFTER:
use serde_json::to_string;

let response = to_string(&mixer_state).map_err(|e| anyhow::anyhow!("Failed to serialize mixer state: {}", e))?;
```

---

## Issue #1: Unsafe unwrap() call in mixer.rs

**Confidence:** High | **Estimated Time:** 3 minutes

### Analysis
The unwrap() method on Result or Option types forces the evaluation of the inner value, panicking on Err or None variants. This violates Rust's error handling philosophy, which emphasizes explicit error propagation via Result<T, E> or Option<T> to maintain memory safety and prevent unexpected program termination. In the context of Tauri commands, which often involve async operations and user-facing APIs, panics can lead to unhandled crashes, undermining the ownership model's guarantee of controlled resource management. The issue likely stems from assuming infallible operations, ignoring Rust's type system enforcement of handling potential failures from I/O, parsing, or API calls.

### Fix Steps
1. Identify the unwrap() call on a Result or Option.
2. If the enclosing function returns Result, replace with the ? operator to propagate the error idiomatically.
3. If error propagation isn't feasible, use expect('detailed reason') to document the assumption of success, or handle with match for custom logic.
4. Ensure the function signature supports Result if using ?; add anyhow::Result for convenient error chaining if not already present.

### Code Example
```rust
// BEFORE:
let value = some_fallible_operation().unwrap();

// AFTER:
let value = some_fallible_operation()?;
// Or, if panicking is acceptable but documented:
let value = some_fallible_operation().expect("Operation must succeed due to prior validation");
```

---

## Issue #2: Unsafe unwrap() call in mixer.rs

**Confidence:** High | **Estimated Time:** 3 minutes

### Analysis
Similar to other unwrap() issues, this call discards error information by panicking, contravening Rust's ownership and borrowing rules that encourage safe error handling to avoid undefined behavior in concurrent or async contexts like Tauri. In audio/MIDI processing (mixer.rs), where real-time constraints apply, panics disrupt lock-free paths and allocations, potentially causing audio glitches or data races if not isolated. The root cause is likely oversight in assuming guaranteed success from operations like JSON serialization or state access, ignoring lifetime-bound failures.

### Fix Steps
1. Locate the specific unwrap() in the mixer command logic.
2. Replace with ? if in an async fn returning Result, leveraging Rust's async/await error propagation.
3. For Options, use methods like ok_or() to convert to Result if needed, or unwrap_or_default() for safe defaults.
4. Import anyhow if not present for contextual error messages.

### Code Example
```rust
// BEFORE:
let config = mixer_state.get_config().unwrap();

// AFTER:
let config = mixer_state.get_config()?;
// Assuming the function now returns Result<Config, anyhow::Error>
```

---

## Issue #3: Unsafe unwrap() call in mixer.rs

**Confidence:** High | **Estimated Time:** 4 minutes

### Analysis
unwrap() here ignores Rust's type system safeguards, where Result/Option enforce explicit handling to preserve memory safety. In mixer.rs, likely involving audio graph or MIDI state, this could stem from unsafe assumptions about borrow checker-validated accesses failing at runtime, leading to panics that bypass Drop traits for cleanup in real-time loops. Rust's emphasis on zero-cost abstractions makes proper handling essential for performance without allocation in hot paths.

### Fix Steps
1. Examine the unwrap() context, e.g., on a Vec or HashMap access.
2. Use if let or match for granular control if ? isn't suitable.
3. Prefer expect() over unwrap() to add runtime assertions with explanations.
4. Consider wrapping in a custom error type with thiserror for domain-specific errors.

### Code Example
```rust
// BEFORE:
let track = tracks.get(&id).unwrap();

// AFTER:
let track = tracks.get(&id).cloned().ok_or_else(|| anyhow::anyhow!("Track {} not found", id))?;
// Or simply:
let track = tracks.get(&id).expect("Track must exist after insertion");
```

---

## Issue #4: Unsafe unwrap() call in pipeline.rs

**Confidence:** High | **Estimated Time:** 3 minutes

### Analysis
In pipeline.rs, which likely handles audio processing chains, unwrap() panics disrupt the non-blocking, async nature of Rust's futures ecosystem (e.g., tokio). This ignores ownership transfer semantics in pipeline stages, where errors from buffer allocations or FFI MIDI calls should propagate to maintain safety. The issue arises from treating potentially failing operations (e.g., graph node connections) as infallible, conflicting with Rust's trait bounds for error-handling iterators or streams.

### Fix Steps
1. Target the unwrap() in pipeline construction or execution.
2. Integrate with async error handling using .await? in tokio contexts.
3. Use Result combinators like map_err() for custom error mapping.
4. Add imports for anyhow or thiserror if propagating domain errors.

### Code Example
```rust
// BEFORE:
let node = pipeline.add_node(config).unwrap();

// AFTER:
let node = pipeline.add_node(config)?;
// Ensure the command fn is async fn command() -> Result<(), Error> { ... }
```

---

## Issue #5: Unsafe unwrap() call in pipeline.rs

**Confidence:** High | **Estimated Time:** 4 minutes

### Analysis
This unwrap() undermines Rust's safety guarantees in async pipelines, where lifetimes and borrowing in streaming audio/MIDI data could lead to dangling references if panics occur mid-processing. Rooted in API design assuming success from operations like buffer slicing or effect chaining, it bypasses Option/Result for explicit failure modes, risking performance hits from unwinding in no-allocation hot paths typical of real-time audio.

### Fix Steps
1. Inspect the unwrap() on likely a future or stream resolution.
2. Replace with proper async error handling, e.g., select! or join! with Results.
3. If safe to default, use unwrap_or() for Options; otherwise, propagate.
4. Document with expect() if the operation is validated earlier in the code.

### Code Example
```rust
// BEFORE:
let output = process_pipeline(input).unwrap();

// AFTER:
let output = process_pipeline(input).await?;
// In an async context returning Result<Output, PipelineError>
```

---

## Issue #1: Safety - Unsafe unwrap() call detected

**Confidence:** High | **Estimated Time:** 5 minutes

### Analysis
The unwrap() method on Result or Option types forces the extraction of the inner value, panicking on Err or None variants. This violates Rust's emphasis on explicit error handling and memory safety principles, as panics can lead to abrupt program termination without cleanup, potentially causing resource leaks (e.g., in Drop impls for file handles or async tasks). In the context of Rust's ownership model, unwrap() discards error information that should be propagated via lifetimes or trait bounds like Error, making it non-idiomatic for production code, especially in a MIDI pipeline where real-time constraints demand predictable behavior without crashes.

### Fix Steps
1. Identify the unwrap() call and determine if the surrounding function can return a Result<T, E> to propagate errors using the ? operator.
2. If propagation isn't feasible (e.g., in a main or non-Result context), use match or if let to handle the Option/Result explicitly, logging errors with a crate like tracing or log.
3. For cases where the value is logically guaranteed (e.g., after prior checks), replace with expect('detailed reason') to document safety without panicking silently.
4. Ensure imports for error types (e.g., anyhow::Result) if using a higher-level error crate, and consider adding #[cfg(debug_assertions)] for unwrap in debug builds only.

### Code Example
```rust
// BEFORE:
let value = some_result.unwrap();

// AFTER:
let value = match some_result {
    Ok(v) => v,
    Err(e) => {
        log::error!("Failed to get value: {}", e);
        return Err(anyhow::anyhow!("Pipeline error: {}", e));
    }
};
```

---

## Issue #2: Safety - Unsafe unwrap() call detected

**Confidence:** High | **Estimated Time:** 5 minutes

### Analysis
The unwrap() method on Result or Option types forces the extraction of the inner value, panicking on Err or None variants. This violates Rust's emphasis on explicit error handling and memory safety principles, as panics can lead to abrupt program termination without cleanup, potentially causing resource leaks (e.g., in Drop impls for file handles or async tasks). In the context of Rust's ownership model, unwrap() discards error information that should be propagated via lifetimes or trait bounds like Error, making it non-idiomatic for production code, especially in a MIDI pipeline where real-time constraints demand predictable behavior without crashes.

### Fix Steps
1. Locate the specific unwrap() in the pipeline.rs file and assess the error type (e.g., io::Error for file ops or custom MIDI errors).
2. Refactor to use the ? operator if the function returns Result, ensuring proper trait bounds like E: std::error::Error.
3. For non-propagatable cases, implement fallback logic with Option::unwrap_or_default() or Result::unwrap_or_else(), avoiding panics.
4. Add unit tests to verify error paths, using #[should_panic] for legacy unwrap if needed during migration.

### Code Example
```rust
// BEFORE:
let config = load_config().unwrap();

// AFTER:
use anyhow::Result;

let config = load_config()?;
// Or if not propagating:
let config = load_config().unwrap_or_else(|e| {
    eprintln!("Config load failed: {}", e);
    Default::default()
});
```

---

## Issue #3: Safety - Unsafe unwrap() call detected

**Confidence:** High | **Estimated Time:** 5 minutes

### Analysis
The unwrap() method on Result or Option types forces the extraction of the inner value, panicking on Err or None variants. This violates Rust's emphasis on explicit error handling and memory safety principles, as panics can lead to abrupt program termination without cleanup, potentially causing resource leaks (e.g., in Drop impls for file handles or async tasks). In the context of Rust's ownership model, unwrap() discards error information that should be propagated via lifetimes or trait bounds like Error, making it non-idiomatic for production code, especially in a MIDI pipeline where real-time constraints demand predictable behavior without crashes.

### Fix Steps
1. Examine the unwrap() context (e.g., async future awaiting or MIDI event parsing) to choose between propagation and local handling.
2. Prefer combinators like ok_or() or map_err() for concise error conversion, maintaining zero-copy where possible for performance.
3. If in a hot path (e.g., real-time audio), use expect() with a clear rationale, but benchmark to ensure no allocation overhead.
4. Integrate with a global error handler if using anyhow, chaining contexts for better debugging in the pipeline.

### Code Example
```rust
// BEFORE:
let event = parse_midi_event(buffer).unwrap();

// AFTER:
let event = parse_midi_event(buffer)
    .map_err(|e| anyhow::anyhow!("MIDI parse error: {}", e))?;
// For Option:
let event = parse_midi_event(buffer).ok_or_else(|| anyhow::anyhow!("No event"))?; 
```

---

## Issue #4: Safety - Unsafe unwrap() call detected

**Confidence:** High | **Estimated Time:** 5 minutes

### Analysis
The unwrap() method on Result or Option types forces the extraction of the inner value, panicking on Err or None variants. This violates Rust's emphasis on explicit error handling and memory safety principles, as panics can lead to abrupt program termination without cleanup, potentially causing resource leaks (e.g., in Drop impls for file handles or async tasks). In the context of Rust's ownership model, unwrap() discards error information that should be propagated via lifetimes or trait bounds like Error, making it non-idiomatic for production code, especially in a MIDI pipeline where real-time constraints demand predictable behavior without crashes.

### Fix Steps
1. Trace the unwrap() to its source (e.g., JSON deserialization in Tauri or MIDI device query) and add type annotations if inference fails.
2. Use if let Some/Ok patterns for borrowing-heavy code to avoid ownership transfer issues.
3. For performance-critical sections, consider unsafe { } only if proven safe via audits, but prefer safe error handling.
4. Document the fix with comments explaining the error scenario, aiding future maintenance in the pipeline module.

### Code Example
```rust
// BEFORE:
let device_id = get_device_id().unwrap();

// AFTER:
let device_id = get_device_id().context("Failed to retrieve MIDI device")?;
// Using anyhow for context; import: use anyhow::{Context, Result};
```

---

## Issue #5: Safety - Unsafe unwrap() call detected

**Confidence:** High | **Estimated Time:** 5 minutes

### Analysis
The unwrap() method on Result or Option types forces the extraction of the inner value, panicking on Err or None variants. This violates Rust's emphasis on explicit error handling and memory safety principles, as panics can lead to abrupt program termination without cleanup, potentially causing resource leaks (e.g., in Drop impls for file handles or async tasks). In the context of Rust's ownership model, unwrap() discards error information that should be propagated via lifetimes or trait bounds like Error, making it non-idiomatic for production code, especially in a MIDI pipeline where real-time constraints demand predictable behavior without crashes.

### Fix Steps
1. Review the entire pipeline.rs for patterns; batch fixes to ensure consistent error types across functions.
2. If unwrap() is on a clone-heavy operation, optimize with as_ref() or to borrow, preserving lifetimes.
3. Test the fix in a MIDI simulation to confirm no regressions in lock-free paths or async yields.
4. Consider procedural macros for boilerplate error handling if multiple similar unwraps exist.

### Code Example
```rust
// BEFORE:
let pipeline_state = build_pipeline().unwrap();

// AFTER:
use thiserror::Error;

#[derive(Error, Debug)]
enum PipelineError { #[error("Build failed")] Build };

type Result<T> = std::result::Result<T, PipelineError>;

let pipeline_state = build_pipeline().map_err(|_| PipelineError::Build)?;
// Import: use thiserror::Error;
```

---

## Issue #1: Safety - Unsafe unwrap() call detected

**Confidence:** High | **Estimated Time:** 3 minutes

### Analysis
In Rust's ownership and error handling model, `unwrap()` on `Option<T>` or `Result<T, E>` assumes the value is `Some` or `Ok`, panicking on `None` or `Err`. This violates Rust's safety principles by introducing potential runtime panics, which can crash the program unexpectedly, especially in a real-time MIDI/audio pipeline where panics in hot paths could disrupt audio processing or cause buffer underruns. Rust encourages explicit error propagation using the `?` operator or pattern matching to maintain memory safety and composability without unwinding the stack.

### Fix Steps
1. Identify the `unwrap()` call on a `Result` or `Option`.
2. If the enclosing function returns a `Result`, replace `unwrap()` with the `?` operator to propagate errors idiomatically.
3. If error propagation isn't feasible (e.g., in a hot path), use `expect()` with a descriptive message to document the assumption, or handle with `match` for graceful fallbacks like logging and default values.
4. In real-time contexts, prefer non-panicking alternatives like `unwrap_or_default()` to avoid allocation-heavy error handling.

### Code Example
```rust
// BEFORE:
let value = some_result.unwrap();

// AFTER:
let value = some_result.expect("Pipeline initialization must succeed in this context");
```

---

## Issue #2: Safety - Unsafe unwrap() call detected

**Confidence:** High | **Estimated Time:** 4 minutes

### Analysis
Rust's type system enforces safe error handling through `Option` and `Result` enums, but `unwrap()` bypasses this by force-unwrapping, leading to panics that contradict the language's zero-cost abstraction and ownership model. In a MIDI pipeline, this could stem from assuming successful operations like buffer allocations or async task joins, but failures (e.g., due to resource exhaustion) must be handled to prevent audio glitches or system instability.

### Fix Steps
1. Locate the specific `unwrap()` in the pipeline command, likely on an async operation or I/O result.
2. For async contexts with Tokio, use `.await?` if the function is async and returns `Result`.
3. Replace with `map_err()` or `context()` from `anyhow` to add context without panicking, ensuring thread-safe error propagation.
4. Test edge cases like resource unavailability to verify the fix maintains real-time constraints.

### Code Example
```rust
// BEFORE:
let data = async_operation().await.unwrap();

// AFTER:
import anyhow::Context;
let data = async_operation().await.context("Failed to fetch pipeline data")?;
```

---

## Issue #3: Safety - Unsafe unwrap() call detected

**Confidence:** High | **Estimated Time:** 3 minutes

### Analysis
The `unwrap()` method ignores Rust's lifetimes and borrowing rules by assuming infallible operations, but in practice, it can lead to use-after-free or invalid state if the underlying `Result` stems from unsafe FFI calls common in audio/MIDI (e.g., binding to C libraries). This breaks the contract of safe Rust code, potentially exposing memory safety issues in the pipeline's hot paths.

### Fix Steps
1. Examine the `unwrap()` context, possibly on a parsed MIDI event or buffer slice.
2. Use `ok_or_else(|| anyhow::anyhow!("Descriptive error"))?.` to convert `Option` to `Result` for uniform handling.
3. In lock-free audio paths, opt for `unwrap_or_else(|| default_value)` to provide fallbacks without allocation.
4. Consider wrapping in a custom error type with `thiserror` for domain-specific errors.

### Code Example
```rust
// BEFORE:
let event = parse_midi_buffer(buffer).unwrap();

// AFTER:
use anyhow::Result;
let event: MidiEvent = parse_midi_buffer(buffer).ok_or_else(|| anyhow::anyhow!("Invalid MIDI buffer"))?;
```

---

## Issue #4: Safety - Unsafe unwrap() call detected

**Confidence:** High | **Estimated Time:** 2 minutes

### Analysis
Rust's ownership semantics require explicit handling of potential failures to prevent data races or invalid borrows, but `unwrap()` short-circuits this, risking panics during concurrent MIDI processing (e.g., in Tokio tasks). In real-time systems, panics can cause desynchronization, violating the no-allocation hot path invariant and leading to jitter or dropouts.

### Fix Steps
1. Target the `unwrap()` likely in a command handler or pipeline setup.
2. Refactor to use combinators like `and_then()` or `unwrap_or()` for Options, preserving ownership transfer.
3. For performance, avoid `clone()` in fixes; use references (`&str` over `String`) where possible.
4. Add unit tests simulating failure modes to ensure the fix doesn't introduce allocations.

### Code Example
```rust
// BEFORE:
let config = load_config().unwrap();

// AFTER:
let config = load_config().unwrap_or_else(|| Config::default()); // Or use ? if returning Result
```

---

## Issue #5: Safety - Unsafe unwrap() call detected

**Confidence:** High | **Estimated Time:** 5 minutes

### Analysis
By design, Rust's trait bounds and generics (e.g., for iterator or future chains in pipelines) expect fallible operations to be handled explicitly, but `unwrap()` violates this, potentially masking lifetime issues or trait object safety problems. In MIDI software, this could occur in event dispatching, where failing to handle `None` events leads to incomplete processing and audio artifacts.

### Fix Steps
1. Inspect the final `unwrap()` in the file, perhaps on a collected result or joined future.
2. Prefer `collect::<Result<Vec<_>, _>>()?.` for iterators returning Results, avoiding individual unwraps.
3. Use `expect()` if the operation is guaranteed by prior invariants (e.g., validated inputs), documenting with comments.
4. Profile the fix to ensure no performance regression in the async pipeline.

### Code Example
```rust
// BEFORE:
let events = futures::join_all(tasks).await.into_iter().map(|r| r.unwrap()).collect();

// AFTER:
let events = futures::join_all(tasks).await.into_iter().collect::<Result<Vec<_>, _>>()?.
```

---

## Issue #1: Unsafe unwrap() call detected in pipeline.rs

**Confidence:** High | **Estimated Time:** 3 minutes

### Analysis
The unwrap() method on Option<T> or Result<T, E> forces the extraction of the inner value, panicking on None or Err variants. This violates Rust's ownership and error handling principles by potentially leading to runtime panics instead of safe error propagation. In the context of a Tauri command handler for MIDI pipeline processing, this could crash the entire application on invalid MIDI data or async failures, undermining memory safety guarantees. Rust's type system encourages explicit error handling via the ? operator or combinators to maintain control flow without unsafe panics.

### Fix Steps
1. Identify the unwrap() call, likely on a Result from an async operation or MIDI parsing.
2. If the enclosing function returns Result<(), TauriError> or similar, replace unwrap() with the ? operator to propagate the error.
3. If propagation isn't feasible, use .expect('detailed reason') for documentation, but prefer ? for production code.
4. Ensure the function signature supports Result return types, adding imports for anyhow or thiserror if needed for error aggregation.

### Code Example
```rust
// BEFORE:
let data = some_midi_pipeline_function().unwrap();

// AFTER:
let data = some_midi_pipeline_function()?;
// Assuming the function now returns Result<T, E> and propagates errors to Tauri.
```

---

## Issue #2: Unsafe unwrap() call detected in pipeline.rs

**Confidence:** High | **Estimated Time:** 4 minutes

### Analysis
unwrap() discards error information and risks panics, conflicting with Rust's emphasis on exhaustive pattern matching and safe resource management. In a real-time MIDI/audio pipeline, this could lead to dropped frames or desynchronized processing if an Option from a buffer lookup or Result from an I/O operation fails unexpectedly. Lifetimes and borrowing rules are indirectly affected if the unwrapped value's Drop isn't handled properly post-panic.

### Fix Steps
1. Locate the specific unwrap(), possibly on an Option from a hashmap lookup in the pipeline state.
2. Use match or if let for explicit handling: match on Ok/Err or Some/None to log or recover.
3. For async contexts (e.g., tokio), ensure the function is async and uses await with ?.
4. If using anyhow, wrap errors with context() for better debugging in MIDI traces.

### Code Example
```rust
// BEFORE:
let buffer = pipeline_state.get(&key).unwrap();

// AFTER:
let buffer = pipeline_state.get(&key).ok_or_else(|| anyhow::anyhow!("Missing pipeline key: {}", key))?;
// Import: use anyhow::{anyhow, Result};
```

---

## Issue #3: Unsafe unwrap() call detected in pipeline.rs

**Confidence:** High | **Estimated Time:** 3 minutes

### Analysis
By panicking on errors, unwrap() bypasses Rust's Result type for fallible operations, potentially leaking resources if the panic occurs mid-Drop for owned types like Vec<u8> in MIDI buffers. In pipeline.rs, this likely occurs during command deserialization or async task spawning, where trait bounds on serializable types (e.g., serde) expect proper error surfacing to maintain API contracts without runtime instability.

### Fix Steps
1. Replace unwrap() on a Result from serde_json or similar with ? in an async fn.
2. Annotate the function return type as -> Result<T, Box<dyn std::error::Error>> if not already.
3. For performance-critical paths, use unwrap_or_default() if a sensible default exists, but document with comments.
4. Test edge cases like invalid JSON payloads from Tauri to ensure no panics.

### Code Example
```rust
// BEFORE:
let config: PipelineConfig = serde_json::from_value(payload).unwrap();

// AFTER:
let config: PipelineConfig = serde_json::from_value(payload).map_err(|e| tauri::Error::from(e))?;
// Import: use tauri::Error; (adjust for Tauri v1 or v2 API)
```

---

## Issue #4: Unsafe unwrap() call detected in pipeline.rs

**Confidence:** High | **Estimated Time:** 5 minutes

### Analysis
unwrap() ignores the ownership transfer semantics of Result, where Err variants often hold owned error types that should be propagated rather than discarded via panic. In MIDI pipeline contexts with async/await, this could interrupt lock-free operations or SIMD-processed audio buffers, violating real-time constraints by introducing non-deterministic panics instead of graceful degradation.

### Fix Steps
1. Target the unwrap() likely on a future's output in an async block.
2. Use .await? to propagate errors from async operations like file I/O for MIDI files.
3. If in a hot path, consider zero-copy alternatives like Cow<str> for strings, but handle Options with unwrap_or_else(|| default::build()).
4. Add #[cfg(test)] for unit tests verifying error paths without panics.

### Code Example
```rust
// BEFORE:
let result = some_async_midi_load().await.unwrap();

// AFTER:
let result = some_async_midi_load().await?;
// Ensure the async fn returns impl Future<Output = Result<T, E>>
```

---

## Issue #5: Unsafe unwrap() call detected in pipeline.rs

**Confidence:** High | **Estimated Time:** 4 minutes

### Analysis
This usage undermines Rust's macro system and generic programming by not leveraging combinators like map_err or and_then, which preserve type invariants. For FFI boundaries in MIDI (e.g., with C libs), unwrap() on Results from unsafe calls exacerbates risks, as panics can corrupt foreign-owned memory without proper lifetime tracking.

### Fix Steps
1. Find the unwrap() near FFI or trait method calls in the pipeline.
2. Replace with .expect("Invariant: MIDI device always initialized") if logically guaranteed, else use ?.
3. Define a custom error enum with #[derive(thiserror::Error)] for MIDI-specific errors like InvalidPort.
4. Use as_ref() or to_owned() if borrowing is involved to avoid unnecessary clones.

### Code Example
```rust
// BEFORE:
let port = midi_backend.open_port(id).unwrap();

// AFTER:
let port = midi_backend.open_port(id).map_err(|e| MyMidiError::PortOpen { id, source: e })?;
// Define: #[derive(thiserror::Error, Debug)] pub enum MyMidiError { #[error("Failed to open port {id}")] PortOpen { id: u32, source: anyhow::Error } }
```

---

## Issue #1: Safety - Unsafe unwrap() call detected

**Confidence:** High | **Estimated Time:** 5 minutes

### Analysis
In Rust's ownership and error handling model, `unwrap()` on `Option<T>` or `Result<T, E>` assumes the value is `Some` or `Ok`, panicking otherwise. This violates Rust's safety principles by introducing runtime crashes instead of leveraging the type system to enforce error handling at compile time. Lifetimes and borrowing are unaffected, but it bypasses `Result`/`Option` combinators, leading to non-idiomatic code that ignores edge cases like I/O failures or missing data in a MIDI pipeline context.

### Fix Steps
1. Locate the `unwrap()` call in the pipeline command, likely on a `Result` from an async operation or parsing.
2. If the function can propagate errors (e.g., it's async and returns `Result`), replace with the `?` operator to delegate handling upstream.
3. If unwrapping is justified (e.g., configuration guarantees success), use `expect()` with a descriptive message.
4. Update the function signature to `async fn command() -> Result<(), Error>` if not already, using `anyhow::Result` for simplicity in Tauri commands.

### Code Example
```rust
// BEFORE:
let config = load_config().unwrap();

// AFTER:
use anyhow::{Result, Context};

let config = load_config().context("Failed to load MIDI pipeline config")?;
```

---

## Issue #2: Safety - Unsafe unwrap() call detected

**Confidence:** High | **Estimated Time:** 5 minutes

### Analysis
Rust's type system encodes possible failures via `Option` and `Result`, but `unwrap()` discards this information, potentially leading to panics in hot paths like real-time MIDI processing. This contradicts idiomatic error handling, where combinators like `map`, `and_then`, or `?` preserve ownership semantics without allocation overhead. In async contexts (e.g., Tokio in Tauri), it can cause task unwinding, disrupting the event loop.

### Fix Steps
1. Identify the specific `unwrap()` , possibly on a parsed MIDI event or async future result.
2. Replace with pattern matching or `ok_or()` to convert to `Result` for propagation.
3. Ensure no allocations in hot paths by using zero-copy methods if applicable (e.g., `as_ref()` for slices).
4. Add imports for error types like `thiserror` if custom errors are needed.

### Code Example
```rust
// BEFORE:
let event = parse_midi_data(buffer).unwrap();

// AFTER:
use anyhow::Result;

let event = parse_midi_data(buffer).ok_or(anyhow::anyhow!("Invalid MIDI data"))?;
```

---

## Issue #3: Safety - Unsafe unwrap() call detected

**Confidence:** High | **Estimated Time:** 5 minutes

### Analysis
The `unwrap()` method ignores Rust's borrow checker and lifetime guarantees by forcing a value out of a potentially absent state, risking undefined behavior in unsafe-adjacent code (e.g., FFI with MIDI libs). In generic programming, it violates trait bounds like `FromStr` which return `Result`. For performance-critical audio pipelines, panics introduce latency jitter, better handled by lock-free error channels.

### Fix Steps
1. Pinpoint the unwrap, likely on a `Vec` or string conversion in pipeline setup.
2. Use `unwrap_or_default()` or `unwrap_or_else(|| { ... })` for fallbacks without panic.
3. If in a generic context, add trait bounds like `T: Default` and use conditional logic.
4. Consider `eyre` or `anyhow` for contextual error reporting in production.

### Code Example
```rust
// BEFORE:
let path = env::var("MIDI_PATH").unwrap();

// AFTER:
use std::env;
use anyhow::Result;

let path = env::var("MIDI_PATH").unwrap_or_else(|_| "/default/path".to_string());
// Or for propagation:
let path = env::var("MIDI_PATH").map_err(|e| anyhow::anyhow!(e))?;
```

---

## Issue #4: Safety - Unsafe unwrap() call detected

**Confidence:** High | **Estimated Time:** 5 minutes

### Analysis
Rust encourages explicit error handling to maintain memory safety; `unwrap()` circumvents this, akin to ignoring `Drop` semantics by crashing before cleanup. In async/await patterns, it can leak resources (e.g., file handles in MIDI I/O). The API design of `futures` or `tokio` favors `await?` over unwrap, aligning with zero-cost abstractions and avoiding stack unwinding in real-time constraints.

### Fix Steps
1. Find the unwrap in an async block, perhaps awaiting a pipeline future.
2. Refactor to use `try_join!` or `select!` with proper error types for concurrent MIDI ops.
3. Annotate with lifetimes if borrowing across awaits.
4. Test edge cases like network timeouts in Tauri commands.

### Code Example
```rust
// BEFORE:
let data = some_async_fn().await.unwrap();

// AFTER:
use anyhow::Result;

let data = some_async_fn().await.context("Async MIDI pipeline failed")?;
```

---

## Issue #5: Safety - Unsafe unwrap() call detected

**Confidence:** High | **Estimated Time:** 5 minutes

### Analysis
In the context of trait design, `unwrap()` breaks compositionality by not respecting bounds like `FallibleIterator`. For MIDI software, where no allocations are desired in hot paths, panics from unwrap exacerbate issues with cache-friendly structures. Rust's macro system can't enforce unwrap avoidance, so manual review is key to uphold ownership transfer semantics.

### Fix Steps
1. Locate the final unwrap, possibly in a loop or macro-expanded code for pipeline processing.
2. Replace with `match` for exhaustive handling, or `if let` for simple cases.
3. Use `as_ref()` or `map(|x| &x)` to avoid ownership transfer if borrowing suffices.
4. Profile for performance post-fix to ensure no regressions in real-time audio.

### Code Example
```rust
// BEFORE:
for item in items {
    process(item.unwrap());
}

// AFTER:
for item in items {
    if let Some(processed) = item {
        process(processed);
    } else {
        log::warn!("Skipping invalid item in pipeline");
    }
}
```

---

## Issue #1: Unsafe unwrap() call detected in pipeline.rs

**Confidence:** High | **Estimated Time:** 5 minutes

### Analysis
The unwrap() method on Option or Result types forces the program to panic at runtime if the value is None or Err, violating Rust's safety guarantees by bypassing the type system's error propagation mechanisms. In Rust's ownership model, this is unsafe because it ignores potential failure modes without documentation or handling, potentially leading to crashes in production. For Tauri commands in a MIDI/audio context, this could disrupt real-time processing if the unwrap occurs in a path that affects audio pipelines. Reference: Rust's Result and Option enums enforce exhaustive handling via match or combinators to ensure memory safety and predictable behavior.

### Fix Steps
1. Identify the unwrap() call on a Result or Option.
2. If the enclosing function returns a Result, replace unwrap() with the ? operator to propagate the error idiomatically.
3. If error propagation isn't feasible, use match to handle Err/None cases explicitly, logging the error (e.g., via tracing or log crate) without panicking.
4. For cases where None/Err is impossible due to prior invariants, replace with expect() providing a descriptive message.
5. Add necessary imports like use anyhow::Result; if using anyhow for error types.

### Code Example
```rust
// BEFORE:
let value = some_option.unwrap();

// AFTER:
let value = match some_option {
    Some(v) => v,
    None => {
        log::warn!("Expected value was None in pipeline");
        return Err(anyhow::anyhow!("Pipeline configuration missing"));
    }
};
```

---

## Issue #2: Unsafe unwrap() call detected in pipeline.rs

**Confidence:** High | **Estimated Time:** 5 minutes

### Analysis
Similar to other unwrap issues, this call discards error information from a Result or Option, potentially causing panics that break Rust's zero-cost abstraction principle by introducing runtime overhead from unwinding. In the context of async Tauri commands for MIDI pipelines, unwrap() ignores borrow checker-enforced lifetimes of temporary values, risking use-after-free if the unwrapped value's lifetime is short. Rust encourages using combinators like .ok_or() or .context() from anyhow to chain errors without panicking.

### Fix Steps
1. Locate the specific unwrap() in the pipeline command.
2. Prefer the ? operator if the function signature allows Result propagation.
3. Otherwise, use if let or match for controlled handling, avoiding allocations in hot paths by using static strings for errors.
4. If the unwrap is on a guaranteed success (e.g., after a checked precondition), document with expect("invariant: pipeline init succeeded").
5. Ensure imports include use std::result::Result; and any error crate like anyhow.

### Code Example
```rust
// BEFORE:
let config = load_pipeline_config().unwrap();

// AFTER:
let config = load_pipeline_config()
    .map_err(|e| anyhow::anyhow!("Failed to load pipeline config: {}", e))?;
```

---

## Issue #3: Unsafe unwrap() call detected in system.rs

**Confidence:** High | **Estimated Time:** 3 minutes

### Analysis
unwrap() on system-related operations (e.g., env vars or file I/O) ignores Rust's type system safeguards against partial failures, where Result types model fallible operations explicitly. This can lead to ownership violations if the unwrapped value is moved unexpectedly, especially in FFI boundaries common in Tauri system commands. In a MIDI software context, system calls should use non-panicking alternatives to maintain lock-free guarantees and avoid interrupting real-time threads.

### Fix Steps
1. Examine the unwrap() in the system command context.
2. Replace with ? if the command returns a serde_json::Value or similar Result-wrapped type for Tauri.
3. For Options, use .unwrap_or_default() or .ok_or() to convert to Result with context.
4. Log errors using a crate like tracing for observability without crashing.
5. Import necessary types: use anyhow::{Context, Result};

### Code Example
```rust
// BEFORE:
let sys_info = get_system_info().unwrap();

// AFTER:
let sys_info = get_system_info()
    .context("Failed to retrieve system information")?;
```

---

## Issue #4: Unsafe unwrap() call detected in system.rs

**Confidence:** High | **Estimated Time:** 4 minutes

### Analysis
By using unwrap(), the code forfeits Rust's compile-time guarantees on error handling, treating Results as infallible when they model I/O or system query failures. This interacts poorly with lifetimes if the unwrapped borrow outlives its source, a common pitfall in system APIs. For production MIDI software, prefer Result combinators to ensure errors are surfaced to users via Tauri's error channels rather than silent panics.

### Fix Steps
1. Target the unwrap() likely on a system query or config load.
2. Use the ? operator for propagation in async contexts (if using tokio).
3. If synchronous, match on the Result and return a custom error type.
4. Document safety with expect() only if backed by tests asserting the invariant.
5. Add use thiserror::Error; if defining custom errors for system module.

### Code Example
```rust
// BEFORE:
let path = std::env::var("MIDI_CONFIG").unwrap();

// AFTER:
let path = std::env::var("MIDI_CONFIG")
    .map_err(|_| anyhow::anyhow!("MIDI_CONFIG environment variable not set"))?;
```

---

## Issue #5: Unsafe unwrap() call detected in system.rs

**Confidence:** High | **Estimated Time:** 5 minutes

### Analysis
This unwrap() exemplifies a common anti-pattern where Rust's ownership model is undermined by runtime panics instead of leveraging trait bounds like FallibleIterator or error traits. In system.rs for a DAW, such calls on resource acquisition (e.g., devices) can lead to inconsistent state, violating Drop semantics if cleanup isn't reached. Idiomatic fixes use anyhow or thiserror to chain and contextualize errors, preserving performance by avoiding unnecessary clones.

### Fix Steps
1. Identify the final unwrap() in system.rs.
2. Convert to proper handling: use .expect() if safe, else propagate with ? or match.
3. Consider edge cases like empty results in system queries, handling with defaults.
4. For real-time constraints, ensure error paths are allocation-free.
5. Imports: use log::{error, warn}; for non-panicking logging.

### Code Example
```rust
// BEFORE:
let devices = enumerate_midi_devices().unwrap();

// AFTER:
let devices = enumerate_midi_devices()
    .unwrap_or_else(|e| {
        error!("Failed to enumerate devices: {}", e);
        Vec::new()
    });
```

---

## Issue #1: Unsafe unwrap() call detected in system.rs

**Confidence:** High | **Estimated Time:** 5 minutes

### Analysis
The unwrap() method on Option<T> or Result<T, E> forces the program to panic if the value is None or Err, violating Rust's emphasis on explicit error handling and memory safety. In Rust's ownership model, this can lead to unexpected program termination, especially in a Tauri command handler where errors should be propagated back to the frontend via Result types rather than crashing the backend. This issue likely stems from assuming a fallible operation (e.g., parsing, file I/O, or config loading) always succeeds, ignoring the type system's enforcement of handling potential failures through lifetimes and borrow checker guarantees.

### Fix Steps
1. Identify the unwrap() call, typically on an Option or Result from an API like serde_json::from_str() or std::env::var().
2. Replace unwrap() with expect() if panicking is acceptable in this context, providing a descriptive message for debugging; otherwise, use ? operator to propagate the error if the enclosing function returns Result.
3. If in a Tauri command, ensure the function signature returns Result<serde_json::Value, String> or similar, and handle errors by mapping them to a serializable type.
4. Add necessary imports like use anyhow::Result; if using anyhow for error chaining.

### Code Example
```rust
// BEFORE:
let config: Config = serde_json::from_str(&json_str).unwrap();

// AFTER:
use anyhow::Result;

let config: Config = serde_json::from_str(&json_str)
    .map_err(|e| anyhow::anyhow!("Failed to parse config: {}", e))?
    .map_err(|e| format!("Config error: {}", e))?; // Or use expect("Config must be valid") if panicking is safe
```

---

## Issue #2: Unsafe unwrap() call detected in system.rs

**Confidence:** High | **Estimated Time:** 3 minutes

### Analysis
Similar to other unwrap() issues, this call bypasses Rust's Result/Option types, which are designed to enforce safe error propagation without panics. In the context of system commands (e.g., env vars or system info retrieval), operations like std::fs::read_to_string() return Result, and unwrapping ignores potential IO errors, conflicting with Rust's zero-cost abstractions and ownership semantics that prevent unhandled resource leaks or invalid states.

### Fix Steps
1. Locate the specific unwrap(), often on file operations or environment queries in system.rs.
2. Convert to proper handling: use ? for propagation in async or sync functions returning Result, or match/if let for local recovery.
3. Consider using thiserror for custom errors if multiple unwraps share error types, ensuring trait bounds like Error + Send + Sync for async contexts.
4. Import std::io::Error or anyhow::Context for better error messages.

### Code Example
```rust
// BEFORE:
let content = std::fs::read_to_string(path).unwrap();

// AFTER:
use std::io;

type Result<T> = std::result::Result<T, io::Error>;

let content = std::fs::read_to_string(path)
    .context("Failed to read system file")?; // Using anyhow::Context if imported
```

---

## Issue #3: Unsafe unwrap() call detected in system.rs

**Confidence:** High | **Estimated Time:** 4 minutes

### Analysis
unwrap() here likely occurs on a fallible conversion or parsing in system commands, where Rust's type system (via FromStr trait or TryFrom) signals potential failure, but the code assumes success. This undermines borrow checker's guarantees, as panics can leave borrowed resources in inconsistent states, especially with lifetimes in config or state management.

### Fix Steps
1. Examine the unwrap() context, e.g., on env::var() or json parsing.
2. Replace with ok_or_else() or map_err() combinators for idiomatic handling, preferring ? over match for conciseness.
3. If Option, use unwrap_or_default() if a default is semantically correct; document with expect() why it's safe.
4. Ensure imports like use std::env; and consider caching results to avoid repeated fallible ops.

### Code Example
```rust
// BEFORE:
let port: u16 = env::var("PORT").unwrap().parse().unwrap();

// AFTER:
let port: u16 = env::var("PORT")
    .ok()
    .and_then(|s| s.parse().ok())
    .unwrap_or(8080); // Or propagate: .map_err(|_| "Invalid PORT".to_string())?;
```

---

## Issue #4: Unsafe unwrap() call detected in system.rs

**Confidence:** High | **Estimated Time:** 5 minutes

### Analysis
In system.rs, this unwrap() probably targets a Result from a system API call (e.g., process::Command output), ignoring Rust's error model that treats errors as values to be owned and transferred. Panicking violates production safety, particularly in async Tauri contexts where tokio::spawn might orphan panics, leading to unobserved crashes.

### Fix Steps
1. Pinpoint the unwrap(), common in command execution or config loading.
2. Use expect() with a context-specific message if the operation is guaranteed (e.g., internal invariant), else propagate with ?.
3. For async, ensure the function is async fn returning impl Future<Output = Result<_, _>>.
4. Add imports: use std::process::Command; use thiserror::Error; for typed errors.

### Code Example
```rust
// BEFORE:
let output = Command::new("ls").output().unwrap();

// AFTER:
#[derive(Error, Debug)]
enum SystemError { #[error("Command failed")] Cmd(io::Error) }

type Result<T> = std::result::Result<T, SystemError>;

let output = Command::new("ls").output()
    .map_err(SystemError::Cmd)?;
```

---

## Issue #5: Unsafe unwrap() call detected in controller.rs

**Confidence:** High | **Estimated Time:** 3 minutes

### Analysis
In a controller editor context for MIDI software, unwrap() likely appears on UI state or MIDI device parsing, where Rust's ownership (e.g., borrowing device handles) expects explicit failure modes to avoid invalid states. This can cause panics during real-time operations, conflicting with lock-free constraints and Drop semantics for resource cleanup.

### Fix Steps
1. Identify unwrap() in controller.rs, possibly on serde deserialization or device query.
2. Opt for expect() if it's a programmer error (e.g., invalid input format), or use if let/unwrap_or for graceful degradation in UI.
3. In real-time paths, avoid allocations in error handling; use static errors or &'static str.
4. Imports: use serde::Deserialize; consider midi crate specifics if applicable.

### Code Example
```rust
// BEFORE:
let device = Device::from_id(id).unwrap();

// AFTER:
let device = Device::from_id(id).expect("Controller device must exist for editing"); // Or: .ok_or("No device")? if propagating
```

---

## Issue #1: Unsafe unwrap() call in tempo.rs

**Confidence:** Medium | **Estimated Time:** 10 minutes

### Analysis
The unwrap() call on an Option or Result in tempo.rs violates Rust's safety principles by potentially panicking at runtime if the value is None or Err. In Rust's ownership and error handling model, unwrap() assumes the operation always succeeds, ignoring the type system's enforcement of explicit error propagation via Result<T, E> or Option<T>. This is particularly risky in a DAW editor context where tempo parsing or configuration loading might fail due to invalid input, leading to crashes instead of graceful recovery. Proper handling uses combinators or match to respect lifetimes and borrowing rules without unnecessary ownership transfers.

### Fix Steps
1. Identify the unwrap() on a Result or Option, typically from parsing or I/O in tempo editing.
2. Replace with ? operator if the enclosing function returns Result, propagating the error idiomatically.
3. If propagation isn't possible, use match or expect() with a descriptive message to document assumptions, avoiding blind unwrap().
4. Ensure imports for error types like anyhow::Result if using anyhow for context-aware errors.

### Code Example
```rust
// BEFORE:
let tempo_value = parse_tempo(input).unwrap();

// AFTER:
use anyhow::Result;

fn edit_tempo(input: &str) -> Result<f64, anyhow::Error> {
    let tempo_value = parse_tempo(input)?;
    Ok(tempo_value)
}
```

---

## Issue #2: Unsafe unwrap() call in query_analyzer.rs

**Confidence:** Medium | **Estimated Time:** 8 minutes

### Analysis
In query_analyzer.rs, the unwrap() likely occurs during profiling data extraction or query parsing, where Rust's type system via Result<Option<T>, E> signals potential failures (e.g., invalid query syntax). Unwrap() discards this safety net, risking panics that violate Rust's 'fail-fast but safe' philosophy. Ownership semantics are unaffected, but error handling should leverage combinators like and_then() to chain operations without cloning unless necessary, preserving performance in profiling hot paths.

### Fix Steps
1. Locate the unwrap() in query analysis, possibly on a parsed query result.
2. Use Option::ok_or() to convert to Result if needed, then propagate with ? for idiomatic error flow.
3. For non-propagating contexts, employ if let or unwrap_or_default() with a safe fallback, avoiding expect() if the reason isn't guaranteed.
4. Add anyhow for richer error contexts if not already present.

### Code Example
```rust
// BEFORE:
let query_result = analyze_query(profiling_data).unwrap();

// AFTER:
use anyhow::Result;

fn analyze_profiling(profiling_data: &str) -> Result<Query, anyhow::Error> {
    let query_result = analyze_query(profiling_data).ok_or(anyhow::anyhow!("Invalid query"))?;
    Ok(query_result)
}
```

---

## Issue #3: Unsafe unwrap() call in fast_tagger.rs (first instance)

**Confidence:** Medium | **Estimated Time:** 7 minutes

### Analysis
The first unwrap() in fast_tagger.rs, a binary for MIDI/audio tagging, probably stems from file I/O or metadata parsing where Result<T, io::Error> indicates potential failures like missing files. Rust's error model encourages propagation over panicking to maintain program integrity, especially in performance-sensitive pipelines. Unwrap() ignores borrow checker guarantees, potentially leading to ownership violations if not handled, and in real-time contexts, it could cause allocation-heavy panics.

### Fix Steps
1. Pinpoint the unwrap() in tagging logic, e.g., on file reading or tag extraction.
2. Refactor the main function or relevant closure to return Result, using ? for propagation.
3. Handle terminal errors with proper exit codes via std::process::exit after logging.
4. Import std::io for error types if needed.

### Code Example
```rust
// BEFORE:
let tags = read_tags_from_file(path).unwrap();

// AFTER:
use std::io::{self, Result};

fn main() -> Result<()> {
    let tags = read_tags_from_file(path)?;
    process_tags(tags);
    Ok(())
}
```

---

## Issue #4: Unsafe unwrap() call in fast_tagger.rs (second instance)

**Confidence:** Medium | **Estimated Time:** 9 minutes

### Analysis
The second unwrap() in fast_tagger.rs likely involves a different operation, such as configuration loading or async future resolution in a tagging pipeline. In Rust's async model (if using tokio), unwrap() on JoinHandle or future results bypasses the Result/Option safety, potentially masking lifetime issues in borrowed data. This contravenes idiomatic error handling, where combinators like map_err() preserve zero-copy performance without unnecessary String allocations.

### Fix Steps
1. Identify the second unwrap(), possibly in a loop or conditional tagging step.
2. Replace with a match expression for fine-grained control if ? isn't suitable.
3. Use expect() only if the failure mode is truly impossible and documented.
4. Consider thiserror for custom errors if domain-specific handling is needed.

### Code Example
```rust
// BEFORE:
let config = load_config().unwrap();

// AFTER:
use thiserror::Error;

#[derive(Error, Debug)]
enum TaggerError {
    #[error("Config load failed")]
    Config,
}

type Result<T> = std::result::Result<T, TaggerError>;

fn load_tagger_config() -> Result<Config> {
    load_config().map_err(|_| TaggerError::Config)
}
```

---

## Issue #5: Unsafe unwrap() call in fast_tagger_full.rs

**Confidence:** Medium | **Estimated Time:** 10 minutes

### Analysis
In fast_tagger_full.rs, an extended version of the tagger, the unwrap() probably occurs in full-pipeline processing, such as batch file handling where Vec<Result<T, E>> might be involved. Rust's iterator and collection APIs favor combinators (e.g., collect::<Result<Vec<_>, _>>()) over unwrap() to handle heterogeneous error types without panicking, aligning with ownership transfer via IntoIterator. In real-time audio constraints, this prevents hot-path crashes and allocations.

### Fix Steps
1. Find the unwrap() in the full tagging workflow, e.g., on a collected iterator of results.
2. Use try_collect() or similar from itertools if available, or manual fold/match for error aggregation.
3. Propagate via ? in a Result-returning function for the entire pipeline.
4. Ensure no unnecessary clones by using references where possible.

### Code Example
```rust
// BEFORE:
let processed_files: Vec<_> = files.iter().map(process_file).collect(); // assuming inner unwraps

// AFTER:
use anyhow::Result;

let processed_files: Result<Vec<_>, _> = files.iter().map(|f| process_file(f)).collect();
let processed_files = processed_files?;
```

---

## Issue #1: Unsafe unwrap() call in fast_tagger_full.rs

**Confidence:** High | **Estimated Time:** 3 minutes

### Analysis
The unwrap() method on Option<T> or Result<T, E> forces the extraction of the inner value, panicking at runtime if the value is None or Err. This violates Rust's ownership and error handling principles by not propagating errors through the type system, potentially leading to abrupt program termination instead of graceful handling. In a binary like fast_tagger_full.rs (likely a CLI tool for MIDI tagging), this ignores edge cases such as file I/O failures or missing data, contravening idiomatic Rust's emphasis on explicit error handling via Result types and the ? operator.

### Fix Steps
1. Identify the unwrap() call, typically on a Result from I/O, parsing, or configuration loading.
2. If in main(), ensure main returns Result<(), Box<dyn std::error::Error>> and replace unwrap() with the ? operator to propagate errors.
3. If the unwrap() is guaranteed to succeed (e.g., hardcoded paths), replace with expect() providing a descriptive message.
4. Add necessary imports like use std::error::Error; if using Box<dyn Error>.

### Code Example
```rust
// BEFORE:
fn main() {
    let config = std::fs::read_to_string("config.toml").unwrap();
    // ... use config
}

// AFTER:
use std::error::Error;

fn main() -> Result<(), Box<dyn Error>> {
    let config = std::fs::read_to_string("config.toml")?;
    // ... use config
    Ok(())
}
```

---

## Issue #2: Unsafe unwrap() call in find_duplicates.rs

**Confidence:** High | **Estimated Time:** 4 minutes

### Analysis
unwrap() discards the error variant of Result or None from Option without handling, which can lead to panics in duplicate-finding logic (e.g., on hash computations or file scans). Rust's type system encourages using combinators like map, and_then, or ? to handle uncertainty safely, preserving memory safety and avoiding undefined behavior from panics in performance-sensitive paths like file hashing for MIDI duplicates.

### Fix Steps
1. Locate the unwrap() in duplicate detection, likely on file reading, hashing, or path resolution.
2. Convert the function containing the unwrap() to return Result if needed, and use ? for propagation.
3. For non-main functions, use match or if let for explicit handling, or propagate via Result.
4. Consider using anyhow::Result for simpler error chaining if the crate is available.

### Code Example
```rust
// BEFORE:
let hash = blake3::hash(&file_bytes).unwrap();

// AFTER:
let hash = blake3::Hasher::new().update(&file_bytes).finalize();
// Note: blake3::hash doesn't return Result; if it's a custom wrapper, adjust:
// let file_bytes = std::fs::read(path).unwrap();
let file_bytes = std::fs::read(path)?;
let hash = blake3::hash(&file_bytes);
```

---

## Issue #3: Unsafe unwrap() call in import_split_files.rs (instance 1)

**Confidence:** High | **Estimated Time:** 2 minutes

### Analysis
In file import logic, unwrap() on operations like path joining or file splitting ignores potential errors from invalid paths or I/O, conflicting with Rust's borrow checker and lifetime rules by not ensuring valid references. This is particularly risky in MIDI import where split files might have inconsistent naming, leading to panics instead of reporting errors to the user via Result propagation.

### Fix Steps
1. Find the first unwrap(), often on PathBuf operations or directory traversal.
2. Replace with ? in a Result-returning function, or use expect() if the operation is infallible in context.
3. Ensure the surrounding function signature supports error propagation.
4. Import std::path::PathBuf if needed for path handling.

### Code Example
```rust
// BEFORE:
let split_path = dir_path.join(&split_name).unwrap();

// AFTER:
use std::path::Path;

let split_path = dir_path.join(&split_name);
// If join can fail (rare), but typically it's infallible; if on canonicalize():
// let split_path = dir_path.join(&split_name).canonicalize().unwrap();
let split_path = dir_path.join(&split_name).canonicalize()?;
```

---

## Issue #4: Unsafe unwrap() call in import_split_files.rs (instance 2)

**Confidence:** High | **Estimated Time:** 3 minutes

### Analysis
Repeated unwrap() in import_split_files.rs likely occurs in loops or chained operations for splitting MIDI files, where errors from metadata reading or buffer allocation are suppressed. Rust's ownership model requires explicit handling to avoid dangling references or leaks; panics here disrupt the entire import pipeline without feedback, against best practices for real-time audio constraints emphasizing no-allocation hot paths with safe fallbacks.

### Fix Steps
1. Target the second unwrap(), possibly on file opening or content parsing.
2. Use Result combinators like and_then() or map_err() for chained errors.
3. If in a loop, collect errors into a Vec<Result> and handle post-loop.
4. Add anyhow for context if not present: use anyhow::Context;

### Code Example
```rust
// BEFORE:
let file = std::fs::File::open(&split_path).unwrap();

// AFTER:
use anyhow::Context;

let file = std::fs::File::open(&split_path)
    .with_context(|| format!("Failed to open split file: {}", split_path.display()))?;
```

---

## Issue #5: Unsafe unwrap() call in import_split_files.rs (instance 3)

**Confidence:** High | **Estimated Time:** 3 minutes

### Analysis
The third unwrap() in this file probably handles post-split validation or renaming, where Option from find() or parse() is forcefully unwrapped. This bypasses Rust's pattern matching for safe extraction, potentially causing panics on malformed MIDI splits. In audio processing, such errors should be logged or skipped, aligning with lock-free, allocation-free ideals by using early returns over panics.

### Fix Steps
1. Identify the unwrap() on an Option, like from string parsing or directory entry filtering.
2. Replace with if let Some(value) = ... { ... } else { continue or return Err(...); }
3. For CLI binaries, propagate to main() for unified error reporting.
4. Use unwrap_or_else() with a default if appropriate, but prefer explicit handling.

### Code Example
```rust
// BEFORE:
let extension = path.extension().unwrap().to_str().unwrap();

// AFTER:
let extension = path.extension()
    .and_then(|s| s.to_str())
    .ok_or_else(|| anyhow::anyhow!("Invalid path extension: {}", path.display()))?;
```

---

## Issue #1: [MEDIUM] Safety - Unsafe unwrap() call detected

**Confidence:** High | **Estimated Time:** 5 minutes

### Analysis
The unwrap() method on Option or Result types forces the program to panic if the value is None or Err, respectively. This violates Rust's emphasis on explicit error handling and memory safety principles, as panics can lead to abrupt termination without cleanup, potentially causing resource leaks (e.g., in Drop implementations for file handles or MIDI ports). In the context of a MIDI inference binary, this could occur when parsing configuration files, reading MIDI data, or deserializing instrument metadata, where inputs might be invalid. Rust's ownership model encourages using the ? operator in functions returning Result to propagate errors, aligning with the type system's goal of compile-time safety over runtime panics.

### Fix Steps
1. Identify the unwrap() call, typically on a Result<T, E> from I/O operations (e.g., fs::read_to_string) or parsing (e.g., serde_json::from_str).
2. Replace with the ? operator if the enclosing function returns Result, propagating the error up the call stack.
3. If in main(), use match or combinators like .expect('detailed message') for documentation, or convert to anyhow::Result for ergonomic error chaining in a CLI context.
4. Add necessary imports like use std::fs; or use anyhow::{Result, bail!}; if not present.

### Code Example
```rust
// BEFORE:
let config = std::fs::read_to_string("config.json").unwrap();

// AFTER:
use anyhow::Result;

fn load_config() -> Result<String> {
    std::fs::read_to_string("config.json").map_err(anyhow::Error::msg)
}

// In main or caller:
let config = load_config()?;
```

---

## Issue #2: [MEDIUM] Safety - Unsafe unwrap() call detected

**Confidence:** High | **Estimated Time:** 3 minutes

### Analysis
unwrap() discards error information and panics, contravening Rust's Result type which encodes success/failure in the type system to prevent silent failures. In async contexts (common in Tokio-based MIDI processing), this could interrupt event loops or drop borrowed resources prematurely, violating lifetime guarantees. For instrument inference, this might happen on Option::unwrap() when accessing parsed MIDI events where data might be absent due to malformed input, leading to undefined behavior if not handled, as Rust's borrow checker can't enforce runtime presence without explicit checks.

### Fix Steps
1. Locate the unwrap() on an Option<T>, possibly from methods like find() on collections or get() on HashMaps storing instrument mappings.
2. Use match or if let for explicit handling, or combinators like .ok_or('error message')?. to convert to Result.
3. In performance-critical paths (e.g., real-time MIDI), prefer expect('why safe here') if analysis confirms non-None, but document the invariant.
4. Ensure imports like use std::collections::HashMap; if relevant.

### Code Example
```rust
// BEFORE:
let instrument = instruments.get(&key).unwrap();

// AFTER:
let instrument = instruments.get(&key).ok_or_else(|| anyhow::anyhow!("Missing instrument for key: {}", key))?;
```

---

## Issue #3: [MEDIUM] Safety - Unsafe unwrap() call detected

**Confidence:** High | **Estimated Time:** 4 minutes

### Analysis
By panicking on Err, unwrap() bypasses Rust's error monad (Result), which is designed to compose error handling without ownership transfer issues. In a systems context like MIDI software, this could occur during FFI calls (e.g., to C libraries for audio) returning Results, where failure might indicate hardware issues, and panicking could leave ports in inconsistent states without Drop invocation. Lifetimes are indirectly affected if the unwrap is on a borrowed value's method, potentially dangling references post-panic.

### Fix Steps
1. Examine the unwrap() context, likely on a Result from a parsing library like nom for MIDI messages or serde for JSON configs.
2. Refactor to use .map_err() for custom error conversion or ? for propagation, ensuring the error type is anyhow::Error for flexibility.
3. For hot paths in inference, use unwrap_or_default() if a sensible default exists, avoiding panic while maintaining zero-cost abstractions.
4. Import use serde_json; or similar if deserialization is involved.

### Code Example
```rust
// BEFORE:
let data: MidiEvent = serde_json::from_str(&json).unwrap();

// AFTER:
#[derive(thiserror::Error, Debug)]
#[error("MIDI parse error")]
struct MidiError;

let data: MidiEvent = serde_json::from_str(&json).map_err(|e| anyhow::anyhow!(MidiError).context(e))?;
```

---

## Issue #4: [MEDIUM] Safety - Unsafe unwrap() call detected

**Confidence:** High | **Estimated Time:** 5 minutes

### Analysis
unwrap() assumes success, ignoring Rust's type system enforcement of handling both arms of Option/Result, which prevents logic errors from propagating unchecked. In real-time audio/MIDI constraints, panics from unwrap() in hot paths (e.g., during instrument detection loops) can cause audio glitches or lock-free structure corruption, as panics don't respect no-allocation guarantees. Ownership semantics are at risk if unwrap() is on a moved value, leading to use-after-move if not panicking early.

### Fix Steps
1. Pinpoint the unwrap(), perhaps on a Vec::pop() or similar in a stack-based MIDI event processor returning Option.
2. Replace with pattern matching for exhaustive handling, or use .expect('invariant: always populated') if code invariants guarantee success (e.g., pre-checked lengths).
3. In CLI binaries, log errors with tracing or log crate before early return.
4. Add use log::{error, info}; if logging is needed.

### Code Example
```rust
// BEFORE:
let event = stack.pop().unwrap();

// AFTER:
let event = match stack.pop() {
    Some(e) => e,
    None => {
        log::warn!("Empty event stack during inference");
        return; // or handle gracefully
    }
};
```

---

## Issue #5: [MEDIUM] Safety - Unsafe unwrap() call detected

**Confidence:** High | **Estimated Time:** 3 minutes

### Analysis
The use of unwrap() undermines Rust's safe abstraction over unsafe operations, as it can mask underlying issues like invalid UTF-8 in string conversions from MIDI byte streams, leading to panics that bypass borrow checker's guarantees. In generic programming for instrument inference, trait bounds (e.g., AsRef<[u8]>) might return Results, and unwrap() ignores potential lifetime mismatches or ownership transfers, risking double-frees in Drop if panic occurs mid-transfer.

### Fix Steps
1. Identify the specific unwrap(), likely on a string conversion like String::from_utf8() in MIDI data processing.
2. Use proper error handling with .into_string().map_err() or combinators, converting to a custom error type.
3. For production, integrate with anyhow for context-rich errors, especially in async Tokio tasks.
4. Ensure imports like use std::string::FromUtf8Error; if needed.

### Code Example
```rust
// BEFORE:
let name = String::from_utf8(bytes).unwrap();

// AFTER:
let name = String::from_utf8(bytes).map_err(|e| anyhow::anyhow!("Invalid UTF-8 in instrument name: {}", e))?;
```

---

## Issue #1: Unsafe unwrap() call detected in infer_instruments.rs

**Confidence:** High | **Estimated Time:** 3 minutes

### Analysis
The unwrap() method on Option<T> or Result<T, E> forces extraction of the inner value, panicking the program if the variant is None or Err. This violates Rust's ownership and error handling principles by not respecting the type system's intent to handle potential failures explicitly. In a real-time audio/MIDI context like infer_instruments.rs, panics can lead to audio dropouts or crashes, undermining memory safety guarantees. Rust encourages using combinators like map, and_then, or the ? operator to propagate errors idiomatically, preserving the Result/Option types for upstream handling.

### Fix Steps
1. Identify the unwrap() call, likely on an io::Result or parsing operation common in instrument inference (e.g., reading MIDI files).
2. Replace with the ? operator if the enclosing function returns Result, propagating the error without panicking.
3. If propagation isn't feasible, use expect('detailed reason') for documentation, or match for custom handling (e.g., logging and default value).
4. Ensure the function signature includes proper Result<T, E> with anyhow::Error or a custom error type for MIDI-specific failures.

### Code Example
```rust
// BEFORE:
let config = std::fs::read_to_string("instruments.toml").unwrap();

// AFTER:
use anyhow::Result;

fn load_config() -> Result<String, anyhow::Error> {
    std::fs::read_to_string("instruments.toml").map_err(anyhow::Error::from)
}

let config = load_config()?;
```

---

## Issue #2: Unsafe unwrap() call detected in infer_instruments.rs

**Confidence:** High | **Estimated Time:** 4 minutes

### Analysis
Similar to other unwrap instances, this call ignores Rust's type system by assuming success, which can invalidate lifetimes and ownership if the operation (e.g., parsing MIDI data) fails. In async MIDI processing, unwraps exacerbate issues with task panics in executors like Tokio, breaking the no-panic guarantee expected in hot paths. Proper handling aligns with Rust's borrow checker by maintaining error invariants without resorting to unsafe panics.

### Fix Steps
1. Locate the unwrap, possibly on a serde_json::from_str or similar deserialization in instrument inference.
2. Use Option/Result combinators like ok_or() or context() from anyhow to add context without unwrapping.
3. For production readiness, wrap in a custom error type using thiserror to categorize MIDI parsing errors.
4. Test edge cases like malformed files to ensure no hidden panics remain.

### Code Example
```rust
// BEFORE:
let instruments: Vec<Instrument> = serde_json::from_str(&json).unwrap();

// AFTER:
use anyhow::{Context, Result};
use thiserror::Error;

#[derive(Error, Debug)]
#[error("MIDI instrument parsing failed")]
struct MidiParseError;

let instruments: Vec<Instrument> = serde_json::from_str(&json)
    .context("Failed to parse instrument JSON")?;
```

---

## Issue #3: Unsafe unwrap() call detected in infer_instruments.rs

**Confidence:** High | **Estimated Time:** 2 minutes

### Analysis
unwrap() discards error information, conflicting with Rust's emphasis on explicit error handling via enums like Result. In the context of infer_instruments.rs, which likely involves file I/O or network fetches for instrument data, this can lead to silent failures or crashes, ignoring ownership transfer semantics (e.g., if unwrapping a Vec from a parser). For real-time MIDI, this risks allocation spikes or lock contention during error recovery, violating performance best practices.

### Fix Steps
1. Pinpoint the unwrap, e.g., on a PathBuf::new() or directory traversal result.
2. Replace with if let or match for graceful degradation, returning a default or empty collection.
3. Use as_ref() or to_owned() if borrowing is involved, avoiding unnecessary clones.
4. Consider zero-copy alternatives like Cow<str> for string handling in paths.

### Code Example
```rust
// BEFORE:
let path = std::path::PathBuf::from(file_path).canonicalize().unwrap();

// AFTER:
use std::path::PathBuf;

let path: PathBuf = std::path::PathBuf::from(file_path)
    .canonicalize()
    .unwrap_or_else(|_| PathBuf::from(file_path)); // Fallback to relative path
```

---

## Issue #4: Unsafe unwrap() call detected in infer_instruments.rs

**Confidence:** High | **Estimated Time:** 5 minutes

### Analysis
By panicking on Err/None, unwrap() bypasses Rust's safe abstraction layers, potentially exposing FFI boundaries or unsafe code in MIDI libraries if errors propagate unexpectedly. This issue stems from not leveraging trait bounds like Error or Debug for proper error chaining. In a systems-level binary like infer_instruments.rs, it undermines the Drop semantics for cleanup (e.g., closing file handles), leading to resource leaks under failure.

### Fix Steps
1. Target the unwrap, likely on a MIDI message parse or config load.
2. Employ the ? operator with a main function returning Result<(), Box<dyn std::error::Error>>.
3. For hot paths, use expect() with a panic message explaining safety (e.g., 'config file always exists').
4. Add unit tests for error paths to validate handling.

### Code Example
```rust
// BEFORE:
let msg = MidiMessage::from_bytes(&bytes).unwrap();

// AFTER:
use thiserror::Error;

#[derive(Error, Debug)]
#[error("Invalid MIDI message")]
pub struct MidiError;

let msg = MidiMessage::from_bytes(&bytes).map_err(|_| MidiError)?;
```

---

## Issue #5: Unsafe unwrap() call detected in infer_instruments.rs

**Confidence:** High | **Estimated Time:** 3 minutes

### Analysis
This unwrap represents a failure to handle uncertainty in Rust's Option/Result monads, which are designed to enforce safe ownership and borrowing without exceptions. In MIDI inference, where async I/O (e.g., via Tokio) might be involved, unwraps can poison futures or deadlock locks, conflicting with lock-free patterns. The root cause is often lazy error avoidance, ignoring combinators that preserve type safety and performance (no allocations in error paths).

### Fix Steps
1. Find the final unwrap, perhaps on an env::var or command-line arg parse.
2. Use clap or similar for args with built-in error handling, or env::var_os().unwrap_or_default().
3. For async contexts, ensure errors are handled with .await? in async fns.
4. Profile for performance: prefer &str over String where possible to avoid clones.

### Code Example
```rust
// BEFORE:
let instrument_dir = std::env::var("INSTRUMENT_DIR").unwrap();

// AFTER:
let instrument_dir = std::env::var("INSTRUMENT_DIR")
    .unwrap_or_else(|_| "/default/instruments".to_string());
// Or with anyhow:
let instrument_dir: String = std::env::var("INSTRUMENT_DIR")
    .context("Missing INSTRUMENT_DIR env var")?;
```

---

## Issue #1: Unsafe unwrap() call detected in infer_instruments.rs

**Confidence:** High | **Estimated Time:** 5 minutes

### Analysis
The unwrap() method on Result or Option types forces the program to panic on error or None variant, violating Rust's emphasis on explicit error handling and memory safety. In the context of a MIDI instrument inference binary, this likely occurs during file I/O, JSON deserialization, or configuration loading where failures (e.g., missing files) should be handled gracefully rather than crashing. Rust's ownership model ensures errors are values that must be propagated or matched, preventing silent failures but requiring developers to address them; unwrap() bypasses this, leading to non-idiomatic and unsafe code in production.

### Fix Steps
1. Identify the unwrap() call, typically on a Result<T, E> from operations like fs::read_to_string() or serde_json::from_str().
2. If the enclosing function can return Result<(), Box<dyn Error>>, replace unwrap() with the ? operator to propagate the error.
3. If propagation isn't feasible (e.g., in main()), use match or if let to handle the error, logging it with eprintln!() and exiting gracefully with std::process::exit(1).
4. For Options, use methods like ok_or() to convert to Result if needed, or provide a default value.

### Code Example
```rust
// BEFORE:
let config = std::fs::read_to_string("config.json").unwrap();
let instruments: Vec<String> = serde_json::from_str(&config).unwrap();

// AFTER:
use std::fs;
use anyhow::{Context, Result};

type anyhow::Result<()>;

let config = fs::read_to_string("config.json")
    .with_context(|| "Failed to read config.json")?;
let instruments: Vec<String> = serde_json::from_str(&config)
    .with_context(|| "Failed to parse config.json")?;

// In main(), propagate with ? or handle:
// fn main() -> Result<()> { ... }
```

---

## Issue #2: Unsafe unwrap() call detected in infer_instruments.rs

**Confidence:** High | **Estimated Time:** 3 minutes

### Analysis
unwrap() on a Result or Option discards error information and panics, contravening Rust's type system which treats errors as first-class values to ensure safe ownership transfer. In a real-time audio/MIDI context like instrument inference, this could occur on parsing MIDI files or environment variables, where unexpected None/Err (e.g., invalid MIDI data) should trigger recovery or logging rather than termination, aligning with lock-free, no-panic best practices to avoid disrupting audio pipelines.

### Fix Steps
1. Locate the unwrap(), possibly on env::var() or a MIDI parsing library call returning Option or Result.
2. Convert to explicit handling: use expect() only if the unwrap is provably safe with a descriptive message, but prefer ? for propagation.
3. In async contexts (if using tokio), ensure error handling doesn't block; use anyhow for chained errors.
4. Test edge cases like missing env vars by setting them to invalid values.

### Code Example
```rust
// BEFORE:
let midi_dir = std::env::var("MIDI_DIR").unwrap();
let files = std::fs::read_dir(&midi_dir).unwrap();

// AFTER:
use std::env;
use anyhow::{Context, Result};

let midi_dir = env::var("MIDI_DIR")
    .context("MIDI_DIR environment variable not set")?;
let files = std::fs::read_dir(&midi_dir)
    .context(format!("Failed to read directory: {}", midi_dir))?;

// For main():
fn main() -> Result<()> {
    // ...
    Ok(())
}
```

---

## Issue #3: Unsafe unwrap() call detected in infer_instruments.rs

**Confidence:** High | **Estimated Time:** 4 minutes

### Analysis
By panicking on failure, unwrap() ignores Rust's lifetimes and borrowing rules for error values, potentially leading to dropped resources without cleanup (e.g., via Drop impls). In MIDI software, this might happen during instrument model loading or vector allocations for note data, where allocation failures or parse errors need handling to maintain performance and avoid hot-path panics, especially in no-allocation constraints.

### Fix Steps
1. Examine the unwrap() context, likely on Vec::new() related ops or parsing numeric data (e.g., note frequencies).
2. Replace with pattern matching for fine-grained control, or use unwrap_or_default() for Options with safe defaults.
3. If in a loop (common in file scanning), use continue on error to skip bad items without crashing.
4. Profile to ensure the fix doesn't introduce allocations in hot paths.

### Code Example
```rust
// BEFORE:
let notes: Vec<f32> = parse_midi_notes(data).unwrap();

// AFTER:
use anyhow::Result;

let notes: Vec<f32> = match parse_midi_notes(data) {
    Ok(notes) => notes,
    Err(e) => {
        eprintln!("Failed to parse MIDI notes: {}", e);
        return; // or continue in loop
    }
};

// Better with ? if function returns Result:
let notes: Vec<f32> = parse_midi_notes(data)?;
```

---

## Issue #4: Unsafe unwrap() call detected in infer_instruments.rs

**Confidence:** High | **Estimated Time:** 5 minutes

### Analysis
unwrap() violates idiomatic Rust by not leveraging the Result/Option combinators, which encourage composable error handling without ownership transfer issues. For instrument inference, this could be on thread::spawn() results or shared state access (e.g., Arc<Mutex<T>>), where panics propagate unexpectedly in multi-threaded MIDI processing, conflicting with memory safety guarantees around shared mutable state.

### Fix Steps
1. Pinpoint the unwrap(), perhaps on a join_handle or lock() call.
2. Use proper synchronization: for MutexGuard, handle poisoning with lock().unwrap_or_else() but prefer non-panicking alternatives like try_lock().
3. In async MIDI pipelines, use select! or futures::try_join! with ? propagation.
4. Add logging for errors to aid debugging in production.

### Code Example
```rust
// BEFORE:
let handle = std::thread::spawn(|| { /* infer */ });
let result = handle.join().unwrap();

// AFTER:
use std::thread;
use anyhow::Result;

let handle = thread::spawn(|| infer_instruments());
let result = handle.join().map_err(|_| anyhow::anyhow!("Thread panicked"))??;

// Or in main() -> Result<()>:
let result = handle.join()
    .context("Failed to join inference thread")?;
```

---

## Issue #5: Unsafe unwrap() call detected in infer_instruments.rs

**Confidence:** High | **Estimated Time:** 6 minutes

### Analysis
The use of unwrap() sidesteps Rust's trait bounds for error types (e.g., std::error::Error), making code less generic and harder to compose. In a MIDI context with FFI or external libs, this might occur on CString conversions or buffer reads, where lifetime mismatches or null pointers could lead to UB if not handled, undermining unsafe Rust boundaries and zero-copy performance goals.

### Fix Steps
1. Identify the unwrap(), likely on to_string_lossy() or a FFI call returning Option<&str>.
2. Prefer borrowing with as_ref() or map() combinators to avoid unnecessary clones.
3. For FFI, use std::ffi::CStr and handle nulls explicitly with if let Some().
4. Ensure no allocations: use &str where possible instead of String.

### Code Example
```rust
// BEFORE:
let path = std::ffi::CString::new("instrument.midi").unwrap();
let c_path = path.as_c_str().to_str().unwrap();

// AFTER:
use std::ffi::CString;
use anyhow::Result;

let path_str = "instrument.midi";
let c_path = CString::new(path_str)
    .with_context(|| format!("Invalid path: {}", path_str))?;
let owned_path = c_path.to_str()
    .context("Invalid UTF-8 in path")?
    .to_owned();

// Better: keep as &CStr if possible for zero-copy.
```

---

## Issue #1: Unsafe unwrap() call detected in midi_doctor.rs

**Confidence:** High | **Estimated Time:** 3 minutes

### Analysis
The unwrap() method on Option<T> or Result<T, E> will panic at runtime if the value is None or Err, violating Rust's safety guarantees by potentially crashing the program instead of handling errors gracefully. This occurs because Rust's ownership and error handling model emphasizes explicit error propagation via Result types, preventing silent failures and encouraging the use of combinators like ? or match expressions. In a binary like midi_doctor.rs, which likely processes MIDI files, unhandled errors could lead to incomplete diagnostics or data loss without user feedback.

### Fix Steps
1. Identify the unwrap() call on a Result or Option.
2. Replace with proper error handling: if in a function returning Result, use the ? operator to propagate errors; otherwise, use match or if let for local handling.
3. If the unwrap is guaranteed to succeed (e.g., due to prior checks), replace with expect() providing a descriptive message for debugging.
4. Ensure the main function returns Result<(), Box<dyn std::error::Error>> to propagate errors to the caller.

### Code Example
```rust
// BEFORE:
let value = some_option.unwrap();

// AFTER:
let value = match some_option {
    Some(v) => v,
    None => return Err("Expected a value but got None".into()),
};
```

---

## Issue #2: Unsafe unwrap() call detected in midi_doctor.rs

**Confidence:** High | **Estimated Time:** 3 minutes

### Analysis
Similar to other unwrap issues, this call risks panicking on Err/None, contravening Rust's type system which uses enums like Result to enforce error handling at compile time. In the context of MIDI processing in midi_doctor.rs, this could mask issues like invalid file formats, leading to unsafe assumptions about data validity without leveraging Rust's borrow checker to ensure soundness.

### Fix Steps
1. Locate the specific unwrap() in the code.
2. Use the ? operator if the function signature allows Result propagation, converting the error type if needed.
3. For non-propagating contexts, employ unwrap_or() or unwrap_or_else() with a safe default or recovery logic.
4. Add logging or user-facing errors for better diagnostics in a tool like midi_doctor.

### Code Example
```rust
// BEFORE:
let result = some_result.unwrap();

// AFTER:
let result = some_result.map_err(|e| format!("MIDI processing error: {}", e))?; // Assuming function returns Result
```

---

## Issue #3: Unsafe unwrap() call detected in midi_doctor.rs

**Confidence:** High | **Estimated Time:** 2 minutes

### Analysis
unwrap() bypasses Rust's ownership model by assuming a value exists, which can lead to panics if invariants are broken at runtime. Rust's lifetimes and borrowing rules prevent such assumptions at compile time, but unwrap() shifts the burden to runtime checks. In midi_doctor.rs, likely dealing with file I/O or parsing, this could crash on edge cases like empty inputs, ignoring best practices for robust CLI tools.

### Fix Steps
1. Replace unwrap() with a match expression to handle both success and failure cases explicitly.
2. If safe to default, use unwrap_or_default() for types implementing Default.
3. Propagate errors upward using ? to centralize handling in main().
4. Consider using expect() if prior logic guarantees success, documenting the assumption.

### Code Example
```rust
// BEFORE:
let config = env::var("MIDI_PATH").unwrap();

// AFTER:
let config = env::var("MIDI_PATH").unwrap_or_else(|_| "/default/path".to_string());
```

---

## Issue #4: Unsafe unwrap() call detected in midi_to_mpcpattern.rs

**Confidence:** High | **Estimated Time:** 4 minutes

### Analysis
In this MIDI conversion binary, unwrap() on parsing or I/O operations ignores potential errors from invalid inputs, conflicting with Rust's error monad (Result) designed to compose fallible operations safely. The type system ensures errors are handled, but unwrap() discards this, risking panics in production during pattern generation from MIDI data.

### Fix Steps
1. Audit the unwrap() in the conversion pipeline.
2. Integrate ? for error propagation, ensuring the function returns a Result.
3. Use combinators like and_then() or map_err() for chained operations common in file processing.
4. For CLI tools, print errors to stderr and exit gracefully with std::process::exit(1).

### Code Example
```rust
// BEFORE:
let pattern = parse_midi(file).unwrap();

// AFTER:
let pattern = parse_midi(file).map_err(|e| {
    eprintln!("Failed to parse MIDI: {}", e);
    std::process::exit(1);
})?;
```

---

## Issue #5: Unsafe unwrap() call detected in midi_to_mpcpattern_parallel.rs

**Confidence:** High | **Estimated Time:** 5 minutes

### Analysis
In a parallel processing context (likely using rayon or threads), unwrap() on shared or concurrent operations amplifies risks, as panics can poison threads or deadlock. Rust's ownership model with Send/Sync traits ensures thread safety, but unwrap() undermines this by not handling race conditions or I/O failures in parallel MIDI-to-pattern conversion, potentially leading to incomplete outputs.

### Fix Steps
1. Identify the unwrap() in parallel iterators or thread spawns.
2. Replace with error-collecting patterns, like using a channel or Vec<Result> to aggregate errors across threads.
3. Use try_join! or similar for concurrent Results if applicable.
4. Ensure error types are Clone + Send for parallel propagation.

### Code Example
```rust
// BEFORE:
let results: Vec<_> = inputs.par_iter().map(|input| process(input).unwrap()).collect();

// AFTER:
let results: Vec<_> = inputs.par_iter()
    .map(|input| process(input).map_err(|e| format!("Parallel error: {}", e)))
    .collect();
// Then handle errors: for result in results { let _ = result?; }
```

---

## Issue #1: Unsafe unwrap() call in midi_to_mpcpattern_parallel.rs

**Confidence:** High | **Estimated Time:** 5 minutes

### Analysis
The unwrap() call on a Result or Option violates Rust's error handling philosophy by panicking on failure, which can crash the binary unexpectedly. In the context of a MIDI processing pipeline (likely involving file I/O or parsing), this ignores ownership transfer semantics where Results from operations like fs::read_to_string or MIDI event parsing must be explicitly handled to maintain memory safety and program reliability. Rust's type system enforces this via the ? operator or match, preventing silent failures and aligning with the ownership model by propagating errors without unnecessary cloning.

### Fix Steps
1. Identify the unwrap() on a Result<T, E> (e.g., from std::fs or a MIDI library).
2. If the enclosing function can return Result, replace unwrap() with the ? operator to propagate the error idiomatically.
3. If in main(), wrap in a Result and use main() -> Result<(), Box<dyn std::error::Error>> for proper error handling.
4. Add necessary imports like use std::error::Error; if propagating.
5. For Options, use methods like ok_or() to convert to Result if needed.

### Code Example
```rust
// BEFORE:
let content = std::fs::read_to_string(&path).unwrap();

// AFTER:
let content = std::fs::read_to_string(&path)?;
// Assuming the function now returns Result<String, std::io::Error>
```

---

## Issue #2: Unsafe unwrap() call in mpc_backup.rs

**Confidence:** High | **Estimated Time:** 5 minutes

### Analysis
Unwrap() discards error information from a Result, leading to panics that bypass Rust's safe error propagation. In a backup script for MPC patterns (likely involving directory traversal or serialization), this contravenes the ownership model by not accounting for lifetime-bound resources like file handles, which could leak if not dropped properly on error. Rust's trait bounds (e.g., for Error types) encourage using anyhow or thiserror for composable errors, ensuring type-safe handling without unsafe blocks.

### Fix Steps
1. Locate the unwrap() likely on a file operation like std::fs::create_dir_all or JSON serialization.
2. Refactor the function to return Result, replacing unwrap() with ? for borrowing-compatible propagation.
3. Use expect("detailed reason") if the operation is guaranteed to succeed (e.g., after checks), but prefer full handling.
4. Import anyhow::Result if using a higher-level error crate for MIDI/backup contexts.
5. Consider edge cases like permission errors in backups.

### Code Example
```rust
// BEFORE:
let dir = std::fs::create_dir_all(&backup_path).unwrap();

// AFTER:
std::fs::create_dir_all(&backup_path)?;
// Function returns anyhow::Result<()> or similar
```

---

## Issue #3: Unsafe unwrap() call in normalize_filenames.rs (first instance)

**Confidence:** High | **Estimated Time:** 3 minutes

### Analysis
This unwrap() on a Result (possibly from path normalization or string manipulation) ignores Rust's Option/Result combinators, forcing a panic instead of safe unwrapping via map or and_then. In filename normalization for MIDI files, it risks crashing on invalid paths, violating memory safety by not respecting string lifetimes (&str vs String ownership). The type system requires explicit conversion (e.g., to_owned()) to avoid dangling references, and proper error handling prevents data loss in production pipelines.

### Fix Steps
1. Pinpoint the unwrap(), e.g., on Path::new().file_name().unwrap().to_str().unwrap().
2. Replace chained unwraps with a single Result handling using ? or match for clarity.
3. Use as_ref() or to_string_lossy() for safe &str to String conversion without panics.
4. Ensure the function signature supports Result propagation.
5. Handle edge cases like non-UTF8 filenames with to_string_lossy().

### Code Example
```rust
// BEFORE:
let name = path.file_name().unwrap().to_str().unwrap().to_string();

// AFTER:
let name = path.file_name()
    .and_then(|n| n.to_str())
    .map(|s| s.to_string())
    .ok_or_else(|| anyhow::anyhow!("Invalid filename"))?;
```

---

## Issue #4: Unsafe unwrap() call in normalize_filenames.rs (second instance)

**Confidence:** High | **Estimated Time:** 3 minutes

### Analysis
Similar to the first instance, this unwrap() undermines Rust's borrow checker by not handling potential None/Err variants, especially in path sanitization where lifetimes of &Path must be managed carefully to avoid use-after-free. In a real-time MIDI context, panics disrupt lock-free operations; idiomatic fixes use iterators or combinators to maintain zero-copy performance while ensuring safety.

### Fix Steps
1. Identify this specific unwrap(), perhaps on a regex match or string replace Result.
2. Convert to a match expression or ? if in a Result-returning context for explicit error branches.
3. Prefer &str borrowing where possible to avoid unnecessary String allocations in hot paths.
4. Add unit tests for edge cases like empty filenames.
5. If using regex, ensure captures are handled with Option combinators.

### Code Example
```rust
// BEFORE:
let sanitized = regex.replace_all(&name, r"[^a-zA-Z0-9-]", "_").to_string().unwrap();

// AFTER:
let sanitized: String = regex.replace_all(&name, r"[^a-zA-Z0-9-]", "_").to_string();
// No unwrap needed if to_string() is infallible; else use ? on any Result
```

---

## Issue #5: Unsafe unwrap() call in orchestrator.rs

**Confidence:** High | **Estimated Time:** 5 minutes

### Analysis
In an orchestrator for MIDI pipelines, unwrap() on coordination primitives (e.g., thread joins or channel receives) ignores Rust's async/await error semantics, potentially leading to deadlocks or panics that violate Drop guarantees for resources like locks. The ownership model requires explicit lifetime annotation for borrowed data across threads, and using futures::join_all or select! for safe concurrency prevents this; trait bounds like Send + Sync must be considered for cross-thread safety.

### Fix Steps
1. Locate the unwrap(), likely on a receiver.recv() or join_handle.join().
2. If synchronous, use match to handle Err; for async (tokio), use .await? in an async fn returning Result.
3. Propagate errors up to main() for logging or recovery in the pipeline.
4. Import tokio::try_join! or similar if async; add error types with thiserror for MIDI-specific failures.
5. Consider performance: avoid blocking in real-time paths by using non-blocking variants.

### Code Example
```rust
// BEFORE:
let result = rx.recv().unwrap();

// AFTER:
// If sync:
let result = match rx.recv() {
    Ok(r) => r,
    Err(e) => return Err(anyhow::anyhow!("Channel error: {}", e)),
};
// Or async: let result = rx.recv().await?; // Assuming async context
```

---

## Issue #1: Safety - Unsafe unwrap() call detected

**Confidence:** High | **Estimated Time:** 3 minutes

### Analysis
In Rust, the `unwrap()` method on `Option<T>` or `Result<T, E>` will panic if the value is `None` or `Err`, respectively. This violates Rust's ownership and error handling principles by potentially terminating the program abruptly instead of propagating errors through the type system. In the context of a systems-level application like a MIDI orchestrator, panics can lead to crashes during initialization or runtime, undermining memory safety guarantees. The root cause is likely a failure to anticipate error cases in I/O, parsing, or configuration loading, where lifetimes and borrowing are not directly implicated but error propagation via `Result` is expected for robust code.

### Fix Steps
1. Identify the `unwrap()` call, typically on a `Result` or `Option` from an API like file reading or JSON parsing.
2. Replace `unwrap()` with `expect()` to provide a descriptive panic message if unwrapping is justified (e.g., in main setup where failure is fatal).
3. If in a function returning `Result`, use the `?` operator for propagation. For main(), convert to `Result` and handle at top level.
4. Add necessary imports like `std::io` if dealing with I/O errors.

### Code Example
```rust
// BEFORE:
let config = std::fs::read_to_string("config.toml").unwrap();

// AFTER:
let config = std::fs::read_to_string("config.toml")
    .expect("Failed to read config.toml - ensure file exists and is readable");
```

---

## Issue #2: Safety - Unsafe unwrap() call detected

**Confidence:** High | **Estimated Time:** 4 minutes

### Analysis
Rust's type system encourages explicit error handling to maintain safety and composability. `unwrap()` bypasses this by assuming success, which can mask bugs or external failures (e.g., missing resources in a MIDI pipeline). In async contexts common to audio processing, panics can corrupt task states or lead to resource leaks due to improper `Drop` invocation. The issue stems from not leveraging `Result`'s monadic combinators, potentially in a setup routine where ownership transfer from I/O operations isn't error-checked.

### Fix Steps
1. Locate the unwrap on likely an async or sync operation returning `Result`.
2. Use `map_err()` or `?` for propagation if the enclosing function can return `Result`.
3. For non-propagatable contexts, use `expect()` with context-specific messaging to document assumptions.
4. Ensure error types are compatible; use `anyhow::Result` if integrating multiple error sources.

### Code Example
```rust
// BEFORE:
let port = serialport::open("COM3").unwrap();

// AFTER:
use anyhow::Result;

let port: serialport::SerialPort = serialport::open("COM3")
    .map_err(anyhow::Error::msg)?;
// Or for main: .expect("Failed to open serial port COM3")
```

---

## Issue #3: Safety - Unsafe unwrap() call detected

**Confidence:** High | **Estimated Time:** 2 minutes

### Analysis
The `unwrap()` call ignores Rust's emphasis on safe error propagation, where `Result` types encode possible failures at compile time. In a real-time MIDI context, such panics could interrupt low-latency paths, violating performance invariants like no allocations or locks in hot paths. Root cause is often in parsing MIDI configs or environment variables, where string ownership (`String` vs `&str`) isn't handled with fallbacks, leading to runtime crashes instead of graceful degradation.

### Fix Steps
1. Examine the call site for environment or config access.
2. Replace with `expect()` for fatal errors or use `unwrap_or_else()` for defaults.
3. Prefer `Option` combinators like `ok_or()` to convert and handle explicitly.
4. Import `std::env` if needed for env vars.

### Code Example
```rust
// BEFORE:
let threads = std::env::var("NUM_THREADS").unwrap().parse::<usize>().unwrap();

// AFTER:
let threads = std::env::var("NUM_THREADS")
    .ok()
    .and_then(|s| s.parse::<usize>().ok())
    .unwrap_or(4); // Default to 4 threads
```

---

## Issue #4: Safety - Unsafe unwrap() call detected

**Confidence:** High | **Estimated Time:** 3 minutes

### Analysis
By using `unwrap()`, the code discards error information, contravening Rust's ownership model where errors should be owned and propagated. In systems programming for audio orchestration, this can lead to undefined behavior if panics occur during FFI or unsafe blocks, though lifetimes aren't directly involved. Likely cause: assuming infallible operations like JSON deserialization in Tauri frontend integration, ignoring potential `serde_json::Error` variants.

### Fix Steps
1. Target JSON or similar deserialization unwrap.
2. Use `?` in a `Result`-returning function or `expect()` for documentation.
3. Handle with `match` if multiple error arms are needed.
4. Add `serde` imports if not present.

### Code Example
```rust
// BEFORE:
let data: MidiConfig = serde_json::from_str(&json_str).unwrap();

// AFTER:
#[derive(serde::Deserialize)]
struct MidiConfig { /* fields */ }

let data: MidiConfig = serde_json::from_str(&json_str)
    .expect("Invalid JSON in MIDI config - check format");
```

---

## Issue #5: Safety - Unsafe unwrap() call detected

**Confidence:** High | **Estimated Time:** 5 minutes

### Analysis
In parallel extraction contexts (e.g., async file processing in MIDI pipelines), `unwrap()` on futures or thread results can propagate panics across boundaries, breaking Rust's thread-safety guarantees. The type system flags this as unsafe because it doesn't respect `Send`/`Sync` bounds or error channels. Root cause: likely in `tokio::join!` or rayon's `par_iter` where results are unwrapped without checking, ignoring potential I/O or parsing errors in concurrent paths.

### Fix Steps
1. Identify in parallel or async block, e.g., on `tokio::fs` or rayon collect.
2. Collect into `Vec<Result>` and handle errors iteratively, or use `try_join!` for early abort.
3. For simplicity in non-critical paths, use `expect()` but prefer propagation.
4. Import `tokio` or `rayon` as needed.

### Code Example
```rust
// BEFORE:
let results = futures::future::join_all(tasks).await;
for res in results {
    process(res.unwrap());
}

// AFTER:
use futures::future::try_join_all;

let results = try_join_all(tasks).await?;
for res in results {
    process(res);
}
```

---

## Issue #1: Unsafe unwrap() call in parallel_extract.rs

**Confidence:** Medium | **Estimated Time:** 10 minutes

### Analysis
The unwrap() method on Option<T> or Result<T, E> forces the program to panic if the value is None or Err, violating Rust's safety guarantees by potentially crashing the application at runtime. This occurs because Rust's ownership and error handling model prefers explicit error propagation via Result or Option combinators over panicking, ensuring memory safety and predictable control flow. In a parallel extraction context (likely involving file I/O or data processing), unwrap() ignores edge cases like missing files or parse failures, which could stem from concurrent access issues or invalid input data.

### Fix Steps
1. Identify the unwrap() call, typically on a Result from I/O operations (e.g., fs::read) or parsing in parallel tasks.
2. Replace with the ? operator if the enclosing function returns Result, propagating errors idiomatically.
3. If panicking is acceptable but needs documentation, use expect() with a descriptive message.
4. For non-Result contexts, use match or if let to handle None/Err branches, logging errors if needed.
5. Ensure thread-safety in parallel_extract by using Arc<Mutex<>> or channels for error reporting if applicable.

### Code Example
```rust
// BEFORE:
let data = some_io_operation().unwrap();

// AFTER:
let data = some_io_operation()?; // Assuming function returns Result
// Or, for explicit handling:
let data = match some_io_operation() {
    Ok(d) => d,
    Err(e) => {
        eprintln!("IO error in extraction: {}", e);
        return Err(e.into()); // Propagate or handle
    }
};
```

---

## Issue #2: Unsafe unwrap() call in parallel_extract.rs

**Confidence:** Medium | **Estimated Time:** 10 minutes

### Analysis
Similar to Issue #1, unwrap() on Option<Result> bypasses Rust's type system for error handling, leading to undefined behavior on failure. In parallel extraction, this might occur during thread spawning (e.g., rayon or std::thread) or data deserialization, where lifetimes of borrowed data could conflict with ownership transfer across threads, exacerbating panics in concurrent environments.

### Fix Steps
1. Locate the second unwrap(), possibly on a join handle or parsed data in a parallel iterator.
2. Use expect() if the unwrap is on a guaranteed-success operation (e.g., after validation), but prefer Result propagation.
3. In async/parallel contexts, integrate with tokio::spawn or rayon::iter for error-collecting futures.
4. Add proper imports for error types if using thiserror or anyhow.
5. Test for race conditions by simulating failures in parallel tasks.

### Code Example
```rust
// BEFORE:
let result = thread::spawn(|| compute()).unwrap().join().unwrap();

// AFTER:
let handle = thread::spawn(|| compute());
let result = handle.join().map_err(|_| "Thread panicked")?;
let value = result?; // If compute() returns Result
// Or use expect for documented safety:
let value = thread::spawn(|| compute()).expect("Spawn failed").join().expect("Join failed");
```

---

## Issue #3: Unsafe unwrap() call in chord_analyzer.rs

**Confidence:** Medium | **Estimated Time:** 8 minutes

### Analysis
In chord analysis (likely MIDI note processing), unwrap() on parsing or indexing operations ignores Rust's bounds checking and Option semantics, potentially panicking on invalid MIDI data. This ties into trait bounds for musical data structures (e.g., Vec<Note> indexing), where lifetimes of borrowed slices could lead to use-after-free if not handled, but primarily it's an error handling lapse in a real-time sensitive context.

### Fix Steps
1. Find the unwrap() in chord detection logic, e.g., on note frequency calculations or interval lookups.
2. Replace with Option combinators like and_then() or map() for chained operations.
3. Use expect() if the input is validated upstream, documenting the assumption.
4. Propagate errors via a custom Error enum implementing std::error::Error.
5. Ensure no allocations in hot paths by using &str/[T] where possible.

### Code Example
```rust
// BEFORE:
let interval = notes.get(index).unwrap().interval();

// AFTER:
let interval = notes.get(index).copied().ok_or("Invalid note index")?.interval()?;
// Or with match:
let interval = match notes.get(index) {
    Some(note) => note.interval().ok(),
    None => None,
};
```

---

## Issue #4: Unsafe unwrap() call in chord_analyzer.rs

**Confidence:** Medium | **Estimated Time:** 8 minutes

### Analysis
The second unwrap() likely occurs in a similar parsing or computation step, such as chord root finding or quality determination, where Result from floating-point approximations (e.g., pitch class sets) is force-unwrapped. Rust's ownership model ensures safe borrowing of analysis buffers, but unwrap() undermines this by not respecting the Err variant, which might represent ambiguous chords or out-of-tune notes.

### Fix Steps
1. Target the unwrap() in a secondary analysis method, e.g., on a HashMap lookup for chord qualities.
2. Prefer if let or unwrap_or_default() for defaults in non-critical paths.
3. Integrate with anyhow for contextual error messages in musical analysis.
4. Consider SIMD for performance in note array processing, but handle errors outside hot loops.
5. Validate MIDI input earlier to justify expect() if safe.

### Code Example
```rust
// BEFORE:
let quality = chord_map.get(&key).unwrap();

// AFTER:
let quality = chord_map.get(&key).cloned().unwrap_or_default();
// Or propagate:
let quality = chord_map.get(&key).ok_or("Unknown chord key")?.clone();
```

---

## Issue #5: Unsafe unwrap() call in filename.rs

**Confidence:** Medium | **Estimated Time:** 5 minutes

### Analysis
In filename normalization (likely sanitizing paths for MIDI files), unwrap() on string operations (e.g., split or replace) ignores edge cases like empty strings or invalid chars, conflicting with Rust's &str vs String ownership distinctions. This can lead to panics on malformed filenames, bypassing safe UTF-8 handling and borrow checker protections for path components.

### Fix Steps
1. Locate unwrap() in path manipulation, e.g., on PathBuf::new() or extension extraction.
2. Use as_ref() or to_string_lossy() for safe conversions between &str and String.
3. Handle with Result via ? in a function returning io::Result<String>.
4. For zero-copy, prefer &str slices where possible in normalization rules.
5. Add unit tests for edge cases like filenames with no extension.

### Code Example
```rust
// BEFORE:
let ext = path.extension().unwrap().to_str().unwrap();

// AFTER:
let ext = path.extension()
    .and_then(|e| e.to_str())
    .unwrap_or("unknown");
// Or with Result:
let ext = path.extension()
    .ok_or("No extension")?
    .to_str()
    .ok_or("Invalid UTF-8")?
    .to_owned();
```

---

## Issue #1: Safety - Unsafe unwrap() call detected

**Confidence:** High | **Estimated Time:** 5 minutes

### Analysis
The unwrap() method on Result or Option types forces the extraction of the inner value, panicking on Err or None variants. This violates Rust's ownership and error handling principles by not propagating errors through the type system, potentially leading to runtime panics instead of graceful failure. In the context of Rust's Result<T, E> enum, which encodes success/failure at the type level, unwrap() discards the error information and assumes success, which is non-idiomatic and unsafe for production code, especially in a main.rs file where the main function typically returns () and cannot easily propagate errors without restructuring.

### Fix Steps
1. Identify the unwrap() call on a Result<T, E> or Option<T>.
2. If the enclosing function can return Result<(), Box<dyn std::error::Error>>, replace unwrap() with the ? operator to propagate the error.
3. If propagation isn't feasible (e.g., in main()), use match or if let to handle the error explicitly, logging it with eprintln!() and exiting with std::process::exit(1).
4. For documentation, use expect("descriptive message") if the unwrap is truly infallible in the program's logic, but prefer proper handling.

### Code Example
```rust
// BEFORE:
let config = std::fs::read_to_string("config.toml").unwrap();

// AFTER:
let config = match std::fs::read_to_string("config.toml") {
    Ok(s) => s,
    Err(e) => {
        eprintln!("Failed to read config: {}", e);
        std::process::exit(1);
    }
};
```

---

## Issue #2: Safety - Unsafe unwrap() call detected

**Confidence:** High | **Estimated Time:** 3 minutes

### Analysis
unwrap() on Option<T> or Result<T, E> bypasses Rust's sum types designed for safe error handling and optional values, leading to panics that unwind the stack and potentially leak resources if Drop impls are not invoked properly. This contradicts Rust's memory safety guarantees by not respecting lifetimes and ownership transfer in error paths. In a script like import-tool/src/main.rs, such calls likely occur during file I/O or parsing, where failures are common, making unwrap() particularly risky as it crashes the tool instead of reporting issues.

### Fix Steps
1. Locate the specific unwrap() and determine if it's on an Option (e.g., from find() or get()) or Result (e.g., from I/O operations).
2. Prefer Option/Result combinators like .ok_or() or .map_err() to convert and chain errors idiomatically.
3. In main(), handle with a match expression to print errors and exit, avoiding panics.
4. Add anyhow crate for easier error chaining if not already used: use anyhow::Result; and return Result<()>.

### Code Example
```rust
// BEFORE:
let path = std::env::args().nth(1).unwrap();

// AFTER:
let path = match std::env::args().nth(1) {
    Some(p) => p,
    None => {
        eprintln!("Usage: {} <file>", std::env::args().next().unwrap());
        std::process::exit(1);
    }
};
```

---

## Issue #3: Safety - Unsafe unwrap() call detected

**Confidence:** High | **Estimated Time:** 5 minutes

### Analysis
Rust's type system encourages explicit error handling via Result and Option to prevent silent failures or crashes. unwrap() short-circuits this by panicking, which is a form of runtime failure not caught at compile-time, undermining borrow checker-enforced safety. In the context of a MIDI import tool, unwrap() might be used on parsing results (e.g., from serde or nom), where invalid input is expected, making proper error propagation essential for user feedback rather than abrupt termination.

### Fix Steps
1. Replace unwrap() with .expect("contextual message") only if the operation is guaranteed to succeed post-validation; otherwise, use ? for propagation.
2. If in a non-Result context, convert to Result using .map_err(|e| anyhow::anyhow!("{}", e)) if using anyhow.
3. For parsing, chain with .context("parsing MIDI file") to add context.
4. Ensure the function signature supports Result to use ? effectively.

### Code Example
```rust
// BEFORE:
let data: MidiData = parse_midi(&bytes).unwrap();

// AFTER:
use anyhow::{Context, Result};

let data: MidiData = parse_midi(&bytes)
    .context("Failed to parse MIDI data")?;
```

---

## Issue #4: Safety - Unsafe unwrap() call detected

**Confidence:** High | **Estimated Time:** 4 minutes

### Analysis
The use of unwrap() ignores Rust's ownership model for errors, where Err variants own error data that should be transferred or cloned appropriately. Panicking discards this ownership, potentially leading to lost diagnostic information. In async contexts (if applicable to the import tool), unwrap() can interfere with future propagation, but here in main.rs, it's likely synchronous I/O or config loading, where idiomatic handling uses combinators to avoid deep nesting and improve readability.

### Fix Steps
1. Use if let Some(value) = option { ... } else { handle_error(); } for Options, or match for Results.
2. For I/O-heavy code, wrap in a main function returning Result<(), anyhow::Error> and use ? throughout.
3. Avoid clone() unless necessary; prefer borrowing with as_ref() if the error doesn't need ownership transfer.
4. Test edge cases like missing files or invalid args to ensure handling covers them.

### Code Example
```rust
// BEFORE:
let file = File::open("import.midi").unwrap();

// AFTER:
use std::fs::File;
use anyhow::Result;

let file = File::open("import.midi")
    .map_err(|e| anyhow::anyhow!("Cannot open MIDI file: {}", e))?;
```

---

## Issue #5: Safety - Unsafe unwrap() call detected

**Confidence:** High | **Estimated Time:** 5 minutes

### Analysis
unwrap() represents a mismatch between expected and actual types at runtime, clashing with Rust's compile-time guarantees for safe code. In performance-sensitive contexts like MIDI processing, panics can disrupt real-time constraints, but here in a script, the issue is reliability: errors should be logged, not crash. This likely stems from assuming infallible operations, ignoring Rust's trait bounds like for std::io::Read which return Results.

### Fix Steps
1. Audit the call: if it's on a collection method like .get(), use .and_then() or unwrap_or_default() for defaults.
2. For final handling in main(), collect all errors and report them before exit.
3. Use expect() with a message explaining why it's safe if after prior checks, but prefer full handling.
4. Consider custom error types with thiserror for domain-specific errors in MIDI import.

### Code Example
```rust
// BEFORE:
let version = metadata.get("version").unwrap();

// AFTER:
let version = metadata.get("version")
    .copied()
    .ok_or_else(|| anyhow::anyhow!("Missing version in metadata"))?;
```

---

## Issue #1: Performance - Large Svelte component

**Confidence:** High | **Estimated Time:** 30-45 minutes

### Analysis
In Svelte, large components exceeding recommended line counts like 775 lines lead to performance degradation due to increased bundle size, slower compilation, and harder-to-optimize reactivity tracking. This mirrors Rust's emphasis on modular code to avoid monoliths that complicate ownership and borrowing across large scopes, but in Svelte, it's about DOM diffing efficiency and developer maintainability.

### Fix Steps
1. Identify logical sub-sections in the Slider.svelte component, such as input handling, display logic, and event bindings.
2. Extract each sub-section into a new .svelte component file, passing props for data and dispatching events for communication.
3. Update the parent Slider.svelte to compose these child components, reducing its size below 300 lines.
4. Ensure props are reactive and use stores if shared state is needed to maintain performance.

### Code Example
```rust
// BEFORE:
<script>
  // 775 lines of mixed logic for slider display, events, validation, etc.
  let value = 0;
  function handleChange(e) { /* complex logic */ }
  // ... many more lines
</script>

<div>
  <!-- large template with all elements -->
</div>

// AFTER:
<!-- Slider.svelte -->
<script>
  import SliderHandle from './SliderHandle.svelte';
  import SliderTrack from './SliderTrack.svelte';
  export let value;
  $: handleChange(value);
</script>

<SliderTrack {value}>
  <SliderHandle {value} on:change />
</SliderTrack>

<!-- New SliderHandle.svelte -->
<script>
  export let value;
  function onInput(e) { /* specific handle logic */ }
</script>

<input type="range" bind:value on:input={onInput} />
```

---

## Issue #2: Performance - Missing key in #each block

**Confidence:** High | **Estimated Time:** 2 minutes

### Analysis
Svelte's #each block relies on keys for efficient DOM reconciliation during updates, similar to how Rust uses unique identifiers in collections for safe iteration and mutation without borrow checker conflicts. Without a key, Svelte may re-render the entire block on changes, causing unnecessary DOM manipulations and performance hits, especially in dynamic lists.

### Fix Steps
1. Locate the #each block at line 399 in Slider.svelte.
2. Assume items have a unique 'id' property; add the key directive.
3. If no unique id exists, compute one or use index as fallback, but prefer stable ids for optimal diffing.
4. Test reactivity to ensure updates don't cause full re-renders.

### Code Example
```rust
// BEFORE:
{#each items as item}
  <div>{item.name}</div>
{/each}

// AFTER:
{#each items as item (item.id)}
  <div>{item.name}</div>
{/each}
<!-- Or using key directive: -->
{#each items as item}
  <div key={item.id}>{item.name}</div>
{/each}
```

---

## Issue #3: Performance - Missing key in #each block

**Confidence:** High | **Estimated Time:** 2 minutes

### Analysis
Similar to Issue #2, the absence of keys in Svelte's #each blocks at line 70 in TagCloud.svelte hinders efficient virtual DOM diffing. In Rust terms, this is akin to iterating over a Vec without stable references, potentially leading to unnecessary cloning or moves; here, it forces Svelte to treat the block as unstable, re-creating elements instead of updating them.

### Fix Steps
1. Find the #each block in TagCloud.svelte at line 70.
2. Add a unique key based on item.id or another stable identifier.
3. Verify that the key property doesn't change during the component's lifecycle to avoid re-mounting.
4. Profile the component before and after to confirm performance improvement.

### Code Example
```rust
// BEFORE:
{#each tags as tag}
  <span>{tag.text}</span>
{/each}

// AFTER:
{#each tags as tag (tag.id)}
  <span>{tag.text}</span>
{/each}
<!-- Alternative with key directive: -->
{#each tags as tag}
  <span key={tag.id}>{tag.text}</span>
{/each}
```

---

## Issue #4: Performance - Large Svelte component

**Confidence:** High | **Estimated Time:** 30-45 minutes

### Analysis
The VUMeter.svelte component at 775 lines suffers from the same issues as Issue #1: bloated code leads to slower hydration, larger JS bundles, and maintenance challenges. Analogous to Rust's discouragement of large functions that obscure lifetimes and borrowing scopes, Svelte benefits from composition to isolate reactive concerns and improve re-usability.

### Fix Steps
1. Break down VUMeter into sub-components like MeterDisplay, LevelIndicator, and PeakHold.
2. Move shared logic to a store or context if needed for state management.
3. Refactor the template to use these sub-components, aiming for under 300 lines in the main file.
4. Handle any cross-sub-component communication via props and events.

### Code Example
```rust
// BEFORE:
<script>
  // 775 lines including calculations, rendering logic, animations, etc.
  let level = 0;
  $: updateDisplay(level);
  // ... extensive code
</script>

<div class="vu-meter">
  <!-- complex inline template -->
</div>

// AFTER:
<!-- VUMeter.svelte -->
<script>
  import VUMeterDisplay from './VUMeterDisplay.svelte';
  import PeakIndicator from './PeakIndicator.svelte';
  export let level;
</script>

<VUMeterDisplay {level}>
  <PeakIndicator level={level} />
</VUMeterDisplay>

<!-- New VUMeterDisplay.svelte -->
<script>
  export let level;
  $: color = getColor(level); // specific display logic
</script>

<div class="display" style="background: {color};">{level}</div>
```

---

## Issue #5: Performance - Missing key in #each block

**Confidence:** High | **Estimated Time:** 2 minutes

### Analysis
As with previous #each issues, line 317 in VUMeter.svelte lacks keys, causing Svelte to inefficiently re-render list items on updates. This parallels Rust's need for explicit ownership transfer in loops to avoid borrow errors; without keys, Svelte can't track item identity, leading to full DOM replacements instead of targeted updates.

### Fix Steps
1. Navigate to line 317 in VUMeter.svelte and identify the #each block.
2. Incorporate a key using (item.id) or key={item.id}, assuming items have unique ids.
3. If ids are absent, introduce them in the data source or use a stable computed key.
4. Run Svelte's dev tools to verify improved diffing.

### Code Example
```rust
// BEFORE:
{#each segments as segment}
  <div class="segment" style="height: {segment.height}px;"></div>
{/each}

// AFTER:
{#each segments as segment (segment.id)}
  <div class="segment" style="height: {segment.height}px;"></div>
{/each}
<!-- Or: -->
{#each segments as segment}
  <div class="segment" key={segment.id} style="height: {segment.height}px;"></div>
{/each}
```

---

## Issue #1: Performance - Missing key in #each block

**Confidence:** High | **Estimated Time:** 2 minutes

### Analysis
In Svelte, the {#each} block iterates over arrays to render lists. Without a unique 'key' directive, Svelte cannot efficiently track item identity during updates, leading to unnecessary DOM diffing and re-renders. This impacts performance by causing full list re-renders on changes, rather than targeted updates. The root cause is Svelte's reconciliation algorithm relying on keys for stable identity, similar to React's key prop, to minimize DOM mutations.

### Fix Steps
1. Locate the {#each items} block around line 423 in VUMeter.svelte.
2. Add the key directive to the iterated element, using a unique property like item.id.
3. Ensure all items in the array have a unique, stable identifier (e.g., UUID or index if stable).

### Code Example
```rust
// BEFORE:
{#each items as item}
  <div>{item.name}</div>
{/each}

// AFTER:
{#each items as item (item.id)}
  <div>{item.name}</div>
{/each}
```

---

## Issue #2: Performance - Large Svelte component

**Confidence:** High | **Estimated Time:** 30-60 minutes

### Analysis
Svelte components exceeding 300 lines become harder to maintain and may lead to bundle bloat or slower compilation. The issue arises from monolithic components handling too many responsibilities, violating single-responsibility principle, which can degrade performance through increased JavaScript output and slower hot-reload during development.

### Fix Steps
1. Review AutomationLane.svelte (304 lines) for logical sections like UI parts, event handlers, or sub-features.
2. Extract reusable parts into child components (e.g., split lane visualization, controls, and settings into separate .svelte files).
3. Use Svelte's component composition: import and use child components with props for data passing.
4. Refactor props and stores to avoid prop drilling; consider Svelte stores for shared state.

### Code Example
```rust
// BEFORE:
<!-- In AutomationLane.svelte, large script and template -->
<script>
  // 100+ lines of logic
</script>

<!-- 200+ lines of markup -->
<div>Entire lane UI here</div>

// AFTER:
<!-- In AutomationLane.svelte -->
<script>
  import LaneVisualization from './LaneVisualization.svelte';
  import LaneControls from './LaneControls.svelte';
  // Reduced logic
</script>

<LaneVisualization {data} />
<LaneControls {settings} onUpdate={handleUpdate} />
```

---

## Issue #3: Performance - Large Svelte component

**Confidence:** High | **Estimated Time:** 45 minutes

### Analysis
Similar to issue #2, Toolbar.svelte at 377 lines indicates over-complexity, potentially causing performance hits from larger compiled JS and slower reactivity tracking. Svelte's compiler optimizes small components better, but large ones can lead to unnecessary re-computations if not sectioned properly.

### Fix Steps
1. Identify distinct features in Toolbar.svelte, such as buttons, menus, or status indicators.
2. Break into sub-components (e.g., ToolButtonGroup.svelte, StatusBar.svelte).
3. Pass props for configuration and use on: directives for events.
4. Test for reactivity: ensure child components only re-render when their props change.

### Code Example
```rust
// BEFORE:
<!-- In Toolbar.svelte, monolithic -->
<script>
  // Extensive toolbar logic
</script>

<!-- Long template with all tools -->
<button>Tool 1</button>
<button>Tool 2</button>
<!-- etc. -->

// AFTER:
<!-- In Toolbar.svelte -->
<script>
  import ToolButtons from './ToolButtons.svelte';
  import StatusIndicator from './StatusIndicator.svelte';
</script>

<ToolButtons tools={toolsList} onSelect={handleSelect} />
<StatusIndicator {status} />
```

---

## Issue #4: Performance - Large Svelte component

**Confidence:** High | **Estimated Time:** 1-2 hours

### Analysis
MenuBar.svelte at 648 lines is significantly oversized, likely causing compilation slowdowns, larger bundle sizes, and maintenance issues. This stems from handling multiple menus, submenus, and logic in one file, leading to entangled concerns and potential reactivity overhead as Svelte tracks more dependencies.

### Fix Steps
1. Divide MenuBar into sections: e.g., FileMenu.svelte, EditMenu.svelte, main MenuBar wrapper.
2. Extract menu items into a data-driven approach with {#each} for dynamic rendering.
3. Use Svelte's context API or stores for menu state to avoid prop drilling in deep hierarchies.
4. Consider lazy-loading non-critical menus if applicable.

### Code Example
```rust
// BEFORE:
<!-- In MenuBar.svelte, huge file -->
<script>
  // All menu logic here
</script>

<!-- Massive template with all menus -->
<nav>
  <ul>File menu items</ul>
  <ul>Edit menu items</ul>
  <!-- etc., 600+ lines -->
</nav>

// AFTER:
<!-- In MenuBar.svelte -->
<script>
  import FileMenu from './FileMenu.svelte';
  import EditMenu from './EditMenu.svelte';
</script>

<nav>
  <FileMenu {project} onSave={handleSave} />
  <EditMenu {selection} onEdit={handleEdit} />
</nav>
```

---

## Issue #5: Performance - Missing key in #each block

**Confidence:** High | **Estimated Time:** 2 minutes

### Analysis
As in issue #1, the {#each} block in MenuBar.svelte lacks a key, causing inefficient DOM updates during menu item changes (e.g., dynamic menus). Svelte's diffing algorithm treats the list as unstable without keys, leading to full re-renders and potential flickering or performance drops in interactive UIs.

### Fix Steps
1. Find the {#each items} around line 351 in MenuBar.svelte.
2. Add key={item.id} or use the (item.id) syntax in the each block.
3. Confirm items have unique IDs; if generating dynamically, use stable identifiers like menu item slugs.

### Code Example
```rust
// BEFORE:
{#each menuItems as item}
  <li><a href={item.href}>{item.label}</a></li>
{/each}

// AFTER:
{#each menuItems as item (item.id)}
  <li><a href={item.href}>{item.label}</a></li>
{/each}
```

---

## Issue #1: Performance - Missing key in #each block in MenuBar.svelte

**Confidence:** High | **Estimated Time:** 2 minutes

### Analysis
In Svelte, the #each block iterates over arrays to render lists, but without a unique key directive, Svelte's diffing algorithm cannot efficiently track item identity across re-renders. This leads to unnecessary DOM manipulations, akin to Rust's ownership model where lacking unique identifiers (like IDs in HashMaps) causes inefficient traversals or full rebuilds instead of targeted updates. The type system here enforces reactivity, but missing keys violate the expectation of stable references, similar to lifetime mismatches causing borrow checker errors in iterative data processing.

### Fix Steps
1. Locate the #each block around line 362 in MenuBar.svelte.
2. Add the key directive to the iterated element, using a unique property like item.id.
3. Ensure all items in the array have a unique id field; if not, generate one (e.g., via index as fallback, but prefer stable IDs).

### Code Example
```rust
// BEFORE:
{#each items as item}
  <div>{item.name}</div>
{/each}

// AFTER:
{#each items as item (item.id)}
  <div>{item.name}</div>
{/each}
```

---

## Issue #2: Performance - Large Svelte component in Knob.svelte

**Confidence:** High | **Estimated Time:** 30-60 minutes

### Analysis
Svelte components exceeding 300 lines become hard to maintain and may lead to slower compilation and runtime due to monolithic reactivity graphs. This mirrors Rust's emphasis on modular crates and small functions for compile-time performance and borrow checker tractability; large components create implicit 'ownership' chains in the DOM tree that hinder optimization, similar to deep nesting causing lifetime inference issues.

### Fix Steps
1. Identify logical sections in Knob.svelte (e.g., rendering logic, event handlers, styles).
2. Extract sub-components, such as a ValueDisplay or RotationHandler, into separate .svelte files.
3. Pass props and events between parent and child components, using stores if shared state is needed.
4. Update imports and exports accordingly.

### Code Example
```rust
// BEFORE:
<!-- Knob.svelte: monolithic 665 lines -->
<script>
  // All logic here
</script>

<div class="knob">
  <!-- All markup here -->
</div>

// AFTER:
<!-- Knob.svelte: reduced -->
<script>
  import ValueDisplay from './ValueDisplay.svelte';
  // Reduced logic
</script>

<div class="knob">
  <ValueDisplay {value} />
  <!-- Other sub-components -->
</div>

<!-- New ValueDisplay.svelte -->
<script>
  export let value;
</script>

<span>{value}</span>
```

---

## Issue #3: Performance - Missing key in #each block in Knob.svelte

**Confidence:** High | **Estimated Time:** 2 minutes

### Analysis
Similar to Issue #1, the absence of a key in the #each block at line 443 prevents Svelte from optimizing list diffing, resulting in full re-renders of the list on state changes. In Rust terms, this is like iterating over a Vec without stable references, forcing quadratic-time updates instead of O(1) targeted mutations, violating the efficiency of borrow-checked iterators.

### Fix Steps
1. Find the #each block at line 443 in Knob.svelte.
2. Insert the key directive using a unique item property, such as item.id.
3. If the array items lack IDs, add them or use a stable index-based key.

### Code Example
```rust
// BEFORE:
{#each subItems as item}
  <span>{item.label}</span>
{/each}

// AFTER:
{#each subItems as item (item.id)}
  <span>{item.label}</span>
{/each}
```

---

## Issue #4: Performance - Large Svelte component in VirtualKeyboard.svelte

**Confidence:** High | **Estimated Time:** 45-90 minutes

### Analysis
A 624-line component in VirtualKeyboard.svelte indicates over-complexity, leading to slower hot-reload, larger bundle sizes, and harder debugging. This parallels Rust's crate modularization to avoid monoliths that overwhelm the compiler's type inference and ownership tracking; in Svelte, it creates a tangled reactivity web, akin to unresolved lifetimes in large generic functions.

### Fix Steps
1. Break down the component: e.g., separate key rendering into Key.svelte, octave handling into OctaveSelector.svelte.
2. Move shared logic to stores or context API if applicable.
3. Refactor markup and script sections into child components, passing necessary props.
4. Test the keyboard interactions post-split to ensure event bubbling works.

### Code Example
```rust
// BEFORE:
<!-- VirtualKeyboard.svelte: 624 lines -->
<script>
  // Extensive logic for keys, octaves, etc.
</script>

<div class="keyboard">
  <!-- All keys rendered here -->
</div>

// AFTER:
<!-- VirtualKeyboard.svelte: slimmed -->
<script>
  import Key from './Key.svelte';
  // Core logic only
</script>

<div class="keyboard">
  {#each keys as keyData}
    <Key {keyData} on:click />
  {/each}
</div>

<!-- New Key.svelte -->
<script>
  export let keyData;
  export let on:click;
</script>

<button>{keyData.note}</button>
```

---

## Issue #5: Performance - Missing key in #each block in VirtualKeyboard.svelte

**Confidence:** High | **Estimated Time:** 2 minutes

### Analysis
Without a key in the #each at line 448, Svelte treats the list as unordered, causing inefficient DOM reconciliations during keyboard state updates (e.g., note presses). This inefficiency is comparable to Rust's Vec reallocation without stable indices, leading to dropped borrows and full copies instead of in-place mutations for performance-critical real-time audio paths.

### Fix Steps
1. Navigate to line 448 in VirtualKeyboard.svelte and identify the #each block.
2. Add key={item.id} or equivalent unique identifier to the directive.
3. Prefer stable keys like note names or positions over indices for dynamic lists.

### Code Example
```rust
// BEFORE:
{#each notes as note}
  <div class="note">{note}</div>
{/each}

// AFTER:
{#each notes as note (note.id)}
  <div class="note">{note}</div>
{/each}
```

---

## Issue #1: Performance - Missing key in #each block

**Confidence:** High | **Estimated Time:** 2 minutes

### Analysis
In Svelte, #each blocks iterate over arrays to render lists. Without a unique 'key' directive, Svelte cannot efficiently track and update individual items during reactivity changes, leading to full re-renders of the list. This causes performance degradation, especially for dynamic lists like virtual keyboard keys. The root cause is Svelte's diffing algorithm relying on keys for optimal DOM reconciliation, similar to React's key prop.

### Fix Steps
1. Locate the #each block at line 449 in VirtualKeyboard.svelte.
2. Add the key directive using a unique identifier from each item, such as key={item.id}.
3. Ensure item.id is unique and stable across renders to avoid unnecessary re-renders.

### Code Example
```rust
// BEFORE:
{#each items as item}
  <div>{item.name}</div>
{/each}

// AFTER:
{#each items as item (item.id)}
  <div>{item.name}</div>
{/each}
```

---

## Issue #2: Performance - Missing key in #each block

**Confidence:** High | **Estimated Time:** 2 minutes

### Analysis
Similar to issue #1, the absence of a key in this #each block at line 493 prevents Svelte from optimizing list updates. Svelte's compiler suggests keys for better performance by enabling targeted DOM mutations instead of wholesale replacements, reducing layout thrashing and improving rendering speed in interactive components like virtual keyboards.

### Fix Steps
1. Find the #each block at line 493 in VirtualKeyboard.svelte.
2. Insert the key directive with a unique item property, e.g., key={item.id}.
3. Test the component to ensure keys remain consistent during state changes.

### Code Example
```rust
// BEFORE:
{#each items as item}
  <button>{item.label}</button>
{/each}

// AFTER:
{#each items as item (item.id)}
  <button>{item.label}</button>
{/each}
```

---

## Issue #3: Performance - Missing key in #each block

**Confidence:** High | **Estimated Time:** 2 minutes

### Analysis
This #each block at line 494 suffers from the same issue as the previous ones: lacking a key leads to inefficient re-rendering. In Svelte, keys are crucial for the runtime to associate DOM nodes with data items, preventing costly operations in performance-sensitive UIs like MIDI virtual keyboards where frequent updates occur.

### Fix Steps
1. Identify the #each block at line 494 in VirtualKeyboard.svelte.
2. Add the key directive using item.id or another unique field.
3. Refactor if necessary to ensure the key source is reactive and stable.

### Code Example
```rust
// BEFORE:
{#each items as item}
  <span>{item.value}</span>
{/each}

// AFTER:
{#each items as item (item.id)}
  <span>{item.value}</span>
{/each}
```

---

## Issue #4: Performance - Large Svelte component

**Confidence:** Medium | **Estimated Time:** 30-60 minutes

### Analysis
Svelte components exceeding 300 lines become harder to maintain and may suffer from bundle bloat or slower compilation. The large size (482 lines) in CommandPaletteWindow.svelte indicates monolithic structure, potentially leading to deeper call stacks in reactivity and increased cognitive load, though not directly tied to runtime performance like missing keys.

### Fix Steps
1. Review the component structure and identify logical sections (e.g., search input, results list, actions).
2. Extract subsections into new .svelte components, passing props as needed.
3. Update the parent component to compose the child components, reducing the main file size.
4. Optionally, use Svelte's <svelte:component> for dynamic loading if sections are conditional.

### Code Example
```rust
// BEFORE:
<!-- In CommandPaletteWindow.svelte (lines 1-482) -->
<script>
  // Large script section
</script>

<main>
  <!-- Inline search input -->
  <input bind:value={query} />
  <!-- Inline results list spanning many lines -->
  {#each results as result}
    <div>{result.name}</div>
  {/each}
  <!-- More inline content -->
</main>

// AFTER:
<!-- In CommandPaletteWindow.svelte (now <300 lines) -->
<script>
  import SearchInput from './SearchInput.svelte';
  import ResultsList from './ResultsList.svelte';
  // Reduced script
</script>

<main>
  <SearchInput bind:query />
  <ResultsList {results} on:select={handleSelect} />
</main>

<!-- New file: SearchInput.svelte -->
<script>
  export let query;
</script>
<input bind:value={query} />

<!-- New file: ResultsList.svelte -->
<script>
  export let results;
  export let onSelect;
</script>
{#each results as result (result.id)}
  <div on:click={() => onSelect(result)}>{result.name}</div>
{/each}
```

---

## Issue #5: Performance - Large Svelte component

**Confidence:** Medium | **Estimated Time:** 45-90 minutes

### Analysis
At 573 lines, TagEditorWindow.svelte is overly complex, risking maintainability issues and potential performance hits from large reactive scopes. Svelte recommends <300 lines to encourage modular design, aiding in faster development iterations and easier debugging, especially in editor-like UIs with many interactive elements.

### Fix Steps
1. Analyze the component for separable concerns (e.g., tag list, editor form, preview pane).
2. Create child components for each section, using stores or props for shared state.
3. Replace inline markup and logic with component invocations in the parent.
4. Consider using Svelte stores for global state if sections need tight coupling.

### Code Example
```rust
// BEFORE:
<!-- In TagEditorWindow.svelte (lines 1-573) -->
<script>
  // Extensive script with all logic
</script>

<div>
  <!-- Inline tag list -->
  {#each tags as tag}
    <input type="checkbox" bind:checked={tag.selected} />
  {/each}
  <!-- Inline editor form spanning lines -->
  <form>
    <!-- Many fields -->
  </form>
  <!-- Inline preview -->
</div>

// AFTER:
<!-- In TagEditorWindow.svelte (now <300 lines) -->
<script>
  import TagList from './TagList.svelte';
  import EditorForm from './EditorForm.svelte';
  import PreviewPane from './PreviewPane.svelte';
  // Simplified script
</script>

<div>
  <TagList {tags} on:toggle={handleToggle} />
  <EditorForm {selectedTags} on:submit={handleSubmit} />
  <PreviewPane {previewData} />
</div>

<!-- New file: TagList.svelte -->
<script>
  export let tags;
  export let onToggle;
</script>
{#each tags as tag (tag.id)}
  <input type="checkbox" bind:checked={tag.selected} on:change={() => onToggle(tag)} />
{/each}

<!-- Similarly for other new components -->
```

---

## Issue #1: Performance - Missing key in #each block in TagEditorWindow.svelte:250

**Confidence:** High | **Estimated Time:** 2 minutes

### Analysis
Although this is a Svelte-specific issue, in the context of a Rust-backed application (e.g., Tauri with Rust core for MIDI handling), inefficient frontend rendering can bottleneck real-time audio/MIDI performance. Svelte's #each directive without a key leads to suboptimal DOM diffing, causing full re-renders instead of targeted updates. This violates Svelte's reactivity model, similar to how Rust's ownership prevents unnecessary copiesâ€”here, lacking a stable identifier forces Svelte to treat the list as unstable, akin to missing trait bounds for efficient iteration.

### Fix Steps
1. Locate the #each block around line 250 in TagEditorWindow.svelte.
2. Add the key directive using a unique property like item.id, ensuring it is stable across renders (e.g., not a random or index-based value).
3. Verify that the items array has a consistent .id field; if not, consider adding one in the Rust backend data model for better integration.

### Code Example
```rust
// BEFORE:
{#each items as item}
  <div>{item.name}</div>
{/each}

// AFTER:
{#each items as item (item.id)}
  <div>{item.name}</div>
{/each}
```

---

## Issue #2: Performance - Missing key in #each block in TagEditorWindow.svelte:396

**Confidence:** High | **Estimated Time:** 2 minutes

### Analysis
Similar to Issue #1, the absence of a key in Svelte's #each block at line 396 hampers diffing efficiency, leading to potential performance degradation in a MIDI software context where UI updates must be snappy to avoid latency in real-time interactions. In Rust terms, this is like iterating over a Vec without indexing, missing opportunities for zero-copy optimizationsâ€”Svelte needs the key as a 'lifetime' marker for elements to track changes without full rebuilds.

### Fix Steps
1. Navigate to line 396 in TagEditorWindow.svelte and identify the #each block.
2. Insert the key directive with (item.id) or key={item.id}, preferring the parenthesized shorthand for brevity.
3. Test the component to ensure reordering or adding/removing items updates correctly without jank.

### Code Example
```rust
// BEFORE:
{#each items as item}
  <input bind:value={item.value} />
{/each}

// AFTER:
{#each items as item (item.id)}
  <input bind:value={item.value} />
{/each}
```

---

## Issue #3: Performance - Large Svelte component in AutomationWindow.svelte

**Confidence:** High | **Estimated Time:** 30-45 minutes

### Analysis
A 492-line Svelte component exceeds maintainability thresholds, increasing cognitive load and bug risk, much like a monolithic Rust module without proper trait decomposition. In performance terms for MIDI apps, large components can lead to slower compilation and runtime reactivity overhead, akin to Rust's borrow checker flagging overly complex ownership graphsâ€”splitting enforces modularity, improving hot-path efficiency in UI updates tied to async Rust backends.

### Fix Steps
1. Review AutomationWindow.svelte and identify logical sections (e.g., controls, lists, modals).
2. Extract reusable parts into new .svelte files, such as a ControlsPanel.svelte or ItemList.svelte, using props for data passing.
3. Update the parent component to import and compose the child components, handling any shared state via stores if needed.
4. Consider Rust-side impacts: if the component consumes heavy data, ensure child components use efficient bindings to avoid unnecessary re-renders.

### Code Example
```rust
// BEFORE (excerpt in AutomationWindow.svelte):
<script>
  let items = [];
</script>
<div>
  <!-- 492 lines of mixed UI logic -->
  {#each items as item}
    <div>{item.name}</div>
  {/each}
  <!-- more UI -->
</div>

// AFTER (in AutomationWindow.svelte):
<script>
  import ItemList from './ItemList.svelte';
  let items = [];
</script>
<div>
  <ItemList {items} />
  <!-- other sections extracted similarly -->
</div>

// New ItemList.svelte:
<script>
  export let items;
</script>
{#each items as item (item.id)}
  <div>{item.name}</div>
{/each}
```

---

## Issue #4: Performance - Missing key in #each block in AutomationWindow.svelte:265

**Confidence:** High | **Estimated Time:** 2 minutes

### Analysis
Without a key at line 265, Svelte's reconciliation algorithm treats list items as unordered, causing expensive DOM manipulationsâ€”critical in MIDI UIs where smooth updates are needed alongside Rust's lock-free audio processing. This mirrors Rust's emphasis on stable references via lifetimes; a missing key erodes the 'identity' of elements, leading to full re-mounts instead of updates.

### Fix Steps
1. Open AutomationWindow.svelte and go to line 265 for the #each block.
2. Add key={item.id} or the shorthand (item.id), ensuring id is a unique, unchanging field.
3. If splitting the component (per Issue #3), incorporate this fix into the extracted child component.

### Code Example
```rust
// BEFORE:
{#each automationItems as item}
  <button>{item.action}</button>
{/each}

// AFTER:
{#each automationItems as item (item.id)}
  <button>{item.action}</button>
{/each}
```

---

## Issue #5: Performance - Missing key in #each block in AutomationWindow.svelte:340

**Confidence:** High | **Estimated Time:** 2 minutes

### Analysis
The #each block at line 340 lacks a key, resulting in inefficient list rendering that could compound with the large component size (Issue #3), impacting overall app responsiveness in a real-time MIDI context. Analogous to Rust's Vec reallocation without capacity hints, this forces Svelte to diff the entire list, missing optimizations for incremental updates based on element identity.

### Fix Steps
1. Locate line 340 in AutomationWindow.svelte and examine the #each iteration.
2. Implement the key directive using a unique item property, such as item.id.
3. Run performance tests post-fix to confirm smoother updates, especially during dynamic MIDI data changes from Rust.

### Code Example
```rust
// BEFORE:
{#each parameters as param}
  <span>{param.value}</span>
{/each}

// AFTER:
{#each parameters as param (param.id)}
  <span>{param.value}</span>
{/each}
```

---

## Issue #1: Performance - Missing key in #each block

**Confidence:** High | **Estimated Time:** 2 minutes

### Analysis
In Svelte, the #each block iterates over arrays to render lists. Without a unique key directive (e.g., key={item.id}), Svelte cannot efficiently track item identity during updates, leading to full re-renders of the list on changes. This violates Svelte's diffing algorithm principles, similar to how React's key prop optimizes reconciliation, causing unnecessary DOM manipulations and performance degradation in dynamic UIs like automation windows.

### Fix Steps
1. Locate the #each block at line 455 in AutomationWindow.svelte.
2. Identify the iterable (e.g., {#each items as item}) and ensure each item has a unique identifier like 'id'.
3. Add the key directive: {#each items as item (item.id)} or {#each items as item, key = item.id}.
4. Verify the key is stable and unique to avoid reconciliation issues.

### Code Example
```rust
// BEFORE:
{#each items as item}
  <div>{item.name}</div>
{/each}

// AFTER:
{#each items as item (item.id)}
  <div>{item.name}</div>
{/each}
```

---

## Issue #2: Performance - Large Svelte component

**Confidence:** High | **Estimated Time:** 30-45 minutes

### Analysis
Svelte components exceeding 300 lines become hard to maintain and can lead to slower compilation and bundle sizes. This issue arises from monolithic designs where logic, markup, and styles are not modularized, contravening Svelte's component composition model which encourages small, reusable units for better tree-shaking and hot-reloading efficiency.

### Fix Steps
1. Review PipelineWindow.svelte (419 lines) and identify logical sections (e.g., header, main content, footer).
2. Extract sections into new .svelte components (e.g., PipelineHeader.svelte, PipelineControls.svelte).
3. Move relevant script logic and styles to the new components, using props for data passing.
4. Import and compose the sub-components in the parent, reducing the main file size.
5. Test for functionality preservation and performance improvements.

### Code Example
```rust
// BEFORE:
<!-- In PipelineWindow.svelte, large markup -->
<script>
  let data = [...]; // 200+ lines of logic
</script>

<main>
  <!-- 300+ lines of HTML -->
</main>

// AFTER:
<!-- In PipelineWindow.svelte, reduced -->
<script>
  import PipelineHeader from './PipelineHeader.svelte';
  import PipelineControls from './PipelineControls.svelte';
  let data = [...];
</script>

<main>
  <PipelineHeader {data} />
  <PipelineControls {data} />
</main>

<!-- New PipelineHeader.svelte -->
<script>
  export let data;
</script>

<header>{/* extracted markup */}</header>

<!-- Similarly for PipelineControls.svelte -->
```

---

## Issue #3: Performance - Large Svelte component

**Confidence:** High | **Estimated Time:** 1-2 hours

### Analysis
Similar to issue #2, components over 300 lines (here 850 lines) indicate over-consolidation, leading to cognitive overload, slower development, and potential runtime inefficiencies from unoptimized renders. Svelte's reactivity system benefits from granular components that isolate state changes, preventing cascade updates across large files.

### Fix Steps
1. Analyze LoopBrowserWindow.svelte (850 lines) for natural breaks (e.g., browser list, preview pane, controls).
2. Create sub-components like LoopList.svelte, LoopPreview.svelte, and BrowserToolbar.svelte.
3. Refactor script sections: move stores or functions to sub-components or shared utilities.
4. Use Svelte's context API or props/events for communication between sub-components.
5. Rebuild and lint to confirm size reduction below 300 lines.

### Code Example
```rust
// BEFORE:
<!-- In LoopBrowserWindow.svelte, massive file -->
<script>
  // Extensive logic spanning hundreds of lines
</script>

<div>
  <!-- Vast HTML structure -->
</div>

// AFTER:
<!-- In LoopBrowserWindow.svelte, slimmed down -->
<script>
  import LoopList from './LoopList.svelte';
  import LoopPreview from './LoopPreview.svelte';
  import BrowserToolbar from './BrowserToolbar.svelte';
  let loops = $state([]);
</script>

<div>
  <BrowserToolbar {loops} />
  <LoopList {loops} on:select={handleSelect} />
  <LoopPreview />
</div>

<!-- Example: LoopList.svelte -->
<script>
  export let loops;
  export let onSelect;
</script>

{#each loops as loop (loop.id)}
  <div on:click={() => onSelect(loop)}>{loop.name}</div>
{/each}
```

---

## Issue #4: Performance - Missing key in #each block

**Confidence:** High | **Estimated Time:** 2 minutes

### Analysis
As in issue #1, the absence of a key in #each blocks at line 346 forces Svelte to treat the list as unordered, resulting in O(n) diffing instead of O(1) item tracking. This is critical in browser windows with dynamic content like loops, where frequent updates amplify performance hits due to inefficient DOM patching.

### Fix Steps
1. Find the #each block at line 346 in LoopBrowserWindow.svelte.
2. Confirm the items have unique IDs (e.g., loop.id).
3. Insert the key directive using the unique property.
4. Test list updates (add/remove items) to verify smoother animations and reactivity.

### Code Example
```rust
// BEFORE:
{#each loops as loop}
  <div>{loop.name}</div>
{/each}

// AFTER:
{#each loops as loop (loop.id)}
  <div>{loop.name}</div>
{/each}
```

---

## Issue #5: Performance - Missing key in #each block

**Confidence:** High | **Estimated Time:** 2 minutes

### Analysis
Reiterating the pattern from issues #1 and #4, line 383's #each lacks a key, causing suboptimal list reconciliation in Svelte's runtime. In a loop browser context, this could lead to janky UI during searches or filters, as Svelte rebuilds DOM nodes unnecessarily without identity hints.

### Fix Steps
1. Navigate to line 383 in LoopBrowserWindow.svelte and inspect the #each iteration.
2. Add key={item.id} or equivalent, assuming 'id' is the unique field.
3. Optionally, use a more complex key if needed (e.g., key={item.id + item.category}).
4. Run performance profiling (e.g., via browser dev tools) before/after to measure DOM update efficiency.

### Code Example
```rust
// BEFORE:
{#each filteredLoops as loop}
  <li>{loop.title}</li>
{/each}

// AFTER:
{#each filteredLoops as loop (loop.id)}
  <li>{loop.title}</li>
{/each}
```

---

## Issue #1: Performance - Missing key in #each block in LoopBrowserWindow.svelte

**Confidence:** High | **Estimated Time:** 2 minutes

### Analysis
Although this is a Svelte-specific issue in a project likely using Rust for backend (e.g., via Tauri or WASM), the root cause is in Svelte's reactivity system. Without a unique 'key' directive in {#each} blocks, Svelte cannot efficiently track item identity during list updates, leading to full re-renders of the block instead of targeted DOM diffing. This violates Svelte's optimization principles similar to how Rust's ownership model prevents unnecessary copiesâ€”here, it causes performance degradation by not leveraging stable identities for reconciliation.

### Fix Steps
1. Locate the {#each items} block around line 394 in LoopBrowserWindow.svelte.
2. Add the key directive to the iterated element, using a unique property like item.id.
3. Ensure item.id is stable and unique across renders to avoid key collisions.

### Code Example
```rust
// BEFORE:
{#each items as item}
  <div>{item.name}</div>
{/each}

// AFTER:
{#each items as item (item.id)}
  <div>{item.name}</div>
{/each}
```

---

## Issue #2: Performance - Missing key in #each block in LoopBrowserWindow.svelte

**Confidence:** High | **Estimated Time:** 2 minutes

### Analysis
Similar to Issue #1, this Svelte reactivity issue at line 747 stems from lacking item identity tracking in {#each}, causing inefficient DOM updates. In a Rust-integrated frontend (e.g., Tauri), this amplifies performance hits during data flows from Rust stores, akin to Rust's borrow checker enforcing efficient referencesâ€”without keys, Svelte re-renders excessively, wasting cycles.

### Fix Steps
1. Find the {#each items} block near line 747 in LoopBrowserWindow.svelte.
2. Insert the key directive using item.id or another unique identifier.
3. Test list updates to confirm smoother animations and reduced re-renders.

### Code Example
```rust
// BEFORE:
{#each items as item}
  <li>{item.title}</li>
{/each}

// AFTER:
{#each items as item (item.id)}
  <li>{item.title}</li>
{/each}
```

---

## Issue #3: Performance - Large Svelte component in MixerWindow.svelte

**Confidence:** High | **Estimated Time:** 30-60 minutes

### Analysis
This is a maintainability and performance concern in Svelte, where components exceeding 300 lines become hard to optimize and debug. In a Rust-Svelte hybrid app, large components can bottleneck reactivity and state management from Rust signals/stores, similar to how Rust encourages modular crates to avoid monolithsâ€”large Svelte files lead to slower compilation, harder testing, and potential memory leaks in the JS runtime.

### Fix Steps
1. Identify logical sections in MixerWindow.svelte (e.g., controls, meters, tracks).
2. Extract each section into a new .svelte component file, passing props from the parent.
3. Update the parent to compose these child components, using stores or props for shared state.
4. Optionally, integrate with Rust stores via Tauri APIs for better data flow.

### Code Example
```rust
// BEFORE:
<!-- In MixerWindow.svelte, lines 1-507 -->
<script>
  // Large script with all logic
</script>
<main>
  <!-- All markup here -->
  <div class="mixer-controls">...</div>
  <div class="track-meters">...</div>
</main>

// AFTER:
<!-- In MixerWindow.svelte -->
<script>
  import MixerControls from './MixerControls.svelte';
  import TrackMeters from './TrackMeters.svelte';
  // Reduced script
</script>
<main>
  <MixerControls {tracks} />
  <TrackMeters {meters} />
</main>

<!-- New file: MixerControls.svelte -->
<script>
  export let tracks;
</script>
<div class="mixer-controls">...</div>

<!-- New file: TrackMeters.svelte -->
<script>
  export let meters;
</script>
<div class="track-meters">...</div>
```

---

## Issue #4: Performance - Large Svelte component in ProjectBrowserWindow.svelte

**Confidence:** High | **Estimated Time:** 60-90 minutes

### Analysis
Exceeding 900 lines in a Svelte component hampers development velocity and runtime efficiency, as Svelte's compiler struggles with large templates and scripts. In the context of a Rust-powered app (e.g., for MIDI handling), this can cascade to slower interop with Rust's async tasks or real-time data, mirroring Rust's preference for small, focused traits over bloated implsâ€”large components increase cognitive load and error proneness.

### Fix Steps
1. Break down ProjectBrowserWindow.svelte into sub-components like ProjectList, SearchBar, PreviewPane.
2. Move related script logic into each child component's <script> section.
3. Use Svelte stores or context for cross-component communication, potentially backed by Rust signals.
4. Refactor iteratively, testing each split to maintain functionality.

### Code Example
```rust
// BEFORE:
<!-- In ProjectBrowserWindow.svelte, lines 1-913 -->
<script>
  // Extensive script logic
</script>
<main>
  <!-- Massive markup -->
  <div class="project-list">...</div>
  <div class="search-bar">...</div>
  <div class="preview">...</div>
</main>

// AFTER:
<!-- In ProjectBrowserWindow.svelte -->
<script>
  import ProjectList from './ProjectList.svelte';
  import SearchBar from './SearchBar.svelte';
  import PreviewPane from './PreviewPane.svelte';
  // Simplified parent script
</script>
<main>
  <SearchBar bind:query />
  <ProjectList {projects} {query} on:select={handleSelect} />
  <PreviewPane {selectedProject} />
</main>

<!-- New file: ProjectList.svelte -->
<script>
  export let projects;
  export let query;
  export let on:select;
</script>
<div class="project-list">...</div>

<!-- Similarly for other components -->
```

---

## Issue #5: Performance - Missing key in #each block in ProjectBrowserWindow.svelte

**Confidence:** High | **Estimated Time:** 2 minutes

### Analysis
As with prior #each issues, the absence of a key at line 437 in Svelte leads to suboptimal list reconciliation, forcing full re-renders on updates. In a MIDI software context with Rust backend, this could stutter UI during real-time project loading, contrasting Rust's zero-cost abstractionsâ€”Svelte keys enable efficient diffs like Rust's borrow-checked mutations.

### Fix Steps
1. Navigate to the {#each} block around line 437 in ProjectBrowserWindow.svelte.
2. Append the key directive with (item.id) or equivalent unique key.
3. Validate that the key property is present and immutable in the data from Rust.

### Code Example
```rust
// BEFORE:
{#each projects as project}
  <div>{project.name}</div>
{/each}

// AFTER:
{#each projects as project (project.id)}
  <div>{project.name}</div>
{/each}
```

---

## Issue #1: Performance - Missing key in #each block

**Confidence:** High | **Estimated Time:** 1 minute

### Analysis
This issue occurs in Svelte's reactivity system, where #each blocks iterate over arrays to render lists. Without a unique 'key' directive, Svelte cannot efficiently track item identity during updates, leading to full list re-renders instead of targeted DOM diffing. This mimics Rust's ownership model in that without stable identifiers (like unique IDs), the framework loses 'borrowing' efficiency for partial updates, resulting in unnecessary computations akin to cloning entire collections instead of borrowing slices. Reference: Svelte's reconciliation algorithm, similar to how Rust's borrow checker prevents aliasing but here it's about diffing efficiency.

### Fix Steps
1. Locate the #each block at line 566 in ProjectBrowserWindow.svelte.
2. Add the key={item.id} directive to the opening #each tag, assuming 'item' is the loop variable and 'id' is a unique property.
3. Ensure all items in the iterated array have a unique 'id' field to avoid fallback behaviors.

### Code Example
```rust
// BEFORE:
{#each items as item}
  <div>{item.name}</div>
{/each}

// AFTER:
{#each items as item (item.id)}
  <div>{item.name}</div>
{/each}
```

---

## Issue #2: Performance - Missing key in #each block

**Confidence:** High | **Estimated Time:** 1 minute

### Analysis
This issue occurs in Svelte's reactivity system, where #each blocks iterate over arrays to render lists. Without a unique 'key' directive, Svelte cannot efficiently track item identity during updates, leading to full list re-renders instead of targeted DOM diffing. This mimics Rust's ownership model in that without stable identifiers (like unique IDs), the framework loses 'borrowing' efficiency for partial updates, resulting in unnecessary computations akin to cloning entire collections instead of borrowing slices. Reference: Svelte's reconciliation algorithm, similar to how Rust's borrow checker prevents aliasing but here it's about diffing efficiency.

### Fix Steps
1. Locate the #each block at line 739 in ProjectBrowserWindow.svelte.
2. Add the key={item.id} directive to the opening #each tag, assuming 'item' is the loop variable and 'id' is a unique property.
3. Ensure all items in the iterated array have a unique 'id' field to avoid fallback behaviors.

### Code Example
```rust
// BEFORE:
{#each items as item}
  <div>{item.name}</div>
{/each}

// AFTER:
{#each items as item (item.id)}
  <div>{item.name}</div>
{/each}
```

---

## Issue #3: Performance - Missing key in #each block

**Confidence:** High | **Estimated Time:** 1 minute

### Analysis
This issue occurs in Svelte's reactivity system, where #each blocks iterate over arrays to render lists. Without a unique 'key' directive, Svelte cannot efficiently track item identity during updates, leading to full list re-renders instead of targeted DOM diffing. This mimics Rust's ownership model in that without stable identifiers (like unique IDs), the framework loses 'borrowing' efficiency for partial updates, resulting in unnecessary computations akin to cloning entire collections instead of borrowing slices. Reference: Svelte's reconciliation algorithm, similar to how Rust's borrow checker prevents aliasing but here it's about diffing efficiency.

### Fix Steps
1. Locate the #each block at line 776 in ProjectBrowserWindow.svelte.
2. Add the key={item.id} directive to the opening #each tag, assuming 'item' is the loop variable and 'id' is a unique property.
3. Ensure all items in the iterated array have a unique 'id' field to avoid fallback behaviors.

### Code Example
```rust
// BEFORE:
{#each items as item}
  <div>{item.name}</div>
{/each}

// AFTER:
{#each items as item (item.id)}
  <div>{item.name}</div>
{/each}
```

---

## Issue #4: Performance - Missing key in #each block

**Confidence:** High | **Estimated Time:** 1 minute

### Analysis
This issue occurs in Svelte's reactivity system, where #each blocks iterate over arrays to render lists. Without a unique 'key' directive, Svelte cannot efficiently track item identity during updates, leading to full list re-renders instead of targeted DOM diffing. This mimics Rust's ownership model in that without stable identifiers (like unique IDs), the framework loses 'borrowing' efficiency for partial updates, resulting in unnecessary computations akin to cloning entire collections instead of borrowing slices. Reference: Svelte's reconciliation algorithm, similar to how Rust's borrow checker prevents aliasing but here it's about diffing efficiency.

### Fix Steps
1. Locate the #each block at line 814 in ProjectBrowserWindow.svelte.
2. Add the key={item.id} directive to the opening #each tag, assuming 'item' is the loop variable and 'id' is a unique property.
3. Ensure all items in the iterated array have a unique 'id' field to avoid fallback behaviors.

### Code Example
```rust
// BEFORE:
{#each items as item}
  <div>{item.name}</div>
{/each}

// AFTER:
{#each items as item (item.id)}
  <div>{item.name}</div>
{/each}
```

---

## Issue #5: Performance - Missing key in #each block

**Confidence:** High | **Estimated Time:** 1 minute

### Analysis
This issue occurs in Svelte's reactivity system, where #each blocks iterate over arrays to render lists. Without a unique 'key' directive, Svelte cannot efficiently track item identity during updates, leading to full list re-renders instead of targeted DOM diffing. This mimics Rust's ownership model in that without stable identifiers (like unique IDs), the framework loses 'borrowing' efficiency for partial updates, resulting in unnecessary computations akin to cloning entire collections instead of borrowing slices. Reference: Svelte's reconciliation algorithm, similar to how Rust's borrow checker prevents aliasing but here it's about diffing efficiency.

### Fix Steps
1. Locate the #each block at line 826 in ProjectBrowserWindow.svelte.
2. Add the key={item.id} directive to the opening #each tag, assuming 'item' is the loop variable and 'id' is a unique property.
3. Ensure all items in the iterated array have a unique 'id' field to avoid fallback behaviors.

### Code Example
```rust
// BEFORE:
{#each items as item}
  <div>{item.name}</div>
{/each}

// AFTER:
{#each items as item (item.id)}
  <div>{item.name}</div>
{/each}
```

---

## Issue #1: Performance - Large Svelte component

**Confidence:** High | **Estimated Time:** 30-45 minutes

### Analysis
In Svelte, large components exceeding recommended line limits (e.g., 570 lines vs. <300) lead to decreased maintainability, slower development iteration, and potential performance issues during compilation and runtime due to excessive reactive updates and DOM diffing. This occurs because Svelte's compiler processes the entire component as a single unit, increasing bundle size and hot-reload times. Unlike Rust's modular crate system, Svelte encourages composition via child components to encapsulate logic and reduce cognitive load.

### Fix Steps
1. Identify logical sections in FavoritesWindow.svelte (e.g., header, list, footer) and extract them into new .svelte files.
2. Create subcomponents like FavoritesHeader.svelte, FavoritesList.svelte, and FavoritesFooter.svelte.
3. Replace the extracted sections with <FavoritesHeader /> , <FavoritesList {items} /> , etc., passing necessary props.
4. Ensure reactive props are properly bound and events are handled via on: directives if needed.

### Code Example
```rust
// BEFORE:
<script>
  let favorites = [];
  // ... 570 lines of mixed logic, markup, and styles
</script>

<main>
  <h1>Favorites</h1>
  {#each favorites as item}
    <div>{item.name}</div>
  {/each}
  <!-- more mixed content -->
</main>

// AFTER:
<script>
  import FavoritesHeader from './FavoritesHeader.svelte';
  import FavoritesList from './FavoritesList.svelte';
  import FavoritesFooter from './FavoritesFooter.svelte';
  let favorites = [];
</script>

<main>
  <FavoritesHeader />
  <FavoritesList {favorites} />
  <FavoritesFooter />
</main>
```

---

## Issue #2: Performance - Missing key in #each block

**Confidence:** High | **Estimated Time:** 2 minutes

### Analysis
Svelte's #each block without a key directive causes inefficient DOM updates during list reconciliation, as the framework cannot track item identity efficiently. This leads to unnecessary re-renders and DOM manipulations on item additions/removals/reorders, impacting performance in dynamic lists. In contrast to Rust's ownership model ensuring unique identities via references, Svelte relies on explicit keys for optimal diffing algorithms similar to React's reconciliation.

### Fix Steps
1. Locate the #each block at line 296 in FavoritesWindow.svelte.
2. Add the key directive using a unique identifier from each item, such as item.id.
3. If no unique id exists, compute one (e.g., via index as fallback, but prefer stable ids).
4. Verify the list updates smoothly without flickering or performance drops.

### Code Example
```rust
// BEFORE:
{#each items as item}
  <div>{item.name}</div>
{/each}

// AFTER:
{#each items as item (item.id)}
  <div>{item.name}</div>
{/each}
```

---

## Issue #3: Documentation - Image missing alt attribute

**Confidence:** High | **Estimated Time:** 1 minute

### Analysis
Accessibility in Svelte (and web standards) requires alt attributes on <img> elements to provide descriptive text for screen readers and when images fail to load. Omitting this violates WCAG guidelines and hinders usability for visually impaired users. Unlike Rust's type system enforcing compile-time checks, this is a runtime/HTML concern handled by linters or manual review in Svelte's markup.

### Fix Steps
1. Find the <img> tag at line 376 in FavoritesWindow.svelte.
2. Add an alt attribute with a concise, descriptive string relevant to the image's purpose (e.g., alt='Favorites icon').
3. If the image is decorative, use alt='' to indicate it's non-informative.
4. Run accessibility tools like axe or Lighthouse to validate.

### Code Example
```rust
// BEFORE:
<img src="favorites.png" />

// AFTER:
<img src="favorites.png" alt="Favorites list icon" />
```

---

## Issue #4: Performance - Large Svelte component

**Confidence:** High | **Estimated Time:** 20-30 minutes

### Analysis
Similar to Issue #1, a 329-line component in DAWWindow.svelte exceeds Svelte's heuristic for maintainable size, leading to slower compilation, harder debugging, and potential reactivity overhead from entangled concerns. Svelte's component model promotes decomposition to leverage scoped CSS, isolated scripts, and reusable logic, akin to Rust's trait-based modularity but focused on UI composition.

### Fix Steps
1. Break down DAWWindow.svelte into thematic subcomponents (e.g., DAWHeader, DAWControls, DAWDisplay).
2. Extract script logic relevant to each section into the subcomponents.
3. Import and use the new components in the parent, passing props like data or event handlers.
4. Refactor styles to be component-specific where possible.

### Code Example
```rust
// BEFORE:
<script>
  let dawData = {};
  // ... 329 lines mixed
</script>

<div>
  <h1>DAW</h1>
  <!-- controls and display mixed -->
</div>

// AFTER:
<script>
  import DAWHeader from './DAWHeader.svelte';
  import DAWControls from './DAWControls.svelte';
  import DAWDisplay from './DAWDisplay.svelte';
  let dawData = {};
</script>

<div>
  <DAWHeader {dawData} />
  <DAWControls {dawData} on:change={handleChange} />
  <DAWDisplay {dawData} />
</div>
```

---

## Issue #5: Performance - Large Svelte component

**Confidence:** High | **Estimated Time:** 45-60 minutes

### Analysis
The 779-line VelocityEditorWindow.svelte suffers from extreme bloat, amplifying issues like slow hot-reloading, error-prone maintenance, and inefficient reactivity in Svelte's update cycle. Large components mix unrelated UI/logic, violating single-responsibility principles; Svelte mitigates this through nested components, paralleling Rust's encapsulation but in a declarative UI paradigm.

### Fix Steps
1. Divide into multiple subcomponents: e.g., VelocityToolbar, VelocityGrid, VelocitySettings, VelocityPreview.
2. Move associated script variables, functions, and styles to each subcomponent.
3. Wire up the parent with props for state sharing (use stores if complex) and on: events for interactions.
4. Iteratively test each extraction to maintain functionality.
5. Consider using Svelte stores for shared state across subcomponents.

### Code Example
```rust
// BEFORE:
<script>
  let velocityData = [];
  // ... 779 lines of everything
</script>

<section>
  <header>Toolbar</header>
  <div>Grid editor</div>
  <!-- massive mixed content -->
</section>

// AFTER:
<script>
  import VelocityToolbar from './VelocityToolbar.svelte';
  import VelocityGrid from './VelocityGrid.svelte';
  import VelocitySettings from './VelocitySettings.svelte';
  import { writable } from 'svelte/store';
  let velocityData = writable([]);
</script>

<section>
  <VelocityToolbar {velocityData} />
  <VelocityGrid {velocityData} />
  <VelocitySettings {velocityData} />
</section>
```

---

## Issue #1: Performance - Missing key in #each block in VelocityEditorWindow.svelte

**Confidence:** High | **Estimated Time:** 2 minutes

### Analysis
This issue occurs because Svelte's compiler optimizes #each blocks for efficient DOM updates by using keys to track identity of list items. Without a unique key, Svelte may inefficiently recreate DOM nodes on every re-render, leading to performance degradation in dynamic lists. In a Rust context (e.g., if this Svelte app interfaces with a Rust WASM backend for MIDI processing), poor frontend performance could bottleneck real-time audio constraints, as excessive DOM manipulations might cause jitter in lock-free audio threads. This relates to Rust's ownership model where efficient borrowing of list slices (&[T]) avoids unnecessary clones, mirroring the need for stable item identities here.

### Fix Steps
1. Locate the #each block around line 408 in VelocityEditorWindow.svelte.
2. Add the key directive to the #each statement, using a unique property like item.id.
3. Ensure all items in the iterated array have a stable, unique id to prevent reordering issues.

### Code Example
```rust
// BEFORE:
{#each items as item}
  <div>{item.name}</div>
{/each}

// AFTER:
{#each items as item (item.id)}
  <div>{item.name}</div>
{/each}
```

---

## Issue #2: Performance - Missing key in #each block in VelocityEditorWindow.svelte

**Confidence:** High | **Estimated Time:** 2 minutes

### Analysis
Similar to Issue #1, the absence of a key in this #each block at line 576 causes Svelte to lose track of item identities, resulting in costly DOM diffing and potential re-renders of the entire list. In Rust terms, this is akin to iterating over a Vec<T> without stable references, leading to unnecessary moves or clones instead of borrows, which could amplify performance issues in a MIDI app where the frontend polls Rust for real-time updates, violating no-allocation hot path principles.

### Fix Steps
1. Find the #each block near line 576.
2. Insert the key using the unique identifier, e.g., item.id.
3. Test the component to ensure keys remain stable across updates.

### Code Example
```rust
// BEFORE:
{#each items as item}
  <div>{item.value}</div>
{/each}

// AFTER:
{#each items as item (item.id)}
  <div>{item.value}</div>
{/each}
```

---

## Issue #3: Performance - Large Svelte component in SettingsWindow.svelte

**Confidence:** High | **Estimated Time:** 30-60 minutes

### Analysis
Svelte components exceeding 300 lines become hard to maintain and may suffer from slower compilation and runtime due to monolithic reactive scopes. This violates Rust's trait design principles of composition over inheritance, where large structs are split into smaller, focused ones with clear ownership boundaries. In a Rust+Svelte MIDI app, a bloated component could lead to excessive JS bundle size, impacting WASM interop performance and potentially causing GC pauses that disrupt real-time audio processing.

### Fix Steps
1. Identify logical sections in SettingsWindow.svelte (e.g., tabs, forms, lists).
2. Extract each section into a new .svelte component file.
3. Import and compose the sub-components in the parent, passing props as needed.
4. Update any reactive statements or stores to be local to sub-components where possible.

### Code Example
```rust
// BEFORE:
<!-- In SettingsWindow.svelte, line ~1-1225 -->
<script>
  let settings = [...]; // large script with all logic
</script>

<main>
  <!-- All UI: tabs, forms, etc. -->
  <div>Tab 1 content...</div>
  <div>Tab 2 content...</div>
</main>

<!-- AFTER: Extract to SubComponent.svelte -->
<!-- SubComponent.svelte -->
<script>
  export let data;
</script>

<div>{data.content}</div>

<!-- In SettingsWindow.svelte -->
<script>
  import SubComponent from './SubComponent.svelte';
  let settings = [...]; // reduced script
</script>

<main>
  <SubComponent data={tab1Data} />
  <SubComponent data={tab2Data} />
</main>
```

---

## Issue #4: Performance - Missing key in #each block in SettingsWindow.svelte

**Confidence:** High | **Estimated Time:** 2 minutes

### Analysis
Without a key in the #each at line 513, Svelte performs inefficient updates by treating the list as unordered, similar to Rust's slice iteration without indices, which might lead to O(n^2) comparisons instead of O(n). For a settings window in a MIDI app, this could slow down UI responsiveness when updating device lists from a Rust backend, potentially interfering with async MIDI event handling in tokio.

### Fix Steps
1. Navigate to line 513 in SettingsWindow.svelte.
2. Add the key directive with a unique item property.
3. Confirm uniqueness by checking the data source.

### Code Example
```rust
// BEFORE:
{#each devices as device}
  <option>{device.name}</option>
{/each}

// AFTER:
{#each devices as device (device.id)}
  <option>{device.name}</option>
{/each}
```

---

## Issue #5: Performance - Missing key in #each block in SettingsWindow.svelte

**Confidence:** High | **Estimated Time:** 2 minutes

### Analysis
The missing key at line 916 leads to suboptimal reconciliation in Svelte's virtual DOM, akin to Rust's lack of HashMap keys causing linear searches instead of O(1) lookups. In real-time MIDI contexts, this inefficiency in a settings list could compound with Rust's lock-free data structures, leading to UI lag that desynchronizes with backend audio streams.

### Fix Steps
1. Go to the #each block at line 916.
2. Append the key using item.id or equivalent unique field.
3. Validate that keys don't change unnecessarily on re-renders.

### Code Example
```rust
// BEFORE:
{#each presets as preset}
  <li>{preset.name}</li>
{/each}

// AFTER:
{#each presets as preset (preset.id)}
  <li>{preset.name}</li>
{/each}
```

---

## Issue #1: Performance - Missing key in #each block

**Confidence:** High | **Estimated Time:** 2 minutes

### Analysis
In Svelte, the #each block iterates over arrays to render lists. Without a unique 'key' directive, Svelte cannot efficiently track item identity during updates, leading to full re-renders of the list on changes. This degrades performance by causing unnecessary DOM manipulations and computations. The root cause ties to Svelte's reactivity system, where keys enable fine-grained updates similar to React's key prop, optimizing diffing algorithms.

### Fix Steps
1. Locate the #each block around line 1016 in SettingsWindow.svelte.
2. Identify the iterated items (e.g., {#each items as item}).
3. Add the key directive: {#each items as item (item.id)} or key={item.id} inside the block.
4. Ensure each item has a unique 'id' property; if not, use a stable unique identifier like index only as a last resort (not recommended for dynamic lists).

### Code Example
```rust
// BEFORE:
{#each items as item}
  <div>{item.name}</div>
{/each}

// AFTER:
{#each items as item (item.id)}
  <div>{item.name}</div>
{/each}
```

---

## Issue #2: Performance - Large Svelte component

**Confidence:** High | **Estimated Time:** 30-60 minutes

### Analysis
Svelte components exceeding ~300 lines become hard to maintain and can impact build times and runtime performance due to increased bundle size and complexity in the compiled JavaScript. The issue stems from Svelte's compilation model, where large templates lead to monolithic functions that are less optimizable by the JS engine, potentially causing slower initial renders and higher memory usage.

### Fix Steps
1. Review ExportWindow.svelte (884 lines) and identify logical sections (e.g., UI panels, forms, lists).
2. Extract reusable parts into new .svelte components (e.g., create ExportList.svelte for list sections, FormPanel.svelte for inputs).
3. Replace extracted sections with <Component props={data} on:event /> invocations.
4. Move related script logic (stores, event handlers) into the new components or shared stores.
5. Use Svelte's context API or props drilling for data sharing if needed.

### Code Example
```rust
// BEFORE:
<!-- In ExportWindow.svelte, lines 1-884 -->
<script>
  let largeState = {...};
  function handleAllEvents() { ... }
</script>

<main>
  <!-- 800+ lines of template with forms, lists, etc. -->
  <form>...</form>
  {#each items as item}
    <div>...</div>
  {/each}
  <!-- more UI -->
</main>

// AFTER:
<!-- In ExportWindow.svelte, reduced to ~200 lines -->
<script>
  import ExportForm from './ExportForm.svelte';
  import ExportList from './ExportList.svelte';
  let data = {...};
</script>

<main>
  <ExportForm {data} on:submit={handleSubmit} />
  <ExportList {data} on:select={handleSelect} />
  <!-- other high-level UI -->
</main>

<!-- New file: ExportForm.svelte -->
<script>
  export let data;
  export let onSubmit;
</script>

<form on:submit={onSubmit}>
  <!-- extracted form logic and template -->
</form>

<!-- New file: ExportList.svelte -->
<script>
  export let data;
  export let onSelect;
  $: items = data.items;
</script>

{#each items as item (item.id)}
  <div on:click={() => onSelect(item)}>{item.name}</div>
{/each}
```

---

## Issue #3: Performance - Missing key in #each block

**Confidence:** High | **Estimated Time:** 2 minutes

### Analysis
Similar to Issue #1, the absence of a 'key' in Svelte's #each directive prevents efficient reconciliation of list items during state updates. Svelte's compiler relies on keys for identity-based diffing, avoiding costly DOM recreations. Without it, mutations like insertions/deletions trigger re-renders of unaffected siblings, impacting performance in dynamic UIs.

### Fix Steps
1. Navigate to line 358 in ExportWindow.svelte and find the #each block.
2. Add the key directive using a unique item property.
3. Confirm the iterated array has stable unique identifiers.

### Code Example
```rust
// BEFORE:
{#each items as item}
  <option>{item.name}</option>
{/each}

// AFTER:
{#each items as item (item.id)}
  <option>{item.name}</option>
{/each}
```

---

## Issue #4: Performance - Missing key in #each block

**Confidence:** High | **Estimated Time:** 2 minutes

### Analysis
As with previous key issues, Svelte's list rendering optimization depends on explicit keys to track item stability. Missing keys lead to quadratic re-render complexity in worst cases, especially for large or frequently updated lists, due to the lack of a stable identity map in the virtual DOM diffing process.

### Fix Steps
1. Go to line 488 in ExportWindow.svelte.
2. Insert key={item.id} or use the parenthesized syntax in the #each.
3. Test the list for updates to ensure smooth animations/transitions if applicable.

### Code Example
```rust
// BEFORE:
{#each presets as preset}
  <div>{preset.title}</div>
{/each}

// AFTER:
{#each presets as preset (preset.id)}
  <div>{preset.title}</div>
{/each}
```

---

## Issue #5: Performance - Missing key in #each block

**Confidence:** High | **Estimated Time:** 2 minutes

### Analysis
The recurring pattern of missing keys in #each blocks highlights a common oversight in Svelte development. Without keys, Svelte falls back to index-based tracking, which fails for non-sequential changes (e.g., sorting, filtering), causing excessive updates and potential UI glitches. This is rooted in Svelte's declarative rendering model prioritizing efficiency via explicit hints.

### Fix Steps
1. Locate the #each at line 529 in ExportWindow.svelte.
2. Apply the key directive with a unique field.
3. Optionally, add {#key items} above the block if the entire list identity changes.

### Code Example
```rust
// BEFORE:
{#each files as file}
  <li>{file.name}</li>
{/each}

// AFTER:
{#each files as file (file.id)}
  <li>{file.name}</li>
{/each}
```

---

## Issue #1: Performance - Missing key in #each block (ExportWindow.svelte:635)

**Confidence:** High | **Estimated Time:** 2 minutes

### Analysis
Although this is a Svelte-specific issue, we can analogize to Rust's ownership model: without a unique key, Svelte's compiler cannot efficiently track item identity during reactivity updates, leading to full re-renders of the block (similar to unnecessary cloning or reallocation in Rust when ownership isn't properly scoped). This violates Svelte's diffing algorithm expectations, causing O(n) performance degradation instead of targeted updates. Reference: Svelte's reactivity system relies on stable identities, akin to Rust's borrow checker ensuring unique references via lifetimes.

### Fix Steps
1. Locate the {#each items} block around line 635 in ExportWindow.svelte.
2. Add the key directive to the iterated element, using a unique identifier like item.id.
3. Ensure item.id is stable and unique across renders to maintain efficient DOM reconciliation.

### Code Example
```rust
// BEFORE:
{#each items as item}
  <div>{item.name}</div>
{/each}

// AFTER:
{#each items as item (item.id)}
  <div key={item.id}>{item.name}</div>
{/each}
```

---

## Issue #2: Performance - Missing key in #each block (ExportWindow.svelte:821)

**Confidence:** High | **Estimated Time:** 2 minutes

### Analysis
Similar to Issue #1, the absence of a key in Svelte's #each directive prevents optimal virtual DOM diffing, forcing complete list re-renders on state changes. In Rust terms, this is like iterating over a Vec without using indices or references efficiently, leading to borrow checker overhead or unnecessary movesâ€”here, it impacts frontend performance in a potentially real-time MIDI app where smooth UI updates are critical to avoid blocking async Rust backends.

### Fix Steps
1. Navigate to line 821 in ExportWindow.svelte and identify the {#each} block.
2. Insert the key using the inline syntax (item.id) or explicit key={item.id} on child elements.
3. Test the component to ensure keys don't change unnecessarily, preserving Svelte's tracking.

### Code Example
```rust
// BEFORE:
{#each items as item}
  <option>{item.label}</option>
{/each}

// AFTER:
{#each items as item (item.id)}
  <option key={item.id}>{item.label}</option>
{/each}
```

---

## Issue #3: Performance - Large Svelte component (DatabaseWindow.svelte)

**Confidence:** High | **Estimated Time:** 30-45 minutes

### Analysis
A 558-line Svelte component exceeds maintainability thresholds, leading to slower compilation, debugging difficulties, and potential reactivity overheadâ€”analogous to a monolithic Rust module violating single-responsibility principle, where large functions hinder borrow checking and optimization passes. Svelte recommends <300 lines to keep components focused, improving tree-shaking and hot-reload performance, especially in apps with Rust FFI for MIDI data handling.

### Fix Steps
1. Review DatabaseWindow.svelte and identify logical sections (e.g., UI parts like tables, forms, modals).
2. Extract each section into a new .svelte component file, passing props for data and event handlers.
3. Update the parent component to compose the child components, using stores or props for shared state.
4. Consider Rust-side impacts if this component interfaces with async MIDI queriesâ€”ensure child components handle their own loading states.

### Code Example
```rust
// BEFORE:
<!-- In DatabaseWindow.svelte, lines 1-558 -->
<script>
  let data = [];
  // ... large script with multiple concerns
</script>

<main>
  <!-- Table section: 100+ lines -->
  {#each data as item}
    <!-- ... -->
  {/each}
  <!-- Form section: 200+ lines -->
  <form><!-- ... --></form>
  <!-- Modal section: 150+ lines -->
</main>

// AFTER:
<!-- In DatabaseWindow.svelte, now ~100 lines -->
<script>
  import DataTable from './DataTable.svelte';
  import EditForm from './EditForm.svelte';
  import Modal from './Modal.svelte';
  let data = [];
</script>

<main>
  <DataTable {data} on:edit={handleEdit} />
  <EditForm bind:data />
  <Modal />
</main>

<!-- New file: DataTable.svelte -->
<script>
  export let data;
  export let onEdit;
</script>

<table>
  {#each data as item (item.id)}
    <tr key={item.id}>
      <!-- Table logic here -->
    </tr>
  {/each}
</table>
```

---

## Issue #4: Performance - Missing key in #each block (DatabaseWindow.svelte:335)

**Confidence:** High | **Estimated Time:** 2 minutes

### Analysis
Without keys, Svelte treats the #each block as unordered, causing inefficient reconciliations during updatesâ€”mirroring Rust's Vec operations without stable indices, where insertions/deletions trigger full reallocations instead of splices. In a database window for MIDI software, this could lag UI when handling large datasets from Rust queries, impacting real-time constraints.

### Fix Steps
1. Open DatabaseWindow.svelte and go to line 335 for the {#each} block.
2. Add the key directive using a unique item property, preferably item.id.
3. If the component is refactored (per Issue #3), apply this in the relevant child component.

### Code Example
```rust
// BEFORE:
{#each databaseItems as item}
  <div class="item">{item.name}</div>
{/each}

// AFTER:
{#each databaseItems as item (item.id)}
  <div class="item" key={item.id}>{item.name}</div>
{/each}
```

---

## Issue #5: Performance - Missing key in #each block (DatabaseWindow.svelte:422)

**Confidence:** High | **Estimated Time:** 2 minutes

### Analysis
The missing key leads to suboptimal DOM diffing in Svelte, akin to Rust's lack of trait bounds for efficient iteration (e.g., no IntoIterator with stable refs), resulting in broader re-renders. For MIDI database ops, this inefficiency compounds with async data fetches from Rust, potentially causing UI jank in lock-free hot paths.

### Fix Steps
1. Locate line 422 in DatabaseWindow.svelte and examine the {#each} iteration.
2. Incorporate key={item.id} or the (item.id) syntax on the looped elements.
3. Validate uniqueness of keys, especially if data comes from dynamic Rust-generated lists.

### Code Example
```rust
// BEFORE:
{#each filteredItems as item}
  <li>{item.title}</li>
{/each}

// AFTER:
{#each filteredItems as item (item.id)}
  <li key={item.id}>{item.title}</li>
{/each}
```

---

## Issue #1: Performance - Missing key in #each block

**Confidence:** High | **Estimated Time:** 2 minutes

### Analysis
In Svelte, the #each block is used for iterating over arrays in templates. Without a unique key directive (e.g., key={item.id}), Svelte cannot efficiently track and update individual items during reactivity changes. This leads to unnecessary DOM diffing and re-renders of the entire list, degrading performance. The root cause is Svelte's reconciliation algorithm relying on stable keys for optimal virtual DOM updates, similar to how React uses keys. Not providing a key causes full list re-renders on mutations, increasing time complexity from O(1) updates to O(n) rebuilds.

### Fix Steps
1. Locate the #each block at line 466 in DatabaseWindow.svelte.
2. Identify the iterable (e.g., {#each items as item}).
3. Add the key directive: {#each items as item (item.id)} or {#each items as item, key={item.id}}.
4. Ensure item.id is unique and stable across renders; if no id exists, use index as fallback but prefer stable identifiers.

### Code Example
```rust
// BEFORE:
{#each items as item}
  <div>{item.name}</div>
{/each}

// AFTER:
{#each items as item (item.id)}
  <div>{item.name}</div>
{/each}
```

---

## Issue #2: Performance - Large Svelte component

**Confidence:** High | **Estimated Time:** 30-60 minutes

### Analysis
Svelte components exceeding 300 lines become hard to maintain and can lead to slower compilation and bundle sizes. The issue stems from monolithic code violating single responsibility principle, causing entangled logic, harder testing, and potential reactivity overhead from large script sections. In Svelte's compile-time framework, large templates increase parse time, and dense scripts can obscure data flow, indirectly affecting runtime performance through unoptimized re-renders.

### Fix Steps
1. Review FileDetailsWindow.svelte (1094 lines) and identify logical sections (e.g., UI parts like headers, lists, modals).
2. Extract reusable sections into new .svelte components (e.g., ItemList.svelte for #each blocks).
3. Move related script logic (stores, functions) into the child components or shared stores.
4. Use Svelte's <svelte:component> or props/events for communication between parent and children.
5. Aim for components under 300 lines; refactor iteratively.

### Code Example
```rust
// BEFORE:
<!-- In FileDetailsWindow.svelte, large template with multiple sections -->
<script>
  let largeState = {...};
  // 500+ lines of logic
</script>

<div>
  <!-- Header -->
  <!-- Long list #each -->
  <!-- Modal -->
  <!-- 800+ lines -->
</div>

// AFTER:
<!-- In FileDetailsWindow.svelte, refactored -->
<script>
  import ItemList from './ItemList.svelte';
  let items = [];
</script>

<div>
  <Header {data} />
  <ItemList {items} on:select={handleSelect} />
  <Modal {show} />
</div>

<!-- New ItemList.svelte -->
<script>
  export let items;
  // Logic for list
</script>

{#each items as item (item.id)}
  <div>{item.name}</div>
{/each}
```

---

## Issue #3: Performance - Missing key in #each block

**Confidence:** High | **Estimated Time:** 2 minutes

### Analysis
Similar to Issue #1, the absence of a key in Svelte's #each directive at line 297 prevents efficient DOM reconciliation. Svelte's runtime uses keys to minimize mutations; without them, array changes (add/remove/update) trigger full re-renders, leading to quadratic performance in dynamic lists. This is exacerbated in performance-sensitive apps like MIDI software where UI updates need to be snappy.

### Fix Steps
1. Find the #each block at line 297 in FileDetailsWindow.svelte.
2. Add key={item.id} or use the parenthesized syntax with a unique property.
3. Confirm the iterated items have stable, unique identifiers like id or uuid.

### Code Example
```rust
// BEFORE:
{#each items as item}
  <li>{item.title}</li>
{/each}

// AFTER:
{#each items as item (item.id)}
  <li>{item.title}</li>
{/each}
```

---

## Issue #4: Performance - Missing key in #each block

**Confidence:** High | **Estimated Time:** 2 minutes

### Analysis
As in previous key issues, lacking a key at line 524 causes Svelte to treat the list as unstable, resulting in inefficient updates. In contexts with frequent data changes (e.g., file details in MIDI software), this can lead to janky UI and higher CPU usage during reactivity.

### Fix Steps
1. Navigate to line 524 in FileDetailsWindow.svelte and locate the #each.
2. Insert the key directive using a unique item property.
3. Test for re-render efficiency post-fix.

### Code Example
```rust
// BEFORE:
{#each files as file}
  <div>{file.name}</div>
{/each}

// AFTER:
{#each files as file (file.id)}
  <div>{file.name}</div>
{/each}
```

---

## Issue #5: Performance - Missing key in #each block

**Confidence:** High | **Estimated Time:** 2 minutes

### Analysis
The missing key at line 562 follows the same pattern: Svelte's diffing algorithm falls back to index-based tracking, which fails on insertions/deletions, causing O(n) DOM operations instead of targeted updates. Critical for real-time interfaces where list stability affects perceived performance.

### Fix Steps
1. Go to line 562 in FileDetailsWindow.svelte.
2. Add the key using (item.id) syntax or key={item.id}.
3. Ensure consistency with other #each blocks in the file.

### Code Example
```rust
// BEFORE:
{#each tags as tag}
  <span>{tag}</span>
{/each}

// AFTER:
{#each tags as tag (tag.id)}
  <span>{tag}</span>
{/each}
```

---

## Issue #1: Performance - Missing key in #each block at line 607

**Confidence:** High | **Estimated Time:** 2 minutes

### Analysis
This issue occurs because Svelte's {#each} blocks rely on keys for efficient DOM diffing and updates. Without a unique key like item.id, Svelte treats the entire list as potentially reordered on every change, leading to unnecessary DOM manipulations, repaints, and degraded performance. In Rust terms, this is analogous to lacking unique identifiers in iterative data structures, causing inefficient traversals without stable references, similar to how missing lifetimes in loops can lead to repeated allocations.

### Fix Steps
1. Locate the {#each items} block around line 607 in FileDetailsWindow.svelte.
2. Add the key directive to the root element inside the {#each} block, using a unique property like item.id.
3. Ensure item.id is stable and unique across renders to avoid key collisions.

### Code Example
```rust
// BEFORE:
{#each items as item}
  <div>{item.name}</div>
{/each}

// AFTER:
{#each items as item (item.id)}
  <div>{item.name}</div>
{/each}
```

---

## Issue #2: Performance - Missing key in #each block at line 618

**Confidence:** High | **Estimated Time:** 2 minutes

### Analysis
Similar to issue #1, the absence of a key in this {#each} block causes Svelte to inefficiently update the DOM by assuming full list recreation. This mirrors Rust's ownership model where without stable borrows (like &'a T), repeated cloning or reallocation occurs in loops, impacting performance in hot paths like UI rendering.

### Fix Steps
1. Find the {#each items} block near line 618.
2. Insert the key using the parenthesized syntax with item.id.
3. Test the component to ensure keys don't change unnecessarily between renders.

### Code Example
```rust
// BEFORE:
{#each items as item}
  <li>{item.title}</li>
{/each}

// AFTER:
{#each items as item (item.id)}
  <li>{item.title}</li>
{/each}
```

---

## Issue #3: Performance - Missing key in #each block at line 745

**Confidence:** High | **Estimated Time:** 2 minutes

### Analysis
Svelte's compiler warns here because keyless {#each} blocks lead to quadratic-time updates in dynamic lists, akin to Rust's Vec operations without indices or references, where insertions/deletions without stable pointers cause full reallocations and copies, harming real-time performance like in audio/MIDI apps.

### Fix Steps
1. Navigate to line 745 in the file.
2. Add key={item.id} or the parenthesized form to the each block.
3. Consider profiling the component post-fix to measure DOM update improvements.

### Code Example
```rust
// BEFORE:
{#each features as feature}
  <span>{feature.desc}</span>
{/each}

// AFTER:
{#each features as feature (feature.id)}
  <span>{feature.desc}</span>
{/each}
```

---

## Issue #4: Performance - Missing key in #each block at line 929

**Confidence:** High | **Estimated Time:** 2 minutes

### Analysis
Without keys, Svelte cannot optimize list reconciliation, resulting in full re-renders that are costly for performance-critical UIs. In Rust analogy, this is like iterating over a collection without & references, forcing ownership transfers or clones each iteration, which would violate zero-allocation goals in hot paths.

### Fix Steps
1. Go to the {#each} block at line 929.
2. Apply the key directive using a unique identifier from the item.
3. Ensure the key is primitive (e.g., string or number) for optimal hashing.

### Code Example
```rust
// BEFORE:
{#each tags as tag}
  <button>{tag.name}</button>
{/each}

// AFTER:
{#each tags as tag (tag.id)}
  <button>{tag.name}</button>
{/each}
```

---

## Issue #5: Performance - Large Svelte component (708 lines)

**Confidence:** High | **Estimated Time:** 1-2 hours

### Analysis
Large components like this violate Svelte's single-responsibility principle, leading to slower compilation, harder maintenance, and potential reactivity overhead from entangled state. Comparable to Rust's macro hygiene issues in large proc-macros or monolithic traits without generics, where lack of modularity causes bloat and error-prone code without clear ownership boundaries.

### Fix Steps
1. Identify logical sections in MIDIDeviceWindow.svelte (e.g., header, body, footer, or feature groups).
2. Extract each section into a new .svelte component (e.g., DeviceHeader.svelte, PropertyList.svelte).
3. Replace inline code with <Component props={data} /> invocations, passing necessary props and handling events.
4. Use stores or context for shared state to avoid prop drilling.
5. Refactor iteratively, testing after each split to maintain functionality.

### Code Example
```rust
// BEFORE:
<script>
  // 708 lines of script + markup
</script>

<main>
  <!-- Massive inline markup -->
  {#each devices as device}
    <div>{device.info}</div>
  {/each}
  <!-- More sections -->
</main>

// AFTER:
<script>
  import DeviceHeader from './DeviceHeader.svelte';
  import DeviceList from './DeviceList.svelte';
  // Reduced script
</script>

<main>
  <DeviceHeader {title} />
  <DeviceList {devices} on:select={handleSelect} />
  <!-- Other sub-components -->
</main>
```

---

## Issue #1: Performance - Missing key in #each block at line 295

**Confidence:** High | **Estimated Time:** 2 minutes

### Analysis
In Svelte, the #each block iterates over arrays to render lists. Without a unique key directive, Svelte cannot efficiently track item identity during updates, leading to full re-renders of the list instead of targeted DOM diffing. This causes performance degradation, especially with dynamic lists like MIDI devices, as it violates Svelte's reconciliation algorithm which relies on stable keys for optimal virtual DOM updates. Similar to how Rust's ownership model ensures unique identifiers for borrow checking, keys provide identity in reactive UIs to prevent unnecessary computations.

### Fix Steps
1. Locate the #each block starting around line 295 in MIDIDeviceWindow.svelte.
2. Add the key directive using a unique property like item.id, assuming items have an 'id' field.
3. Ensure the key is stable and unique across renders to enable efficient diffing.

### Code Example
```rust
// BEFORE:
{#each items as item}
  <div>{item.name}</div>
{/each}

// AFTER:
{#each items as item (item.id)}
  <div>{item.name}</div>
{/each}
```

---

## Issue #2: Performance - Missing key in #each block at line 357

**Confidence:** High | **Estimated Time:** 2 minutes

### Analysis
Svelte's #each directive without keys hinders the framework's ability to perform fine-grained DOM updates, resulting in O(n) re-renders for list changes. This is inefficient for real-time MIDI device lists where items may add/remove frequently. Analogous to Rust's borrow checker requiring explicit lifetimes for safe concurrent access, keys enforce item identity to optimize reactivity without full list rebuilds.

### Fix Steps
1. Find the #each block near line 357.
2. Insert the key using (item.id) syntax, ensuring 'id' is unique.
3. Test the list updates to confirm smoother performance.

### Code Example
```rust
// BEFORE:
{#each items as item}
  <li>{item.name}</li>
{/each}

// AFTER:
{#each items as item (item.id)}
  <li>{item.name}</li>
{/each}
```

---

## Issue #3: Performance - Missing key in #each block at line 493

**Confidence:** High | **Estimated Time:** 2 minutes

### Analysis
The absence of keys in Svelte #each blocks leads to suboptimal diffing algorithms, causing excessive DOM manipulations and potential jank in UI updates. For MIDI software, where device lists need low-latency rendering, this can impact user experience. This mirrors Rust's emphasis on zero-cost abstractions; keys allow Svelte to abstract away inefficient updates, much like traits bound efficient implementations.

### Fix Steps
1. Navigate to line 493 in the Svelte file.
2. Add the key directive with a unique item property.
3. Optionally, use key={item.id} if the parenthetical syntax conflicts.

### Code Example
```rust
// BEFORE:
{#each devices as device}
  <option>{device.name}</option>
{/each}

// AFTER:
{#each devices as device (device.id)}
  <option>{device.name}</option>
{/each}
```

---

## Issue #4: Performance - Missing key in #each block at line 518

**Confidence:** High | **Estimated Time:** 2 minutes

### Analysis
Svelte relies on keys for identity-based reconciliation in #each loops, preventing unnecessary re-renders when lists change. Without them, the entire block re-mounts, increasing CPU usageâ€”critical for performance-sensitive apps like MIDI interfaces. Comparable to Rust's Drop trait ensuring resource cleanup, keys ensure UI resources (DOM nodes) are updated precisely without waste.

### Fix Steps
1. Inspect the #each block at line 518.
2. Append the key using the item's unique identifier.
3. Validate by simulating list changes (e.g., add/remove items).

### Code Example
```rust
// BEFORE:
{#each ports as port}
  <div class="port">{port.name}</div>
{/each}

// AFTER:
{#each ports as port (port.id)}
  <div class="port">{port.name}</div>
{/each}
```

---

## Issue #5: Performance - Missing key in #each block at line 563

**Confidence:** High | **Estimated Time:** 2 minutes

### Analysis
Missing keys force Svelte to treat the #each block as a single unit for updates, leading to quadratic performance in list mutations. In a MIDI context with real-time constraints, this could cause UI lag. Like Rust's ownership semantics preventing aliasing, keys provide unambiguous item tracking for efficient, lock-free-like UI updates.

### Fix Steps
1. Go to line 563 and locate the #each iteration.
2. Add the key directive with item.id.
3. Consider profiling the component before/after to measure improvement.

### Code Example
```rust
// BEFORE:
{#each connections as connection}
  <span>{connection.status}</span>
{/each}

// AFTER:
{#each connections as connection (connection.id)}
  <span>{connection.status}</span>
{/each}
```

---

## Issue #1: Performance - Missing key in #each block

**Confidence:** High | **Estimated Time:** 2 minutes

### Analysis
This issue appears in a Svelte component (.svelte file), not Rust code. Rust's type system and ownership model do not directly apply here, as Svelte uses JavaScript-like templating for UI rendering. The missing key in an {#each} block can lead to inefficient DOM diffing and re-renders, but this is a frontend performance concern unrelated to Rust concepts like lifetimes or borrowing. If this project integrates Rust via WASM (e.g., for MIDI processing), ensure any data passed to Svelte respects ownership transfer via wasm-bindgen, but the core issue is Svelte-specific.

### Fix Steps
1. Locate the {#each items as item} block around line 622 in MIDIDeviceWindow.svelte.
2. Add a key directive: {#each items as item (item.id)} or use key={item.id} if supported.
3. Ensure item.id is unique and stable across renders to optimize reconciliation.

### Code Example
```rust
// BEFORE:
{#each items as item}
  <div>{item.name}</div>
{/each}

// AFTER:
{#each items as item (item.id)}
  <div>{item.name}</div>
{/each}
```

---

## Issue #2: Performance - Large Svelte component

**Confidence:** High | **Estimated Time:** 30-60 minutes

### Analysis
This is a Svelte UI concern in PianoRollWindow.svelte, exceeding 300 lines, which can hinder maintainability and performance in rendering. Rust's ownership and borrowing rules don't apply directly, but if this component consumes data from a Rust crate (e.g., for piano roll MIDI rendering with real-time constraints), large components might amplify issues like unnecessary clones or borrows in data pipelines. Split to improve modularity, akin to Rust's preference for small, focused modules.

### Fix Steps
1. Identify logical sections in PianoRollWindow.svelte (e.g., header, canvas, controls).
2. Extract each into sub-components (e.g., PianoRollCanvas.svelte, Controls.svelte).
3. Pass props from parent to children, ensuring minimal data copying.

### Code Example
```rust
// BEFORE:
<!-- Entire 400-line component in PianoRollWindow.svelte -->
<script>
  // All logic here
</script>

<!-- Huge template -->

// AFTER:
<!-- PianoRollWindow.svelte -->
<script>
  import PianoRollCanvas from './PianoRollCanvas.svelte';
  import Controls from './Controls.svelte';
  let notes = []; // props or state
</script>

<PianoRollCanvas {notes} />
<Controls {notes} />
```

---

## Issue #3: Safety - Dangerous: 'eval' usage detected (line 27)

**Confidence:** High | **Estimated Time:** 10 minutes

### Analysis
This issue is in a shell script (verify-fix.sh), not Rust. Eval in shell introduces security risks like code injection, unrelated to Rust's memory safety or ownership. However, if this script interacts with a Rust binary (e.g., building/verifying MIDI software), prefer safe alternatives to avoid runtime errors that could crash Rust processes via FFI or subprocess calls. Rust's Result types emphasize safe error propagation, mirroring the need for explicit handling here.

### Fix Steps
1. Replace eval at line 27 with an array or direct command execution.
2. If eval parses dynamic code, refactor to use case statements or functions.
3. Test the script to ensure no behavioral changes.

### Code Example
```rust
// BEFORE:
# Line 27
eval "$command"

// AFTER:
# Line 27
case "$command" in
  build) cargo build ;;  # Example for Rust project
  test) cargo test ;;
  *) echo "Unknown command" ;;
esac
```

---

## Issue #4: Documentation - Anti-pattern: Bare 'except:' catches all exceptions (line 249)

**Confidence:** High | **Estimated Time:** 5 minutes

### Analysis
This is a Python anti-pattern in ultra_supercharged_grok_reviewer.py, where bare except: swallows all errors, hiding bugs. Rust's error handling with Result and ? operator enforces explicit error types (e.g., via thiserror), preventing silent failures. If this Python script reviews or interacts with Rust code (e.g., linting MIDI project), broad catches could mask Rust compilation errors; adopt specific exceptions like Rust's trait bounds for errors.

### Fix Steps
1. At line 249, replace bare except: with except SpecificError: or at minimum except Exception as e: and log e.
2. Identify expected exceptions from context (e.g., ValueError for parsing).
3. Add logging or re-raise for unexpected errors.

### Code Example
```rust
// BEFORE:
# Line 249
try:
    # some code
except:
    pass

// AFTER:
# Line 249
try:
    # some code
except ValueError as e:
    print(f"ValueError: {e}")
except Exception as e:
    raise  # Or log and re-raise
```

---

## Issue #5: Documentation - Anti-pattern: Bare 'except:' catches all exceptions (line 266)

**Confidence:** High | **Estimated Time:** 5 minutes

### Analysis
Similar to Issue #4, this Python bare except: at line 266 violates best practices by masking errors. In a Rust context, this contrasts with anyhow or thiserror for typed errors, ensuring failures are handled explicitly. For a MIDI software reviewer script, this could hide issues in Rust FFI or async MIDI event handling; specific catches promote safer integration.

### Fix Steps
1. At line 266, specify the exception type based on surrounding code.
2. Use except Exception as e: if unsure, but log the error.
3. Refactor for granularity if multiple error types are possible.

### Code Example
```rust
// BEFORE:
# Line 266
try:
    # some code
except:
    continue

// AFTER:
# Line 266
try:
    # some code
except ValueError as e:
    logger.warning(f"ValueError: {e}")
    continue
except Exception as e:
    logger.error(f"Unexpected: {e}")
    raise
```

---

## Issue #1: Documentation - Anti-pattern: Bare 'except:' catches all exceptions (line 358)

**Confidence:** High | **Estimated Time:** 2 minutes

### Analysis
This is a Python issue, not Rust-specific. In Python's exception handling system, a bare 'except:' clause catches all exceptions indiscriminately, which masks bugs and unexpected errors. Unlike Rust's Result/Option types that force explicit error handling via the type system, Python relies on runtime checks, making broad catches an anti-pattern that violates error transparency principles similar to Rust's ownership model enforcing safety at compile time.

### Fix Steps
1. Identify the expected exception type from the surrounding code (e.g., ValueError for parsing issues).
2. Replace 'except:' with 'except ValueError:' or 'except Exception as e:' for logging.
3. Add logging or re-raising for unhandled cases to maintain error visibility.

### Code Example
```rust
// BEFORE:
try:
    some_operation()
except:
    pass

// AFTER:
try:
    some_operation()
except ValueError as e:
    logger.error(f"ValueError: {e}")
    # Handle specifically or re-raise
```

---

## Issue #2: Documentation - Anti-pattern: Bare 'except:' catches all exceptions (line 370)

**Confidence:** High | **Estimated Time:** 2 minutes

### Analysis
Similar to Issue #1, this Python bare 'except:' violates best practices by suppressing all errors, contrasting with Rust's compile-time enforcement of error paths via traits like Error. Python's dynamic typing allows this but leads to silent failures, akin to ignoring Rust's borrow checker warnings.

### Fix Steps
1. Examine the try block to determine likely exceptions (e.g., KeyError for dict access).
2. Specify the exception type in the except clause.
3. Optionally, use a catch-all 'except Exception:' only for final logging before re-raising.

### Code Example
```rust
// BEFORE:
try:
    data = dict_value['key']
except:
    data = default

// AFTER:
try:
    data = dict_value['key']
except KeyError:
    data = default
except Exception as e:
    logger.warning(f"Unexpected error: {e}")
    raise
```

---

## Issue #3: Build - SQL syntax error: Failed to parse SQL

**Confidence:** Medium | **Estimated Time:** 10 minutes

### Analysis
This is an SQL syntax issue in a .sql file, unrelated to Rust but potentially loaded via Rust's sqlx or diesel crates. SQL parsers enforce strict grammar (like Rust's type system), and errors at line 1 often stem from missing semicolons, invalid keywords, or encoding issues. In a Rust context, this would fail at query compilation time if using compile-time checked queries.

### Fix Steps
1. Open the file and inspect line 1 for common issues: unclosed quotes, missing keywords (e.g., 'CREATE' vs 'CREAT'), or BOM characters.
2. Validate the full SQL using a tool like sqlite3 or pg_dump.
3. If integrated with Rust, use sqlx::query! macro to catch errors at compile time post-fix.

### Code Example
```rust
// BEFORE:
-- Invalid: Missing semicolon or keyword
CREATE TABLE test (id INT

// AFTER:
-- Fixed: Proper syntax with semicolon
CREATE TABLE test (
    id INTEGER PRIMARY KEY
);
```

---

## Issue #4: Build - SQL syntax error: Failed to parse SQL

**Confidence:** Medium | **Estimated Time:** 10 minutes

### Analysis
Analogous to Issue #3, this SQL parse failure at line 1 indicates a syntax violation in the parser's grammar rules. In Rust applications using embedded SQL, this mirrors lifetime mismatches where early errors propagate; fix ensures type-safe query execution.

### Fix Steps
1. Check line 1 for syntax: ensure statements end with ';', no reserved word misuse.
2. Test the SQL in an isolated database session.
3. If Rust-involved, embed as a string literal and use anyhow::Result for runtime parsing if not compile-checked.

### Code Example
```rust
// BEFORE:
-- Invalid: Typo in keyword
INSERT INTO users VALUES (1, 'name'

// AFTER:
-- Fixed: Complete statement
INSERT INTO users (id, name) VALUES (1, 'name');
```

---

## Issue #5: Build - SQL syntax error: Failed to parse SQL

**Confidence:** Medium | **Estimated Time:** 15 minutes

### Analysis
This critical SQL error in an optimization script likely from malformed DDL or DCL at line 1. Rust's FFI with SQL libs (e.g., rusqlite) would surface this as a runtime error, but compile-time tools like sqlx prevent it; root cause is parser rejection due to invalid tokens, similar to Rust's trait bound failures.

### Fix Steps
1. Review line 1: Common in RESTORE scripts are missing 'RESTORE DATABASE' params or path quotes.
2. Use SQL linter or database CLI to parse and fix.
3. In Rust context, wrap execution in a Result and log parse errors with thiserror.

### Code Example
```rust
// BEFORE:
-- Invalid: Incomplete RESTORE
RESTORE DATABASE db FROM 'backup.bak'

-- AFTER:
-- Fixed: Full syntax
RESTORE DATABASE db
FROM DISK = 'C:\backup.bak'
WITH REPLACE;

// Rust integration example:
// BEFORE:
// let result = conn.execute("RESTORE...", ()); // Fails at runtime

// AFTER:
use anyhow::Result;

fn restore_db(conn: &rusqlite::Connection, path: &str) -> Result<()> {
    conn.execute(
        "RESTORE DATABASE db FROM ? WITH REPLACE;",
        (path,),
    )?;
    Ok(())
}
```

---

## Issue #1: Build - SQL syntax error: Failed to parse SQL in add_tagging_indexes.sql

**Confidence:** High | **Estimated Time:** 10 minutes

### Analysis
This build failure occurs because the Rust project's database migration system (likely Diesel or sqlx) embeds or validates SQL files during compilation or build time. Rust's type system ensures safety at compile-time, but when integrating external SQL via macros or build scripts (e.g., Diesel's `embed_migrations!`), invalid SQL syntax triggers a parse error, halting the build. The error at line 1 suggests a fundamental syntax issue, such as missing semicolons, unclosed quotes, or invalid keywords, violating SQL's context-free grammar parsed by the underlying SQLite/PostgreSQL parser integrated into the Rust crate.

### Fix Steps
1. Inspect the SQL file at line 1 for common syntax errors: ensure statements end with semicolons, quotes are properly closed, and keywords are correctly spelled.
2. Validate the SQL using a tool like `sqlfmt` or the database CLI (e.g., `sqlite3` or `psql`) before rebuilding.
3. If using Diesel, run `diesel migration run` post-fix to verify; for sqlx, use `cargo sqlx prepare` to re-validate embedded queries.

### Code Example
```rust
// BEFORE:
CREATE INDEX idx_tags ON software_tags (tag_name  -- Missing closing parenthesis and semicolon

// AFTER:
CREATE INDEX idx_tags ON software_tags (tag_name);
```

---

## Issue #2: Build - SQL syntax error: Failed to parse SQL in ULTRA_FAST_CONFIG.sql

**Confidence:** High | **Estimated Time:** 10 minutes

### Analysis
Similar to Issue #1, this is a compile-time validation failure in the Rust build pipeline where SQL files are parsed for correctness. Rust's ownership model doesn't directly apply, but the integration via procedural macros (e.g., sqlx's `query!` or Diesel migrations) enforces SQL validity to prevent runtime panics from `Result` unwrapping in query execution. Line 1 error indicates a top-level syntax flaw, possibly an invalid pragma, missing CREATE TABLE structure, or encoding issue, breaking the parser's expectation of well-formed DDL.

### Fix Steps
1. Open the file and check line 1 for syntax: verify PRAGMA statements (common in SQLite configs) are correctly formatted, e.g., no trailing commas or unquoted identifiers.
2. Test the SQL snippet in isolation with the target database engine to isolate the parse error.
3. Rebuild the Rust project after correction to confirm the build passes, ensuring no lifetime or borrowing issues in query execution code are masked.

### Code Example
```rust
// BEFORE:
PRAGMA journal_mode = WAL,  -- Invalid trailing comma in PRAGMA

// AFTER:
PRAGMA journal_mode = WAL;
```

---

## Issue #3: Performance - Possible N+1 query pattern in organize_by_instruments.sql

**Confidence:** High | **Estimated Time:** 20 minutes

### Analysis
In the context of a Rust application using an ORM like Diesel or raw SQL with sqlx, an N+1 query pattern arises from looping over results and issuing individual queries per iteration, leading to O(N) database roundtrips. Rust's ownership semantics exacerbate this if queries return owned `Vec`s that are iterated with `for` loops, consuming resources without reuse. This violates performance best practices by not leveraging SQL's set-based operations, potentially causing high latency in async contexts (e.g., Tokio runtime) where I/O awaits compound.

### Fix Steps
1. Replace the loop at line 190 with a single JOIN query to fetch related data in one go, using LEFT JOIN or INNER JOIN based on cardinality.
2. In Rust code executing this SQL, ensure the query returns a `Vec` of structs with borrowed references where possible to avoid unnecessary cloning.
3. Profile the query with `EXPLAIN ANALYZE` in the DB and use batching if JOINs are too wide; consider async batching in Rust with `futures::join_all` if needed.

### Code Example
```rust
// BEFORE:
-- Line 190: Loop example
SELECT * FROM instruments;
-- Then in Rust: for instrument in instruments { query_tags(instrument.id); }

-- AFTER:
SELECT i.*, t.tag FROM instruments i
LEFT JOIN tags t ON i.id = t.instrument_id;
```

---

## Issue #4: Performance - SELECT * fetches all columns in organize_by_instruments.sql

**Confidence:** High | **Estimated Time:** 5 minutes

### Analysis
Using `SELECT *` in SQL executed from Rust pulls unnecessary columns into memory, bloating data transfer and deserialization overhead. Rust's type system, via derive macros like `#[derive(Deserialize)]` or Diesel's query DSL, expects specific fields, but `*` can lead to partial matches or extra allocations for unused `String` or `Vec` fields. This ignores zero-copy principles, forcing ownership transfers and clones, especially harmful in performance-critical paths like real-time MIDI processing where cache misses degrade throughput.

### Fix Steps
1. At line 387, identify required columns from the Rust struct (e.g., id, name, config) and explicitly list them in SELECT.
2. Use `as` aliases if column names differ from Rust field names to ensure seamless mapping.
3. In Rust, leverage `&str` slices for string columns to avoid `to_owned()` calls during parsing.

### Code Example
```rust
// BEFORE:
-- Line 387
SELECT * FROM configurations;

-- AFTER:
-- Line 387
SELECT id, name, value FROM configurations;
```

---

## Issue #5: Performance - SELECT * fetches all columns in organize_by_instruments.sql

**Confidence:** High | **Estimated Time:** 5 minutes

### Analysis
Analogous to Issue #4, `SELECT *` at line 408 incurs bandwidth and CPU waste by fetching extraneous data, conflicting with Rust's emphasis on minimal ownership transfers and borrow checker-enforced efficiency. In async Rust contexts, this amplifies await overhead; for MIDI software, unnecessary columns (e.g., timestamps) could cause jitter in real-time loops if deserialized into owned types without `as_ref()` optimization.

### Fix Steps
1. Explicitly select only needed columns at line 408, based on the query's purpose (e.g., instrument_id, type, metadata).
2. If this query is parameterized in Rust, use turbofish `::<(Type1, Type2)>` for precise tuple deserialization.
3. Benchmark before/after with Rust's criterion crate to quantify I/O reduction.

### Code Example
```rust
// BEFORE:
-- Line 408
SELECT * FROM instruments WHERE active = true;

-- AFTER:
-- Line 408
SELECT id, type, name FROM instruments WHERE active = true;
```

---

## Issue #1: Safety - Security: String concatenation in SQL may enable injection (line 166)

**Confidence:** High | **Estimated Time:** 15 minutes

### Analysis
This issue arises because the SQL query in the .sql file or its execution in Rust code uses string concatenation to build dynamic queries, bypassing Rust's type safety. In Rust's ownership model, strings like String or &str are concatenated without sanitization, allowing untrusted input to inject malicious SQL. This violates memory safety principles indirectly, as it can lead to runtime data corruption or unauthorized access. Reference: Rust's str/String types do not inherently escape SQL metacharacters, requiring explicit parameterization to enforce trait bounds like Borrow<str> safely in database APIs (e.g., sqlx::Query).

### Fix Steps
1. Identify the dynamic parts of the SQL query at line 166 (e.g., instrument names or IDs being concatenated).
2. Refactor the SQL to use placeholders like $1, $2 for parameters.
3. In the Rust code executing this query (likely using sqlx or diesel), bind parameters using methods like .bind(value) to prevent injection, ensuring ownership transfer or borrowing is handled correctly (e.g., via Into<String> or AsRef<str>).
4. If the .sql is a migration file, update it directly; if embedded in Rust, use the query! macro for compile-time verification.

### Code Example
```rust
// BEFORE:
let sql = format!("SELECT * FROM instruments WHERE name = '{}'", user_input);
let rows = conn.execute(sql.as_str(), ()).await?;

// AFTER:
use sqlx::PgConnection;
let rows = sqlx::query("SELECT * FROM instruments WHERE name = $1")
    .bind(&user_input)
    .fetch_all(&mut conn).await?;
```

---

## Issue #2: Build - SQL syntax error: Failed to parse SQL

**Confidence:** Medium | **Estimated Time:** 10 minutes

### Analysis
The SQL syntax error at line 1 of the .sql file indicates invalid SQL structure, which Rust's database crates (e.g., sqlx) will fail to parse at compile-time or runtime if using query macros. This stems from Rust's emphasis on type safety and early error detection; mismatched syntax violates the expected Query trait bounds, leading to Result<_, sqlx::Error> failures. Without proper SQL, Rust's ownership of query strings cannot be safely transferred to the database executor.

### Fix Steps
1. Examine line 1 of organize_by_instruments_enhanced.sql for common issues like missing semicolons, unbalanced quotes, or invalid keywords.
2. Validate the entire SQL file using a tool like psql or sqlx's offline mode.
3. Correct the syntax (e.g., ensure proper CREATE TABLE or INSERT statements).
4. In Rust integration, use sqlx::migrate!() if this is a migration, ensuring the file is parsed correctly.

### Code Example
```rust
// BEFORE (embedded SQL example):
// Invalid: let sql = "CREATE TABLE instruments (id INT, name TEXT);  // missing closing quote or syntax
sqlx::query(sql).execute(&mut conn).await?;

// AFTER:
// Fixed SQL: let sql = "CREATE TABLE instruments (id SERIAL PRIMARY KEY, name TEXT NOT NULL);";
sqlx::query(sql).execute(&mut conn).await?;
// Or use sqlx::migrate!("src/database/migrations") for file-based migrations.
```

---

## Issue #3: Performance - Performance: SELECT * fetches all columns (line 533)

**Confidence:** High | **Estimated Time:** 5 minutes

### Analysis
Using SELECT * retrieves all columns unnecessarily, leading to excess data transfer and memory allocation in Rust. This conflicts with Rust's zero-copy and performance-oriented design, as deserializing unused fields into structs wastes bandwidth and CPU (e.g., via SIMD-unfriendly parsing). It ignores cache-friendly data structures by pulling irrelevant data, potentially violating ownership semantics when mapping to Vec<Row> or custom types without explicit trait bounds like Selectable.

### Fix Steps
1. Identify the required columns for the query at line 533 (e.g., only id, name, type for instruments).
2. Replace SELECT * with explicit column names to minimize data fetch.
3. In Rust, define a struct with only needed fields and use sqlx::FromRow for type-safe mapping, avoiding full Row ownership transfer.
4. Consider indexing on selected columns for further perf gains.

### Code Example
```rust
// BEFORE:
let rows = sqlx::query("SELECT * FROM instruments WHERE type = $1")
    .bind(&instrument_type)
    .fetch_all(&mut conn).await?;

// AFTER:
#[derive(sqlx::FromRow)]
struct Instrument { id: i32, name: String, instrument_type: String }

let rows: Vec<Instrument> = sqlx::query_as("SELECT id, name, type FROM instruments WHERE type = $1")
    .bind(&instrument_type)
    .fetch_all(&mut conn).await?;
```

---

## Issue #4: Safety - Security: String concatenation in SQL may enable injection (line 527)

**Confidence:** High | **Estimated Time:** 10 minutes

### Analysis
Similar to issue #1, string concatenation at line 527 exposes the application to SQL injection, undermining Rust's memory safety guarantees. User-controlled data concatenated into &str or String bypasses the type system, allowing arbitrary code execution. This is exacerbated in async contexts (e.g., tokio), where borrowed references might outlive their scope, but the core issue is lack of parameterization enforcing safe borrowing via AsRef<[u8]> in query builders.

### Fix Steps
1. Locate the concatenated values at line 527 (e.g., dynamic WHERE clauses).
2. Convert to parameterized form with $1 placeholders.
3. In Rust execution code, use bind() to safely transfer ownership or borrow inputs, preferring ? combinators for error propagation.
4. Scan for similar patterns elsewhere in the file.

### Code Example
```rust
// BEFORE:
let sql = format!("UPDATE instruments SET active = {} WHERE id = {}", active, id);
conn.execute(sql.as_str(), ()).await?;

// AFTER:
use sqlx::Row;
let result = sqlx::query("UPDATE instruments SET active = $1 WHERE id = $2")
    .bind(active)
    .bind(id)
    .execute(&mut conn).await?;
```

---

## Issue #5: Safety - Security: String concatenation in SQL may enable injection (line 528)

**Confidence:** High | **Estimated Time:** 10 minutes

### Analysis
This consecutive issue at line 528 mirrors #1 and #4, indicating a pattern of unsafe query building via concatenation. Rust's ownership model allows easy str manipulation, but without parameterization, it fails to prevent injection attacks, potentially leading to lifetime mismatches if borrowed user input escapes incorrectly. Relates to trait design in DB crates, where Query::bind requires safe, owned or borrowed inputs without metacharacter interpretation.

### Fix Steps
1. Check line 528 for concatenated elements, likely continuing from line 527.
2. Parameterize the query similarly, using multiple $n placeholders.
3. Refactor Rust code to bind all parameters at once, using into() for type coercion if needed.
4. Consider wrapping in a custom error type with thiserror for domain-specific safety.

### Code Example
```rust
// BEFORE:
let sql = format!("UPDATE instruments SET name = '{}' WHERE id = {}", new_name, id);
conn.execute(sql.as_str(), ()).await?;

// AFTER:
#[derive(thiserror::Error, Debug)]
#[error("Database update failed")]
struct UpdateError;

let result = sqlx::query("UPDATE instruments SET name = $1 WHERE id = $2")
    .bind(&new_name)
    .bind(id)
    .execute(&mut conn).await
    .map_err(|e| anyhow::anyhow!("{}", e))?;
```

---

## Issue #1: Security: String concatenation in SQL may enable injection (line 529)

**Confidence:** Medium | **Estimated Time:** Variable

### Analysis
AI Analysis (text format):
[
  {
    "issue_id": 1,
    "issue_title": "Safety - Security: String concatenation in SQL may enable injection (line 529)",
    "analysis": "This issue arises because the SQL script uses string concatenation (likely via SQL's || operator or implicit embedding) to build dynamic queries, which bypasses Rust's type safety when the script is executed via a Rust database library like rusqlite or sqlx. In Rust's ownership model, strings are owned and immutable by default, but concatenating user-controlled input into SQL strings can introduce injection vulnerabilities, similar to how unchecked borrowing can lead to dangling references. Rust encourages safe APIs (e.g., prepared statements) to enforce bounds checking at the type level, preventing runtime errors like SQL injection that would be caught at compile time if using a query builder like diesel.",
    "fix_steps": [
      "Identify the concatenation at line 529 in organize_by_instruments_enhanced.sql, e.g., something like SELECT * FROM instruments WHERE name = '" || $name || "'.",
      "Replace with parameterized placeholders using $1, $2, etc., assuming PostgreSQL-style params.",
      "In the Rust code executing this SQL (likely via sqlx::query or similar), bind parameters using .bind(value) to ensure type-safe escaping, leveraging Rust's Result types for error handling.",
      "Add imports in Rust: use sqlx::PgConnection; and handle errors with ? or anyhow::Result."
    ],
    "code_example": "// BEFORE (in SQL file):\nSELECT * FROM instruments WHERE name = '" || user_input || "' AND type = 'keyboard';\n\n// AFTER (in SQL file):\nSELECT * FROM instruments WHERE name = $1 AND type = $2;\n\n// In Rust code executing it:\n// BEFORE:\nlet sql = format!(\"SELECT * FROM instruments WHERE name = '{}' AND type = '{}'\", user_name, instr_type);\nlet rows = conn.execute(sql.as_str(), ()).await?;\n\n// AFTER:\nuse sqlx::Row;\nlet rows = sqlx::query(\"SELECT * FROM instruments WHERE name = $1 AND type = $2\")\n    .bind(&user_name)\n    .bind(&instr_type)\n    .fetch_all(&mut conn).await?;",
    "confidence": "High",
    "estimated_time": "15 minutes",
    "related_changes": "This fix requires updating the Rust code that runs this SQL script to pass parameters instead of raw strings; may need to refactor query execution sites."
  },
  {
    "issue_id": 2,
    "issue_title": "Build - SQL syntax error: Failed to parse SQL",
    "analysis": "The SQL syntax error at line 1 of insert_sample_data.sql indicates malformed SQL that fails parsing when executed from Rust, likely due to missing semicolons, unbalanced quotes, or invalid keywords. In Rust's context, database libraries like sqlx perform static query analysis at compile time (if using query! macros), enforcing syntax correctness akin to the type system's trait bounds. This error surfaces because raw SQL strings don't benefit from Rust's compile-time checks, leading to runtime panics instead of early detection.",
    "fix_steps": [
      "Inspect line 1 for common issues: missing commas in INSERT, unclosed strings, or reserved word misuse.",
      "Validate the entire script using a SQL linter or tool like sqlfmt.",
      "If embedded in Rust, wrap in sqlx::query! macro for compile-time verification.",
      "Test execution in Rust with proper error handling using thiserror for custom DB errors."
    ],
    "code_example": "// BEFORE (in SQL file, hypothetical syntax error):\nINSERT INTO samples (name, path) VALUES ('sample1', /path/to/audio.wav);\n\n// AFTER (in SQL file):\nINSERT INTO samples (name, path) VALUES ('sample1', '/path/to/audio.wav');\n\n// In Rust code:\n// BEFORE:\nlet result = conn.execute(\"INSERT INTO samples ...\", ()).await;\n\n// AFTER:\nuse sqlx::query;\nlet result = query!(\n    r#\"INSERT INTO samples (name, path) VALUES ($1, $2)\"#,\n    \"sample1\",\n    \"/path/to/audio.wav\"\n).execute(&mut conn).await?;",
    "confidence": "Medium",
    "estimated_time": "10 minutes",
    "related_changes": "Fix may reveal downstream errors in data insertion; ensure Rust schema matches updated SQL."
  },
  {
    "issue_id": 3,
    "issue_title": "Safety - Security: MD5/SHA1 are weak for password hashing (line 39)",
    "analysis": "Using MD5 or SHA1 in the SQL script (e.g., via SQL functions like MD5()) for password storage violates cryptographic best practices and Rust's emphasis on safe, modern APIs. Rust's standard library avoids weak hashes, pushing developers to crates like bcrypt or argon2rs, which integrate with the ownership model via secure memory handling (e.g., zeroing on Drop). Embedding weak hashing in SQL bypasses Rust's type-safe error handling, exposing the app to brute-force attacks, similar to using unsafe code without bounds checks.",
    "fix_steps": [
      "Remove hashing from SQL; perform it in Rust before inserting.",
      "Use argon2rs or bcrypt crate in Rust for secure hashing with salt and work factors.",
      "Store only the hash in the DB; use Result<_, CryptoError> for error propagation.",
      "Add to Cargo.toml: argon2 = '0.5'; and handle async if needed for real-time MIDI context."
    ],
    "code_example": "// BEFORE (in SQL file):\nINSERT INTO users (username, password) VALUES ('user', MD5('password123'));\n\n// AFTER (in SQL file, remove hash):\nINSERT INTO users (username, password_hash) VALUES ($1, $2);\n\n// In Rust code:\n// BEFORE:\n// (Assuming raw SQL execution with MD5)\n\n// AFTER:\nuse argon2::{self, Config};\nuse anyhow::Result;\n\nfn hash_password(password: &str) -> Result<String> {\n    let salt = b\"some_random_salt\";\n    let config = Config::default();\n    let hash = argon2::hash_encoded(password.as_bytes(), salt, &config)?;\n    Ok(hash)\n}\n\n// Usage:\nlet hashed = hash_password(\"password123\")?;\nlet _ = sqlx::query(\"INSERT INTO users (username, password_hash) VALUES ($1, $2)\")\n    .bind(\"user\")\n    .bind(&hashed)\n    .execute(&mut conn).await?;",
    "confidence": "High",
    "estimated_time": "20 minutes",
    "related_changes": "Requires updating all user registration/login Rust code to use the new hashing function; migrate existing DB passwords if in production."
  },
  {
    "issue_id": 4,
    "issue_title": "Safety - Security: String concatenation in SQL may enable injection (line 163)",
    "analysis": "Similar to issue #1, concatenation at line 163 in insert_sample_data.sql creates injection risks when executed from Rust, undermining the language's memory safety guarantees. Rust's borrow checker prevents data races, but dynamic SQL building evades this by treating queries as owned Strings without parameterization, akin to raw pointers in unsafe blocks. Proper use of &str slices and query builders ensures lifetimes align with safe execution.",
    "fix_steps": [
      "Locate concatenation at line 163, e.g., INSERT with embedded values.",
      "Convert to placeholders $1, etc.",
      "In Rust executor, use bind() for safe injection prevention, preferring Cow<str> for zero-copy if inputs are borrowed.",
      "Handle errors with anyhow for chained failures."
    ],
    "code_example": "// BEFORE (in SQL file):\nINSERT INTO instruments (name, category) VALUES ('piano' || $var, 'keyboard');\n\n// AFTER (in SQL file):\nINSERT INTO instruments (name, category) VALUES ($1, $2);\n\n// In Rust code:\n// BEFORE:\nlet sql = format!(\"INSERT INTO instruments (name, category) VALUES ('{}', '{}')\", name, cat);\nconn.execute(sql.as_str(), ()).await?;\n\n// AFTER:\nuse std::borrow::Cow;\nlet name_borrow: Cow<str> = name.as_str().into();\nlet _ = sqlx::query(\"INSERT INTO instruments (name, category) VALUES ($1, $2)\")\n    .bind(&name_borrow)\n    .bind(&cat)\n    .execute(&mut conn).await?;",
    "confidence": "High",
    "estimated_time": "10 minutes",
    "related_changes": "Update Rust insertion logic; test for performance in hot paths if this is called frequently in MIDI processing."
  },
  {
    "issue_id": 5,
    "issue_title": "Build - SQL syntax error: Failed to parse SQL",
    "analysis": "A syntax error at line 1 of INDEX_BACKUP.sql prevents parsing during Rust DB initialization or migration, as libraries like sqlx expect valid SQL strings. This mirrors Rust's compile-time syntax enforcement; invalid SQL leads to runtime errors instead of type-checked failures. Likely causes include backup artifacts like incomplete CREATE INDEX statements or encoding issues, not leveraging Rust's string validation.",
    "fix_steps": [
      "Examine line 1 for syntax: check for missing parentheses in INDEX creation or trailing commas.",
      "Clean up backup file; ensure it's valid SQL.",
      "If loaded in Rust, use sqlx::migrate! macro for compile-time checks.",
      "Add logging with tracing crate for better error diagnostics."
    ],
    "code_example": "// BEFORE (in SQL file, hypothetical):\nCREATE INDEX idx_samples_path ON samples (path;\n\n// AFTER (in SQL file):\nCREATE INDEX idx_samples_path ON samples (path);\n\n// In Rust code:\n// BEFORE:\ninclude_str!(\"INDEX_BACKUP.sql\"); // Raw include may fail at runtime\n\n// AFTER:\n// Use sqlx migrations or:\nsqlx::query(include_str!(\"INDEX_BACKUP.sql\"))\n    .execute(&mut conn).await\n    .map_err(|e| anyhow::anyhow!(\"SQL parse error: {}\", e))?;",
    "confidence": "Medium",
    "estimated_time": "5 minutes",
    "related_changes": "This may affect DB migration scripts in Rust; verify indexes post-fix with EXPLAIN queries."
  }
]

### Fix Steps
1. Review the AI analysis above

---

## Issue #2: SQL syntax error: Failed to parse SQL

**Confidence:** Medium | **Estimated Time:** Variable

### Analysis
AI Analysis (text format):
[
  {
    "issue_id": 1,
    "issue_title": "Safety - Security: String concatenation in SQL may enable injection (line 529)",
    "analysis": "This issue arises because the SQL script uses string concatenation (likely via SQL's || operator or implicit embedding) to build dynamic queries, which bypasses Rust's type safety when the script is executed via a Rust database library like rusqlite or sqlx. In Rust's ownership model, strings are owned and immutable by default, but concatenating user-controlled input into SQL strings can introduce injection vulnerabilities, similar to how unchecked borrowing can lead to dangling references. Rust encourages safe APIs (e.g., prepared statements) to enforce bounds checking at the type level, preventing runtime errors like SQL injection that would be caught at compile time if using a query builder like diesel.",
    "fix_steps": [
      "Identify the concatenation at line 529 in organize_by_instruments_enhanced.sql, e.g., something like SELECT * FROM instruments WHERE name = '" || $name || "'.",
      "Replace with parameterized placeholders using $1, $2, etc., assuming PostgreSQL-style params.",
      "In the Rust code executing this SQL (likely via sqlx::query or similar), bind parameters using .bind(value) to ensure type-safe escaping, leveraging Rust's Result types for error handling.",
      "Add imports in Rust: use sqlx::PgConnection; and handle errors with ? or anyhow::Result."
    ],
    "code_example": "// BEFORE (in SQL file):\nSELECT * FROM instruments WHERE name = '" || user_input || "' AND type = 'keyboard';\n\n// AFTER (in SQL file):\nSELECT * FROM instruments WHERE name = $1 AND type = $2;\n\n// In Rust code executing it:\n// BEFORE:\nlet sql = format!(\"SELECT * FROM instruments WHERE name = '{}' AND type = '{}'\", user_name, instr_type);\nlet rows = conn.execute(sql.as_str(), ()).await?;\n\n// AFTER:\nuse sqlx::Row;\nlet rows = sqlx::query(\"SELECT * FROM instruments WHERE name = $1 AND type = $2\")\n    .bind(&user_name)\n    .bind(&instr_type)\n    .fetch_all(&mut conn).await?;",
    "confidence": "High",
    "estimated_time": "15 minutes",
    "related_changes": "This fix requires updating the Rust code that runs this SQL script to pass parameters instead of raw strings; may need to refactor query execution sites."
  },
  {
    "issue_id": 2,
    "issue_title": "Build - SQL syntax error: Failed to parse SQL",
    "analysis": "The SQL syntax error at line 1 of insert_sample_data.sql indicates malformed SQL that fails parsing when executed from Rust, likely due to missing semicolons, unbalanced quotes, or invalid keywords. In Rust's context, database libraries like sqlx perform static query analysis at compile time (if using query! macros), enforcing syntax correctness akin to the type system's trait bounds. This error surfaces because raw SQL strings don't benefit from Rust's compile-time checks, leading to runtime panics instead of early detection.",
    "fix_steps": [
      "Inspect line 1 for common issues: missing commas in INSERT, unclosed strings, or reserved word misuse.",
      "Validate the entire script using a SQL linter or tool like sqlfmt.",
      "If embedded in Rust, wrap in sqlx::query! macro for compile-time verification.",
      "Test execution in Rust with proper error handling using thiserror for custom DB errors."
    ],
    "code_example": "// BEFORE (in SQL file, hypothetical syntax error):\nINSERT INTO samples (name, path) VALUES ('sample1', /path/to/audio.wav);\n\n// AFTER (in SQL file):\nINSERT INTO samples (name, path) VALUES ('sample1', '/path/to/audio.wav');\n\n// In Rust code:\n// BEFORE:\nlet result = conn.execute(\"INSERT INTO samples ...\", ()).await;\n\n// AFTER:\nuse sqlx::query;\nlet result = query!(\n    r#\"INSERT INTO samples (name, path) VALUES ($1, $2)\"#,\n    \"sample1\",\n    \"/path/to/audio.wav\"\n).execute(&mut conn).await?;",
    "confidence": "Medium",
    "estimated_time": "10 minutes",
    "related_changes": "Fix may reveal downstream errors in data insertion; ensure Rust schema matches updated SQL."
  },
  {
    "issue_id": 3,
    "issue_title": "Safety - Security: MD5/SHA1 are weak for password hashing (line 39)",
    "analysis": "Using MD5 or SHA1 in the SQL script (e.g., via SQL functions like MD5()) for password storage violates cryptographic best practices and Rust's emphasis on safe, modern APIs. Rust's standard library avoids weak hashes, pushing developers to crates like bcrypt or argon2rs, which integrate with the ownership model via secure memory handling (e.g., zeroing on Drop). Embedding weak hashing in SQL bypasses Rust's type-safe error handling, exposing the app to brute-force attacks, similar to using unsafe code without bounds checks.",
    "fix_steps": [
      "Remove hashing from SQL; perform it in Rust before inserting.",
      "Use argon2rs or bcrypt crate in Rust for secure hashing with salt and work factors.",
      "Store only the hash in the DB; use Result<_, CryptoError> for error propagation.",
      "Add to Cargo.toml: argon2 = '0.5'; and handle async if needed for real-time MIDI context."
    ],
    "code_example": "// BEFORE (in SQL file):\nINSERT INTO users (username, password) VALUES ('user', MD5('password123'));\n\n// AFTER (in SQL file, remove hash):\nINSERT INTO users (username, password_hash) VALUES ($1, $2);\n\n// In Rust code:\n// BEFORE:\n// (Assuming raw SQL execution with MD5)\n\n// AFTER:\nuse argon2::{self, Config};\nuse anyhow::Result;\n\nfn hash_password(password: &str) -> Result<String> {\n    let salt = b\"some_random_salt\";\n    let config = Config::default();\n    let hash = argon2::hash_encoded(password.as_bytes(), salt, &config)?;\n    Ok(hash)\n}\n\n// Usage:\nlet hashed = hash_password(\"password123\")?;\nlet _ = sqlx::query(\"INSERT INTO users (username, password_hash) VALUES ($1, $2)\")\n    .bind(\"user\")\n    .bind(&hashed)\n    .execute(&mut conn).await?;",
    "confidence": "High",
    "estimated_time": "20 minutes",
    "related_changes": "Requires updating all user registration/login Rust code to use the new hashing function; migrate existing DB passwords if in production."
  },
  {
    "issue_id": 4,
    "issue_title": "Safety - Security: String concatenation in SQL may enable injection (line 163)",
    "analysis": "Similar to issue #1, concatenation at line 163 in insert_sample_data.sql creates injection risks when executed from Rust, undermining the language's memory safety guarantees. Rust's borrow checker prevents data races, but dynamic SQL building evades this by treating queries as owned Strings without parameterization, akin to raw pointers in unsafe blocks. Proper use of &str slices and query builders ensures lifetimes align with safe execution.",
    "fix_steps": [
      "Locate concatenation at line 163, e.g., INSERT with embedded values.",
      "Convert to placeholders $1, etc.",
      "In Rust executor, use bind() for safe injection prevention, preferring Cow<str> for zero-copy if inputs are borrowed.",
      "Handle errors with anyhow for chained failures."
    ],
    "code_example": "// BEFORE (in SQL file):\nINSERT INTO instruments (name, category) VALUES ('piano' || $var, 'keyboard');\n\n// AFTER (in SQL file):\nINSERT INTO instruments (name, category) VALUES ($1, $2);\n\n// In Rust code:\n// BEFORE:\nlet sql = format!(\"INSERT INTO instruments (name, category) VALUES ('{}', '{}')\", name, cat);\nconn.execute(sql.as_str(), ()).await?;\n\n// AFTER:\nuse std::borrow::Cow;\nlet name_borrow: Cow<str> = name.as_str().into();\nlet _ = sqlx::query(\"INSERT INTO instruments (name, category) VALUES ($1, $2)\")\n    .bind(&name_borrow)\n    .bind(&cat)\n    .execute(&mut conn).await?;",
    "confidence": "High",
    "estimated_time": "10 minutes",
    "related_changes": "Update Rust insertion logic; test for performance in hot paths if this is called frequently in MIDI processing."
  },
  {
    "issue_id": 5,
    "issue_title": "Build - SQL syntax error: Failed to parse SQL",
    "analysis": "A syntax error at line 1 of INDEX_BACKUP.sql prevents parsing during Rust DB initialization or migration, as libraries like sqlx expect valid SQL strings. This mirrors Rust's compile-time syntax enforcement; invalid SQL leads to runtime errors instead of type-checked failures. Likely causes include backup artifacts like incomplete CREATE INDEX statements or encoding issues, not leveraging Rust's string validation.",
    "fix_steps": [
      "Examine line 1 for syntax: check for missing parentheses in INDEX creation or trailing commas.",
      "Clean up backup file; ensure it's valid SQL.",
      "If loaded in Rust, use sqlx::migrate! macro for compile-time checks.",
      "Add logging with tracing crate for better error diagnostics."
    ],
    "code_example": "// BEFORE (in SQL file, hypothetical):\nCREATE INDEX idx_samples_path ON samples (path;\n\n// AFTER (in SQL file):\nCREATE INDEX idx_samples_path ON samples (path);\n\n// In Rust code:\n// BEFORE:\ninclude_str!(\"INDEX_BACKUP.sql\"); // Raw include may fail at runtime\n\n// AFTER:\n// Use sqlx migrations or:\nsqlx::query(include_str!(\"INDEX_BACKUP.sql\"))\n    .execute(&mut conn).await\n    .map_err(|e| anyhow::anyhow!(\"SQL parse error: {}\", e))?;",
    "confidence": "Medium",
    "estimated_time": "5 minutes",
    "related_changes": "This may affect DB migration scripts in Rust; verify indexes post-fix with EXPLAIN queries."
  }
]

### Fix Steps
1. Review the AI analysis above

---

## Issue #3: Security: MD5/SHA1 are weak for password hashing (line 39)

**Confidence:** Medium | **Estimated Time:** Variable

### Analysis
AI Analysis (text format):
[
  {
    "issue_id": 1,
    "issue_title": "Safety - Security: String concatenation in SQL may enable injection (line 529)",
    "analysis": "This issue arises because the SQL script uses string concatenation (likely via SQL's || operator or implicit embedding) to build dynamic queries, which bypasses Rust's type safety when the script is executed via a Rust database library like rusqlite or sqlx. In Rust's ownership model, strings are owned and immutable by default, but concatenating user-controlled input into SQL strings can introduce injection vulnerabilities, similar to how unchecked borrowing can lead to dangling references. Rust encourages safe APIs (e.g., prepared statements) to enforce bounds checking at the type level, preventing runtime errors like SQL injection that would be caught at compile time if using a query builder like diesel.",
    "fix_steps": [
      "Identify the concatenation at line 529 in organize_by_instruments_enhanced.sql, e.g., something like SELECT * FROM instruments WHERE name = '" || $name || "'.",
      "Replace with parameterized placeholders using $1, $2, etc., assuming PostgreSQL-style params.",
      "In the Rust code executing this SQL (likely via sqlx::query or similar), bind parameters using .bind(value) to ensure type-safe escaping, leveraging Rust's Result types for error handling.",
      "Add imports in Rust: use sqlx::PgConnection; and handle errors with ? or anyhow::Result."
    ],
    "code_example": "// BEFORE (in SQL file):\nSELECT * FROM instruments WHERE name = '" || user_input || "' AND type = 'keyboard';\n\n// AFTER (in SQL file):\nSELECT * FROM instruments WHERE name = $1 AND type = $2;\n\n// In Rust code executing it:\n// BEFORE:\nlet sql = format!(\"SELECT * FROM instruments WHERE name = '{}' AND type = '{}'\", user_name, instr_type);\nlet rows = conn.execute(sql.as_str(), ()).await?;\n\n// AFTER:\nuse sqlx::Row;\nlet rows = sqlx::query(\"SELECT * FROM instruments WHERE name = $1 AND type = $2\")\n    .bind(&user_name)\n    .bind(&instr_type)\n    .fetch_all(&mut conn).await?;",
    "confidence": "High",
    "estimated_time": "15 minutes",
    "related_changes": "This fix requires updating the Rust code that runs this SQL script to pass parameters instead of raw strings; may need to refactor query execution sites."
  },
  {
    "issue_id": 2,
    "issue_title": "Build - SQL syntax error: Failed to parse SQL",
    "analysis": "The SQL syntax error at line 1 of insert_sample_data.sql indicates malformed SQL that fails parsing when executed from Rust, likely due to missing semicolons, unbalanced quotes, or invalid keywords. In Rust's context, database libraries like sqlx perform static query analysis at compile time (if using query! macros), enforcing syntax correctness akin to the type system's trait bounds. This error surfaces because raw SQL strings don't benefit from Rust's compile-time checks, leading to runtime panics instead of early detection.",
    "fix_steps": [
      "Inspect line 1 for common issues: missing commas in INSERT, unclosed strings, or reserved word misuse.",
      "Validate the entire script using a SQL linter or tool like sqlfmt.",
      "If embedded in Rust, wrap in sqlx::query! macro for compile-time verification.",
      "Test execution in Rust with proper error handling using thiserror for custom DB errors."
    ],
    "code_example": "// BEFORE (in SQL file, hypothetical syntax error):\nINSERT INTO samples (name, path) VALUES ('sample1', /path/to/audio.wav);\n\n// AFTER (in SQL file):\nINSERT INTO samples (name, path) VALUES ('sample1', '/path/to/audio.wav');\n\n// In Rust code:\n// BEFORE:\nlet result = conn.execute(\"INSERT INTO samples ...\", ()).await;\n\n// AFTER:\nuse sqlx::query;\nlet result = query!(\n    r#\"INSERT INTO samples (name, path) VALUES ($1, $2)\"#,\n    \"sample1\",\n    \"/path/to/audio.wav\"\n).execute(&mut conn).await?;",
    "confidence": "Medium",
    "estimated_time": "10 minutes",
    "related_changes": "Fix may reveal downstream errors in data insertion; ensure Rust schema matches updated SQL."
  },
  {
    "issue_id": 3,
    "issue_title": "Safety - Security: MD5/SHA1 are weak for password hashing (line 39)",
    "analysis": "Using MD5 or SHA1 in the SQL script (e.g., via SQL functions like MD5()) for password storage violates cryptographic best practices and Rust's emphasis on safe, modern APIs. Rust's standard library avoids weak hashes, pushing developers to crates like bcrypt or argon2rs, which integrate with the ownership model via secure memory handling (e.g., zeroing on Drop). Embedding weak hashing in SQL bypasses Rust's type-safe error handling, exposing the app to brute-force attacks, similar to using unsafe code without bounds checks.",
    "fix_steps": [
      "Remove hashing from SQL; perform it in Rust before inserting.",
      "Use argon2rs or bcrypt crate in Rust for secure hashing with salt and work factors.",
      "Store only the hash in the DB; use Result<_, CryptoError> for error propagation.",
      "Add to Cargo.toml: argon2 = '0.5'; and handle async if needed for real-time MIDI context."
    ],
    "code_example": "// BEFORE (in SQL file):\nINSERT INTO users (username, password) VALUES ('user', MD5('password123'));\n\n// AFTER (in SQL file, remove hash):\nINSERT INTO users (username, password_hash) VALUES ($1, $2);\n\n// In Rust code:\n// BEFORE:\n// (Assuming raw SQL execution with MD5)\n\n// AFTER:\nuse argon2::{self, Config};\nuse anyhow::Result;\n\nfn hash_password(password: &str) -> Result<String> {\n    let salt = b\"some_random_salt\";\n    let config = Config::default();\n    let hash = argon2::hash_encoded(password.as_bytes(), salt, &config)?;\n    Ok(hash)\n}\n\n// Usage:\nlet hashed = hash_password(\"password123\")?;\nlet _ = sqlx::query(\"INSERT INTO users (username, password_hash) VALUES ($1, $2)\")\n    .bind(\"user\")\n    .bind(&hashed)\n    .execute(&mut conn).await?;",
    "confidence": "High",
    "estimated_time": "20 minutes",
    "related_changes": "Requires updating all user registration/login Rust code to use the new hashing function; migrate existing DB passwords if in production."
  },
  {
    "issue_id": 4,
    "issue_title": "Safety - Security: String concatenation in SQL may enable injection (line 163)",
    "analysis": "Similar to issue #1, concatenation at line 163 in insert_sample_data.sql creates injection risks when executed from Rust, undermining the language's memory safety guarantees. Rust's borrow checker prevents data races, but dynamic SQL building evades this by treating queries as owned Strings without parameterization, akin to raw pointers in unsafe blocks. Proper use of &str slices and query builders ensures lifetimes align with safe execution.",
    "fix_steps": [
      "Locate concatenation at line 163, e.g., INSERT with embedded values.",
      "Convert to placeholders $1, etc.",
      "In Rust executor, use bind() for safe injection prevention, preferring Cow<str> for zero-copy if inputs are borrowed.",
      "Handle errors with anyhow for chained failures."
    ],
    "code_example": "// BEFORE (in SQL file):\nINSERT INTO instruments (name, category) VALUES ('piano' || $var, 'keyboard');\n\n// AFTER (in SQL file):\nINSERT INTO instruments (name, category) VALUES ($1, $2);\n\n// In Rust code:\n// BEFORE:\nlet sql = format!(\"INSERT INTO instruments (name, category) VALUES ('{}', '{}')\", name, cat);\nconn.execute(sql.as_str(), ()).await?;\n\n// AFTER:\nuse std::borrow::Cow;\nlet name_borrow: Cow<str> = name.as_str().into();\nlet _ = sqlx::query(\"INSERT INTO instruments (name, category) VALUES ($1, $2)\")\n    .bind(&name_borrow)\n    .bind(&cat)\n    .execute(&mut conn).await?;",
    "confidence": "High",
    "estimated_time": "10 minutes",
    "related_changes": "Update Rust insertion logic; test for performance in hot paths if this is called frequently in MIDI processing."
  },
  {
    "issue_id": 5,
    "issue_title": "Build - SQL syntax error: Failed to parse SQL",
    "analysis": "A syntax error at line 1 of INDEX_BACKUP.sql prevents parsing during Rust DB initialization or migration, as libraries like sqlx expect valid SQL strings. This mirrors Rust's compile-time syntax enforcement; invalid SQL leads to runtime errors instead of type-checked failures. Likely causes include backup artifacts like incomplete CREATE INDEX statements or encoding issues, not leveraging Rust's string validation.",
    "fix_steps": [
      "Examine line 1 for syntax: check for missing parentheses in INDEX creation or trailing commas.",
      "Clean up backup file; ensure it's valid SQL.",
      "If loaded in Rust, use sqlx::migrate! macro for compile-time checks.",
      "Add logging with tracing crate for better error diagnostics."
    ],
    "code_example": "// BEFORE (in SQL file, hypothetical):\nCREATE INDEX idx_samples_path ON samples (path;\n\n// AFTER (in SQL file):\nCREATE INDEX idx_samples_path ON samples (path);\n\n// In Rust code:\n// BEFORE:\ninclude_str!(\"INDEX_BACKUP.sql\"); // Raw include may fail at runtime\n\n// AFTER:\n// Use sqlx migrations or:\nsqlx::query(include_str!(\"INDEX_BACKUP.sql\"))\n    .execute(&mut conn).await\n    .map_err(|e| anyhow::anyhow!(\"SQL parse error: {}\", e))?;",
    "confidence": "Medium",
    "estimated_time": "5 minutes",
    "related_changes": "This may affect DB migration scripts in Rust; verify indexes post-fix with EXPLAIN queries."
  }
]

### Fix Steps
1. Review the AI analysis above

---

## Issue #4: Security: String concatenation in SQL may enable injection (line 163)

**Confidence:** Medium | **Estimated Time:** Variable

### Analysis
AI Analysis (text format):
[
  {
    "issue_id": 1,
    "issue_title": "Safety - Security: String concatenation in SQL may enable injection (line 529)",
    "analysis": "This issue arises because the SQL script uses string concatenation (likely via SQL's || operator or implicit embedding) to build dynamic queries, which bypasses Rust's type safety when the script is executed via a Rust database library like rusqlite or sqlx. In Rust's ownership model, strings are owned and immutable by default, but concatenating user-controlled input into SQL strings can introduce injection vulnerabilities, similar to how unchecked borrowing can lead to dangling references. Rust encourages safe APIs (e.g., prepared statements) to enforce bounds checking at the type level, preventing runtime errors like SQL injection that would be caught at compile time if using a query builder like diesel.",
    "fix_steps": [
      "Identify the concatenation at line 529 in organize_by_instruments_enhanced.sql, e.g., something like SELECT * FROM instruments WHERE name = '" || $name || "'.",
      "Replace with parameterized placeholders using $1, $2, etc., assuming PostgreSQL-style params.",
      "In the Rust code executing this SQL (likely via sqlx::query or similar), bind parameters using .bind(value) to ensure type-safe escaping, leveraging Rust's Result types for error handling.",
      "Add imports in Rust: use sqlx::PgConnection; and handle errors with ? or anyhow::Result."
    ],
    "code_example": "// BEFORE (in SQL file):\nSELECT * FROM instruments WHERE name = '" || user_input || "' AND type = 'keyboard';\n\n// AFTER (in SQL file):\nSELECT * FROM instruments WHERE name = $1 AND type = $2;\n\n// In Rust code executing it:\n// BEFORE:\nlet sql = format!(\"SELECT * FROM instruments WHERE name = '{}' AND type = '{}'\", user_name, instr_type);\nlet rows = conn.execute(sql.as_str(), ()).await?;\n\n// AFTER:\nuse sqlx::Row;\nlet rows = sqlx::query(\"SELECT * FROM instruments WHERE name = $1 AND type = $2\")\n    .bind(&user_name)\n    .bind(&instr_type)\n    .fetch_all(&mut conn).await?;",
    "confidence": "High",
    "estimated_time": "15 minutes",
    "related_changes": "This fix requires updating the Rust code that runs this SQL script to pass parameters instead of raw strings; may need to refactor query execution sites."
  },
  {
    "issue_id": 2,
    "issue_title": "Build - SQL syntax error: Failed to parse SQL",
    "analysis": "The SQL syntax error at line 1 of insert_sample_data.sql indicates malformed SQL that fails parsing when executed from Rust, likely due to missing semicolons, unbalanced quotes, or invalid keywords. In Rust's context, database libraries like sqlx perform static query analysis at compile time (if using query! macros), enforcing syntax correctness akin to the type system's trait bounds. This error surfaces because raw SQL strings don't benefit from Rust's compile-time checks, leading to runtime panics instead of early detection.",
    "fix_steps": [
      "Inspect line 1 for common issues: missing commas in INSERT, unclosed strings, or reserved word misuse.",
      "Validate the entire script using a SQL linter or tool like sqlfmt.",
      "If embedded in Rust, wrap in sqlx::query! macro for compile-time verification.",
      "Test execution in Rust with proper error handling using thiserror for custom DB errors."
    ],
    "code_example": "// BEFORE (in SQL file, hypothetical syntax error):\nINSERT INTO samples (name, path) VALUES ('sample1', /path/to/audio.wav);\n\n// AFTER (in SQL file):\nINSERT INTO samples (name, path) VALUES ('sample1', '/path/to/audio.wav');\n\n// In Rust code:\n// BEFORE:\nlet result = conn.execute(\"INSERT INTO samples ...\", ()).await;\n\n// AFTER:\nuse sqlx::query;\nlet result = query!(\n    r#\"INSERT INTO samples (name, path) VALUES ($1, $2)\"#,\n    \"sample1\",\n    \"/path/to/audio.wav\"\n).execute(&mut conn).await?;",
    "confidence": "Medium",
    "estimated_time": "10 minutes",
    "related_changes": "Fix may reveal downstream errors in data insertion; ensure Rust schema matches updated SQL."
  },
  {
    "issue_id": 3,
    "issue_title": "Safety - Security: MD5/SHA1 are weak for password hashing (line 39)",
    "analysis": "Using MD5 or SHA1 in the SQL script (e.g., via SQL functions like MD5()) for password storage violates cryptographic best practices and Rust's emphasis on safe, modern APIs. Rust's standard library avoids weak hashes, pushing developers to crates like bcrypt or argon2rs, which integrate with the ownership model via secure memory handling (e.g., zeroing on Drop). Embedding weak hashing in SQL bypasses Rust's type-safe error handling, exposing the app to brute-force attacks, similar to using unsafe code without bounds checks.",
    "fix_steps": [
      "Remove hashing from SQL; perform it in Rust before inserting.",
      "Use argon2rs or bcrypt crate in Rust for secure hashing with salt and work factors.",
      "Store only the hash in the DB; use Result<_, CryptoError> for error propagation.",
      "Add to Cargo.toml: argon2 = '0.5'; and handle async if needed for real-time MIDI context."
    ],
    "code_example": "// BEFORE (in SQL file):\nINSERT INTO users (username, password) VALUES ('user', MD5('password123'));\n\n// AFTER (in SQL file, remove hash):\nINSERT INTO users (username, password_hash) VALUES ($1, $2);\n\n// In Rust code:\n// BEFORE:\n// (Assuming raw SQL execution with MD5)\n\n// AFTER:\nuse argon2::{self, Config};\nuse anyhow::Result;\n\nfn hash_password(password: &str) -> Result<String> {\n    let salt = b\"some_random_salt\";\n    let config = Config::default();\n    let hash = argon2::hash_encoded(password.as_bytes(), salt, &config)?;\n    Ok(hash)\n}\n\n// Usage:\nlet hashed = hash_password(\"password123\")?;\nlet _ = sqlx::query(\"INSERT INTO users (username, password_hash) VALUES ($1, $2)\")\n    .bind(\"user\")\n    .bind(&hashed)\n    .execute(&mut conn).await?;",
    "confidence": "High",
    "estimated_time": "20 minutes",
    "related_changes": "Requires updating all user registration/login Rust code to use the new hashing function; migrate existing DB passwords if in production."
  },
  {
    "issue_id": 4,
    "issue_title": "Safety - Security: String concatenation in SQL may enable injection (line 163)",
    "analysis": "Similar to issue #1, concatenation at line 163 in insert_sample_data.sql creates injection risks when executed from Rust, undermining the language's memory safety guarantees. Rust's borrow checker prevents data races, but dynamic SQL building evades this by treating queries as owned Strings without parameterization, akin to raw pointers in unsafe blocks. Proper use of &str slices and query builders ensures lifetimes align with safe execution.",
    "fix_steps": [
      "Locate concatenation at line 163, e.g., INSERT with embedded values.",
      "Convert to placeholders $1, etc.",
      "In Rust executor, use bind() for safe injection prevention, preferring Cow<str> for zero-copy if inputs are borrowed.",
      "Handle errors with anyhow for chained failures."
    ],
    "code_example": "// BEFORE (in SQL file):\nINSERT INTO instruments (name, category) VALUES ('piano' || $var, 'keyboard');\n\n// AFTER (in SQL file):\nINSERT INTO instruments (name, category) VALUES ($1, $2);\n\n// In Rust code:\n// BEFORE:\nlet sql = format!(\"INSERT INTO instruments (name, category) VALUES ('{}', '{}')\", name, cat);\nconn.execute(sql.as_str(), ()).await?;\n\n// AFTER:\nuse std::borrow::Cow;\nlet name_borrow: Cow<str> = name.as_str().into();\nlet _ = sqlx::query(\"INSERT INTO instruments (name, category) VALUES ($1, $2)\")\n    .bind(&name_borrow)\n    .bind(&cat)\n    .execute(&mut conn).await?;",
    "confidence": "High",
    "estimated_time": "10 minutes",
    "related_changes": "Update Rust insertion logic; test for performance in hot paths if this is called frequently in MIDI processing."
  },
  {
    "issue_id": 5,
    "issue_title": "Build - SQL syntax error: Failed to parse SQL",
    "analysis": "A syntax error at line 1 of INDEX_BACKUP.sql prevents parsing during Rust DB initialization or migration, as libraries like sqlx expect valid SQL strings. This mirrors Rust's compile-time syntax enforcement; invalid SQL leads to runtime errors instead of type-checked failures. Likely causes include backup artifacts like incomplete CREATE INDEX statements or encoding issues, not leveraging Rust's string validation.",
    "fix_steps": [
      "Examine line 1 for syntax: check for missing parentheses in INDEX creation or trailing commas.",
      "Clean up backup file; ensure it's valid SQL.",
      "If loaded in Rust, use sqlx::migrate! macro for compile-time checks.",
      "Add logging with tracing crate for better error diagnostics."
    ],
    "code_example": "// BEFORE (in SQL file, hypothetical):\nCREATE INDEX idx_samples_path ON samples (path;\n\n// AFTER (in SQL file):\nCREATE INDEX idx_samples_path ON samples (path);\n\n// In Rust code:\n// BEFORE:\ninclude_str!(\"INDEX_BACKUP.sql\"); // Raw include may fail at runtime\n\n// AFTER:\n// Use sqlx migrations or:\nsqlx::query(include_str!(\"INDEX_BACKUP.sql\"))\n    .execute(&mut conn).await\n    .map_err(|e| anyhow::anyhow!(\"SQL parse error: {}\", e))?;",
    "confidence": "Medium",
    "estimated_time": "5 minutes",
    "related_changes": "This may affect DB migration scripts in Rust; verify indexes post-fix with EXPLAIN queries."
  }
]

### Fix Steps
1. Review the AI analysis above

---

## Issue #5: SQL syntax error: Failed to parse SQL

**Confidence:** Medium | **Estimated Time:** Variable

### Analysis
AI Analysis (text format):
[
  {
    "issue_id": 1,
    "issue_title": "Safety - Security: String concatenation in SQL may enable injection (line 529)",
    "analysis": "This issue arises because the SQL script uses string concatenation (likely via SQL's || operator or implicit embedding) to build dynamic queries, which bypasses Rust's type safety when the script is executed via a Rust database library like rusqlite or sqlx. In Rust's ownership model, strings are owned and immutable by default, but concatenating user-controlled input into SQL strings can introduce injection vulnerabilities, similar to how unchecked borrowing can lead to dangling references. Rust encourages safe APIs (e.g., prepared statements) to enforce bounds checking at the type level, preventing runtime errors like SQL injection that would be caught at compile time if using a query builder like diesel.",
    "fix_steps": [
      "Identify the concatenation at line 529 in organize_by_instruments_enhanced.sql, e.g., something like SELECT * FROM instruments WHERE name = '" || $name || "'.",
      "Replace with parameterized placeholders using $1, $2, etc., assuming PostgreSQL-style params.",
      "In the Rust code executing this SQL (likely via sqlx::query or similar), bind parameters using .bind(value) to ensure type-safe escaping, leveraging Rust's Result types for error handling.",
      "Add imports in Rust: use sqlx::PgConnection; and handle errors with ? or anyhow::Result."
    ],
    "code_example": "// BEFORE (in SQL file):\nSELECT * FROM instruments WHERE name = '" || user_input || "' AND type = 'keyboard';\n\n// AFTER (in SQL file):\nSELECT * FROM instruments WHERE name = $1 AND type = $2;\n\n// In Rust code executing it:\n// BEFORE:\nlet sql = format!(\"SELECT * FROM instruments WHERE name = '{}' AND type = '{}'\", user_name, instr_type);\nlet rows = conn.execute(sql.as_str(), ()).await?;\n\n// AFTER:\nuse sqlx::Row;\nlet rows = sqlx::query(\"SELECT * FROM instruments WHERE name = $1 AND type = $2\")\n    .bind(&user_name)\n    .bind(&instr_type)\n    .fetch_all(&mut conn).await?;",
    "confidence": "High",
    "estimated_time": "15 minutes",
    "related_changes": "This fix requires updating the Rust code that runs this SQL script to pass parameters instead of raw strings; may need to refactor query execution sites."
  },
  {
    "issue_id": 2,
    "issue_title": "Build - SQL syntax error: Failed to parse SQL",
    "analysis": "The SQL syntax error at line 1 of insert_sample_data.sql indicates malformed SQL that fails parsing when executed from Rust, likely due to missing semicolons, unbalanced quotes, or invalid keywords. In Rust's context, database libraries like sqlx perform static query analysis at compile time (if using query! macros), enforcing syntax correctness akin to the type system's trait bounds. This error surfaces because raw SQL strings don't benefit from Rust's compile-time checks, leading to runtime panics instead of early detection.",
    "fix_steps": [
      "Inspect line 1 for common issues: missing commas in INSERT, unclosed strings, or reserved word misuse.",
      "Validate the entire script using a SQL linter or tool like sqlfmt.",
      "If embedded in Rust, wrap in sqlx::query! macro for compile-time verification.",
      "Test execution in Rust with proper error handling using thiserror for custom DB errors."
    ],
    "code_example": "// BEFORE (in SQL file, hypothetical syntax error):\nINSERT INTO samples (name, path) VALUES ('sample1', /path/to/audio.wav);\n\n// AFTER (in SQL file):\nINSERT INTO samples (name, path) VALUES ('sample1', '/path/to/audio.wav');\n\n// In Rust code:\n// BEFORE:\nlet result = conn.execute(\"INSERT INTO samples ...\", ()).await;\n\n// AFTER:\nuse sqlx::query;\nlet result = query!(\n    r#\"INSERT INTO samples (name, path) VALUES ($1, $2)\"#,\n    \"sample1\",\n    \"/path/to/audio.wav\"\n).execute(&mut conn).await?;",
    "confidence": "Medium",
    "estimated_time": "10 minutes",
    "related_changes": "Fix may reveal downstream errors in data insertion; ensure Rust schema matches updated SQL."
  },
  {
    "issue_id": 3,
    "issue_title": "Safety - Security: MD5/SHA1 are weak for password hashing (line 39)",
    "analysis": "Using MD5 or SHA1 in the SQL script (e.g., via SQL functions like MD5()) for password storage violates cryptographic best practices and Rust's emphasis on safe, modern APIs. Rust's standard library avoids weak hashes, pushing developers to crates like bcrypt or argon2rs, which integrate with the ownership model via secure memory handling (e.g., zeroing on Drop). Embedding weak hashing in SQL bypasses Rust's type-safe error handling, exposing the app to brute-force attacks, similar to using unsafe code without bounds checks.",
    "fix_steps": [
      "Remove hashing from SQL; perform it in Rust before inserting.",
      "Use argon2rs or bcrypt crate in Rust for secure hashing with salt and work factors.",
      "Store only the hash in the DB; use Result<_, CryptoError> for error propagation.",
      "Add to Cargo.toml: argon2 = '0.5'; and handle async if needed for real-time MIDI context."
    ],
    "code_example": "// BEFORE (in SQL file):\nINSERT INTO users (username, password) VALUES ('user', MD5('password123'));\n\n// AFTER (in SQL file, remove hash):\nINSERT INTO users (username, password_hash) VALUES ($1, $2);\n\n// In Rust code:\n// BEFORE:\n// (Assuming raw SQL execution with MD5)\n\n// AFTER:\nuse argon2::{self, Config};\nuse anyhow::Result;\n\nfn hash_password(password: &str) -> Result<String> {\n    let salt = b\"some_random_salt\";\n    let config = Config::default();\n    let hash = argon2::hash_encoded(password.as_bytes(), salt, &config)?;\n    Ok(hash)\n}\n\n// Usage:\nlet hashed = hash_password(\"password123\")?;\nlet _ = sqlx::query(\"INSERT INTO users (username, password_hash) VALUES ($1, $2)\")\n    .bind(\"user\")\n    .bind(&hashed)\n    .execute(&mut conn).await?;",
    "confidence": "High",
    "estimated_time": "20 minutes",
    "related_changes": "Requires updating all user registration/login Rust code to use the new hashing function; migrate existing DB passwords if in production."
  },
  {
    "issue_id": 4,
    "issue_title": "Safety - Security: String concatenation in SQL may enable injection (line 163)",
    "analysis": "Similar to issue #1, concatenation at line 163 in insert_sample_data.sql creates injection risks when executed from Rust, undermining the language's memory safety guarantees. Rust's borrow checker prevents data races, but dynamic SQL building evades this by treating queries as owned Strings without parameterization, akin to raw pointers in unsafe blocks. Proper use of &str slices and query builders ensures lifetimes align with safe execution.",
    "fix_steps": [
      "Locate concatenation at line 163, e.g., INSERT with embedded values.",
      "Convert to placeholders $1, etc.",
      "In Rust executor, use bind() for safe injection prevention, preferring Cow<str> for zero-copy if inputs are borrowed.",
      "Handle errors with anyhow for chained failures."
    ],
    "code_example": "// BEFORE (in SQL file):\nINSERT INTO instruments (name, category) VALUES ('piano' || $var, 'keyboard');\n\n// AFTER (in SQL file):\nINSERT INTO instruments (name, category) VALUES ($1, $2);\n\n// In Rust code:\n// BEFORE:\nlet sql = format!(\"INSERT INTO instruments (name, category) VALUES ('{}', '{}')\", name, cat);\nconn.execute(sql.as_str(), ()).await?;\n\n// AFTER:\nuse std::borrow::Cow;\nlet name_borrow: Cow<str> = name.as_str().into();\nlet _ = sqlx::query(\"INSERT INTO instruments (name, category) VALUES ($1, $2)\")\n    .bind(&name_borrow)\n    .bind(&cat)\n    .execute(&mut conn).await?;",
    "confidence": "High",
    "estimated_time": "10 minutes",
    "related_changes": "Update Rust insertion logic; test for performance in hot paths if this is called frequently in MIDI processing."
  },
  {
    "issue_id": 5,
    "issue_title": "Build - SQL syntax error: Failed to parse SQL",
    "analysis": "A syntax error at line 1 of INDEX_BACKUP.sql prevents parsing during Rust DB initialization or migration, as libraries like sqlx expect valid SQL strings. This mirrors Rust's compile-time syntax enforcement; invalid SQL leads to runtime errors instead of type-checked failures. Likely causes include backup artifacts like incomplete CREATE INDEX statements or encoding issues, not leveraging Rust's string validation.",
    "fix_steps": [
      "Examine line 1 for syntax: check for missing parentheses in INDEX creation or trailing commas.",
      "Clean up backup file; ensure it's valid SQL.",
      "If loaded in Rust, use sqlx::migrate! macro for compile-time checks.",
      "Add logging with tracing crate for better error diagnostics."
    ],
    "code_example": "// BEFORE (in SQL file, hypothetical):\nCREATE INDEX idx_samples_path ON samples (path;\n\n// AFTER (in SQL file):\nCREATE INDEX idx_samples_path ON samples (path);\n\n// In Rust code:\n// BEFORE:\ninclude_str!(\"INDEX_BACKUP.sql\"); // Raw include may fail at runtime\n\n// AFTER:\n// Use sqlx migrations or:\nsqlx::query(include_str!(\"INDEX_BACKUP.sql\"))\n    .execute(&mut conn).await\n    .map_err(|e| anyhow::anyhow!(\"SQL parse error: {}\", e))?;",
    "confidence": "Medium",
    "estimated_time": "5 minutes",
    "related_changes": "This may affect DB migration scripts in Rust; verify indexes post-fix with EXPLAIN queries."
  }
]

### Fix Steps
1. Review the AI analysis above

---

## Issue #1: SQL syntax error in 012_daw_features_rollback.sql

**Confidence:** Medium | **Estimated Time:** 5 minutes

### Analysis
This build failure occurs because the Rust project likely uses a database migration tool like sqlx with compile-time query verification (via the sqlx::migrate! macro) or Diesel with embedded migrations. These tools parse SQL files at compile time to ensure type safety and correctness, integrating with Rust's type system. An invalid SQL syntax on line 1 violates the parser's expectations, causing the Rust compiler to error out as if it were a type mismatch or invalid trait boundâ€”preventing the binary from building. This enforces memory safety indirectly by catching data integrity issues early, but it's not a Rust ownership or lifetime issue; it's an API design choice in the migration crate to fail fast.

### Fix Steps
1. Open the file /home/dojevou/projects/midi-software-center/database/rollbacks/012_daw_features_rollback.sql.
2. Inspect line 1 for common SQL syntax errors such as missing semicolons, unquoted identifiers, invalid keywords, or mismatched quotes (e.g., a stray backtick or unbalanced parentheses).
3. Correct the syntax to valid SQL (e.g., ensure statements end with ';', use double quotes for identifiers if needed, or fix ALTER/DROP statements for the DAW features rollback).
4. Rebuild the project to verify the sqlx or Diesel parser accepts the changes; if using sqlx, run `cargo sqlx prepare` to re-validate.

### Code Example
```rust
// BEFORE:
-- Hypothetical invalid line 1
CREATE TABLE daw_features (id INT PRIMARY KEY

// AFTER:
-- Fixed valid SQL
CREATE TABLE daw_features (
    id INT PRIMARY KEY
);
```

---

## Issue #2: SQL syntax error in update_normalized_filenames.sql

**Confidence:** Medium | **Estimated Time:** 5 minutes

### Analysis
Similar to other migration errors, this stems from compile-time SQL parsing in Rust's build process (e.g., via sqlx's query macro or Diesel's schema inference). The migration tool treats SQL as a typed resource, akin to Rust's trait bounds on generics, where invalid syntax fails parsing like a missing lifetime annotation. Line 1 likely has a basic syntax flaw, such as an unterminated string or incorrect UPDATE statement structure, breaking the build and preventing ownership-safe database interactions from compiling.

### Fix Steps
1. Locate and open /home/dojevou/projects/midi-software-center/database/migrations/update_normalized_filenames.sql.
2. Examine line 1 for syntax issues like improper quoting in filename paths, missing commas in column lists, or invalid function calls (e.g., in normalizing filenames with LOWER() or REPLACE()).
3. Amend to standard SQL syntax, ensuring compatibility with the underlying database (e.g., PostgreSQL if using sqlx defaults).
4. Test by rebuilding; use `cargo check` to isolate the migration validation without full compilation.

### Code Example
```rust
// BEFORE:
-- Hypothetical invalid line 1
UPDATE files SET normalized_name = LOWER(filename

// AFTER:
-- Fixed valid SQL
UPDATE files
SET normalized_name = LOWER(filename)
WHERE normalized_name IS NULL;
```

---

## Issue #3: SQL syntax error in 012_daw_features.sql

**Confidence:** Medium | **Estimated Time:** 5 minutes

### Analysis
The error arises from Rust's integration with SQL via crates like sqlx, which embeds and parses migrations at compile time to provide type-safe queriesâ€”mirroring Rust's borrow checker by validating data flows early. A syntax error on line 1 (e.g., malformed CREATE TABLE for DAW features) fails this parse, akin to a type inference error, ensuring no unsafe FFI or ownership violations in database code but halting the build entirely.

### Fix Steps
1. Edit /home/dojevou/projects/midi-software-center/database/migrations/012_daw_features.sql.
2. Review line 1 for errors like undefined columns, incorrect data types (e.g., mismatched enums for DAW features), or missing constraints.
3. Revise to idiomatic SQL, adding PRIMARY KEY, FOREIGN KEY, or INDEX as needed for performance in real-time audio contexts.
4. Validate by running the build; consider adding sqlx::query! macros in Rust code that depend on this schema for compile-time checks.

### Code Example
```rust
// BEFORE:
-- Hypothetical invalid line 1
CREATE TABLE daw_features id SERIAL PRIMARY KEY, name TEXT

// AFTER:
-- Fixed valid SQL
CREATE TABLE daw_features (
    id SERIAL PRIMARY KEY,
    name TEXT NOT NULL
);
```

---

## Issue #4: SQL syntax error in 009_text_metadata.sql

**Confidence:** Medium | **Estimated Time:** 5 minutes

### Analysis
In Rust projects with database tooling, SQL files are parsed during compilation to enforce safety, similar to how lifetimes prevent dangling references. The tool (sqlx or Diesel) fails on invalid syntax in line 1, treating it as a compile-time invariant violation. This could be due to text-specific issues like improper VARCHAR lengths or unescaped quotes in metadata columns, impacting string ownership in Rust (e.g., &str slices from query results).

### Fix Steps
1. Access /home/dojevou/projects/midi-software-center/database/migrations/009_text_metadata.sql.
2. Check line 1 for text handling errors, such as missing DEFAULT values, invalid CHARACTER SET, or syntax in adding text columns.
3. Correct to valid SQL, optimizing for performance (e.g., TEXT vs. VARCHAR for MIDI metadata to avoid allocations).
4. Recompile and test; if using anyhow for errors, ensure migration failures are handled gracefully in Rust code.

### Code Example
```rust
// BEFORE:
-- Hypothetical invalid line 1
ALTER TABLE metadata ADD COLUMN text_data TEXT(

// AFTER:
-- Fixed valid SQL
ALTER TABLE metadata
ADD COLUMN text_data TEXT;
```

---

## Issue #5: SQL syntax error in 001_initial_schema.sql

**Confidence:** Medium | **Estimated Time:** 5 minutes

### Analysis
As the initial migration, this file sets the foundation for the database schema, parsed at Rust compile time by migration crates to ensure type-safe interactions (e.g., sqlx inferring Row types). A line 1 syntax errorâ€”possibly a basic CREATE DATABASE or TABLE misformationâ€”fails like a missing impl for a trait, blocking the entire build and preventing any ownership transfers to database connections.

### Fix Steps
1. Open /home/dojevou/projects/midi-software-center/database/migrations/001_initial_schema.sql.
2. Analyze line 1 for foundational errors like incorrect schema delimiters, missing ENGINE (if MySQL), or unclosed statements.
3. Fix to clean, standard SQL, including indexes for real-time MIDI queries to maintain lock-free performance.
4. Build to confirm; this fix cascades to all subsequent migrations, so test the full migration chain.

### Code Example
```rust
// BEFORE:
-- Hypothetical invalid line 1
CREATE SCHEMA midi_center;
CREATE TABLE users (id INT

-- AFTER:
-- Fixed valid SQL
CREATE SCHEMA IF NOT EXISTS midi_center;
CREATE TABLE users (
    id SERIAL PRIMARY KEY
);
```

---

## Issue #1: Documentation - Migration best practice: Wrap DDL in transaction

**Confidence:** High | **Estimated Time:** 2 minutes

### Analysis
This issue arises because SQL migrations, when executed in a Rust application using crates like sqlx or diesel, benefit from explicit transaction wrapping to ensure atomicity and rollback on failure. Without BEGIN and COMMIT, individual DDL statements (e.g., CREATE TABLE) are auto-committed, leading to partial application if an error occurs mid-migration. In Rust's ownership model, this mirrors resource management where transactions act like scopes with Drop semantics for rollback, preventing inconsistent database states that could violate type safety in ORM mappings.

### Fix Steps
1. Open the SQL migration file at the specified path.
2. Add 'BEGIN;' at the very start of the file (line 1).
3. Add 'COMMIT;' at the very end of the file, after all DDL statements.
4. Ensure no other transactions are nested; test the migration in a Rust test environment using sqlx::migrate! macro or equivalent to verify atomic execution.

### Code Example
```rust
// BEFORE:
CREATE TABLE IF NOT EXISTS enhanced_analysis_json (
    id INTEGER PRIMARY KEY,
    -- other columns
);

// AFTER:
BEGIN;

CREATE TABLE IF NOT EXISTS enhanced_analysis_json (
    id INTEGER PRIMARY KEY,
    -- other columns
);

COMMIT;
```

---

## Issue #2: Documentation - Migration best practice: Wrap DDL in transaction

**Confidence:** High | **Estimated Time:** 2 minutes

### Analysis
Similar to issue #1, the lack of transaction wrapping in DDL migrations can lead to non-atomic changes, which in a Rust context (e.g., with async database pools in tokio-based apps) risks lifetime mismatches between schema expectations and runtime queries. Rust's borrow checker enforces safety at compile-time, but database consistency requires explicit transaction lifetimes to prevent data races or inconsistent states during concurrent migrations.

### Fix Steps
1. Locate the migration file.
2. Insert 'BEGIN;' immediately after the file header (line 1).
3. Append 'COMMIT;' at the file's end.
4. Validate by running the migration in a Rust integration test, ensuring no partial commits affect query lifetimes.

### Code Example
```rust
// BEFORE:
CREATE TABLE harmonic_analysis (
    id INTEGER PRIMARY KEY,
    -- other columns
);

// AFTER:
BEGIN;

CREATE TABLE harmonic_analysis (
    id INTEGER PRIMARY KEY,
    -- other columns
);

COMMIT;
```

---

## Issue #3: Build - SQL syntax error: Failed to parse SQL

**Confidence:** Medium | **Estimated Time:** 10 minutes

### Analysis
SQL syntax errors in migration files halt the build process in Rust projects using embedded migrations (e.g., sqlx::migrate! or diesel_migrations), as the parser treats invalid SQL as a compile-time error akin to type mismatches. This violates Rust's type system guarantees for database interactions, where invalid SQL could lead to runtime panics or unsafe FFI calls if not caught early. The root cause is likely a missing semicolon, unclosed quote, or invalid keyword in the DDL.

### Fix Steps
1. Inspect the SQL file for common syntax issues: missing semicolons, unbalanced parentheses, or invalid identifiers.
2. Use a SQL linter or run 'sqlx prepare' in Rust to validate syntax at compile-time.
3. Correct the specific error (e.g., add missing comma or fix quote escaping).
4. Rebuild the Rust project to confirm the migration parses correctly.

### Code Example
```rust
// BEFORE:
-- Example invalid: missing semicolon
CREATE TABLE enhanced_tags (
    id INTEGER PRIMARY KEY
-- other columns
);

// AFTER:
-- Fixed: ensure all statements end with semicolon
CREATE TABLE enhanced_tags (
    id INTEGER PRIMARY KEY,
    -- other columns
);
-- Add semicolon if missing on prior statements
```

---

## Issue #4: Performance - Performance: NOT IN with subquery is slow (line 368)

**Confidence:** High | **Estimated Time:** 15 minutes

### Analysis
The NOT IN subquery performs poorly due to full table scans and potential null handling issues in SQL, which in a Rust application (e.g., querying via async futures in tokio) amplifies latency in hot paths like real-time MIDI processing. This doesn't directly tie to Rust's ownership but affects performance optimization principles: subqueries block cache-friendly access, similar to how non-zero-copy data structures hinder SIMD efficiency. Use NOT EXISTS for correlated execution or LEFT JOIN for index utilization.

### Fix Steps
1. Locate line 368 in the migration file.
2. Replace 'NOT IN (SELECT ...)' with 'NOT EXISTS (SELECT 1 FROM ... WHERE ...)' for better index usage.
3. Alternatively, rewrite as a LEFT JOIN with IS NULL check for anti-join semantics.
4. Add appropriate indexes on join columns to optimize; test query performance in Rust with criterion or sqlx tracing.

### Code Example
```rust
// BEFORE:
-- Line 368 example
WHERE some_id NOT IN (SELECT id FROM other_table WHERE condition);

// AFTER:
-- Using NOT EXISTS for performance
WHERE NOT EXISTS (
    SELECT 1 FROM other_table ot
    WHERE ot.id = some_id AND condition
);
-- Or LEFT JOIN alternative:
-- LEFT JOIN other_table ot ON ot.id = some_id AND condition
-- WHERE ot.id IS NULL
```

---

## Issue #5: Documentation - Migration best practice: Wrap DDL in transaction

**Confidence:** High | **Estimated Time:** 2 minutes

### Analysis
As with issues #1 and #2, unwrapped DDL risks non-atomic execution, which in Rust's async/await patterns (e.g., database transactions in sqlx::Transaction) could lead to lifetime extension issues or dropped connections mid-migration. This ensures the entire migration acts as a single ownership unit, aligning with Rust's Drop trait for cleanup on failure.

### Fix Steps
1. Edit the specified migration file.
2. Prepend 'BEGIN;' at line 1.
3. Append 'COMMIT;' after the last statement.
4. Integrate with Rust's migration system and run a dry-run to verify.

### Code Example
```rust
// BEFORE:
ALTER TABLE add_parent_folder (
    parent_id INTEGER
);

-- Wait, assuming CREATE or ALTER

// AFTER:
BEGIN;

CREATE TABLE IF NOT EXISTS parent_folder (
    id INTEGER PRIMARY KEY,
    -- columns
);

COMMIT;
```

---

## Issue #1: [CRITICAL] Build - SQL syntax error: Failed to parse SQL

**Confidence:** High | **Estimated Time:** 10 minutes

### Analysis
This error occurs because the SQL file contains invalid syntax that fails parsing during build time, likely due to integration with a Rust SQL library like sqlx, which performs compile-time query validation via macros (e.g., query![]). The root cause is a mismatch between the SQL dialect expected by the library (e.g., PostgreSQL) and the written query, such as missing semicolons, incorrect keywords, or unbalanced quotes. In Rust's type system, this manifests as a compile-time error to enforce memory safety and correctness before runtime, preventing panics from malformed queries. Lifetimes are not directly involved, but the static query embedding ensures borrow-checked string literals.

### Fix Steps
1. Inspect line 1 of /home/dojevou/projects/midi-software-center/database/organize_by_instruments_optimized.sql for syntax issues like missing commas, incorrect JOIN syntax, or unclosed parentheses.
2. Validate the SQL using the database's CLI tool (e.g., psql for PostgreSQL) or an online validator matching your DB dialect.
3. If using sqlx, re-run cargo check after fixes to leverage compile-time verification. Ensure the query uses &str literals in Rust macros for zero-copy efficiency.
4. Consider wrapping dynamic parts in parameterized queries to avoid future syntax issues from string interpolation.

### Code Example
```rust
// BEFORE:
// In organize_by_instruments_optimized.sql line 1 (example invalid SQL):
SELECT * FROM instruments WHERE name = 'guitar'  -- Missing semicolon or invalid clause

// AFTER:
// Corrected SQL in the .sql file:
SELECT * FROM instruments WHERE name = 'guitar'; -- Added semicolon, ensure valid syntax

// In Rust code embedding this (if applicable):
// BEFORE:
let query = include_str!("database/organize_by_instruments_optimized.sql");
// sqlx::query(query) // This would fail at compile time

// AFTER:
// Fix the .sql file directly; no Rust change needed unless dynamic:
use sqlx::query;
let row: (String,) = sqlx::query_as("SELECT name FROM instruments WHERE name = $1")
    .bind("guitar")
    .fetch_one(&pool)
    .await?; // Use parameters for safety
```

---

## Issue #2: [HIGH] Safety - Security: String concatenation in SQL may enable injection (line 460)

**Confidence:** High | **Estimated Time:** 15 minutes

### Analysis
Although this is flagged in a .sql file, the issue likely stems from dynamic SQL generation in Rust code that embeds or modifies this file, using string concatenation (e.g., format! macro or + operator on Strings). This violates Rust's ownership model by transferring ownership of user inputs into SQL strings without sanitization, enabling SQL injection attacks. Rust's type system doesn't inherently prevent this at compile time for dynamic strings, but libraries like sqlx enforce safe parameterization via trait bounds (e.g., Into<Database> for binds). The root cause is treating user input as owned String instead of borrowing it safely into placeholders, bypassing borrow checker protections.

### Fix Steps
1. Locate the Rust code that executes or builds queries from this .sql file (likely using sqlx::query or diesel).
2. Replace string concatenation with parameterized queries using $1, $2 placeholders and .bind() method.
3. Use &str for static parts and borrow user inputs via as_ref() or into() for bind values to avoid unnecessary cloning.
4. If the .sql file itself has concatenated strings (unlikely but possible in templates), refactor to static queries with parameters.

### Code Example
```rust
// BEFORE:
// Hypothetical Rust code building dynamic SQL from line 460 in .sql:
let user_input = "' OR 1=1; --";
let sql = format!("SELECT * FROM instruments WHERE name = '{}'", user_input); // Vulnerable to injection
let rows = sqlx::query(&sql).fetch_all(&pool).await?;

// In .sql file line 460 (if dynamic placeholder):
-- Example: SELECT * FROM table || 'WHERE id=' || $1  -- But use params

// AFTER:
// Refactored Rust code:
use sqlx::{query, Row};
let user_input: &str = "guitar"; // Borrow, don't own unnecessarily
let rows = query("SELECT * FROM instruments WHERE name = $1")
    .bind(user_input) // Safe parameterization, no concat
    .fetch_all(&pool)
    .await?;

// Update .sql file if embedded:
-- Static with placeholder: SELECT * FROM instruments WHERE name = $1;
```

---

## Issue #3: [HIGH] Safety - Security: String concatenation in SQL may enable injection (line 461)

**Confidence:** High | **Estimated Time:** 10 minutes

### Analysis
Similar to issue #2, this flags unsafe string interpolation in dynamic SQL construction from the .sql file, exploiting Rust's flexible String handling without runtime checks. The ownership transfer in concatenation (e.g., String + &str) allows tainted data to pollute queries, circumventing the borrow checker's aliasing rules. In async contexts (common for DB ops with tokio), this could lead to race conditions if inputs are shared, but primarily it's an API design flaw ignoring safe combinators like bind(). Reference: Rust's From/Into traits enable conversion but don't sanitize.

### Fix Steps
1. Audit line 461 in the .sql file and associated Rust code for concat patterns like || in SQL or format! in Rust.
2. Convert to parameterized form with placeholders; use Option combinators if inputs can be None.
3. Test with malicious inputs (e.g., via unit tests with sqlx::test) to verify injection resistance.
4. Prefer query_as! macro for compile-time type safety if using sqlx.

### Code Example
```rust
// BEFORE:
// Example in Rust executing line 461:
let id = get_user_id(); // Potentially unsafe input
let sql = format!("UPDATE instruments SET active = true WHERE id = {}", id); // Injection risk
sqlx::query(&sql).execute(&pool).await?;

// AFTER:
// Safe parameterized version:
let id: i32 = get_user_id()?; // Assume parsed safely
sqlx::query("UPDATE instruments SET active = true WHERE id = $1")
    .bind(id)
    .execute(&pool)
    .await?;

// For .sql file line 461:
-- BEFORE: UPDATE table SET col = 'value' || $1  -- Avoid SQL concat
-- AFTER: UPDATE table SET col = $1  -- Use bind for value
```

---

## Issue #4: [HIGH] Safety - Security: String concatenation in SQL may enable injection (line 462)

**Confidence:** High | **Estimated Time:** 12 minutes

### Analysis
This is another instance of insecure dynamic SQL building, where Rust's ownership semantics allow cheap concatenation but fail to enforce input validation. The issue arises from using owned types (String) for queries instead of borrowed &str with parameters, potentially leading to use-after-free if inputs are dropped prematurely in async scopes. Trait bounds in DB libraries (e.g., sqlx::Encode) ensure safe binding, but manual concat ignores this, violating idiomatic error handling with Result combinators over panics.

### Fix Steps
1. Examine line 462 for concat operations and trace back to Rust code (e.g., in a migration or query builder).
2. Refactor to use .bind() with type-safe placeholders; employ map_err for custom error types if needed.
3. If in a hot path (e.g., real-time MIDI processing), ensure zero-allocation by using static &str queries.
4. Add clippy lints or sqlx checks to prevent future occurrences.

### Code Example
```rust
// BEFORE:
// Rust code for line 462:
let filter = user_provided_filter();
let sql = "SELECT * FROM instruments".to_owned() + &format!(" WHERE {} = 1", filter); // Double concat vulnerability
let result = sqlx::query(&sql).fetch_optional(&pool).await?;

// AFTER:
// Idiomatic fix:
let filter_value: &str = user_provided_filter().as_ref().unwrap_or("default"); // Safe borrow
let result = sqlx::query("SELECT * FROM instruments WHERE $1 = $2")
    .bind("type")
    .bind(filter_value) // Parameterized, no ownership transfer needed
    .fetch_optional(&pool)
    .await?;

// .sql file line 462:
-- BEFORE: SELECT * || ' FROM ' || table_name
-- AFTER: SELECT * FROM $1  -- Parameterize table if dynamic (use whitelist for tables)
```

---

## Issue #5: [CRITICAL] Build - SQL syntax error: Failed to parse SQL

**Confidence:** High | **Estimated Time:** 8 minutes

### Analysis
Analogous to issue #1, this build failure indicates malformed SQL in the schema validation file, caught by Rust's compile-time checks in libraries like sqlx or diesel migrations. The type system integrates SQL parsing to ensure queries align with schema structs (via derive macros), preventing ownership violations from mismatched data. Root cause: Syntax errors like invalid constraints or missing keywords disrupt the parser, halting compilation to maintain memory safety guarantees.

### Fix Steps
1. Review line 1 of /home/dojevou/projects/midi-software-center/verification/sql/schema_validation.sql for basic syntax (e.g., CREATE TABLE without proper columns).
2. Use database-specific tools to lint the SQL; ensure compatibility with your DB (e.g., SQLite vs. Postgres).
3. If embedded in Rust, use include_str! and sqlx macros for validation.
4. Handle edge cases like empty schemas with Option types in Rust integrations.

### Code Example
```rust
// BEFORE:
// In schema_validation.sql line 1 (example):
CREATE TABLE validation (id INT  -- Missing PRIMARY KEY or type

// AFTER:
// Fixed SQL:
CREATE TABLE validation (
    id INTEGER PRIMARY KEY,
    name TEXT NOT NULL
);

// Rust embedding example:
// BEFORE:
sqlx::migrate!("./verification/sql/schema_validation.sql"); // Fails build

// AFTER:
// After fixing SQL, no change needed; or for inline:
#[derive(sqlx::FromRow)]
struct Validation { id: i32, name: String }

let schema_query = "CREATE TABLE IF NOT EXISTS validation (id INTEGER PRIMARY KEY, name TEXT NOT NULL)";
sqlx::query(schema_query).execute(&pool).await?;
```

---

## Issue #1: Build - SQL syntax error: Failed to parse SQL

**Confidence:** High | **Estimated Time:** 10 minutes

### Analysis
This issue arises because the SQL script contains invalid syntax, which fails parsing during build time if the Rust project uses a crate like sqlx with compile-time query verification enabled (via SQLx's query macro or offline mode). Rust's type system integrates with sqlx to statically verify SQL at compile time, ensuring type safety and correctness; an invalid syntax on line 1 (likely a missing keyword, unbalanced quotes, or incorrect clause) violates this, preventing the build. This ties into Rust's ownership model indirectly, as query results are tied to strongly-typed structs, but the root cause is the malformed SQL string literal or embedded query.

### Fix Steps
1. Inspect line 1 of the SQL file for common syntax errors (e.g., missing semicolon, invalid keyword, or unbalanced parentheses).
2. Correct the SQL syntax to make it valid PostgreSQL (assuming Postgres based on $1 placeholders).
3. If the SQL is embedded in Rust code (e.g., via sqlx::query!), update the string literal accordingly. Re-run cargo check to verify.
4. Enable sqlx's query verification if not already (add sqlx::query! macro and DATABASE_URL env for offline mode).

### Code Example
```rust
// BEFORE:
// In scripts/infer-instruments-parallel.sql:1 (example invalid syntax)
SELECT * FROM instruments WHERE id = ; -- Missing value or clause

// AFTER:
// Corrected SQL in the .sql file or embedded in Rust:
SELECT * FROM instruments WHERE id = 1; -- Fixed syntax

// In Rust code (if embedded):
// BEFORE:
let row: (i32,) = sqlx::query_as!("SELECT * FROM instruments WHERE id = ;")
    .fetch_one(&pool)
    .await?;

// AFTER:
let row: (i32,) = sqlx::query_as!("SELECT * FROM instruments WHERE id = $1")
    .bind(1i32)
    .fetch_one(&pool)
    .await?;

// Necessary imports:
use sqlx::{PgPool, Row};
```

---

## Issue #2: Safety - Security: String concatenation in SQL may enable injection (line 165)

**Confidence:** High | **Estimated Time:** 15 minutes

### Analysis
The root cause is unsafe string concatenation in the SQL script, likely using || operator in PostgreSQL dynamic SQL (e.g., 'SELECT ... WHERE name = ' || user_input), which bypasses escaping and allows SQL injection. In a Rust context, if this script is executed via a Rust driver like sqlx or tokio-postgres, passing unparameterized dynamic SQL exposes the application to injection attacks, violating Rust's memory safety principles at the FFI boundary with the database. Rust's ownership model ensures strings are owned or borrowed safely, but concatenating without parameterization ignores SQL's type system, potentially leading to runtime panics or data corruption via Result unwrapping.

### Fix Steps
1. Rewrite the dynamic SQL at line 165 to use prepared statement placeholders ($1, $2) instead of concatenation.
2. In the Rust code executing this script, use bind() to safely pass parameters, leveraging sqlx's type-safe parameterization.
3. Test the query with various inputs to ensure no injection vectors remain.
4. Consider using sqlx::query! macro for compile-time safety if embedding the query in Rust.

### Code Example
```rust
// BEFORE:
// In scripts/infer-instruments-parallel.sql:165 (example concatenation)
EXECUTE 'SELECT * FROM instruments WHERE name = ' || quote_ident($1);

// AFTER:
// Parameterized in .sql (for PREPARE/EXECUTE) or direct query
PREPARE stmt AS SELECT * FROM instruments WHERE name = $1;
EXECUTE stmt($1);

// In Rust code executing the query:
// BEFORE:
let sql = format!("SELECT * FROM instruments WHERE name = {}", name);
let rows = sqlx::query(&sql).fetch_all(&pool).await?;

// AFTER:
use sqlx::postgres::PgQueryAs;
let rows = sqlx::query_as!(
    Instrument,
    "SELECT * FROM instruments WHERE name = $1",
    name.as_str()
).fetch_all(&pool).await?;

// Assume struct Instrument { name: String, ... }
// Necessary imports:
use sqlx::{PgPool, FromRow};
```

---

## Issue #3: Safety - Security: String concatenation in SQL may enable injection (line 172)

**Confidence:** High | **Estimated Time:** 15 minutes

### Analysis
Similar to issue #2, this stems from string concatenation at line 172, creating dynamic SQL vulnerable to injection. Rust's string handling (e.g., via format! or + operator) is safe for memory but not for SQL semantics; when executing such scripts through a Rust Postgres client, it undermines the borrow checkerâ€™s guarantees by allowing malicious input to alter query structure. This violates trait bounds for safe database interactions (e.g., sqlx's Encode/Decode traits), potentially causing ownership transfer issues in error paths if injection leads to unexpected results.

### Fix Steps
1. Replace concatenation at line 172 with $1, $2 placeholders for safe parameterization.
2. Adjust the Rust execution code to bind values, using as_ref() or into() for type conversion if needed.
3. Use Option/Result combinators in Rust to handle potential empty results post-fix.
4. Validate inputs in Rust before binding to add an extra layer of safety.

### Code Example
```rust
// BEFORE:
// In scripts/infer-instruments-parallel.sql:172 (example)
SELECT * FROM users WHERE id = ' || $1 || ' AND active = true;

// AFTER:
// Fixed SQL with placeholders
SELECT * FROM users WHERE id = $1 AND active = $2;

// In Rust:
// BEFORE:
let id_str = id.to_string();
let sql = format!("SELECT * FROM users WHERE id = '{}' AND active = true", id_str);
let row = sqlx::query(&sql).fetch_optional(&pool).await?;

// AFTER:
let row = sqlx::query_as!(
    User,
    "SELECT * FROM users WHERE id = $1 AND active = $2",
    id,
    true
).fetch_optional(&pool).await?;

// Use match or ? for handling Option<User>
// Necessary imports:
use sqlx::{PgPool, query_as};
```

---

## Issue #4: Safety - Security: String concatenation in SQL may enable injection (line 189)

**Confidence:** High | **Estimated Time:** 20 minutes

### Analysis
At line 189, concatenation likely builds a query with user-controlled data, enabling injection. In Rust, this manifests when scripts are loaded and executed via PgConnection or Pool, where Rust's lifetimes ensure the SQL string lives long enough, but the lack of parameterization allows runtime exploits. This interacts poorly with Rust's error handling (e.g., sqlx::Error), as injection could lead to unhandled database errors; idiomatic Rust favors &str slices for queries to avoid unnecessary allocations, but concatenation creates owned Strings prone to misuse.

### Fix Steps
1. Convert line 189's concatenation to use positional placeholders ($1 etc.).
2. In Rust, employ sqlx's bind method with proper type inference via turbofish if ambiguous.
3. Prefer &str for static query parts to optimize performance and avoid clone() overhead.
4. Add logging or anyhow for wrapping sqlx errors in production.

### Code Example
```rust
// BEFORE:
// In scripts/infer-instruments-parallel.sql:189 (example)
DO $$
BEGIN
    EXECUTE 'UPDATE instruments SET data = ' || $1;
END $$;

// AFTER:
// Parameterized dynamic SQL
DO $$
DECLARE
    stmt text;
BEGIN
    PREPARE upd AS UPDATE instruments SET data = $1;
    EXECUTE upd($1);
END $$;

// In Rust (if executing block):
// BEFORE:
let data = serde_json::to_string(&value).unwrap();
let sql = format!("DO $$ BEGIN EXECUTE 'UPDATE instruments SET data = {}'; END $$;", data);
sqlx::query(&sql).execute(&pool).await?;

// AFTER:
use anyhow::Result;
let row_affected = sqlx::query("UPDATE instruments SET data = $1")
    .bind(serde_json::to_value(&value)?)
    .execute(&pool)
    .await?
    .rows_affected();

// Necessary imports:
use sqlx::PgPool;
use anyhow::Context;
```

---

## Issue #5: Safety - Security: String concatenation in SQL may enable injection (line 214)

**Confidence:** High | **Estimated Time:** 15 minutes

### Analysis
Line 214 in a different script follows the same pattern: concatenation for dynamic SQL, risking injection. From a Rust perspective, executing such scripts via async runtime (e.g., tokio-postgres) ignores Rust's async/await safety nets, as malicious input could deadlock or allocate unexpectedly in hot paths. This conflicts with trait design for database traits (e.g., sqlx::Database), where generics over parameter types ensure safety; using String over &str here wastes performance, and without proper Drop semantics for connections, leaks could occur on injection-induced errors.

### Fix Steps
1. Refactor line 214 to parameterized form with $1 placeholders.
2. In Rust, use async-compatible execution with proper error propagation via ? operator.
3. Opt for zero-copy where possible (e.g., bind &str instead of String).
4. If in a real-time audio/MIDI context, ensure no allocations in query paths by pre-preparing statements.

### Code Example
```rust
// BEFORE:
// In scripts/infer-instruments-enhanced.sql:214 (example)
INSERT INTO logs (message) VALUES ('Error: ' || $1);

// AFTER:
// Parameterized INSERT
INSERT INTO logs (message) VALUES ($1);

// In Rust:
// BEFORE:
let err_msg = error.to_string();
let sql = format!("INSERT INTO logs (message) VALUES ('Error: {}')", err_msg);
sqlx::query(&sql).execute(&pool).await?;

// AFTER:
use thiserror::Error;
#[derive(Error, Debug)]
struct MidiError;

let msg = format!("Error: {}", error);
sqlx::query("INSERT INTO logs (message) VALUES ($1)")
    .bind(msg.as_str())
    .execute(&pool)
    .await
    .context("Failed to log error")?;

// Necessary imports:
use sqlx::PgPool;
use anyhow::{Context, Result};
```

---

## Issue #1: Safety - Security: String concatenation in SQL may enable injection (line 222)

**Confidence:** High | **Estimated Time:** 15 minutes

### Analysis
In Rust, SQL queries are often constructed as string literals or via the format! macro, which treats user input as raw data without automatic escaping. This bypasses Rust's type system safety guarantees, allowing untrusted input (e.g., from MIDI instrument data) to be directly interpolated into SQL strings, enabling injection attacks. Unlike Rust's ownership model that prevents data races, string concatenation here violates secure coding principles, as lifetimes and borrowing don't apply to string safetyâ€”it's an API design issue where the database crate's raw query methods don't enforce parameterization.

### Fix Steps
1. Identify the SQL query at line 222 in the embedded SQL string or script execution.
2. Replace string concatenation with parameterized placeholders ($1, $2) assuming PostgreSQL via sqlx crate.
3. In Rust code executing the query, bind parameters using sqlx::query! macro or query_as for type-safe execution.
4. Add necessary imports: use sqlx::{PgPool, Row}; and ensure the pool is configured for prepared statements.

### Code Example
```rust
// BEFORE:
let user_input = "' OR '1'='1";
let sql = format!("SELECT * FROM instruments WHERE name = '{}'", user_input);
let rows = sqlx::query(&sql).fetch_all(&pool).await?;

// AFTER:
use sqlx::PgPool;
let user_input = "' OR '1'='1'";
let rows = sqlx::query!(
    r#"SELECT * FROM instruments WHERE name = $1"#,
    user_input
).fetch_all(&pool as &PgPool).await?;
```

---

## Issue #2: Safety - Security: String concatenation in SQL may enable injection (line 229)

**Confidence:** High | **Estimated Time:** 10 minutes

### Analysis
Similar to issue #1, Rust's string handling via concat or format! allows arbitrary user input (potentially from untrusted MIDI data sources) to corrupt SQL structure without compile-time checks. The type system ensures borrow checker compliance but not semantic safety for external DSLs like SQL; this is a trait bound omission in database APIs, where Query traits should mandate parameterization to align with Rust's safety ethos.

### Fix Steps
1. Locate the concatenation at line 229, likely involving dynamic values like instrument IDs.
2. Refactor to use positional placeholders ($1, etc.) in the SQL string.
3. Execute via sqlx with bound parameters to leverage automatic escaping and prevent injection.
4. Consider wrapping in a Result for error propagation using anyhow for idiomatic error handling.

### Code Example
```rust
// BEFORE:
let id = get_user_id();
let sql = format!("UPDATE instruments SET type = '{}' WHERE id = {}", input_type, id);
sqlx::query(&sql).execute(&pool).await?;

// AFTER:
use anyhow::Result;
use sqlx::PgPool;
let id = get_user_id();
let result: Result<(), sqlx::Error> = sqlx::query!(
    r#"UPDATE instruments SET type = $1 WHERE id = $2"#,
    input_type,
    id
).execute(&pool as &PgPool).await;
result.map_err(anyhow::Error::from)?;
```

---

## Issue #3: Safety - Security: String concatenation in SQL may enable injection (line 237)

**Confidence:** High | **Estimated Time:** 12 minutes

### Analysis
Rust's ownership semantics prevent use-after-free but offer no protection against logical errors like SQL injection when building queries with String::push_str or similar. This occurs because user-controlled data (e.g., pattern names in MIDI context) violates the invariant that SQL strings must be escaped; it's an issue of missing trait bounds on query builders, where From<String> for Query shouldn't allow unsafe interpolation without lifetimes tied to sanitized inputs.

### Fix Steps
1. Examine line 237 for concatenation patterns, such as appending WHERE clauses dynamically.
2. Convert to a parameterized query with multiple placeholders for all dynamic parts.
3. Use sqlx's query macro for compile-time verification of placeholders.
4. Handle potential errors with ? operator for propagation, aligning with Rust's error handling best practices.

### Code Example
```rust
// BEFORE:
let name = user_provided_name();
let sql = String::new() + "INSERT INTO patterns (name) VALUES ('" + &name + "')";
sqlx::query(&sql).execute(&pool).await?;

// AFTER:
use sqlx::PgPool;
let name = user_provided_name();
sqlx::query!(
    r#"INSERT INTO patterns (name) VALUES ($1)"#,
    name.as_str()
).execute(&pool as &PgPool).await?;
```

---

## Issue #4: Build - SQL syntax error: Failed to parse SQL

**Confidence:** Medium | **Estimated Time:** 5 minutes

### Analysis
SQL syntax errors in embedded queries aren't caught by Rust's compiler but surface at runtime or build-time if using sqlx's compile-time checks (via sqlx::query! macro). This stems from treating SQL as opaque strings, bypassing Rust's type system; improper quoting or missing commas violates SQL grammar, unrelated to lifetimes but highlighting the need for static analysis tools or query macros that enforce syntax via procedural macros.

### Fix Steps
1. Inspect line 1 of extract-pattern-types-simple.sql for common issues: missing semicolons, unbalanced quotes, or invalid keywords.
2. Correct the syntax directly in the SQL file or Rust string literal (e.g., add missing comma or fix SELECT clause).
3. If embedded in Rust, use sqlx::query! for compile-time parsing to catch errors early.
4. Rebuild and test the query execution to verify.

### Code Example
```rust
// BEFORE:
// In SQL file or string: SELECT * FROM patterns WHERE type = 'simple'  -- missing semicolon or invalid syntax
let sql = r#"SELECT * FROM patterns WHERE type = 'simple'"#;
sqlx::query(sql).fetch_all(&pool).await?;

// AFTER:
// Fixed SQL: SELECT * FROM patterns WHERE type = 'simple';
use sqlx::PgPool;
let rows = sqlx::query!(
    r#"SELECT * FROM patterns WHERE type = $1"#,
    "simple"
).fetch_all(&pool as &PgPool).await?;
```

---

## Issue #5: Performance - Performance: Possible N+1 query pattern (line 15)

**Confidence:** High | **Estimated Time:** 20 minutes

### Analysis
In Rust async contexts (e.g., tokio for real-time MIDI), N+1 queries arise from loops executing individual DB calls, leading to excessive round-trips and allocations. Rust's ownership model allows this via repeated borrows of the connection pool, but it ignores performance invariants; without async iterator traits or batching, it violates zero-copy ideals and can block hot paths, especially under real-time constraints where latency matters more than memory safety alone.

### Fix Steps
1. Analyze line 15 for a loop like for item in items { query_single(item) }, which triggers N+1.
2. Refactor to a single JOIN query or use sqlx's fetch_all with IN clause for batching.
3. For async safety, ensure the query uses non-blocking execution and consider caching results to avoid repeated DB hits.
4. Profile with criterion or tokio-console to verify performance gains.

### Code Example
```rust
// BEFORE:
// At line 15:
for pattern_id in pattern_ids {
    let count = sqlx::query!("SELECT COUNT(*) FROM types WHERE pattern_id = $1", pattern_id)
        .fetch_one(&pool).await?.count;
}

// AFTER:
use sqlx::PgPool;
// Batch with IN clause or JOIN
let counts = sqlx::query!(
    r#"SELECT p.id, COUNT(t.id) as type_count
       FROM patterns p
       LEFT JOIN types t ON p.id = t.pattern_id
       WHERE p.id = ANY($1)
       GROUP BY p.id"#,
    &pattern_ids[..]  // Slice for array param
).fetch_all(&pool as &PgPool).await?;
// Process counts map or vec for all IDs in one go
```

---

## Issue #1: Build - SQL syntax error: Failed to parse SQL in extract-pattern-types.sql

**Confidence:** Medium | **Estimated Time:** 5 minutes

### Analysis
This build failure occurs because the Rust project likely uses a crate like sqlx or diesel with compile-time query validation enabled (e.g., via sqlx::query! macros or migration checks). Rust's type system enforces static verification of embedded SQL for memory safety and correctness, treating SQL syntax errors as compile-time errors akin to type mismatches. The error at line 1 indicates a fundamental parsing issue, such as a missing semicolon, invalid keyword, or unclosed quote, which violates the SQL dialect's grammar (e.g., PostgreSQL or SQLite). This integrates with Rust's ownership model indirectly, as query results must align with expected types (e.g., Result<Vec<Struct>, sqlx::Error>), but the root cause is in the SQL file itself, not Rust code.

### Fix Steps
1. Open the file /home/dojevou/projects/midi-software-center/scripts/extract-pattern-types.sql.
2. Inspect line 1 for common syntax issues: ensure statements end with ';', keywords are correctly spelled (e.g., 'SELECT' not 'SELEC'), and strings are properly quoted.
3. Validate the entire SQL using a tool like psql or sqlite3 CLI, or an online SQL parser for the project's dialect.
4. Re-run cargo build to confirm the fix; if using sqlx, ensure the SQL file is included in the query validation path (e.g., via include_str! or migration setup).

### Code Example
```rust
// BEFORE (example of common line 1 error):
SELECT * FROM patterns -- missing semicolon

// AFTER:
SELECT * FROM patterns;
```

---

## Issue #2: Build - SQL syntax error: Failed to parse SQL in PERFORMANCE-SQL-MIGRATIONS.sql

**Confidence:** Medium | **Estimated Time:** 5 minutes

### Analysis
Similar to Issue #1, this is a compile-time validation failure in a Rust project using SQL-embedded crates (e.g., sqlx migrations or diesel schema). Rust's build system parses SQL files during compilation to ensure type-safe database interactions, leveraging traits like sqlx::FromRow for ownership-safe deserialization. An error at line 1 suggests a syntax violation in the migration script, such as an invalid ALTER TABLE clause, missing CREATE TABLE structure, or dialect-specific issue (e.g., non-standard SQL in a performance test file). This prevents the build from succeeding, as Rust treats it as a static error to maintain memory safety in async database operations (e.g., avoiding runtime panics from malformed queries).

### Fix Steps
1. Locate and open /home/dojevou/projects/midi-software-center/_disabled_tests/docs/performance/PERFORMANCE-SQL-MIGRATIONS.sql.
2. Examine line 1: check for migration-specific syntax like 'CREATE INDEX' without proper constraints, or unescaped special characters.
3. Test the SQL in isolation using the project's database tool (e.g., diesel cli or sqlx migrate), focusing on performance-related optimizations that might introduce syntax errors.
4. After correction, rebuild with cargo; note that since this is in _disabled_tests, ensure it's enabled for validation if needed, or exclude it via build flags if it's intentionally broken.

### Code Example
```rust
// BEFORE (example migration syntax error at line 1):
ALTER TABLE performance_data ADD COLUMN new_col TYPE int -- invalid syntax

// AFTER:
ALTER TABLE performance_data ADD COLUMN new_col INTEGER;
```

---

