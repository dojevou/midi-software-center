//! Comprehensive tests for TagRepository
//!
//! **Target Coverage:** 90%+ (Trusty Module requirement: 80%+)
//! **Total Tests:** 80 (69 original + 11 error path tests)
//!
//! This test suite covers all 9 public methods of TagRepository with comprehensive
//! edge case testing, constraint violation handling, and performance verification.
//!
//! **Test Categories:**
//! 1. Tag CRUD Operations (8 tests) - Insert, find, update, delete
//! 2. Batch Tag Operations (9 tests) - Bulk upsert, batch insert
//! 3. File-Tag Associations (10 tests) - Add, remove, many-to-many
//! 4. Tag Queries and Filtering (9 tests) - Search, fuzzy, pattern matching
//! 5. Popular Tags and Usage Counts (7 tests) - Top tags, usage metrics
//! 6. Tag Category Operations (5 tests) - Category grouping, filtering
//! 7. File Filtering by Tags (6 tests) - Multi-tag queries, aggregation
//! 8. Update File Tags (Replace All) (6 tests) - Batch replace, transaction safety
//! 9. Edge Cases and Boundary Conditions (6 tests) - Empty, large datasets, null
//! 10. Error Path Tests (12 tests) - Constraint violations, FK, uniqueness
//! 11. Performance and Optimization (2 tests) - Bulk operations, indexing
//!
//! **Special Considerations:**
//! - Unique constraint on (file_id, tag_id) pairs
//! - Tag name length limit (VARCHAR(100))
//! - Category length limit (VARCHAR(50))
//! - Foreign key constraint (file_id must exist)
//! - Idempotent operations (remove non-existent tag)
//!
//! Total: 74 tests

use midi_pipeline::db::repositories::tag_repository::{TagRepository, TagRepositoryError};
use midi_pipeline::db::repositories::FileRepository;
use midi_pipeline::db::models::NewFile;
use sqlx::PgPool;

mod fixtures;
mod helpers;
mod common;

use fixtures::{NewFileBuilder, NewTagBuilder, Fixtures, random_hash};
use helpers::db::*;
use common::assertions::{
    assert_metadata_exists, assert_file_has_tag, assert_bpm_set,
    assert_file_not_exists as assert_file_path_not_exists,
};

// ============================================================================
// SECTION 1: Tag CRUD Operations (8 tests)
// ============================================================================

#[tokio::test]
async fn test_get_or_create_tag_new_tag() {
    let pool = setup_test_pool().await;
    cleanup_database(&pool).await.expect("Cleanup failed");

    let repo = TagRepository::new(pool.clone());
    let tag_id = repo.get_or_create_tag("drums", Some("instrument"))
        .await
        .expect("Failed to create tag");

    assert!(tag_id > 0);
    assert_tag_exists(&pool, tag_id).await;

    cleanup_database(&pool).await.expect("Cleanup failed");
}

#[tokio::test]
async fn test_get_or_create_tag_existing_tag() {
    let pool = setup_test_pool().await;
    cleanup_database(&pool).await.expect("Cleanup failed");

    let repo = TagRepository::new(pool.clone());

    let tag_id1 = repo.get_or_create_tag("drums", Some("instrument"))
        .await
        .expect("Failed to create tag");
    let tag_id2 = repo.get_or_create_tag("drums", Some("instrument"))
        .await
        .expect("Failed to get existing tag");

    assert_eq!(tag_id1, tag_id2, "Should return same ID for existing tag");

    let count = count_tags(&pool).await.expect("Failed to count tags");
    assert_eq!(count, 1, "Should only have 1 tag");

    cleanup_database(&pool).await.expect("Cleanup failed");
}

#[tokio::test]
async fn test_get_or_create_tag_without_category() {
    let pool = setup_test_pool().await;
    cleanup_database(&pool).await.expect("Cleanup failed");

    let repo = TagRepository::new(pool.clone());
    let tag_id = repo.get_or_create_tag("drums", None)
        .await
        .expect("Failed to create tag without category");

    assert!(tag_id > 0);

    let tag = get_tag_by_id(&pool, tag_id).await.expect("Failed to get tag");
    assert_eq!(tag.name, "drums");
    assert!(tag.category.is_none());

    cleanup_database(&pool).await.expect("Cleanup failed");
}

#[tokio::test]
async fn test_get_or_create_tag_with_category() {
    let pool = setup_test_pool().await;
    cleanup_database(&pool).await.expect("Cleanup failed");

    let repo = TagRepository::new(pool.clone());
    let tag_id = repo.get_or_create_tag("house", Some("genre"))
        .await
        .expect("Failed to create tag with category");

    let tag = get_tag_by_id(&pool, tag_id).await.expect("Failed to get tag");
    assert_eq!(tag.name, "house");
    assert_eq!(tag.category, Some("genre".to_string()));

    cleanup_database(&pool).await.expect("Cleanup failed");
}

#[tokio::test]
async fn test_get_or_create_tag_case_sensitive() {
    let pool = setup_test_pool().await;
    cleanup_database(&pool).await.expect("Cleanup failed");

    let repo = TagRepository::new(pool.clone());

    let tag_id1 = repo.get_or_create_tag("House", Some("genre"))
        .await
        .expect("Failed to create tag");
    let tag_id2 = repo.get_or_create_tag("house", Some("genre"))
        .await
        .expect("Failed to create tag");

    assert_ne!(tag_id1, tag_id2, "Should create separate tags for different cases");

    let count = count_tags(&pool).await.expect("Failed to count tags");
    assert_eq!(count, 2, "Should have 2 tags with different cases");

    cleanup_database(&pool).await.expect("Cleanup failed");
}

#[tokio::test]
async fn test_get_tag_categories() {
    let pool = setup_test_pool().await;
    cleanup_database(&pool).await.expect("Cleanup failed");

    let repo = TagRepository::new(pool.clone());

    // Create tags with various categories
    repo.get_or_create_tag("drums", Some("instrument")).await.expect("Failed");
    repo.get_or_create_tag("bass", Some("instrument")).await.expect("Failed");
    repo.get_or_create_tag("house", Some("genre")).await.expect("Failed");
    repo.get_or_create_tag("techno", Some("genre")).await.expect("Failed");
    repo.get_or_create_tag("loop", Some("type")).await.expect("Failed");
    repo.get_or_create_tag("uncategorized", None).await.expect("Failed");

    let categories = repo.get_tag_categories().await.expect("Failed to get categories");

    assert_eq!(categories.len(), 3);
    assert!(categories.contains(&"instrument".to_string()));
    assert!(categories.contains(&"genre".to_string()));
    assert!(categories.contains(&"type".to_string()));
    assert!(!categories.contains(&"".to_string()));

    cleanup_database(&pool).await.expect("Cleanup failed");
}

#[tokio::test]
async fn test_get_tag_categories_empty() {
    let pool = setup_test_pool().await;
    cleanup_database(&pool).await.expect("Cleanup failed");

    let repo = TagRepository::new(pool.clone());
    let categories = repo.get_tag_categories().await.expect("Failed");

    assert_eq!(categories.len(), 0);

    cleanup_database(&pool).await.expect("Cleanup failed");
}

#[tokio::test]
async fn test_get_tag_categories_all_null() {
    let pool = setup_test_pool().await;
    cleanup_database(&pool).await.expect("Cleanup failed");

    let repo = TagRepository::new(pool.clone());

    repo.get_or_create_tag("tag1", None).await.expect("Failed");
    repo.get_or_create_tag("tag2", None).await.expect("Failed");
    repo.get_or_create_tag("tag3", None).await.expect("Failed");

    let categories = repo.get_tag_categories().await.expect("Failed");
    assert_eq!(categories.len(), 0);

    cleanup_database(&pool).await.expect("Cleanup failed");
}

// ============================================================================
// SECTION 2: Batch Tag Operations (9 tests)
// ============================================================================

#[tokio::test]
async fn test_get_or_create_tags_batch_new_tags() {
    let pool = setup_test_pool().await;
    cleanup_database(&pool).await.expect("Cleanup failed");

    let repo = TagRepository::new(pool.clone());

    let tags = vec![
        ("drums".to_string(), Some("instrument".to_string())),
        ("bass".to_string(), Some("instrument".to_string())),
        ("piano".to_string(), Some("instrument".to_string())),
        ("synth".to_string(), Some("instrument".to_string())),
        ("fx".to_string(), Some("type".to_string())),
    ];

    let tag_ids = repo.get_or_create_tags_batch(&tags)
        .await
        .expect("Failed to create batch tags");

    assert_eq!(tag_ids.len(), 5);
    assert!(tag_ids.iter().all(|&id| id > 0));

    // Verify all unique
    let mut unique_ids = tag_ids.clone();
    unique_ids.sort();
    unique_ids.dedup();
    assert_eq!(unique_ids.len(), 5, "All IDs should be unique");

    cleanup_database(&pool).await.expect("Cleanup failed");
}

#[tokio::test]
async fn test_get_or_create_tags_batch_mixed_existing() {
    let pool = setup_test_pool().await;
    cleanup_database(&pool).await.expect("Cleanup failed");

    let repo = TagRepository::new(pool.clone());

    // Create some tags first
    let drums_id = repo.get_or_create_tag("drums", Some("instrument")).await.expect("Failed");
    let bass_id = repo.get_or_create_tag("bass", Some("instrument")).await.expect("Failed");

    // Batch create with mixed existing and new
    let tags = vec![
        ("drums".to_string(), Some("instrument".to_string())),
        ("bass".to_string(), Some("instrument".to_string())),
        ("piano".to_string(), Some("instrument".to_string())),
        ("synth".to_string(), Some("instrument".to_string())),
    ];

    let tag_ids = repo.get_or_create_tags_batch(&tags).await.expect("Failed");

    assert_eq!(tag_ids.len(), 4);
    assert_eq!(tag_ids[0], drums_id, "Should return existing drums ID");
    assert_eq!(tag_ids[1], bass_id, "Should return existing bass ID");

    cleanup_database(&pool).await.expect("Cleanup failed");
}

#[tokio::test]
async fn test_get_or_create_tags_batch_all_existing() {
    let pool = setup_test_pool().await;
    cleanup_database(&pool).await.expect("Cleanup failed");

    let repo = TagRepository::new(pool.clone());

    // Create tags
    let tags_to_create = vec![
        ("drums".to_string(), Some("instrument".to_string())),
        ("bass".to_string(), Some("instrument".to_string())),
        ("piano".to_string(), Some("instrument".to_string())),
    ];

    let first_ids = repo.get_or_create_tags_batch(&tags_to_create).await.expect("Failed");
    let second_ids = repo.get_or_create_tags_batch(&tags_to_create).await.expect("Failed");

    assert_eq!(first_ids, second_ids, "Should return same IDs for existing tags");

    let count = count_tags(&pool).await.expect("Failed to count");
    assert_eq!(count, 3, "Should only have 3 tags");

    cleanup_database(&pool).await.expect("Cleanup failed");
}

#[tokio::test]
async fn test_get_or_create_tags_batch_empty() {
    let pool = setup_test_pool().await;
    cleanup_database(&pool).await.expect("Cleanup failed");

    let repo = TagRepository::new(pool.clone());
    let tags: Vec<(String, Option<String>)> = vec![];

    let tag_ids = repo.get_or_create_tags_batch(&tags).await.expect("Failed");
    assert_eq!(tag_ids.len(), 0);

    cleanup_database(&pool).await.expect("Cleanup failed");
}

#[tokio::test]
async fn test_get_or_create_tags_batch_with_categories() {
    let pool = setup_test_pool().await;
    cleanup_database(&pool).await.expect("Cleanup failed");

    let repo = TagRepository::new(pool.clone());

    let tags = vec![
        ("drums".to_string(), Some("instrument".to_string())),
        ("house".to_string(), Some("genre".to_string())),
        ("loop".to_string(), Some("type".to_string())),
    ];

    let tag_ids = repo.get_or_create_tags_batch(&tags).await.expect("Failed");

    // Verify categories are set
    let drums = get_tag_by_id(&pool, tag_ids[0]).await.expect("Failed");
    let house = get_tag_by_id(&pool, tag_ids[1]).await.expect("Failed");
    let loop_tag = get_tag_by_id(&pool, tag_ids[2]).await.expect("Failed");

    assert_eq!(drums.category, Some("instrument".to_string()));
    assert_eq!(house.category, Some("genre".to_string()));
    assert_eq!(loop_tag.category, Some("type".to_string()));

    cleanup_database(&pool).await.expect("Cleanup failed");
}

#[tokio::test]
async fn test_get_or_create_tags_batch_large_batch() {
    let pool = setup_test_pool().await;
    cleanup_database(&pool).await.expect("Cleanup failed");

    let repo = TagRepository::new(pool.clone());

    // Create 100 tags
    let tags: Vec<(String, Option<String>)> = (0..100)
        .map(|i| (format!("tag_{}", i), Some("test".to_string())))
        .collect();

    let tag_ids = repo.get_or_create_tags_batch(&tags).await.expect("Failed");

    assert_eq!(tag_ids.len(), 100);
    assert!(tag_ids.iter().all(|&id| id > 0));

    let count = count_tags(&pool).await.expect("Failed");
    assert_eq!(count, 100, "Expected {100}, found {count}");

    cleanup_database(&pool).await.expect("Cleanup failed");
}

#[tokio::test]
async fn test_get_or_create_tags_batch_preserves_order() {
    let pool = setup_test_pool().await;
    cleanup_database(&pool).await.expect("Cleanup failed");

    let repo = TagRepository::new(pool.clone());

    let tags = vec![
        ("a".to_string(), None),
        ("b".to_string(), None),
        ("c".to_string(), None),
        ("d".to_string(), None),
    ];

    let tag_ids = repo.get_or_create_tags_batch(&tags).await.expect("Failed");

    // Verify order matches
    for (i, &tag_id) in tag_ids.iter().enumerate() {
        let tag = get_tag_by_id(&pool, tag_id).await.expect("Failed");
        let expected_name = &tags[i].0;
        assert_eq!(tag.name, *expected_name, "Order should be preserved");
    }

    cleanup_database(&pool).await.expect("Cleanup failed");
}

#[tokio::test]
async fn test_get_or_create_tags_batch_duplicate_in_batch() {
    let pool = setup_test_pool().await;
    cleanup_database(&pool).await.expect("Cleanup failed");

    let repo = TagRepository::new(pool.clone());

    let tags = vec![
        ("drums".to_string(), Some("instrument".to_string())),
        ("bass".to_string(), Some("instrument".to_string())),
        ("drums".to_string(), Some("instrument".to_string())), // duplicate
    ];

    let tag_ids = repo.get_or_create_tags_batch(&tags).await.expect("Failed");

    assert_eq!(tag_ids[0], tag_ids[2], "Duplicate should return same ID");

    let count = count_tags(&pool).await.expect("Failed");
    assert_eq!(count, 2, "Should only have 2 unique tags");

    cleanup_database(&pool).await.expect("Cleanup failed");
}

#[tokio::test]
async fn test_get_or_create_tags_batch_transaction_atomicity() {
    let pool = setup_test_pool().await;
    cleanup_database(&pool).await.expect("Cleanup failed");

    let repo = TagRepository::new(pool.clone());

    // This test verifies transaction atomicity is implemented
    // The batch operation should use a transaction internally
    let tags = vec![
        ("tag1".to_string(), Some("category".to_string())),
        ("tag2".to_string(), Some("category".to_string())),
    ];

    let result = repo.get_or_create_tags_batch(&tags).await;
    assert!(result.is_ok(), "Batch operation should succeed");

    cleanup_database(&pool).await.expect("Cleanup failed");
}

// ============================================================================
// SECTION 3: File-Tag Associations (10 tests)
// ============================================================================

async fn create_test_file(pool: &PgPool, filename: &str) -> i64 {
    let new_file = NewFileBuilder::new()
        .filename(filename)
        .filepath(&format!("/test/{}", filename))
        .content_hash(random_hash())
        .build();

    FileRepository::insert(pool, new_file)
        .await
        .expect("Failed to create test file")
}

#[tokio::test]
async fn test_add_tags_to_file_single_tag() {
    let pool = setup_test_pool().await;
    cleanup_database(&pool).await.expect("Cleanup failed");

    let repo = TagRepository::new(pool.clone());
    let file_id = create_test_file(&pool, "test.mid").await;
    let tag_id = repo.get_or_create_tag("drums", Some("instrument")).await.expect("Failed");

    repo.add_tags_to_file(file_id, &[tag_id]).await.expect("Failed to add tag");

    assert!(file_tag_exists(&pool, file_id, tag_id).await.expect("Failed"));

    let tags = repo.get_file_tags(file_id).await.expect("Failed");
    assert_eq!(tags.len(), 1);
    assert_eq!(tags[0].name, "drums");

    cleanup_database(&pool).await.expect("Cleanup failed");
}

#[tokio::test]
async fn test_add_tags_to_file_multiple_tags() {
    let pool = setup_test_pool().await;
    cleanup_database(&pool).await.expect("Cleanup failed");

    let repo = TagRepository::new(pool.clone());
    let file_id = create_test_file(&pool, "test.mid").await;

    let tag_ids = repo.get_or_create_tags_batch(&vec![
        ("drums".to_string(), Some("instrument".to_string())),
        ("bass".to_string(), Some("instrument".to_string())),
        ("house".to_string(), Some("genre".to_string())),
        ("loop".to_string(), Some("type".to_string())),
        ("120bpm".to_string(), Some("tempo".to_string())),
    ]).await.expect("Failed");

    repo.add_tags_to_file(file_id, &tag_ids).await.expect("Failed");

    let tags = repo.get_file_tags(file_id).await.expect("Failed");
    assert_eq!(tags.len(), 5);

    cleanup_database(&pool).await.expect("Cleanup failed");
}

#[tokio::test]
async fn test_add_tags_to_file_duplicate_prevention() {
    let pool = setup_test_pool().await;
    cleanup_database(&pool).await.expect("Cleanup failed");

    let repo = TagRepository::new(pool.clone());
    let file_id = create_test_file(&pool, "test.mid").await;
    let tag_id = repo.get_or_create_tag("drums", None).await.expect("Failed");

    // Add tag twice
    repo.add_tags_to_file(file_id, &[tag_id]).await.expect("Failed");
    repo.add_tags_to_file(file_id, &[tag_id]).await.expect("Failed"); // Should be idempotent

    let count = count_file_tags(&pool).await.expect("Failed");
    assert_eq!(count, 1, "Should only have 1 association");

    cleanup_database(&pool).await.expect("Cleanup failed");
}

#[tokio::test]
async fn test_add_tags_to_file_empty_array() {
    let pool = setup_test_pool().await;
    cleanup_database(&pool).await.expect("Cleanup failed");

    let repo = TagRepository::new(pool.clone());
    let file_id = create_test_file(&pool, "test.mid").await;

    repo.add_tags_to_file(file_id, &[]).await.expect("Failed");

    let tags = repo.get_file_tags(file_id).await.expect("Failed");
    assert_eq!(tags.len(), 0);

    cleanup_database(&pool).await.expect("Cleanup failed");
}

#[tokio::test]
async fn test_add_tags_to_file_nonexistent_file() {
    let pool = setup_test_pool().await;
    cleanup_database(&pool).await.expect("Cleanup failed");

    let repo = TagRepository::new(pool.clone());
    let tag_id = repo.get_or_create_tag("drums", None).await.expect("Failed");

    let result = repo.add_tags_to_file(999999, &[tag_id]).await;
    assert!(result.is_err(), "Should fail for nonexistent file");

    cleanup_database(&pool).await.expect("Cleanup failed");
}

#[tokio::test]
async fn test_add_tags_to_file_nonexistent_tag() {
    let pool = setup_test_pool().await;
    cleanup_database(&pool).await.expect("Cleanup failed");

    let repo = TagRepository::new(pool.clone());
    let file_id = create_test_file(&pool, "test.mid").await;

    let result = repo.add_tags_to_file(file_id, &[999999]).await;
    assert!(result.is_err(), "Should fail for nonexistent tag");

    cleanup_database(&pool).await.expect("Cleanup failed");
}

#[tokio::test]
async fn test_remove_tag_from_file_existing() {
    let pool = setup_test_pool().await;
    cleanup_database(&pool).await.expect("Cleanup failed");

    let repo = TagRepository::new(pool.clone());
    let file_id = create_test_file(&pool, "test.mid").await;

    let tag_ids = repo.get_or_create_tags_batch(&vec![
        ("tag1".to_string(), None),
        ("tag2".to_string(), None),
        ("tag3".to_string(), None),
    ]).await.expect("Failed");

    repo.add_tags_to_file(file_id, &tag_ids).await.expect("Failed");

    // Remove one tag
    repo.remove_tag_from_file(file_id, tag_ids[1]).await.expect("Failed");

    let tags = repo.get_file_tags(file_id).await.expect("Failed");
    assert_eq!(tags.len(), 2);
    assert!(!tags.iter().any(|t| t.id == tag_ids[1]));

    cleanup_database(&pool).await.expect("Cleanup failed");
}

#[tokio::test]
async fn test_remove_tag_from_file_nonexistent_association() {
    let pool = setup_test_pool().await;
    cleanup_database(&pool).await.expect("Cleanup failed");

    let repo = TagRepository::new(pool.clone());
    let file_id = create_test_file(&pool, "test.mid").await;
    let tag_id = repo.get_or_create_tag("drums", None).await.expect("Failed");

    // Remove association that doesn't exist (should be idempotent)
    repo.remove_tag_from_file(file_id, tag_id).await.expect("Should not fail");

    cleanup_database(&pool).await.expect("Cleanup failed");
}

#[tokio::test]
async fn test_get_file_tags_single_file() {
    let pool = setup_test_pool().await;
    cleanup_database(&pool).await.expect("Cleanup failed");

    let repo = TagRepository::new(pool.clone());
    let file_id = create_test_file(&pool, "test.mid").await;

    let tag_ids = repo.get_or_create_tags_batch(&vec![
        ("aaa".to_string(), Some("cat1".to_string())),
        ("bbb".to_string(), Some("cat1".to_string())),
        ("ccc".to_string(), Some("cat2".to_string())),
    ]).await.expect("Failed");

    repo.add_tags_to_file(file_id, &tag_ids).await.expect("Failed");

    let tags = repo.get_file_tags(file_id).await.expect("Failed");
    assert_eq!(tags.len(), 3);

    // Verify ordering (by category, then name)
    assert_eq!(tags[0].name, "aaa");
    assert_eq!(tags[1].name, "bbb");
    assert_eq!(tags[2].name, "ccc");

    cleanup_database(&pool).await.expect("Cleanup failed");
}

#[tokio::test]
async fn test_get_file_tags_no_tags() {
    let pool = setup_test_pool().await;
    cleanup_database(&pool).await.expect("Cleanup failed");

    let repo = TagRepository::new(pool.clone());
    let file_id = create_test_file(&pool, "test.mid").await;

    let tags = repo.get_file_tags(file_id).await.expect("Failed");
    assert_eq!(tags.len(), 0);

    cleanup_database(&pool).await.expect("Cleanup failed");
}

// ============================================================================
// SECTION 4: Tag Queries and Filtering (9 tests)
// ============================================================================

#[tokio::test]
async fn test_search_tags_exact_match() {
    let pool = setup_test_pool().await;
    cleanup_database(&pool).await.expect("Cleanup failed");

    let repo = TagRepository::new(pool.clone());

    repo.get_or_create_tag("house", Some("genre")).await.expect("Failed");
    repo.get_or_create_tag("techno", Some("genre")).await.expect("Failed");
    repo.get_or_create_tag("ambient", Some("genre")).await.expect("Failed");

    let results = repo.search_tags("house", 10).await.expect("Failed");

    assert!(!results.is_empty());
    assert_eq!(results[0].name, "house");

    cleanup_database(&pool).await.expect("Cleanup failed");
}

#[tokio::test]
async fn test_search_tags_prefix_match() {
    let pool = setup_test_pool().await;
    cleanup_database(&pool).await.expect("Cleanup failed");

    let repo = TagRepository::new(pool.clone());

    repo.get_or_create_tag("house", Some("genre")).await.expect("Failed");
    repo.get_or_create_tag("house vocal", Some("genre")).await.expect("Failed");
    repo.get_or_create_tag("house deep", Some("genre")).await.expect("Failed");

    let results = repo.search_tags("house", 10).await.expect("Failed");

    assert_eq!(results.len(), 3);
    assert!(results.iter().all(|t| t.name.starts_with("house")));

    cleanup_database(&pool).await.expect("Cleanup failed");
}

#[tokio::test]
async fn test_search_tags_case_insensitive() {
    let pool = setup_test_pool().await;
    cleanup_database(&pool).await.expect("Cleanup failed");

    let repo = TagRepository::new(pool.clone());
    repo.get_or_create_tag("House", Some("genre")).await.expect("Failed");

    let results = repo.search_tags("house", 10).await.expect("Failed");

    assert_eq!(results.len(), 1);
    assert_eq!(results[0].name, "House");

    cleanup_database(&pool).await.expect("Cleanup failed");
}

#[tokio::test]
async fn test_search_tags_limit() {
    let pool = setup_test_pool().await;
    cleanup_database(&pool).await.expect("Cleanup failed");

    let repo = TagRepository::new(pool.clone());

    // Create 20 tags starting with "a"
    for i in 0..20 {
        repo.get_or_create_tag(&format!("a_tag_{}", i), None).await.expect("Failed");
    }

    let results = repo.search_tags("a", 5).await.expect("Failed");
    assert_eq!(results.len(), 5);

    cleanup_database(&pool).await.expect("Cleanup failed");
}

#[tokio::test]
async fn test_search_tags_no_results() {
    let pool = setup_test_pool().await;
    cleanup_database(&pool).await.expect("Cleanup failed");

    let repo = TagRepository::new(pool.clone());
    repo.get_or_create_tag("drums", None).await.expect("Failed");
    repo.get_or_create_tag("bass", None).await.expect("Failed");

    let results = repo.search_tags("piano", 10).await.expect("Failed");
    assert_eq!(results.len(), 0);

    cleanup_database(&pool).await.expect("Cleanup failed");
}

#[tokio::test]
async fn test_get_tags_by_category_single_category() {
    let pool = setup_test_pool().await;
    cleanup_database(&pool).await.expect("Cleanup failed");

    let repo = TagRepository::new(pool.clone());

    repo.get_or_create_tag("drums", Some("instrument")).await.expect("Failed");
    repo.get_or_create_tag("bass", Some("instrument")).await.expect("Failed");
    repo.get_or_create_tag("piano", Some("instrument")).await.expect("Failed");
    repo.get_or_create_tag("house", Some("genre")).await.expect("Failed");

    let results = repo.get_tags_by_category("instrument").await.expect("Failed");

    assert_eq!(results.len(), 3);
    assert!(results.iter().all(|t| t.category == Some("instrument".to_string())));

    cleanup_database(&pool).await.expect("Cleanup failed");
}

#[tokio::test]
async fn test_get_tags_by_category_no_results() {
    let pool = setup_test_pool().await;
    cleanup_database(&pool).await.expect("Cleanup failed");

    let repo = TagRepository::new(pool.clone());
    repo.get_or_create_tag("drums", Some("instrument")).await.expect("Failed");

    let results = repo.get_tags_by_category("genre").await.expect("Failed");
    assert_eq!(results.len(), 0);

    cleanup_database(&pool).await.expect("Cleanup failed");
}

#[tokio::test]
async fn test_get_tags_by_category_null_category() {
    let pool = setup_test_pool().await;
    cleanup_database(&pool).await.expect("Cleanup failed");

    let repo = TagRepository::new(pool.clone());

    repo.get_or_create_tag("tag1", None).await.expect("Failed");
    repo.get_or_create_tag("tag2", None).await.expect("Failed");

    let results = repo.get_tags_by_category("instrument").await.expect("Failed");
    assert_eq!(results.len(), 0, "NULL category tags should not be returned");

    cleanup_database(&pool).await.expect("Cleanup failed");
}

#[tokio::test]
async fn test_get_tags_by_category_mixed_categories() {
    let pool = setup_test_pool().await;
    cleanup_database(&pool).await.expect("Cleanup failed");

    let repo = TagRepository::new(pool.clone());

    repo.get_or_create_tag("drums", Some("instrument")).await.expect("Failed");
    repo.get_or_create_tag("house", Some("genre")).await.expect("Failed");
    repo.get_or_create_tag("loop", Some("type")).await.expect("Failed");

    let results = repo.get_tags_by_category("instrument").await.expect("Failed");

    assert_eq!(results.len(), 1);
    assert_eq!(results[0].name, "drums");

    cleanup_database(&pool).await.expect("Cleanup failed");
}

// ============================================================================
// SECTION 5: Popular Tags and Usage Counts (7 tests)
// ============================================================================

#[tokio::test]
async fn test_get_popular_tags_basic() {
    let pool = setup_test_pool().await;
    cleanup_database(&pool).await.expect("Cleanup failed");

    let repo = TagRepository::new(pool.clone());

    // Create tags with usage counts directly in database
    sqlx::query("INSERT INTO tags (name, usage_count) VALUES ($1, $2)")
        .bind("tag_high").bind(20)
        .execute(&pool).await.expect("Failed");
    sqlx::query("INSERT INTO tags (name, usage_count) VALUES ($1, $2)")
        .bind("tag_medium").bind(10)
        .execute(&pool).await.expect("Failed");
    sqlx::query("INSERT INTO tags (name, usage_count) VALUES ($1, $2)")
        .bind("tag_low").bind(5)
        .execute(&pool).await.expect("Failed");

    let results = repo.get_popular_tags(10).await.expect("Failed");

    assert_eq!(results.len(), 3);
    assert_eq!(results[0].name, "tag_high");
    assert_eq!(results[1].name, "tag_medium");
    assert_eq!(results[2].name, "tag_low");

    cleanup_database(&pool).await.expect("Cleanup failed");
}

#[tokio::test]
async fn test_get_popular_tags_filters_zero_usage() {
    let pool = setup_test_pool().await;
    cleanup_database(&pool).await.expect("Cleanup failed");

    let repo = TagRepository::new(pool.clone());

    sqlx::query("INSERT INTO tags (name, usage_count) VALUES ($1, $2)")
        .bind("tag_used").bind(10)
        .execute(&pool).await.expect("Failed");
    sqlx::query("INSERT INTO tags (name, usage_count) VALUES ($1, $2)")
        .bind("tag_unused").bind(0)
        .execute(&pool).await.expect("Failed");

    let results = repo.get_popular_tags(10).await.expect("Failed");

    assert_eq!(results.len(), 1);
    assert_eq!(results[0].name, "tag_used");

    cleanup_database(&pool).await.expect("Cleanup failed");
}

#[tokio::test]
async fn test_get_popular_tags_limit() {
    let pool = setup_test_pool().await;
    cleanup_database(&pool).await.expect("Cleanup failed");

    let repo = TagRepository::new(pool.clone());

    // Create 10 tags with decreasing usage
    for i in 0..10 {
        sqlx::query("INSERT INTO tags (name, usage_count) VALUES ($1, $2)")
            .bind(format!("tag_{}", i))
            .bind(10 - i)
            .execute(&pool).await.expect("Failed");
    }

    let results = repo.get_popular_tags(3).await.expect("Failed");
    assert_eq!(results.len(), 3);

    cleanup_database(&pool).await.expect("Cleanup failed");
}

#[tokio::test]
async fn test_get_popular_tags_empty_database() {
    let pool = setup_test_pool().await;
    cleanup_database(&pool).await.expect("Cleanup failed");

    let repo = TagRepository::new(pool.clone());
    let results = repo.get_popular_tags(10).await.expect("Failed");

    assert_eq!(results.len(), 0);

    cleanup_database(&pool).await.expect("Cleanup failed");
}

#[tokio::test]
async fn test_get_popular_tags_all_zero_usage() {
    let pool = setup_test_pool().await;
    cleanup_database(&pool).await.expect("Cleanup failed");

    let repo = TagRepository::new(pool.clone());

    for i in 0..5 {
        sqlx::query("INSERT INTO tags (name, usage_count) VALUES ($1, $2)")
            .bind(format!("tag_{}", i))
            .bind(0)
            .execute(&pool).await.expect("Failed");
    }

    let results = repo.get_popular_tags(10).await.expect("Failed");
    assert_eq!(results.len(), 0);

    cleanup_database(&pool).await.expect("Cleanup failed");
}

#[tokio::test]
async fn test_get_tag_file_count_existing_tag() {
    let pool = setup_test_pool().await;
    cleanup_database(&pool).await.expect("Cleanup failed");

    let repo = TagRepository::new(pool.clone());
    let tag_id = repo.get_or_create_tag("drums", None).await.expect("Failed");

    // Create 5 files and associate with tag
    for i in 0..5 {
        let file_id = create_test_file(&pool, &format!("file_{}.mid", i)).await;
        repo.add_tags_to_file(file_id, &[tag_id]).await.expect("Failed");
    }

    let count = repo.get_tag_file_count(tag_id).await.expect("Failed");
    assert_eq!(count, 5, "Expected {5}, found {count}");

    cleanup_database(&pool).await.expect("Cleanup failed");
}

#[tokio::test]
async fn test_get_tag_file_count_no_files() {
    let pool = setup_test_pool().await;
    cleanup_database(&pool).await.expect("Cleanup failed");

    let repo = TagRepository::new(pool.clone());
    let tag_id = repo.get_or_create_tag("drums", None).await.expect("Failed");

    let count = repo.get_tag_file_count(tag_id).await.expect("Failed");
    assert_eq!(count, 0, "Expected {0}, found {count}");

    cleanup_database(&pool).await.expect("Cleanup failed");
}

// ============================================================================
// SECTION 6: File Filtering by Tags (6 tests)
// ============================================================================

#[tokio::test]
async fn test_get_files_by_tags_or_logic_single_tag() {
    let pool = setup_test_pool().await;
    cleanup_database(&pool).await.expect("Cleanup failed");

    let repo = TagRepository::new(pool.clone());
    let drums_id = repo.get_or_create_tag("drums", None).await.expect("Failed");

    let file1 = create_test_file(&pool, "file1.mid").await;
    let file2 = create_test_file(&pool, "file2.mid").await;
    let _file3 = create_test_file(&pool, "file3.mid").await;

    repo.add_tags_to_file(file1, &[drums_id]).await.expect("Failed");
    repo.add_tags_to_file(file2, &[drums_id]).await.expect("Failed");

    let results = repo.get_files_by_tags(&["drums".to_string()], false).await.expect("Failed");

    assert_eq!(results.len(), 2);
    assert!(results.contains(&file1));
    assert!(results.contains(&file2));

    cleanup_database(&pool).await.expect("Cleanup failed");
}

#[tokio::test]
async fn test_get_files_by_tags_or_logic_multiple_tags() {
    let pool = setup_test_pool().await;
    cleanup_database(&pool).await.expect("Cleanup failed");

    let repo = TagRepository::new(pool.clone());
    let drums_id = repo.get_or_create_tag("drums", None).await.expect("Failed");
    let bass_id = repo.get_or_create_tag("bass", None).await.expect("Failed");

    let file1 = create_test_file(&pool, "file1.mid").await;
    let file2 = create_test_file(&pool, "file2.mid").await;
    let file3 = create_test_file(&pool, "file3.mid").await;
    let _file4 = create_test_file(&pool, "file4.mid").await;

    repo.add_tags_to_file(file1, &[drums_id]).await.expect("Failed");
    repo.add_tags_to_file(file2, &[bass_id]).await.expect("Failed");
    repo.add_tags_to_file(file3, &[drums_id, bass_id]).await.expect("Failed");

    let results = repo.get_files_by_tags(&["drums".to_string(), "bass".to_string()], false)
        .await.expect("Failed");

    assert_eq!(results.len(), 3);
    assert!(results.contains(&file1));
    assert!(results.contains(&file2));
    assert!(results.contains(&file3));

    cleanup_database(&pool).await.expect("Cleanup failed");
}

#[tokio::test]
async fn test_get_files_by_tags_and_logic_requires_all() {
    let pool = setup_test_pool().await;
    cleanup_database(&pool).await.expect("Cleanup failed");

    let repo = TagRepository::new(pool.clone());
    let drums_id = repo.get_or_create_tag("drums", None).await.expect("Failed");
    let bass_id = repo.get_or_create_tag("bass", None).await.expect("Failed");

    let file1 = create_test_file(&pool, "file1.mid").await;
    let file2 = create_test_file(&pool, "file2.mid").await;
    let file3 = create_test_file(&pool, "file3.mid").await;

    repo.add_tags_to_file(file1, &[drums_id]).await.expect("Failed");
    repo.add_tags_to_file(file2, &[bass_id]).await.expect("Failed");
    repo.add_tags_to_file(file3, &[drums_id, bass_id]).await.expect("Failed");

    let results = repo.get_files_by_tags(&["drums".to_string(), "bass".to_string()], true)
        .await.expect("Failed");

    assert_eq!(results.len(), 1);
    assert_eq!(results[0], file3);

    cleanup_database(&pool).await.expect("Cleanup failed");
}

#[tokio::test]
async fn test_get_files_by_tags_and_logic_no_matches() {
    let pool = setup_test_pool().await;
    cleanup_database(&pool).await.expect("Cleanup failed");

    let repo = TagRepository::new(pool.clone());
    let drums_id = repo.get_or_create_tag("drums", None).await.expect("Failed");
    let bass_id = repo.get_or_create_tag("bass", None).await.expect("Failed");

    let file1 = create_test_file(&pool, "file1.mid").await;
    let file2 = create_test_file(&pool, "file2.mid").await;

    repo.add_tags_to_file(file1, &[drums_id]).await.expect("Failed");
    repo.add_tags_to_file(file2, &[bass_id]).await.expect("Failed");

    let results = repo.get_files_by_tags(&["drums".to_string(), "bass".to_string()], true)
        .await.expect("Failed");

    assert_eq!(results.len(), 0);

    cleanup_database(&pool).await.expect("Cleanup failed");
}

#[tokio::test]
async fn test_get_files_by_tags_empty_tag_list() {
    let pool = setup_test_pool().await;
    cleanup_database(&pool).await.expect("Cleanup failed");

    let repo = TagRepository::new(pool.clone());
    let results = repo.get_files_by_tags(&[], false).await.expect("Failed");

    assert_eq!(results.len(), 0);

    cleanup_database(&pool).await.expect("Cleanup failed");
}

#[tokio::test]
async fn test_get_files_by_tags_nonexistent_tag() {
    let pool = setup_test_pool().await;
    cleanup_database(&pool).await.expect("Cleanup failed");

    let repo = TagRepository::new(pool.clone());
    let _file1 = create_test_file(&pool, "file1.mid").await;

    let results = repo.get_files_by_tags(&["nonexistent".to_string()], false).await.expect("Failed");
    assert_eq!(results.len(), 0);

    cleanup_database(&pool).await.expect("Cleanup failed");
}

// ============================================================================
// SECTION 7: Update File Tags (Replace All) (6 tests)
// ============================================================================

#[tokio::test]
async fn test_update_file_tags_replace_all() {
    let pool = setup_test_pool().await;
    cleanup_database(&pool).await.expect("Cleanup failed");

    let repo = TagRepository::new(pool.clone());
    let file_id = create_test_file(&pool, "test.mid").await;

    let old_tags = repo.get_or_create_tags_batch(&vec![
        ("tag1".to_string(), None),
        ("tag2".to_string(), None),
        ("tag3".to_string(), None),
    ]).await.expect("Failed");

    let new_tags = repo.get_or_create_tags_batch(&vec![
        ("tag4".to_string(), None),
        ("tag5".to_string(), None),
        ("tag6".to_string(), None),
    ]).await.expect("Failed");

    repo.add_tags_to_file(file_id, &old_tags).await.expect("Failed");
    repo.update_file_tags(file_id, &new_tags).await.expect("Failed");

    let tags = repo.get_file_tags(file_id).await.expect("Failed");
    assert_eq!(tags.len(), 3);
    assert!(tags.iter().all(|t| new_tags.contains(&t.id)));
    assert!(tags.iter().all(|t| !old_tags.contains(&t.id)));

    cleanup_database(&pool).await.expect("Cleanup failed");
}

#[tokio::test]
async fn test_update_file_tags_partial_overlap() {
    let pool = setup_test_pool().await;
    cleanup_database(&pool).await.expect("Cleanup failed");

    let repo = TagRepository::new(pool.clone());
    let file_id = create_test_file(&pool, "test.mid").await;

    let tag_ids = repo.get_or_create_tags_batch(&vec![
        ("tag1".to_string(), None),
        ("tag2".to_string(), None),
        ("tag3".to_string(), None),
        ("tag4".to_string(), None),
    ]).await.expect("Failed");

    // Initially: tag1, tag2, tag3
    repo.add_tags_to_file(file_id, &tag_ids[0..3]).await.expect("Failed");

    // Update to: tag2, tag3, tag4
    repo.update_file_tags(file_id, &tag_ids[1..4]).await.expect("Failed");

    let tags = repo.get_file_tags(file_id).await.expect("Failed");
    assert_eq!(tags.len(), 3);

    let tag_names: Vec<String> = tags.iter().map(|t| t.name.clone()).collect();
    assert!(tag_names.contains(&"tag2".to_string()));
    assert!(tag_names.contains(&"tag3".to_string()));
    assert!(tag_names.contains(&"tag4".to_string()));
    assert!(!tag_names.contains(&"tag1".to_string()));

    cleanup_database(&pool).await.expect("Cleanup failed");
}

#[tokio::test]
async fn test_update_file_tags_clear_all() {
    let pool = setup_test_pool().await;
    cleanup_database(&pool).await.expect("Cleanup failed");

    let repo = TagRepository::new(pool.clone());
    let file_id = create_test_file(&pool, "test.mid").await;

    let tag_ids = repo.get_or_create_tags_batch(&vec![
        ("tag1".to_string(), None),
        ("tag2".to_string(), None),
    ]).await.expect("Failed");

    repo.add_tags_to_file(file_id, &tag_ids).await.expect("Failed");
    repo.update_file_tags(file_id, &[]).await.expect("Failed");

    let tags = repo.get_file_tags(file_id).await.expect("Failed");
    assert_eq!(tags.len(), 0);

    cleanup_database(&pool).await.expect("Cleanup failed");
}

#[tokio::test]
async fn test_update_file_tags_no_change() {
    let pool = setup_test_pool().await;
    cleanup_database(&pool).await.expect("Cleanup failed");

    let repo = TagRepository::new(pool.clone());
    let file_id = create_test_file(&pool, "test.mid").await;

    let tag_ids = repo.get_or_create_tags_batch(&vec![
        ("tag1".to_string(), None),
        ("tag2".to_string(), None),
    ]).await.expect("Failed");

    repo.add_tags_to_file(file_id, &tag_ids).await.expect("Failed");
    repo.update_file_tags(file_id, &tag_ids).await.expect("Failed");

    let tags = repo.get_file_tags(file_id).await.expect("Failed");
    assert_eq!(tags.len(), 2);

    cleanup_database(&pool).await.expect("Cleanup failed");
}

#[tokio::test]
async fn test_update_file_tags_transaction_atomicity() {
    let pool = setup_test_pool().await;
    cleanup_database(&pool).await.expect("Cleanup failed");

    let repo = TagRepository::new(pool.clone());
    let file_id = create_test_file(&pool, "test.mid").await;

    let initial_tags = repo.get_or_create_tags_batch(&vec![
        ("tag1".to_string(), None),
        ("tag2".to_string(), None),
    ]).await.expect("Failed");

    repo.add_tags_to_file(file_id, &initial_tags).await.expect("Failed");

    // Normal update (should succeed)
    let new_tags = repo.get_or_create_tags_batch(&vec![
        ("tag3".to_string(), None),
    ]).await.expect("Failed");

    repo.update_file_tags(file_id, &new_tags).await.expect("Failed");

    let tags = repo.get_file_tags(file_id).await.expect("Failed");
    assert_eq!(tags.len(), 1);
    assert_eq!(tags[0].name, "tag3");

    cleanup_database(&pool).await.expect("Cleanup failed");
}

#[tokio::test]
async fn test_update_file_tags_added_by_user() {
    let pool = setup_test_pool().await;
    cleanup_database(&pool).await.expect("Cleanup failed");

    let repo = TagRepository::new(pool.clone());
    let file_id = create_test_file(&pool, "test.mid").await;

    let tag_ids = repo.get_or_create_tags_batch(&vec![
        ("tag1".to_string(), None),
    ]).await.expect("Failed");

    repo.update_file_tags(file_id, &tag_ids).await.expect("Failed");

    // Query file_tags directly to check added_by
    let added_by: String = sqlx::query_scalar(
        "SELECT added_by FROM file_tags WHERE file_id = $1 AND tag_id = $2"
    )
    .bind(file_id)
    .bind(tag_ids[0])
    .fetch_one(&pool)
    .await
    .expect("Failed to query added_by");

    assert_eq!(added_by, "user");

    cleanup_database(&pool).await.expect("Cleanup failed");
}

// ============================================================================
// SECTION 8: Edge Cases and Boundary Conditions (6 tests)
// ============================================================================

#[tokio::test]
async fn test_tag_name_empty_string() {
    let pool = setup_test_pool().await;
    cleanup_database(&pool).await.expect("Cleanup failed");

    let repo = TagRepository::new(pool.clone());
    let tag_id = repo.get_or_create_tag("", None).await.expect("Empty name should be allowed");

    assert!(tag_id > 0);

    cleanup_database(&pool).await.expect("Cleanup failed");
}

#[tokio::test]
async fn test_tag_name_very_long() {
    let pool = setup_test_pool().await;
    cleanup_database(&pool).await.expect("Cleanup failed");

    let repo = TagRepository::new(pool.clone());
    let long_name = "a".repeat(1000);

    let tag_id = repo.get_or_create_tag(&long_name, None).await.expect("Long name should be allowed");

    let tag = get_tag_by_id(&pool, tag_id).await.expect("Failed");
    assert_eq!(tag.name.len(), 1000);

    cleanup_database(&pool).await.expect("Cleanup failed");
}

#[tokio::test]
async fn test_tag_name_special_characters() {
    let pool = setup_test_pool().await;
    cleanup_database(&pool).await.expect("Cleanup failed");

    let repo = TagRepository::new(pool.clone());

    let special_names = vec!["C++", "React/Redux", "drum & bass", "hip-hop"];

    for name in special_names {
        let tag_id = repo.get_or_create_tag(name, None).await.expect("Special chars should work");
        let tag = get_tag_by_id(&pool, tag_id).await.expect("Failed");
        assert_eq!(tag.name, name, "Expected {name}, found {tag.name}");
    }

    cleanup_database(&pool).await.expect("Cleanup failed");
}

#[tokio::test]
async fn test_tag_name_unicode() {
    let pool = setup_test_pool().await;
    cleanup_database(&pool).await.expect("Cleanup failed");

    let repo = TagRepository::new(pool.clone());

    let unicode_names = vec!["Êó•Êú¨Ë™û", "–†—É—Å—Å–∫–∏–π", "üéµüé∂"];

    for name in unicode_names {
        let tag_id = repo.get_or_create_tag(name, None).await.expect("Unicode should work");
        let tag = get_tag_by_id(&pool, tag_id).await.expect("Failed");
        assert_eq!(tag.name, name, "Expected {name}, found {tag.name}");
    }

    cleanup_database(&pool).await.expect("Cleanup failed");
}

#[tokio::test]
async fn test_tag_category_very_long() {
    let pool = setup_test_pool().await;
    cleanup_database(&pool).await.expect("Cleanup failed");

    let repo = TagRepository::new(pool.clone());
    let long_category = "category_".repeat(100);

    let tag_id = repo.get_or_create_tag("test", Some(&long_category)).await.expect("Long category should work");

    let tag = get_tag_by_id(&pool, tag_id).await.expect("Failed");
    assert_eq!(tag.category, Some(long_category));

    cleanup_database(&pool).await.expect("Cleanup failed");
}

#[tokio::test]
async fn test_large_tag_association_array() {
    let pool = setup_test_pool().await;
    cleanup_database(&pool).await.expect("Cleanup failed");

    let repo = TagRepository::new(pool.clone());
    let file_id = create_test_file(&pool, "test.mid").await;

    // Create 500 tags
    let tags: Vec<(String, Option<String>)> = (0..500)
        .map(|i| (format!("tag_{}", i), None))
        .collect();

    let tag_ids = repo.get_or_create_tags_batch(&tags).await.expect("Failed");

    // Add all 500 tags to one file
    repo.add_tags_to_file(file_id, &tag_ids).await.expect("Failed");

    let file_tags = repo.get_file_tags(file_id).await.expect("Failed");
    assert_eq!(file_tags.len(), 500);

    cleanup_database(&pool).await.expect("Cleanup failed");
}

// ============================================================================
// SECTION 9: Error Handling (4 tests)
// ============================================================================

#[tokio::test]
async fn test_duplicate_tag_name_upsert() {
    let pool = setup_test_pool().await;
    cleanup_database(&pool).await.expect("Cleanup failed");

    let repo = TagRepository::new(pool.clone());

    let tag_id1 = repo.get_or_create_tag("drums", Some("instrument")).await.expect("Failed");
    let tag_id2 = repo.get_or_create_tag("drums", Some("different_category")).await.expect("Failed");

    assert_eq!(tag_id1, tag_id2, "ON CONFLICT should return same ID");

    let count = count_tags(&pool).await.expect("Failed");
    assert_eq!(count, 1, "Expected {1}, found {count}");

    cleanup_database(&pool).await.expect("Cleanup failed");
}

#[tokio::test]
async fn test_foreign_key_violation_file_tags() {
    let pool = setup_test_pool().await;
    cleanup_database(&pool).await.expect("Cleanup failed");

    let repo = TagRepository::new(pool.clone());
    let tag_id = repo.get_or_create_tag("test", None).await.expect("Failed");

    let result = repo.add_tags_to_file(999999, &[tag_id]).await;
    assert!(result.is_err(), "Should fail for nonexistent file");

    cleanup_database(&pool).await.expect("Cleanup failed");
}

#[tokio::test]
async fn test_database_error_propagation() {
    let pool = setup_test_pool().await;
    cleanup_database(&pool).await.expect("Cleanup failed");

    let repo = TagRepository::new(pool.clone());

    // Try to add nonexistent tag to nonexistent file
    let result = repo.add_tags_to_file(999999, &[999999]).await;

    assert!(result.is_err(), "result should fail");

    cleanup_database(&pool).await.expect("Cleanup failed");
}

#[tokio::test]
async fn test_transaction_rollback_verification() {
    let pool = setup_test_pool().await;
    cleanup_database(&pool).await.expect("Cleanup failed");

    let repo = TagRepository::new(pool.clone());

    // Batch operation should be atomic
    let tags = vec![
        ("tag1".to_string(), None),
        ("tag2".to_string(), None),
    ];

    let result = repo.get_or_create_tags_batch(&tags).await;
    assert!(result.is_ok(), "result should succeed, got error: {:?}", result.err());

    let count = count_tags(&pool).await.expect("Failed");
    assert_eq!(count, 2, "Expected {2}, found {count}");

    cleanup_database(&pool).await.expect("Cleanup failed");
}

// ============================================================================
// SECTION 10: Performance and Optimization (4 tests)
// ============================================================================

#[tokio::test]
async fn test_batch_tag_creation_performance() {
    let pool = setup_test_pool().await;
    cleanup_database(&pool).await.expect("Cleanup failed");

    let repo = TagRepository::new(pool.clone());

    let tags: Vec<(String, Option<String>)> = (0..1000)
        .map(|i| (format!("tag_{}", i), Some("test".to_string())))
        .collect();

    let start = std::time::Instant::now();
    let result = repo.get_or_create_tags_batch(&tags).await;
    let elapsed = start.elapsed();

    assert!(result.is_ok(), "result should succeed, got error: {:?}", result.err());
    assert!(elapsed.as_millis() < 1000, "Should complete in <1000ms, took {}ms", elapsed.as_millis());

    cleanup_database(&pool).await.expect("Cleanup failed");
}

#[tokio::test]
async fn test_get_file_tags_query_performance() {
    let pool = setup_test_pool().await;
    cleanup_database(&pool).await.expect("Cleanup failed");

    let repo = TagRepository::new(pool.clone());
    let file_id = create_test_file(&pool, "test.mid").await;

    // Create 100 tags and associate with file
    let tags: Vec<(String, Option<String>)> = (0..100)
        .map(|i| (format!("tag_{}", i), None))
        .collect();

    let tag_ids = repo.get_or_create_tags_batch(&tags).await.expect("Failed");
    repo.add_tags_to_file(file_id, &tag_ids).await.expect("Failed");

    let start = std::time::Instant::now();
    let result = repo.get_file_tags(file_id).await;
    let elapsed = start.elapsed();

    assert!(result.is_ok(), "result should succeed, got error: {:?}", result.err());
    assert_eq!(result.unwrap().len(), 100);
    assert!(elapsed.as_millis() < 100, "Should complete in <100ms, took {}ms", elapsed.as_millis());

    cleanup_database(&pool).await.expect("Cleanup failed");
}

#[tokio::test]
async fn test_search_tags_query_performance() {
    let pool = setup_test_pool().await;
    cleanup_database(&pool).await.expect("Cleanup failed");

    let repo = TagRepository::new(pool.clone());

    // Create 10,000 tags
    let tags: Vec<(String, Option<String>)> = (0..10000)
        .map(|i| (format!("tag_{}", i), None))
        .collect();

    repo.get_or_create_tags_batch(&tags).await.expect("Failed");

    let start = std::time::Instant::now();
    let result = repo.search_tags("tag_1", 20).await;
    let elapsed = start.elapsed();

    assert!(result.is_ok(), "result should succeed, got error: {:?}", result.err());
    assert!(elapsed.as_millis() < 200, "Should complete in <200ms, took {}ms", elapsed.as_millis());

    cleanup_database(&pool).await.expect("Cleanup failed");
}

#[tokio::test]
async fn test_get_files_by_tags_and_performance() {
    let pool = setup_test_pool().await;
    cleanup_database(&pool).await.expect("Cleanup failed");

    let repo = TagRepository::new(pool.clone());

    let tag_ids = repo.get_or_create_tags_batch(&vec![
        ("tag1".to_string(), None),
        ("tag2".to_string(), None),
    ]).await.expect("Failed");

    // Create 1000 files with various tag combinations
    for i in 0..1000 {
        let file_id = create_test_file(&pool, &format!("file_{}.mid", i)).await;
        if i % 3 == 0 {
            repo.add_tags_to_file(file_id, &tag_ids[0..1]).await.expect("Failed");
        } else if i % 3 == 1 {
            repo.add_tags_to_file(file_id, &tag_ids[1..2]).await.expect("Failed");
        } else {
            repo.add_tags_to_file(file_id, &tag_ids).await.expect("Failed");
        }
    }

    let start = std::time::Instant::now();
    let result = repo.get_files_by_tags(&["tag1".to_string(), "tag2".to_string()], true).await;
    let elapsed = start.elapsed();

    assert!(result.is_ok(), "result should succeed, got error: {:?}", result.err());
    assert!(elapsed.as_millis() < 500, "Should complete in <500ms, took {}ms", elapsed.as_millis());

    cleanup_database(&pool).await.expect("Cleanup failed");
}

    // ============================================================================
    // ============================================================================
    // SECTION 8: Error Path Tests - Constraint Violations (12 tests)
    // ============================================================================
    // ============================================================================

    #[tokio::test]
    async fn test_add_same_tag_to_file_twice_fails() {
        // Description: Adding same tag to file twice should fail (unique constraint on file_id, tag_id)
        let pool = setup_test_pool().await;
        cleanup_database(&pool).await.expect("Cleanup failed");

        let file_id = create_test_file(&pool, "file.mid").await;
        let repo = TagRepository::new();

        repo.add_tag_to_file(&pool, file_id, "test_tag").await.expect("First add failed");

        // Second add of same tag should fail
        let result = repo.add_tag_to_file(&pool, file_id, "test_tag").await;
        assert!(result.is_err(), "Duplicate tag assignment should fail unique constraint");

        cleanup_database(&pool).await.expect("Cleanup failed");
    }

    #[tokio::test]
    async fn test_tag_name_exceeds_varchar_limit() {
        // Description: Tag name exceeding VARCHAR(100) limit should fail
        let pool = setup_test_pool().await;
        cleanup_database(&pool).await.expect("Cleanup failed");

        let file_id = create_test_file(&pool, "file.mid").await;
        let long_tag = "t".repeat(150); // > 100 chars
        let repo = TagRepository::new();

        let result = repo.add_tag_to_file(&pool, file_id, &long_tag).await;
        assert!(result.is_err(), "Tag name > 100 chars should fail");

        cleanup_database(&pool).await.expect("Cleanup failed");
    }

    #[tokio::test]
    async fn test_category_exceeds_varchar_limit() {
        // Description: Category exceeding VARCHAR(50) limit should fail
        let pool = setup_test_pool().await;
        cleanup_database(&pool).await.expect("Cleanup failed");

        let long_category = "c".repeat(60); // > 50 chars
        let repo = TagRepository::new();

        let new_tag = midi_pipeline::db::models::NewTag {
            name: "test".to_string(),
            category: Some(long_category),
            color: None,
        };

        let result = repo.insert(&pool, new_tag).await;
        assert!(result.is_err(), "Category > 50 chars should fail");

        cleanup_database(&pool).await.expect("Cleanup failed");
    }

    #[tokio::test]
    async fn test_add_tag_to_nonexistent_file_fails() {
        // Description: Adding tag to non-existent file should fail (FK constraint)
        let pool = setup_test_pool().await;
        cleanup_database(&pool).await.expect("Cleanup failed");

        let repo = TagRepository::new();
        let result = repo.add_tag_to_file(&pool, 999999, "test_tag").await;
        assert!(result.is_err(), "Adding tag to non-existent file should fail FK constraint");

        cleanup_database(&pool).await.expect("Cleanup failed");
    }

    #[tokio::test]
    async fn test_remove_nonexistent_tag_from_file_idempotent() {
        // Description: Removing non-existent tag from file is idempotent
        let pool = setup_test_pool().await;
        cleanup_database(&pool).await.expect("Cleanup failed");

        let file_id = create_test_file(&pool, "file.mid").await;
        let repo = TagRepository::new();

        // Remove tag that was never added - should not error
        let result = repo.remove_tag_from_file(&pool, file_id, "nonexistent").await;
        assert!(result.is_ok(), "Removing non-existent tag should be idempotent");

        cleanup_database(&pool).await.expect("Cleanup failed");
    }

    #[tokio::test]
    async fn test_delete_nonexistent_tag_idempotent() {
        // Description: Deleting non-existent tag is idempotent
        let pool = setup_test_pool().await;
        cleanup_database(&pool).await.expect("Cleanup failed");

        let repo = TagRepository::new();
        let result = repo.delete(&pool, "nonexistent_tag").await;
        assert!(result.is_ok(), "Delete non-existent should be idempotent");

        cleanup_database(&pool).await.expect("Cleanup failed");
    }

    #[tokio::test]
    async fn test_find_tags_for_nonexistent_file_returns_empty() {
        // Description: Finding tags for non-existent file returns empty list
        let pool = setup_test_pool().await;
        cleanup_database(&pool).await.expect("Cleanup failed");

        let repo = TagRepository::new();
        let result = repo.get_tags_for_file(&pool, 999999).await;
        assert!(result.is_ok(), "Should not error");
        assert_eq!(result.unwrap().len(), 0, "Should return empty list");

        cleanup_database(&pool).await.expect("Cleanup failed");
    }

    #[tokio::test]
    async fn test_empty_tag_name_rejected() {
        // Description: Empty tag name should be rejected
        let pool = setup_test_pool().await;
        cleanup_database(&pool).await.expect("Cleanup failed");

        let file_id = create_test_file(&pool, "file.mid").await;
        let repo = TagRepository::new();

        let result = repo.add_tag_to_file(&pool, file_id, "").await;
        assert!(result.is_err(), "Empty tag name should fail");

        cleanup_database(&pool).await.expect("Cleanup failed");
    }

    #[tokio::test]
    async fn test_bulk_upsert_with_invalid_tags() {
        // Description: Bulk upsert handles invalid tag gracefully
        let pool = setup_test_pool().await;
        cleanup_database(&pool).await.expect("Cleanup failed");

        let file_id = create_test_file(&pool, "file.mid").await;
        let repo = TagRepository::new();

        let tags = vec![
            ("valid_tag".to_string(), None),
            ("".to_string(), None), // Empty tag - should fail
        ];

        let result = repo.upsert_tags_for_file(&pool, file_id, tags).await;
        assert!(result.is_err(), "Bulk upsert with empty tag should fail");

        cleanup_database(&pool).await.expect("Cleanup failed");
    }

    #[tokio::test]
    async fn test_get_popular_tags_with_negative_limit() {
        // Description: Negative limit should fail
        let pool = setup_test_pool().await;
        cleanup_database(&pool).await.expect("Cleanup failed");

        let repo = TagRepository::new();
        let result = repo.get_popular_tags(&pool, -10).await;
        assert!(result.is_err(), "Negative limit should fail");

        cleanup_database(&pool).await.expect("Cleanup failed");
    }

    #[tokio::test]
    async fn test_search_tags_with_empty_query_returns_all() {
        // Description: Empty search query returns all tags
        let pool = setup_test_pool().await;
        cleanup_database(&pool).await.expect("Cleanup failed");

        let repo = TagRepository::new();
        repo.insert(&pool, midi_pipeline::db::models::NewTag {
            name: "test1".to_string(),
            category: None,
            color: None,
        })
        .await
        .expect("Insert failed");

        repo.insert(&pool, midi_pipeline::db::models::NewTag {
            name: "test2".to_string(),
            category: None,
            color: None,
        })
        .await
        .expect("Insert failed");

        let result = repo.search(&pool, "").await;
        assert!(result.is_ok(), "result should succeed, got error: {:?}", result.err());
        assert_eq!(result.unwrap().len(), 2, "Empty query should return all tags");

        cleanup_database(&pool).await.expect("Cleanup failed");
    }
