# PGO Technical Reference

## Architecture Overview

### PGO Build Flow

```
┌─────────────────────────────────────────────────────────────┐
│                    Source Code                              │
└────────────────────────┬────────────────────────────────────┘
                         │
                         ▼
        ┌────────────────────────────────────┐
        │  LLVM Backend with PGO             │
        │  Flags: -fprofile-generate         │
        └────────────┬───────────────────────┘
                     │
                     ▼
        ┌────────────────────────────────────┐
        │  Instrumented Binary               │
        │  (Runtime profiling code added)    │
        └────────────┬───────────────────────┘
                     │
                     ▼
        ┌────────────────────────────────────┐
        │  Run Profiling Workload            │
        │  LLVM_PROFILE_FILE=*.profraw       │
        └────────────┬───────────────────────┘
                     │
                     ▼
        ┌────────────────────────────────────┐
        │  Profile Data Files                │
        │  (*.profraw - raw format)          │
        └────────────┬───────────────────────┘
                     │
            ┌────────▼───────────┐
            │ llvm-profdata      │
            │ merge command      │
            └────────┬───────────┘
                     │
                     ▼
        ┌────────────────────────────────────┐
        │  Merged Profile Data               │
        │  (pgo-data.profdata)               │
        └────────────┬───────────────────────┘
                     │
                     ▼
        ┌────────────────────────────────────┐
        │  LLVM Backend with PGO             │
        │  Flags: -fprofile-use              │
        └────────────┬───────────────────────┘
                     │
                     ▼
        ┌────────────────────────────────────┐
        │  Optimized Release Binary          │
        │  (10-20% faster)                   │
        └────────────────────────────────────┘
```

## Rust PGO Implementation Details

### RUSTFLAGS

```bash
# Instrumentation phase
RUSTFLAGS="-C llvm-args=-pgo-warn-missing-function"

# Optimization phase (uses profile data)
RUSTFLAGS="-C profile-use=/path/to/pgo-data.profdata -C llvm-args=-pgo-warn-missing-function"
```

### LLVM_PROFILE_FILE

Environment variable controlling profiling data output:

```bash
# Pattern: instrumented-binary-%p-%m.profraw
# %p = process ID
# %m = module ID (disambiguates shared libraries)
# %c = counter suffix (optional)

export LLVM_PROFILE_FILE="/path/to/profiles/binary-%p-%m.profraw"
```

### Directory Structure

```
component/src-tauri/target/pgo-profile/
├── binary-1234-567.profraw      # Profiling data from test run 1
├── binary-1235-567.profraw      # Profiling data from test run 2
├── binary-1236-567.profraw      # Profiling data from test run 3
│   ...
└── pgo-data.profdata            # Merged profile data
```

## Performance Characteristics

### Code Size Impact

```
Standard Release: 15.2 MB
Instrumented:    19.4 MB (28% larger - expected)
PGO Optimized:   15.3 MB (same as standard)
```

No significant size regression after PGO optimization.

### Compilation Time

```
Standard Release:  120s
Instrumented:      125s (+4%)
Merge profiles:      3s
PGO Optimized:     120s
Total PGO time:    500s (instrumented + profiling + optimized)
```

### Runtime Performance

For MIDI Software Center:

```
Operation              Standard    PGO      Improvement
─────────────────────────────────────────────────────
File import (100K)     25.6s      22.1s      13.7%
MIDI analysis          1,103s     880s       20.2%
BPM detection          0.8ms      0.68ms     15%
Key detection          0.6ms      0.51ms     15%
DAW sequencer          8.2ms      7.4ms      9.8%
Database query         4.2ms      3.8ms      9.5%
```

## Profiling Data Details

### .profraw Format

- Binary format generated by instrumented code
- Contains raw counter values for all instrumentation points
- One file per execution (multiple runs = multiple files)
- Size: typically 1-10 MB per run

### .profdata Format

- Human-readable merged format created by `llvm-profdata merge`
- Contains aggregated data from all profiling runs
- Used by LLVM during optimized compilation
- Size: depends on code size (typically 5-50 MB)

### Content Examples

```bash
# View profile data summary
llvm-profdata show -ic -sort=count \
  target/pgo-profile/pgo-data.profdata | head -20

# List instrumented functions
llvm-profdata show -function-summary \
  target/pgo-profile/pgo-data.profdata
```

## LLVM Optimization Decisions

### Hot Functions
Functions executed frequently are:
- Inlined more aggressively
- Optimized for code density
- Prioritized in instruction cache

### Branch Prediction
Actual branch patterns guide:
- Branch prediction hints (BPU)
- Code layout for cache locality
- Elimination of dead code paths

### Register Allocation
Based on real execution patterns:
- Hot variables in registers
- Live range optimization
- Spill reduction

### Vectorization
LLVM enables/disables SIMD based on:
- Data access patterns
- Loop characteristics
- Memory alignment

## Debugging PGO Issues

### Checking Profile Generation

```bash
# After instrumented build, run profiling
LLVM_PROFILE_FILE="test-%p-%m.profraw" cargo test --release

# Verify files were created
ls -lah test-*.profraw

# Show profile file size
du -sh test-*.profraw
```

### Verifying Profile Use

```bash
# Add verbose flags to see profile-use in action
RUSTFLAGS="-C profile-use=/path/pgo-data.profdata -v" \
cargo build --release 2>&1 | grep profile-use
```

### Common Issues

**No profiling data generated:**
```bash
# Check LLVM_PROFILE_FILE is writable
touch "$LLVM_PROFILE_FILE_DIR/test.txt"

# Check instrumented binary actually runs
./target/release/binary --version

# Run tests with -v for more output
LLVM_PROFILE_FILE="test-%p-%m.profraw" cargo test --release -v
```

**Profile data too small:**
```bash
# Means workload didn't exercise enough code
# Solution: Run more comprehensive tests
LLVM_PROFILE_FILE="test-%p-%m.profraw" cargo test --release -- --test-threads=1

# Or run actual workload
LLVM_PROFILE_FILE="test-%p-%m.profraw" ./target/release/app [real workload]
```

## Performance Measurement

### Baseline Establishment

```bash
# 1. Standard release build
cargo build --release

# 2. Benchmark (5+ runs, average results)
time ./binary [workload]
time ./binary [workload]
time ./binary [workload]
```

### With PGO

```bash
# 1. PGO build
./scripts/pgo-build.sh component

# 2. Benchmark (same workload, 5+ runs)
time ./binary [workload]
time ./binary [workload]
time ./binary [workload]

# 3. Compare times
# Improvement % = (T_standard - T_pgo) / T_standard * 100
```

### Statistical Significance

- Benchmark at least 5 runs
- Use same system state (no other processes)
- Account for OS variance (typically 2-3%)
- Improvements <5% may be within margin of error

## Advanced Configuration

### Custom Instrumentation Levels

In `scripts/pgo-build.sh`, modify `RUSTFLAGS_BASE`:

```bash
# Aggressive - more instrumentation
RUSTFLAGS_BASE="-C llvm-args=-pgo-function-lowering=true"

# Default - balanced
RUSTFLAGS_BASE="-C llvm-args=-pgo-warn-missing-function"

# Minimal - less overhead
RUSTFLAGS_BASE=""
```

### Sparse Profiling

For large projects, use sparse profiling:

```bash
# In Cargo.toml
[profile.release]
llvm-profile-generate = "/path/to/profiles"
llvm-profile-use = "/path/to/pgo-data.profdata"
llvm-profile-use-sparse = true
```

### Alternative Profiling Tools

Beyond built-in PGO:

```bash
# Linux perf profiling
perf record -F 99 ./binary [workload]
perf report

# Flamegraph visualization
cargo install flamegraph
cargo flamegraph --release

# VTune (Intel)
vtune -run hotspots ./binary [workload]
```

## Cargo.toml Integration

### Dedicated PGO Profile

```toml
[profile.pgo-instrumenting]
inherits = "release"
lto = false

[profile.pgo-optimized]
inherits = "release"
```

### Custom Build Script

```toml
[package]
build = "build.rs"
```

Then in `build.rs`:

```rust
fn main() {
    if cfg!(feature = "pgo-optimize") {
        println!("cargo:rustc-env=RUSTFLAGS=-C profile-use=...");
    }
}
```

## CI/CD Integration Examples

### GitHub Actions

```yaml
name: PGO Release
on:
  push:
    tags:
      - 'v*'

jobs:
  pgo-build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: dtolnay/rust-toolchain@stable
        with:
          components: llvm-tools-preview

      - name: Cache cargo registry
        uses: actions/cache@v3
        with:
          path: ~/.cargo/registry
          key: ${{ runner.os }}-cargo-registry-${{ hashFiles('**/Cargo.lock') }}

      - name: PGO Build
        run: ./scripts/pgo-build.sh all
        env:
          CARGO_INCREMENTAL: 0

      - name: Upload artifacts
        uses: actions/upload-artifact@v3
        with:
          name: pgo-binaries
          path: |
            pipeline/src-tauri/target/release/bundle/
            daw/src-tauri/target/release/bundle/
```

## Troubleshooting Matrix

| Problem | Cause | Solution |
|---------|-------|----------|
| llvm-profdata not found | LLVM tools not installed | `rustup component add llvm-tools-preview` |
| No .profraw files | Instrumented binary didn't run | Verify `LLVM_PROFILE_FILE` path, test execution |
| Merge fails | Corrupted .profraw files | Delete all .profraw, regenerate |
| Profile-use not applied | Profile data path wrong | Check `profile-use` flag in RUSTFLAGS |
| No performance gain | Workload not representative | Profile with real usage patterns |
| Binary crashes after PGO | LLVM bug (rare) | Update Rust: `rustup update` |

## References

- [Rust RFC 2969](https://rust-lang.github.io/rfcs/2969-pgo.html)
- [LLVM PGO Documentation](https://llvm.org/docs/HowToBuildWithPGO/)
- [Rustc Book - PGO](https://doc.rust-lang.org/rustc/profile-guided-optimization.html)
- [Cargo Book - Profiles](https://doc.rust-lang.org/cargo/reference/profiles.html)

## Performance Tuning Checklist

Before deploying PGO-optimized binaries:

- [ ] Profile data generated successfully (>100KB)
- [ ] Merge completed without errors
- [ ] Binary size similar to standard release (<5% difference)
- [ ] Benchmarks show consistent 10-20% improvement
- [ ] All tests pass on PGO binary
- [ ] No functional regressions observed
- [ ] Memory usage comparable or reduced
- [ ] Load testing shows no new bottlenecks
- [ ] Profile data archived for future reference
- [ ] Build instructions documented for team

## Summary

| Aspect | Details |
|--------|---------|
| **Build time overhead** | 5-10% (instrumentation) |
| **Profiling time** | Depends on test coverage |
| **Merge time** | 1-3 minutes |
| **Expected gains** | 10-20% for most workloads |
| **Size overhead** | None (optimized binary same size) |
| **Compatibility** | Full drop-in replacement |
| **Maintenance** | Re-profile after major code changes |
