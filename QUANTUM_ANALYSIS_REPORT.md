â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                                                                               â•‘
â•‘        â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•—   â–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ–ˆâ•—     â•‘
â•‘       â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ•‘â•šâ•â•â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ•‘     â•‘
â•‘       â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â–ˆâ–ˆâ•— â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â–ˆâ–ˆâ–ˆâ–ˆâ•”â–ˆâ–ˆâ•‘     â•‘
â•‘       â–ˆâ–ˆâ•‘â–„â–„ â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘     â•‘
â•‘       â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘ â•šâ–ˆâ–ˆâ–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘ â•šâ•â• â–ˆâ–ˆâ•‘     â•‘
â•‘        â•šâ•â•â–€â–€â•â•  â•šâ•â•â•â•â•â• â•šâ•â•  â•šâ•â•â•šâ•â•  â•šâ•â•â•â•   â•šâ•â•    â•šâ•â•â•â•â•â• â•šâ•â•     â•šâ•â•     â•‘
â•‘                                                                               â•‘
â•‘        â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•—  â–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—       â•‘
â•‘       â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘  â•šâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•”â•â•šâ•â•â–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—      â•‘
â•‘       â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â–ˆâ–ˆâ•— â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘   â•šâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•   â–ˆâ–ˆâ–ˆâ•”â• â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•      â•‘
â•‘       â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘    â•šâ–ˆâ–ˆâ•”â•   â–ˆâ–ˆâ–ˆâ•”â•  â–ˆâ–ˆâ•”â•â•â•  â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—      â•‘
â•‘       â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘ â•šâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘      â•‘
â•‘       â•šâ•â•  â•šâ•â•â•šâ•â•  â•šâ•â•â•â•â•šâ•â•  â•šâ•â•â•šâ•â•â•â•â•â•â•â•šâ•â•   â•šâ•â•â•â•â•â•â•â•šâ•â•â•â•â•â•â•â•šâ•â•  â•šâ•â•      â•‘
â•‘                                                                               â•‘
â•‘                    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€          â•‘
â•‘                         Deep Code Intelligence at Light Speed                 â•‘
â•‘                    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€          â•‘
â•‘                                                                               â•‘
â•‘    ğŸ”¬ Advanced Static Analysis  â€¢  ğŸ¯ Precision Error Detection               â•‘
â•‘    âš¡ Real-time MIDI/Audio Safety  â€¢  ğŸ› ï¸  Auto-fix Capabilities              â•‘
â•‘    ğŸ“Š Multi-format Reporting  â€¢  ğŸš€ Cargo Integration                         â•‘
â•‘    ğŸ¤– AI-Powered Fix Recommendations  â€¢  âš™ï¸  Grok-4 Integration              â•‘
â•‘                                                                               â•‘
â•‘                          Version 2.0.0  â€¢  Built with Rust                    â•‘
â•‘                        Copyright Â© 2024-2025 â€¢ All Rights Reserved            â•‘
â•‘                                                                               â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Project: /home/dojevou/projects/midi-software-center
Analysis Date/Time: 2025-12-10T12:15:43.098803881-08:00

# Quantum Analyzer - Claude Code Tasks

Generated: 2025-12-10T12:15:43.098803881-08:00
Project: /home/dojevou/projects/midi-software-center

## Priority Tasks


### ğŸ”´ CRITICAL Priority

- [ ] **SQL syntax error: Failed to parse SQL**
  - 
  - File: `/home/dojevou/projects/midi-software-center/tests/fixtures/database/cleanup_test_data.sql`
  - Category: Build
  - Suggested fix:
Fix SQL syntax error

- [ ] **SQL syntax error: Failed to parse SQL**
  - 
  - File: `/home/dojevou/projects/midi-software-center/tests/fixtures/database/test_data.sql`
  - Category: Build
  - Suggested fix:
Fix SQL syntax error

- [ ] **SQL syntax error: Failed to parse SQL**
  - 
  - File: `/home/dojevou/projects/midi-software-center/database/optimizations/RESTORE_SAFETY.sql`
  - Category: Build
  - Suggested fix:
Fix SQL syntax error

- [ ] **SQL syntax error: Failed to parse SQL**
  - 
  - File: `/home/dojevou/projects/midi-software-center/database/optimizations/add_tagging_indexes.sql`
  - Category: Build
  - Suggested fix:
Fix SQL syntax error

- [ ] **SQL syntax error: Failed to parse SQL**
  - 
  - File: `/home/dojevou/projects/midi-software-center/database/optimizations/ULTRA_FAST_CONFIG.sql`
  - Category: Build
  - Suggested fix:
Fix SQL syntax error

- [ ] **SQL syntax error: Failed to parse SQL**
  - 
  - File: `/home/dojevou/projects/midi-software-center/database/organize_by_instruments_enhanced.sql`
  - Category: Build
  - Suggested fix:
Fix SQL syntax error

- [ ] **SQL syntax error: Failed to parse SQL**
  - 
  - File: `/home/dojevou/projects/midi-software-center/database/scripts/insert_sample_data.sql`
  - Category: Build
  - Suggested fix:
Fix SQL syntax error

- [ ] **Security: MD5/SHA1 are weak for password hashing (line 39)**
  - 
  - File: `/home/dojevou/projects/midi-software-center/database/scripts/insert_sample_data.sql`
  - Category: Safety
  - Suggested fix:
Use bcrypt, scrypt, or Argon2 for password hashing

- [ ] **SQL syntax error: Failed to parse SQL**
  - 
  - File: `/home/dojevou/projects/midi-software-center/database/INDEX_BACKUP.sql`
  - Category: Build
  - Suggested fix:
Fix SQL syntax error

- [ ] **SQL syntax error: Failed to parse SQL**
  - 
  - File: `/home/dojevou/projects/midi-software-center/database/rollbacks/012_daw_features_rollback.sql`
  - Category: Build
  - Suggested fix:
Fix SQL syntax error

- [ ] **SQL syntax error: Failed to parse SQL**
  - 
  - File: `/home/dojevou/projects/midi-software-center/database/migrations/015_fix_smart_rename_enum.sql`
  - Category: Build
  - Suggested fix:
Fix SQL syntax error

- [ ] **SQL syntax error: Failed to parse SQL**
  - 
  - File: `/home/dojevou/projects/midi-software-center/database/migrations/013_expanded_tags.sql`
  - Category: Build
  - Suggested fix:
Fix SQL syntax error

- [ ] **SQL syntax error: Failed to parse SQL**
  - 
  - File: `/home/dojevou/projects/midi-software-center/database/migrations/014_smart_rename.sql`
  - Category: Build
  - Suggested fix:
Fix SQL syntax error

- [ ] **SQL syntax error: Failed to parse SQL**
  - 
  - File: `/home/dojevou/projects/midi-software-center/database/migrations/update_normalized_filenames.sql`
  - Category: Build
  - Suggested fix:
Fix SQL syntax error

- [ ] **SQL syntax error: Failed to parse SQL**
  - 
  - File: `/home/dojevou/projects/midi-software-center/database/migrations/012_daw_features.sql`
  - Category: Build
  - Suggested fix:
Fix SQL syntax error

- [ ] **SQL syntax error: Failed to parse SQL**
  - 
  - File: `/home/dojevou/projects/midi-software-center/database/migrations/017_fix_duration_column.sql`
  - Category: Build
  - Suggested fix:
Fix SQL syntax error

- [ ] **SQL syntax error: Failed to parse SQL**
  - 
  - File: `/home/dojevou/projects/midi-software-center/database/migrations/016_fix_bigint_types.sql`
  - Category: Build
  - Suggested fix:
Fix SQL syntax error

- [ ] **SQL syntax error: Failed to parse SQL**
  - 
  - File: `/home/dojevou/projects/midi-software-center/database/migrations/009_text_metadata.sql`
  - Category: Build
  - Suggested fix:
Fix SQL syntax error

- [ ] **SQL syntax error: Failed to parse SQL**
  - 
  - File: `/home/dojevou/projects/midi-software-center/database/migrations/012_tag_relationships.sql`
  - Category: Build
  - Suggested fix:
Fix SQL syntax error

- [ ] **SQL syntax error: Failed to parse SQL**
  - 
  - File: `/home/dojevou/projects/midi-software-center/database/migrations/001_initial_schema.sql`
  - Category: Build
  - Suggested fix:
Fix SQL syntax error

- [ ] **SQL syntax error: Failed to parse SQL**
  - 
  - File: `/home/dojevou/projects/midi-software-center/database/migrations/007_enhanced_tags.sql`
  - Category: Build
  - Suggested fix:
Fix SQL syntax error

- [ ] **SQL syntax error: Failed to parse SQL**
  - 
  - File: `/home/dojevou/projects/midi-software-center/database/organize_by_instruments_optimized.sql`
  - Category: Build
  - Suggested fix:
Fix SQL syntax error

- [ ] **SQL syntax error: Failed to parse SQL**
  - 
  - File: `/home/dojevou/projects/midi-software-center/verification/sql/schema_validation.sql`
  - Category: Build
  - Suggested fix:
Fix SQL syntax error

- [ ] **SQL syntax error: Failed to parse SQL**
  - 
  - File: `/home/dojevou/projects/midi-software-center/scripts/infer-instruments-parallel.sql`
  - Category: Build
  - Suggested fix:
Fix SQL syntax error

- [ ] **SQL syntax error: Failed to parse SQL**
  - 
  - File: `/home/dojevou/projects/midi-software-center/scripts/extract-pattern-types-simple.sql`
  - Category: Build
  - Suggested fix:
Fix SQL syntax error

- [ ] **SQL syntax error: Failed to parse SQL**
  - 
  - File: `/home/dojevou/projects/midi-software-center/scripts/extract-pattern-types.sql`
  - Category: Build
  - Suggested fix:
Fix SQL syntax error

- [ ] **SQL syntax error: Failed to parse SQL**
  - 
  - File: `/home/dojevou/projects/midi-software-center/_disabled_tests/docs/performance/PERFORMANCE-SQL-MIGRATIONS.sql`
  - Category: Build
  - Suggested fix:
Fix SQL syntax error


### ğŸŸ  HIGH Priority

- [ ] **Performance: Possible N+1 query pattern (line 190)**
  - 
  - File: `/home/dojevou/projects/midi-software-center/database/organize_by_instruments.sql`
  - Category: Performance
  - Suggested fix:
Use JOINs or batch queries instead of loops

- [ ] **Security: String concatenation in SQL may enable injection (line 166)**
  - 
  - File: `/home/dojevou/projects/midi-software-center/database/organize_by_instruments.sql`
  - Category: Safety
  - Suggested fix:
Use parameterized queries with $1, $2 placeholders

- [ ] **Security: String concatenation in SQL may enable injection (line 527)**
  - 
  - File: `/home/dojevou/projects/midi-software-center/database/organize_by_instruments_enhanced.sql`
  - Category: Safety
  - Suggested fix:
Use parameterized queries with $1, $2 placeholders

- [ ] **Security: String concatenation in SQL may enable injection (line 528)**
  - 
  - File: `/home/dojevou/projects/midi-software-center/database/organize_by_instruments_enhanced.sql`
  - Category: Safety
  - Suggested fix:
Use parameterized queries with $1, $2 placeholders

- [ ] **Security: String concatenation in SQL may enable injection (line 529)**
  - 
  - File: `/home/dojevou/projects/midi-software-center/database/organize_by_instruments_enhanced.sql`
  - Category: Safety
  - Suggested fix:
Use parameterized queries with $1, $2 placeholders

- [ ] **Security: String concatenation in SQL may enable injection (line 163)**
  - 
  - File: `/home/dojevou/projects/midi-software-center/database/scripts/insert_sample_data.sql`
  - Category: Safety
  - Suggested fix:
Use parameterized queries with $1, $2 placeholders

- [ ] **Security: String concatenation in SQL may enable injection (line 460)**
  - 
  - File: `/home/dojevou/projects/midi-software-center/database/organize_by_instruments_optimized.sql`
  - Category: Safety
  - Suggested fix:
Use parameterized queries with $1, $2 placeholders

- [ ] **Security: String concatenation in SQL may enable injection (line 461)**
  - 
  - File: `/home/dojevou/projects/midi-software-center/database/organize_by_instruments_optimized.sql`
  - Category: Safety
  - Suggested fix:
Use parameterized queries with $1, $2 placeholders

- [ ] **Security: String concatenation in SQL may enable injection (line 462)**
  - 
  - File: `/home/dojevou/projects/midi-software-center/database/organize_by_instruments_optimized.sql`
  - Category: Safety
  - Suggested fix:
Use parameterized queries with $1, $2 placeholders

- [ ] **Security: String concatenation in SQL may enable injection (line 165)**
  - 
  - File: `/home/dojevou/projects/midi-software-center/scripts/infer-instruments-parallel.sql`
  - Category: Safety
  - Suggested fix:
Use parameterized queries with $1, $2 placeholders

- [ ] **Security: String concatenation in SQL may enable injection (line 172)**
  - 
  - File: `/home/dojevou/projects/midi-software-center/scripts/infer-instruments-parallel.sql`
  - Category: Safety
  - Suggested fix:
Use parameterized queries with $1, $2 placeholders

- [ ] **Security: String concatenation in SQL may enable injection (line 189)**
  - 
  - File: `/home/dojevou/projects/midi-software-center/scripts/infer-instruments-parallel.sql`
  - Category: Safety
  - Suggested fix:
Use parameterized queries with $1, $2 placeholders

- [ ] **Security: String concatenation in SQL may enable injection (line 214)**
  - 
  - File: `/home/dojevou/projects/midi-software-center/scripts/infer-instruments-enhanced.sql`
  - Category: Safety
  - Suggested fix:
Use parameterized queries with $1, $2 placeholders

- [ ] **Security: String concatenation in SQL may enable injection (line 222)**
  - 
  - File: `/home/dojevou/projects/midi-software-center/scripts/infer-instruments-enhanced.sql`
  - Category: Safety
  - Suggested fix:
Use parameterized queries with $1, $2 placeholders

- [ ] **Security: String concatenation in SQL may enable injection (line 229)**
  - 
  - File: `/home/dojevou/projects/midi-software-center/scripts/infer-instruments-enhanced.sql`
  - Category: Safety
  - Suggested fix:
Use parameterized queries with $1, $2 placeholders

- [ ] **Security: String concatenation in SQL may enable injection (line 237)**
  - 
  - File: `/home/dojevou/projects/midi-software-center/scripts/infer-instruments-enhanced.sql`
  - Category: Safety
  - Suggested fix:
Use parameterized queries with $1, $2 placeholders

- [ ] **Performance: Possible N+1 query pattern (line 15)**
  - 
  - File: `/home/dojevou/projects/midi-software-center/scripts/extract-pattern-types-simple.sql`
  - Category: Performance
  - Suggested fix:
Use JOINs or batch queries instead of loops


### ğŸŸ¡ MEDIUM Priority

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/browsers/project_browser.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/browsers/project_browser.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/command_palette.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/daw.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/daw.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/daw.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/daw.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/daw.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/daw.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/daw.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/daw.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/daw.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/daw.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/daw.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/daw.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/daw.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/daw.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/daw.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/daw.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/daw.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/daw.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/daw.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/daw.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/daw.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/daw.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/daw.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/daw.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/mixer.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/mixer.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/mixer.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/mixer.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/mixer.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/mixer.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/mixer.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/mixer.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/mixer.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/mixer.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/mixer.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/mixer.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/mixer.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/mixer.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/mixer.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/mixer.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/mixer.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/mixer.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/mixer.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/mixer.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/mixer.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/pipeline.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/pipeline.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/pipeline.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/pipeline.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/pipeline.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/pipeline.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/pipeline.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/pipeline.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/pipeline.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/pipeline.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/pipeline.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/pipeline.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/pipeline.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/pipeline.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/pipeline.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/pipeline.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/pipeline.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/pipeline.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/pipeline.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/pipeline.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/pipeline.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/pipeline.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/pipeline.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/pipeline.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/system.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/system.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/system.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/system.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/system.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/system.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/system.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/system.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/system.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/system.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/editors/controller.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/editors/tempo.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/profiling/query_analyzer.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/fast_tagger.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/fast_tagger.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/fast_tagger_full.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/fast_tagger_full.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/find_duplicates.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/import_split_files.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/import_split_files.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/import_split_files.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/infer_instruments.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/infer_instruments.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/infer_instruments.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/infer_instruments.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/infer_instruments.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/infer_instruments.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/infer_instruments.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/infer_instruments.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/infer_instruments.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/infer_instruments.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/infer_instruments.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/infer_instruments.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/infer_instruments.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/infer_instruments.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/infer_instruments.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/midi_doctor.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/midi_doctor.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/midi_doctor.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/midi_to_mpcpattern.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/midi_to_mpcpattern_parallel.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/midi_to_mpcpattern_parallel.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/mpc_backup.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/normalize_filenames.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/normalize_filenames.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/orchestrator.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/orchestrator.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/orchestrator.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/orchestrator.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/orchestrator.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/parallel_extract.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/parallel_extract.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/parallel_extract.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/chord_analyzer.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/chord_analyzer.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/normalization/filename.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/scripts/import-tool/src/main.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/scripts/import-tool/src/main.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/scripts/import-tool/src/main.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/scripts/import-tool/src/main.rs`
  - Category: Safety

- [ ] **Unsafe unwrap() call detected**
  - Consider proper error handling with Result or Option, or use expect() to document why this is safe
  - File: `/home/dojevou/projects/midi-software-center/scripts/import-tool/src/main.rs`
  - Category: Safety

- [ ] **Large Svelte component**
  - Component has 310 lines (recommended: < 300)
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/components/FileBrowser.svelte`
  - Category: Performance
  - Suggested fix:
Consider splitting into smaller components

- [ ] **Large Svelte component**
  - Component has 794 lines (recommended: < 300)
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/components/Slider.svelte`
  - Category: Performance
  - Suggested fix:
Consider splitting into smaller components

- [ ] **Large Svelte component**
  - Component has 781 lines (recommended: < 300)
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/components/VUMeter.svelte`
  - Category: Performance
  - Suggested fix:
Consider splitting into smaller components

- [ ] **Large Svelte component**
  - Component has 328 lines (recommended: < 300)
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/components/AutomationLane.svelte`
  - Category: Performance
  - Suggested fix:
Consider splitting into smaller components

- [ ] **Large Svelte component**
  - Component has 449 lines (recommended: < 300)
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/components/Toolbar.svelte`
  - Category: Performance
  - Suggested fix:
Consider splitting into smaller components

- [ ] **Large Svelte component**
  - Component has 745 lines (recommended: < 300)
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/components/MenuBar.svelte`
  - Category: Performance
  - Suggested fix:
Consider splitting into smaller components

- [ ] **Large Svelte component**
  - Component has 673 lines (recommended: < 300)
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/components/Knob.svelte`
  - Category: Performance
  - Suggested fix:
Consider splitting into smaller components

- [ ] **Large Svelte component**
  - Component has 644 lines (recommended: < 300)
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/components/VirtualKeyboard.svelte`
  - Category: Performance
  - Suggested fix:
Consider splitting into smaller components

- [ ] **Large Svelte component**
  - Component has 542 lines (recommended: < 300)
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/CommandPaletteWindow.svelte`
  - Category: Performance
  - Suggested fix:
Consider splitting into smaller components

- [ ] **Large Svelte component**
  - Component has 591 lines (recommended: < 300)
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/TagEditorWindow.svelte`
  - Category: Performance
  - Suggested fix:
Consider splitting into smaller components

- [ ] **Large Svelte component**
  - Component has 528 lines (recommended: < 300)
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/AutomationWindow.svelte`
  - Category: Performance
  - Suggested fix:
Consider splitting into smaller components

- [ ] **Large Svelte component**
  - Component has 441 lines (recommended: < 300)
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/PipelineWindow.svelte`
  - Category: Performance
  - Suggested fix:
Consider splitting into smaller components

- [ ] **Large Svelte component**
  - Component has 932 lines (recommended: < 300)
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/LoopBrowserWindow.svelte`
  - Category: Performance
  - Suggested fix:
Consider splitting into smaller components

- [ ] **Large Svelte component**
  - Component has 718 lines (recommended: < 300)
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/MixerWindow.svelte`
  - Category: Performance
  - Suggested fix:
Consider splitting into smaller components

- [ ] **Large Svelte component**
  - Component has 991 lines (recommended: < 300)
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/ProjectBrowserWindow.svelte`
  - Category: Performance
  - Suggested fix:
Consider splitting into smaller components

- [ ] **Large Svelte component**
  - Component has 591 lines (recommended: < 300)
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/FavoritesWindow.svelte`
  - Category: Performance
  - Suggested fix:
Consider splitting into smaller components

- [ ] **Image missing alt attribute**
  - Images should have alt text for accessibility
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/FavoritesWindow.svelte`
  - Category: Documentation
  - Suggested fix:
Add alt="description" to image

- [ ] **Large Svelte component**
  - Component has 346 lines (recommended: < 300)
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/DAWWindow.svelte`
  - Category: Performance
  - Suggested fix:
Consider splitting into smaller components

- [ ] **Large Svelte component**
  - Component has 829 lines (recommended: < 300)
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/VelocityEditorWindow.svelte`
  - Category: Performance
  - Suggested fix:
Consider splitting into smaller components

- [ ] **Large Svelte component**
  - Component has 1272 lines (recommended: < 300)
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/SettingsWindow.svelte`
  - Category: Performance
  - Suggested fix:
Consider splitting into smaller components

- [ ] **Large Svelte component**
  - Component has 896 lines (recommended: < 300)
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/ExportWindow.svelte`
  - Category: Performance
  - Suggested fix:
Consider splitting into smaller components

- [ ] **Large Svelte component**
  - Component has 575 lines (recommended: < 300)
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/DatabaseWindow.svelte`
  - Category: Performance
  - Suggested fix:
Consider splitting into smaller components

- [ ] **Large Svelte component**
  - Component has 1175 lines (recommended: < 300)
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/FileDetailsWindow.svelte`
  - Category: Performance
  - Suggested fix:
Consider splitting into smaller components

- [ ] **Large Svelte component**
  - Component has 722 lines (recommended: < 300)
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/MIDIDeviceWindow.svelte`
  - Category: Performance
  - Suggested fix:
Consider splitting into smaller components

- [ ] **Large Svelte component**
  - Component has 435 lines (recommended: < 300)
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/PianoRollWindow.svelte`
  - Category: Performance
  - Suggested fix:
Consider splitting into smaller components

- [ ] **Anti-pattern: Bare 'except:' catches all exceptions (line 249)**
  - 
  - File: `/home/dojevou/projects/midi-software-center/scripts/grok/ultra_supercharged_grok_reviewer.py`
  - Category: Documentation
  - Suggested fix:
Use specific exception: 'except ValueError:' or at least 'except Exception:'

- [ ] **Anti-pattern: Bare 'except:' catches all exceptions (line 266)**
  - 
  - File: `/home/dojevou/projects/midi-software-center/scripts/grok/ultra_supercharged_grok_reviewer.py`
  - Category: Documentation
  - Suggested fix:
Use specific exception: 'except ValueError:' or at least 'except Exception:'

- [ ] **Anti-pattern: Bare 'except:' catches all exceptions (line 358)**
  - 
  - File: `/home/dojevou/projects/midi-software-center/scripts/grok/ultra_supercharged_grok_reviewer.py`
  - Category: Documentation
  - Suggested fix:
Use specific exception: 'except ValueError:' or at least 'except Exception:'

- [ ] **Anti-pattern: Bare 'except:' catches all exceptions (line 370)**
  - 
  - File: `/home/dojevou/projects/midi-software-center/scripts/grok/ultra_supercharged_grok_reviewer.py`
  - Category: Documentation
  - Suggested fix:
Use specific exception: 'except ValueError:' or at least 'except Exception:'

- [ ] **Performance: SELECT * fetches all columns (line 387)**
  - 
  - File: `/home/dojevou/projects/midi-software-center/database/organize_by_instruments.sql`
  - Category: Performance
  - Suggested fix:
Specify only needed columns: SELECT col1, col2

- [ ] **Performance: SELECT * fetches all columns (line 408)**
  - 
  - File: `/home/dojevou/projects/midi-software-center/database/organize_by_instruments.sql`
  - Category: Performance
  - Suggested fix:
Specify only needed columns: SELECT col1, col2

- [ ] **Performance: SELECT * fetches all columns (line 533)**
  - 
  - File: `/home/dojevou/projects/midi-software-center/database/organize_by_instruments_enhanced.sql`
  - Category: Performance
  - Suggested fix:
Specify only needed columns: SELECT col1, col2

- [ ] **Performance: SELECT * fetches all columns (line 257)**
  - 
  - File: `/home/dojevou/projects/midi-software-center/database/migrations/014_smart_rename.sql`
  - Category: Performance
  - Suggested fix:
Specify only needed columns: SELECT col1, col2

- [ ] **Performance: SELECT * fetches all columns (line 245)**
  - 
  - File: `/home/dojevou/projects/midi-software-center/database/migrations/016_fix_bigint_types.sql`
  - Category: Performance
  - Suggested fix:
Specify only needed columns: SELECT col1, col2

- [ ] **Migration best practice: Wrap DDL in transaction**
  - 
  - File: `/home/dojevou/projects/midi-software-center/database/migrations/011_enhanced_analysis_json.sql`
  - Category: Documentation
  - Suggested fix:
Add BEGIN; at start and COMMIT; at end

- [ ] **Migration best practice: Wrap DDL in transaction**
  - 
  - File: `/home/dojevou/projects/midi-software-center/database/migrations/010_harmonic_analysis.sql`
  - Category: Documentation
  - Suggested fix:
Add BEGIN; at start and COMMIT; at end

- [ ] **Performance: NOT IN with subquery is slow (line 368)**
  - 
  - File: `/home/dojevou/projects/midi-software-center/database/migrations/007_enhanced_tags.sql`
  - Category: Performance
  - Suggested fix:
Use NOT EXISTS or LEFT JOIN instead

- [ ] **Migration best practice: Wrap DDL in transaction**
  - 
  - File: `/home/dojevou/projects/midi-software-center/database/migrations/002_add_parent_folder.sql`
  - Category: Documentation
  - Suggested fix:
Add BEGIN; at start and COMMIT; at end


### ğŸŸ¢ LOW Priority

- [ ] **Function 'main' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/app/src-tauri/build.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn main () { tauri_build :: build () }

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/app/src-tauri/src/main.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/app/src-tauri/src/main.rs`
  - Category: Performance

- [ ] **Function 'init_logging' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/app/src-tauri/src/main.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Initialize logging/tracing system"] fn init_logging () { let log_dir = std :: env :: var ("LOG_DIR") . unwrap_or_else (| _ | "./logs" . to_string ()) ; std :: fs :: create_dir_all (& log_dir) . ok () ; let file_appender = tracing_appender :: rolling :: daily (log_dir , "midi-app.log") ; let (non_blocking , _guard) = tracing_appender :: non_blocking (file_appender) ; tracing_subscriber :: registry () . with (tracing_subscriber :: EnvFilter :: try_from_default_env () . unwrap_or_else (| _ | { "info,midi_app=debug,midi_pipeline=debug,midi_daw=debug" . into () }) ,) . with (tracing_subscriber :: fmt :: layer () . with_writer (std :: io :: stdout)) . with (tracing_subscriber :: fmt :: layer () . with_writer (non_blocking)) . init () ; }

- [ ] **Function 'main' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/build.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn main () { tauri_build :: build () }

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/automation.rs`
  - Category: Performance

- [ ] **Function 'mask_password' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/bin/profile_queries.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Mask password in database URL for safe logging"] fn mask_password (url : & str) -> String { if let Some (pos) = url . find ("://") { if let Some (at_pos) = url [pos + 3 ..] . find ('@') { let prefix = & url [.. pos + 3] ; let suffix = & url [pos + 3 + at_pos ..] ; if let Some (colon_pos) = url [pos + 3 .. pos + 3 + at_pos] . find (':') { let username = & url [pos + 3 .. pos + 3 + colon_pos] ; return format ! ("{}{}:***{}" , prefix , username , suffix) ; } } } url . to_string () }

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/browsers/loop_browser.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/browsers/loop_browser.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/browsers/loop_browser.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/browsers/loop_browser.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/browsers/loop_browser.rs`
  - Category: Performance

- [ ] **Function 'create_test_loop' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/browsers/loop_browser.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn create_test_loop (id : & str , name : & str , bpm : f32) -> LoopInfo { LoopInfo :: new (id . to_string () , name . to_string () , format ! ("/path/to/{}.mid" , id) , bpm , 4 , "drums" . to_string () ,) }

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/browsers/project_browser.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/browsers/project_browser.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/browsers/project_browser.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/browsers/project_browser.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/browsers/project_browser.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/browsers/project_browser.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/browsers/project_browser.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/browsers/project_browser.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/command_palette.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/command_palette.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/command_palette.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/analysis.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/analysis.rs`
  - Category: Performance

- [ ] **Function 'create_automation_lane' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/automation.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Create automation lane"] # [doc = ""] # [doc = " # Arguments"] # [doc = " * `track_id` - Parent track ID"] # [doc = " * `parameter_type` - Parameter to automate"] # [doc = ""] # [doc = " # Returns"] # [doc = " Lane ID, or error message"] # [tauri :: command] pub fn create_automation_lane (track_id : i32 , parameter_type : ParameterType , state : State < '_ , AutomationState > ,) -> Result < i32 , String > { let mut manager = state . manager . lock () . map_err (| e | format ! ("Failed to lock manager: {}" , e)) ? ; manager . create_lane (track_id , parameter_type) }

- [ ] **Function 'delete_automation_lane' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/automation.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Delete automation lane"] # [doc = ""] # [doc = " # Arguments"] # [doc = " * `track_id` - Parent track ID"] # [doc = " * `parameter_type` - Parameter type"] # [doc = ""] # [doc = " # Returns"] # [doc = " Ok or error message"] # [tauri :: command] pub fn delete_automation_lane (track_id : i32 , parameter_type : ParameterType , state : State < '_ , AutomationState > ,) -> Result < () , String > { let mut manager = state . manager . lock () . map_err (| e | format ! ("Failed to lock manager: {}" , e)) ? ; manager . delete_lane (track_id , parameter_type) }

- [ ] **Function 'add_automation_point' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/automation.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Add automation point"] # [doc = ""] # [doc = " # Arguments"] # [doc = " * `track_id` - Parent track ID"] # [doc = " * `parameter_type` - Parameter type"] # [doc = " * `time` - Time in ticks"] # [doc = " * `value` - Normalized value (0.0-1.0)"] # [doc = ""] # [doc = " # Returns"] # [doc = " Point ID, or error message"] # [tauri :: command] pub fn add_automation_point (track_id : i32 , parameter_type : ParameterType , time : u64 , value : f64 , state : State < '_ , AutomationState > ,) -> Result < i32 , String > { let mut manager = state . manager . lock () . map_err (| e | format ! ("Failed to lock manager: {}" , e)) ? ; manager . add_point (track_id , parameter_type , time , value) }

- [ ] **Function 'remove_automation_point' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/automation.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Remove automation point"] # [doc = ""] # [doc = " # Arguments"] # [doc = " * `track_id` - Parent track ID"] # [doc = " * `parameter_type` - Parameter type"] # [doc = " * `point_id` - Point ID to remove"] # [doc = ""] # [doc = " # Returns"] # [doc = " Ok or error message"] # [tauri :: command] pub fn remove_automation_point (track_id : i32 , parameter_type : ParameterType , point_id : i32 , state : State < '_ , AutomationState > ,) -> Result < () , String > { let mut manager = state . manager . lock () . map_err (| e | format ! ("Failed to lock manager: {}" , e)) ? ; manager . remove_point (track_id , parameter_type , point_id) }

- [ ] **Function 'move_automation_point' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/automation.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Move automation point"] # [doc = ""] # [doc = " # Arguments"] # [doc = " * `track_id` - Parent track ID"] # [doc = " * `parameter_type` - Parameter type"] # [doc = " * `point_id` - Point ID to move"] # [doc = " * `new_time` - New time position"] # [doc = " * `new_value` - New normalized value"] # [doc = ""] # [doc = " # Returns"] # [doc = " Ok or error message"] # [tauri :: command] pub fn move_automation_point (track_id : i32 , parameter_type : ParameterType , point_id : i32 , new_time : u64 , new_value : f64 , state : State < '_ , AutomationState > ,) -> Result < () , String > { let mut manager = state . manager . lock () . map_err (| e | format ! ("Failed to lock manager: {}" , e)) ? ; manager . move_point (track_id , parameter_type , point_id , new_time , new_value) }

- [ ] **Function 'set_automation_curve_type' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/automation.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Set automation curve type"] # [doc = ""] # [doc = " # Arguments"] # [doc = " * `track_id` - Parent track ID"] # [doc = " * `parameter_type` - Parameter type"] # [doc = " * `curve_type` - New curve type"] # [doc = ""] # [doc = " # Returns"] # [doc = " Ok or error message"] # [tauri :: command] pub fn set_automation_curve_type (track_id : i32 , parameter_type : ParameterType , curve_type : CurveType , state : State < '_ , AutomationState > ,) -> Result < () , String > { let mut manager = state . manager . lock () . map_err (| e | format ! ("Failed to lock manager: {}" , e)) ? ; manager . set_curve_type (track_id , parameter_type , curve_type) }

- [ ] **Function 'get_automation_lane' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/automation.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Get automation lane"] # [doc = ""] # [doc = " # Arguments"] # [doc = " * `track_id` - Parent track ID"] # [doc = " * `parameter_type` - Parameter type"] # [doc = ""] # [doc = " # Returns"] # [doc = " Automation lane, or error message"] # [tauri :: command] pub fn get_automation_lane (track_id : i32 , parameter_type : ParameterType , state : State < '_ , AutomationState > ,) -> Result < AutomationLane , String > { let manager = state . manager . lock () . map_err (| e | format ! ("Failed to lock manager: {}" , e)) ? ; manager . get_lane (track_id , parameter_type) }

- [ ] **Function 'get_track_automation' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/automation.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Get all automation lanes for track"] # [doc = ""] # [doc = " # Arguments"] # [doc = " * `track_id` - Track ID"] # [doc = ""] # [doc = " # Returns"] # [doc = " Vector of all lanes for track"] # [tauri :: command] pub fn get_track_automation (track_id : i32 , state : State < '_ , AutomationState > ,) -> Result < Vec < AutomationLane > , String > { let manager = state . manager . lock () . map_err (| e | format ! ("Failed to lock manager: {}" , e)) ? ; Ok (manager . get_track_lanes (track_id)) }

- [ ] **Function 'get_automation_value' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/automation.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Get automation value at specific time"] # [doc = ""] # [doc = " # Arguments"] # [doc = " * `track_id` - Track ID"] # [doc = " * `parameter_type` - Parameter type"] # [doc = " * `time` - Time in ticks"] # [doc = ""] # [doc = " # Returns"] # [doc = " Interpolated value, or None if no automation"] # [tauri :: command] pub fn get_automation_value (track_id : i32 , parameter_type : ParameterType , time : u64 , state : State < '_ , AutomationState > ,) -> Result < Option < f64 > , String > { let manager = state . manager . lock () . map_err (| e | format ! ("Failed to lock manager: {}" , e)) ? ; Ok (manager . get_value_at (track_id , parameter_type , time)) }

- [ ] **Function 'clear_track_automation' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/automation.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Clear all automation for track"] # [doc = ""] # [doc = " # Arguments"] # [doc = " * `track_id` - Track ID"] # [doc = ""] # [doc = " # Returns"] # [doc = " Ok or error message"] # [tauri :: command] pub fn clear_track_automation (track_id : i32 , state : State < '_ , AutomationState > ,) -> Result < () , String > { let mut manager = state . manager . lock () . map_err (| e | format ! ("Failed to lock manager: {}" , e)) ? ; manager . remove_track (track_id) ; Ok (()) }

- [ ] **Function 'clear_all_automation' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/automation.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Clear all automation"] # [doc = ""] # [doc = " # Returns"] # [doc = " Ok or error message"] # [tauri :: command] pub fn clear_all_automation (state : State < '_ , AutomationState >) -> Result < () , String > { let mut manager = state . manager . lock () . map_err (| e | format ! ("Failed to lock manager: {}" , e)) ? ; manager . clear_all () ; Ok (()) }

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/daw.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/daw.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/daw.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/daw.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/daw.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/daw.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/daw.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/daw.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/daw.rs`
  - Category: Performance

- [ ] **Function 'generate_effect_id' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/effect.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn generate_effect_id () -> EffectId { format ! ("fx_{}" , uuid :: Uuid :: new_v4 () . to_string () . replace ("-" , "") [.. 12] . to_string ()) }

- [ ] **Function 'normalize_value' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/effect.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn normalize_value (value : f64 , min : f64 , max : f64 , logarithmic : bool) -> f64 { if logarithmic && min > 0.0 { let log_min = min . ln () ; let log_max = max . ln () ; let log_value = value . ln () ; (log_value - log_min) / (log_max - log_min) } else { (value - min) / (max - min) } }

- [ ] **Function 'denormalize_value' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/effect.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn denormalize_value (normalized : f64 , min : f64 , max : f64 , logarithmic : bool) -> f64 { if logarithmic && min > 0.0 { let log_min = min . ln () ; let log_max = max . ln () ; (log_min + normalized * (log_max - log_min)) . exp () } else { min + normalized * (max - min) } }

- [ ] **Function 'format_parameter_value' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/effect.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn format_parameter_value (value : f64 , format : & ParameterFormat) -> String { match format { ParameterFormat :: Float { decimals } => format ! ("{:.1$}" , value , * decimals as usize) , ParameterFormat :: Db => format ! ("{:.1} dB" , value) , ParameterFormat :: Hz => { if value >= 1000.0 { format ! ("{:.2} kHz" , value / 1000.0) } else { format ! ("{:.1} Hz" , value) } } , ParameterFormat :: Ms => { if value >= 1000.0 { format ! ("{:.2} s" , value / 1000.0) } else { format ! ("{:.1} ms" , value) } } , ParameterFormat :: Percent => format ! ("{:.0}%" , value * 100.0) , ParameterFormat :: Ratio => { if value >= 1.0 { format ! ("{:.1}:1" , value) } else { format ! ("1:{:.1}" , 1.0 / value) } } , ParameterFormat :: Semitones => { if value >= 0.0 { format ! ("+{:.0} st" , value) } else { format ! ("{:.0} st" , value) } } , ParameterFormat :: Cents => { if value >= 0.0 { format ! ("+{:.0} ct" , value) } else { format ! ("{:.0} ct" , value) } } , ParameterFormat :: OnOff => { if value >= 0.5 { "On" . to_string () } else { "Off" . to_string () } } , ParameterFormat :: Enum { values } => { let index = (value . round () as usize) . min (values . len () . saturating_sub (1)) ; values . get (index) . cloned () . unwrap_or_else (| | format ! ("{}" , index)) } , } }

- [ ] **Function 'get_default_parameters' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/effect.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Get default parameters for an effect type"] fn get_default_parameters (effect_type : & EffectType) -> Vec < ParameterDef > { match effect_type { EffectType :: Compressor => vec ! [ParameterDef { id : "threshold" . into () , name : "Threshold" . into () , unit : "dB" . into () , min : - 60.0 , max : 0.0 , default : - 20.0 , step : 0.5 , logarithmic : false , format : ParameterFormat :: Db , group : Some ("Dynamics" . into ()) , automatable : true , } , ParameterDef { id : "ratio" . into () , name : "Ratio" . into () , unit : ":1" . into () , min : 1.0 , max : 20.0 , default : 4.0 , step : 0.1 , logarithmic : true , format : ParameterFormat :: Ratio , group : Some ("Dynamics" . into ()) , automatable : true , } , ParameterDef { id : "attack" . into () , name : "Attack" . into () , unit : "ms" . into () , min : 0.1 , max : 100.0 , default : 10.0 , step : 0.1 , logarithmic : true , format : ParameterFormat :: Ms , group : Some ("Envelope" . into ()) , automatable : true , } , ParameterDef { id : "release" . into () , name : "Release" . into () , unit : "ms" . into () , min : 10.0 , max : 1000.0 , default : 100.0 , step : 1.0 , logarithmic : true , format : ParameterFormat :: Ms , group : Some ("Envelope" . into ()) , automatable : true , } , ParameterDef { id : "makeup" . into () , name : "Makeup Gain" . into () , unit : "dB" . into () , min : 0.0 , max : 24.0 , default : 0.0 , step : 0.5 , logarithmic : false , format : ParameterFormat :: Db , group : Some ("Output" . into ()) , automatable : true , } , ParameterDef { id : "knee" . into () , name : "Knee" . into () , unit : "dB" . into () , min : 0.0 , max : 12.0 , default : 6.0 , step : 0.5 , logarithmic : false , format : ParameterFormat :: Db , group : Some ("Dynamics" . into ()) , automatable : true , } ,] , EffectType :: Delay => vec ! [ParameterDef { id : "time" . into () , name : "Time" . into () , unit : "ms" . into () , min : 1.0 , max : 2000.0 , default : 250.0 , step : 1.0 , logarithmic : true , format : ParameterFormat :: Ms , group : Some ("Delay" . into ()) , automatable : true , } , ParameterDef { id : "feedback" . into () , name : "Feedback" . into () , unit : "%" . into () , min : 0.0 , max : 1.0 , default : 0.3 , step : 0.01 , logarithmic : false , format : ParameterFormat :: Percent , group : Some ("Delay" . into ()) , automatable : true , } , ParameterDef { id : "lowcut" . into () , name : "Low Cut" . into () , unit : "Hz" . into () , min : 20.0 , max : 2000.0 , default : 100.0 , step : 1.0 , logarithmic : true , format : ParameterFormat :: Hz , group : Some ("Filter" . into ()) , automatable : true , } , ParameterDef { id : "highcut" . into () , name : "High Cut" . into () , unit : "Hz" . into () , min : 1000.0 , max : 20000.0 , default : 8000.0 , step : 10.0 , logarithmic : true , format : ParameterFormat :: Hz , group : Some ("Filter" . into ()) , automatable : true , } , ParameterDef { id : "sync" . into () , name : "Tempo Sync" . into () , unit : "" . into () , min : 0.0 , max : 1.0 , default : 0.0 , step : 1.0 , logarithmic : false , format : ParameterFormat :: OnOff , group : Some ("Sync" . into ()) , automatable : false , } ,] , EffectType :: Room | EffectType :: Hall | EffectType :: Plate | EffectType :: Spring | EffectType :: Convolution | EffectType :: Shimmer => vec ! [ParameterDef { id : "size" . into () , name : "Size" . into () , unit : "%" . into () , min : 0.0 , max : 1.0 , default : 0.5 , step : 0.01 , logarithmic : false , format : ParameterFormat :: Percent , group : Some ("Room" . into ()) , automatable : true , } , ParameterDef { id : "decay" . into () , name : "Decay" . into () , unit : "s" . into () , min : 0.1 , max : 10.0 , default : 2.0 , step : 0.1 , logarithmic : true , format : ParameterFormat :: Float { decimals : 1 } , group : Some ("Room" . into ()) , automatable : true , } , ParameterDef { id : "predelay" . into () , name : "Pre-delay" . into () , unit : "ms" . into () , min : 0.0 , max : 200.0 , default : 20.0 , step : 1.0 , logarithmic : false , format : ParameterFormat :: Ms , group : Some ("Room" . into ()) , automatable : true , } , ParameterDef { id : "damping" . into () , name : "Damping" . into () , unit : "%" . into () , min : 0.0 , max : 1.0 , default : 0.5 , step : 0.01 , logarithmic : false , format : ParameterFormat :: Percent , group : Some ("Tone" . into ()) , automatable : true , } , ParameterDef { id : "diffusion" . into () , name : "Diffusion" . into () , unit : "%" . into () , min : 0.0 , max : 1.0 , default : 0.7 , step : 0.01 , logarithmic : false , format : ParameterFormat :: Percent , group : Some ("Tone" . into ()) , automatable : true , } ,] , EffectType :: Gain => vec ! [ParameterDef { id : "gain" . into () , name : "Gain" . into () , unit : "dB" . into () , min : - 24.0 , max : 24.0 , default : 0.0 , step : 0.1 , logarithmic : false , format : ParameterFormat :: Db , group : None , automatable : true , }] , _ => vec ! [ParameterDef { id : "mix" . into () , name : "Mix" . into () , unit : "%" . into () , min : 0.0 , max : 1.0 , default : 1.0 , step : 0.01 , logarithmic : false , format : ParameterFormat :: Percent , group : None , automatable : true , } ,] , } }

- [ ] **Function 'create_default_values' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/effect.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Create default parameter values from definitions"] fn create_default_values (defs : & [ParameterDef]) -> Vec < ParameterValue > { defs . iter () . map (| def | { let normalized = normalize_value (def . default , def . min , def . max , def . logarithmic) ; ParameterValue { id : def . id . clone () , value : def . default , normalized , display : format_parameter_value (def . default , & def . format) , is_automated : false , modulation_amount : 0.0 , } }) . collect () }

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/effect.rs`
  - Category: Performance

- [ ] **Function 'get_available_effects_impl' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/effect.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Get all available effect types"] pub fn get_available_effects_impl () -> Vec < EffectTypeMeta > { let effect_types = vec ! [EffectType :: Compressor , EffectType :: Limiter , EffectType :: Gate , EffectType :: ParametricEq , EffectType :: HighPass , EffectType :: LowPass , EffectType :: Overdrive , EffectType :: Distortion , EffectType :: BitCrusher , EffectType :: Chorus , EffectType :: Flanger , EffectType :: Phaser , EffectType :: Delay , EffectType :: PingPong , EffectType :: Room , EffectType :: Hall , EffectType :: Plate , EffectType :: PitchShifter , EffectType :: Gain , EffectType :: Pan , EffectType :: StereoWidth , EffectType :: Spectrum , EffectType :: LevelMeter ,] ; effect_types . into_iter () . map (| effect_type | { let parameters = get_default_parameters (& effect_type) ; EffectTypeMeta { name : effect_type . display_name () . to_string () , category : effect_type . category () , has_sidechain : matches ! (effect_type , EffectType :: Compressor | EffectType :: Gate | EffectType :: Expander) , latency_samples : 0 , effect_type , parameters , } }) . collect () }

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/effect.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/effect.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/effect.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/effect.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/effect.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/effect.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/effect.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/effect.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/effect.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/effect.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/effect.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/effect.rs`
  - Category: Performance

- [ ] **Function 'get_available_effects' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/effect.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [tauri :: command] pub fn get_available_effects () -> Vec < EffectTypeMeta > { get_available_effects_impl () }

- [ ] **Function 'create_demo_events' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/export.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Create demonstration MIDI events"] # [doc = ""] # [doc = " This is a placeholder for integration with the sequencer."] # [doc = " A real implementation would:"] # [doc = " 1. Get all tracks from the sequencer engine"] # [doc = " 2. Merge events from all enabled tracks"] # [doc = " 3. Apply track properties (mute, solo, volume, pan)"] # [doc = " 4. Sort events by timestamp"] # [doc = ""] # [doc = " Current implementation creates a simple C major arpeggio pattern."] fn create_demo_events () -> Vec < MidiEvent > { vec ! [MidiEvent { event_type : MidiEventType :: NoteOn , tick : 0 , channel : 0 , note : Some (60) , velocity : Some (80) , controller : None , value : None , program : None , } , MidiEvent { event_type : MidiEventType :: NoteOff , tick : 480 , channel : 0 , note : Some (60) , velocity : Some (0) , controller : None , value : None , program : None , } , MidiEvent { event_type : MidiEventType :: NoteOn , tick : 480 , channel : 0 , note : Some (64) , velocity : Some (80) , controller : None , value : None , program : None , } , MidiEvent { event_type : MidiEventType :: NoteOff , tick : 960 , channel : 0 , note : Some (64) , velocity : Some (0) , controller : None , value : None , program : None , } , MidiEvent { event_type : MidiEventType :: NoteOn , tick : 960 , channel : 0 , note : Some (67) , velocity : Some (80) , controller : None , value : None , program : None , } , MidiEvent { event_type : MidiEventType :: NoteOff , tick : 1440 , channel : 0 , note : Some (67) , velocity : Some (0) , controller : None , value : None , program : None , } , MidiEvent { event_type : MidiEventType :: NoteOn , tick : 1440 , channel : 0 , note : Some (72) , velocity : Some (80) , controller : None , value : None , program : None , } , MidiEvent { event_type : MidiEventType :: NoteOff , tick : 1920 , channel : 0 , note : Some (72) , velocity : Some (0) , controller : None , value : None , program : None , } ,] }

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/mixer.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/mixer.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/mixer.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/mixer.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/mixer.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/mixer.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/mixer.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/mixer.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/mixer.rs`
  - Category: Performance

- [ ] **Function 'validate_pitch' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/piano_roll.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn validate_pitch (pitch : i32) -> Result < () , PianoRollError > { if ! (0 ..= 127) . contains (& pitch) { return Err (PianoRollError :: InvalidPitch (pitch)) ; } Ok (()) }

- [ ] **Function 'validate_velocity' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/piano_roll.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn validate_velocity (velocity : i32) -> Result < () , PianoRollError > { if ! (0 ..= 127) . contains (& velocity) { return Err (PianoRollError :: InvalidVelocity (velocity)) ; } Ok (()) }

- [ ] **Function 'validate_duration' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/piano_roll.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn validate_duration (duration : i64) -> Result < () , PianoRollError > { if duration <= 0 { return Err (PianoRollError :: InvalidDuration (duration)) ; } Ok (()) }

- [ ] **Function 'validate_channel' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/piano_roll.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn validate_channel (channel : i32) -> Result < () , PianoRollError > { if ! (0 ..= 15) . contains (& channel) { return Err (PianoRollError :: InvalidChannel (channel)) ; } Ok (()) }

- [ ] **Function 'validate_note_input' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/piano_roll.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn validate_note_input (note : & NoteInput) -> Result < () , PianoRollError > { validate_pitch (note . pitch) ? ; validate_velocity (note . velocity) ? ; validate_duration (note . duration) ? ; validate_channel (note . channel) ? ; Ok (()) }

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/piano_roll.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/piano_roll.rs`
  - Category: Performance

- [ ] **Function 'quantize_value' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/piano_roll.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Apply quantization to a single value"] fn quantize_value (value : i64 , grid_size : i64 , strength : f64 , swing : f64) -> i64 { let grid_position = (value as f64 / grid_size as f64) . round () as i64 ; let quantized = grid_position * grid_size ; let swung = if grid_position % 2 == 1 { quantized + (grid_size as f64 * swing * 0.5) as i64 } else { quantized } ; let result = value as f64 + (swung as f64 - value as f64) * strength ; result . round () as i64 }

- [ ] **Function 'snap_to_scale' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/piano_roll.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Snap a pitch to the nearest scale degree"] fn snap_to_scale (pitch : i32 , scale_notes : & [i32]) -> i32 { let octave = pitch / 12 ; let pitch_class = pitch % 12 ; let nearest = scale_notes . iter () . min_by_key (| & & note | { let diff = (note - pitch_class) . abs () ; diff . min (12 - diff) }) . copied () . unwrap_or (pitch_class) ; octave * 12 + nearest }

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/piano_roll.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/piano_roll.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/piano_roll.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/piano_roll.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/piano_roll.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/piano_roll.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/piano_roll.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/pipeline.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/pipeline.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/pipeline.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/pipeline.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/pipeline.rs`
  - Category: Performance

- [ ] **Function 'read_file_bytes' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/repair.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn read_file_bytes (path : & Path , max_size : u64) -> Result < Vec < u8 > , RepairError > { let metadata = fs :: metadata (path) . map_err (| e | RepairError :: IoError (format ! ("Cannot read metadata: {}" , e))) ? ; if metadata . len () > max_size { return Err (RepairError :: FileTooLarge (metadata . len () , max_size)) ; } let mut file = fs :: File :: open (path) ? ; let mut buffer = Vec :: with_capacity (metadata . len () as usize) ; file . read_to_end (& mut buffer) ? ; Ok (buffer) }

- [ ] **Function 'is_midi_file' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/repair.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn is_midi_file (data : & [u8]) -> bool { data . len () >= 14 && & data [0 .. 4] == MIDI_HEADER }

- [ ] **Function 'find_pattern' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/repair.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn find_pattern (data : & [u8] , pattern : & [u8]) -> Option < usize > { data . windows (pattern . len ()) . position (| w | w == pattern) }

- [ ] **Function 'find_all_patterns' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/repair.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn find_all_patterns (data : & [u8] , pattern : & [u8]) -> Vec < usize > { data . windows (pattern . len ()) . enumerate () . filter (| (_ , w) | * w == pattern) . map (| (i , _) | i) . collect () }

- [ ] **Function 'read_u16_be' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/repair.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn read_u16_be (data : & [u8] , offset : usize) -> u16 { if offset + 2 > data . len () { return 0 ; } ((data [offset] as u16) << 8) | (data [offset + 1] as u16) }

- [ ] **Function 'read_u32_be' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/repair.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn read_u32_be (data : & [u8] , offset : usize) -> u32 { if offset + 4 > data . len () { return 0 ; } ((data [offset] as u32) << 24) | ((data [offset + 1] as u32) << 16) | ((data [offset + 2] as u32) << 8) | (data [offset + 3] as u32) }

- [ ] **Function 'write_u32_be' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/repair.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn write_u32_be (value : u32) -> [u8 ; 4] { [(value >> 24) as u8 , (value >> 16) as u8 , (value >> 8) as u8 , value as u8] }

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/repair.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/repair.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/repair.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/repair.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/repair.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/repair.rs`
  - Category: Performance

- [ ] **Function 'get_repair_strategies' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/repair.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [tauri :: command] pub fn get_repair_strategies () -> Vec < RepairStrategyInfo > { vec ! [RepairStrategy :: Auto , RepairStrategy :: Conservative , RepairStrategy :: Aggressive , RepairStrategy :: AddEndOfTrack , RepairStrategy :: TrimGarbage , RepairStrategy :: FixTrackLength , RepairStrategy :: FixTrackCount , RepairStrategy :: RemoveInvalidEvents , RepairStrategy :: ClampValues , RepairStrategy :: Rebuild ,] . into_iter () . map (| s | RepairStrategyInfo { id : s , name : format ! ("{:?}" , s) , description : s . description () . to_string () , }) . collect () }

- [ ] **Function 'get_corruption_types' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/repair.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [tauri :: command] pub fn get_corruption_types () -> Vec < CorruptionTypeInfo > { vec ! [CorruptionType :: MissingEndOfTrack , CorruptionType :: InvalidHeader , CorruptionType :: TruncatedFile , CorruptionType :: InvalidTrackLength , CorruptionType :: GarbageAtEnd , CorruptionType :: InvalidDeltaTime , CorruptionType :: InvalidEventType , CorruptionType :: InvalidRunningStatus , CorruptionType :: InvalidMetaEvent , CorruptionType :: InvalidSysexEvent , CorruptionType :: MissingTrackHeader , CorruptionType :: TrackCountMismatch , CorruptionType :: NestedSysex , CorruptionType :: InvalidChannel , CorruptionType :: InvalidNote , CorruptionType :: InvalidVelocity , CorruptionType :: FileTooLarge , CorruptionType :: Unknown ,] . into_iter () . map (| t | CorruptionTypeInfo { id : t , name : format ! ("{:?}" , t) , description : t . description () . to_string () , severity : t . severity () , }) . collect () }

- [ ] **Function 'current_timestamp' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/settings.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn current_timestamp () -> i64 { std :: time :: SystemTime :: now () . duration_since (std :: time :: UNIX_EPOCH) . map (| d | d . as_secs () as i64) . unwrap_or (0) }

- [ ] **Function 'generate_profile_id' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/settings.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn generate_profile_id () -> String { format ! ("profile_{}" , current_timestamp ()) }

- [ ] **Function 'ensure_profiles_dir' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/settings.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn ensure_profiles_dir (profiles_dir : & PathBuf) -> Result < () , SettingsError > { if ! profiles_dir . exists () { fs :: create_dir_all (profiles_dir) . map_err (| e | { SettingsError :: FileError (format ! ("Failed to create profiles directory: {}" , e)) }) ? ; } Ok (()) }

- [ ] **Function 'profile_path' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/settings.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn profile_path (profiles_dir : & PathBuf , profile_id : & str) -> PathBuf { profiles_dir . join (format ! ("{}.json" , profile_id)) }

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/settings.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/settings.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/settings.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/settings.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/settings.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/settings.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/settings.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/settings.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/settings.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/settings.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/settings.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/settings.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/settings.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/settings.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/settings.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/settings.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/settings.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/settings.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/settings.rs`
  - Category: Performance

- [ ] **Function 'get_settings_categories' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/settings.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [tauri :: command] pub fn get_settings_categories () -> Vec < SettingsCategoryInfo > { SettingsCategory :: all () . into_iter () . map (| cat | SettingsCategoryInfo { id : cat , name : cat . display_name () . to_string () }) . collect () }

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/system.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/system.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/system.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/system.rs`
  - Category: Performance

- [ ] **Function 'read_file_bytes' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/trim.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Read file bytes with size validation"] fn read_file_bytes (path : & Path) -> Result < Vec < u8 > , TrimError > { let metadata = fs :: metadata (path) . map_err (| _ | TrimError :: FileNotFound (path . display () . to_string ())) ? ; let size = metadata . len () ; if size > MAX_FILE_SIZE { return Err (TrimError :: FileTooLarge (size , MAX_FILE_SIZE)) ; } fs :: read (path) . map_err (TrimError :: Io) }

- [ ] **Function 'detect_file_type' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/trim.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Detect file type from extension and content"] fn detect_file_type (path : & Path , data : & [u8]) -> TrimFileType { if let Some (ext) = path . extension () { let ext_lower = ext . to_string_lossy () . to_lowercase () ; match ext_lower . as_str () { "mid" | "midi" | "smf" => return TrimFileType :: Midi , "wav" | "wave" | "aif" | "aiff" | "mp3" | "flac" | "ogg" => return TrimFileType :: Audio , _ => { } , } } if data . len () >= 4 && & data [0 .. 4] == MIDI_HEADER { return TrimFileType :: Midi ; } if data . len () >= 4 && & data [0 .. 4] == b"RIFF" { return TrimFileType :: Audio ; } TrimFileType :: Midi }

- [ ] **Function 'read_vlq' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/trim.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Read variable-length quantity from MIDI data"] fn read_vlq (data : & [u8] , offset : usize) -> Option < (u32 , usize) > { let mut value : u32 = 0 ; let mut bytes_read = 0 ; for i in 0 .. 4 { if offset + i >= data . len () { return None ; } let byte = data [offset + i] ; value = (value << 7) | (byte & 0x7F) as u32 ; bytes_read += 1 ; if byte & 0x80 == 0 { break ; } } Some ((value , bytes_read)) }

- [ ] **Function 'write_vlq' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/trim.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Write variable-length quantity to buffer"] fn write_vlq (value : u32) -> Vec < u8 > { if value == 0 { return vec ! [0] ; } let mut bytes = Vec :: new () ; let mut v = value ; let mut first = true ; while v > 0 || first { let mut byte = (v & 0x7F) as u8 ; v >>= 7 ; if ! first { byte |= 0x80 ; } bytes . push (byte) ; first = false ; } bytes . reverse () ; bytes }

- [ ] **Function 'read_u16_be' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/trim.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Read 16-bit big-endian value"] fn read_u16_be (data : & [u8] , offset : usize) -> Option < u16 > { if offset + 2 > data . len () { return None ; } Some (u16 :: from_be_bytes ([data [offset] , data [offset + 1]])) }

- [ ] **Function 'read_u32_be' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/trim.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Read 32-bit big-endian value"] fn read_u32_be (data : & [u8] , offset : usize) -> Option < u32 > { if offset + 4 > data . len () { return None ; } Some (u32 :: from_be_bytes ([data [offset] , data [offset + 1] , data [offset + 2] , data [offset + 3] ,])) }

- [ ] **Function 'write_u32_be' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/trim.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Write 32-bit big-endian value"] fn write_u32_be (value : u32) -> [u8 ; 4] { value . to_be_bytes () }

- [ ] **Function 'analyze_midi_file' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/trim.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Analyze MIDI file for trimming"] fn analyze_midi_file (data : & [u8] , options : & TrimOptions) -> Result < TrimAnalysis , TrimError > { if data . len () < 14 || & data [0 .. 4] != MIDI_HEADER { return Err (TrimError :: InvalidFormat ("Not a valid MIDI file" . to_string () ,)) ; } let header_length = read_u32_be (data , 4) . ok_or_else (| | TrimError :: InvalidFormat ("Invalid header length" . to_string ())) ? ; let _format = read_u16_be (data , 8) . ok_or_else (| | TrimError :: InvalidFormat ("Invalid format" . to_string ())) ? ; let num_tracks = read_u16_be (data , 10) . ok_or_else (| | TrimError :: InvalidFormat ("Invalid track count" . to_string ())) ? ; let ppqn = read_u16_be (data , 12) . ok_or_else (| | TrimError :: InvalidFormat ("Invalid PPQN" . to_string ())) ? ; let mut offset = 8 + header_length as usize ; let mut first_event_tick : u64 = u64 :: MAX ; let mut last_event_tick : u64 = 0 ; let mut total_events : u32 = 0 ; let mut warnings = Vec :: new () ; for _track_idx in 0 .. num_tracks { if offset + 8 > data . len () { warnings . push ("Truncated track header" . to_string ()) ; break ; } if & data [offset .. offset + 4] != TRACK_HEADER { warnings . push ("Invalid track header" . to_string ()) ; break ; } let track_length = read_u32_be (data , offset + 4) . ok_or_else (| | TrimError :: InvalidFormat ("Invalid track length" . to_string ())) ? as usize ; let track_start = offset + 8 ; let track_end = track_start + track_length ; if track_end > data . len () { warnings . push ("Track extends beyond file" . to_string ()) ; break ; } let mut pos = track_start ; let mut current_tick : u64 = 0 ; let mut running_status : u8 = 0 ; while pos < track_end { if let Some ((delta , vlq_len)) = read_vlq (data , pos) { current_tick += delta as u64 ; pos += vlq_len ; } else { break ; } if pos >= track_end { break ; } let status = data [pos] ; if status == 0xFF { if pos + 2 >= track_end { break ; } let meta_type = data [pos + 1] ; if let Some ((length , vlq_len)) = read_vlq (data , pos + 2) { pos += 2 + vlq_len + length as usize ; if meta_type == 0x2F { break ; } } else { break ; } } else if status == 0xF0 || status == 0xF7 { if let Some ((length , vlq_len)) = read_vlq (data , pos + 1) { pos += 1 + vlq_len + length as usize ; } else { break ; } } else if status & 0x80 != 0 { running_status = status ; pos += 1 ; let event_type = status & 0xF0 ; let data_bytes = match event_type { 0xC0 | 0xD0 => 1 , _ => 2 , } ; if event_type == 0x90 || event_type == 0x80 { total_events += 1 ; if current_tick < first_event_tick { first_event_tick = current_tick ; } if current_tick > last_event_tick { last_event_tick = current_tick ; } } pos += data_bytes ; } else { let event_type = running_status & 0xF0 ; let data_bytes = match event_type { 0xC0 | 0xD0 => 0 , _ => 1 , } ; if event_type == 0x90 || event_type == 0x80 { total_events += 1 ; if current_tick < first_event_tick { first_event_tick = current_tick ; } if current_tick > last_event_tick { last_event_tick = current_tick ; } } pos += 1 + data_bytes ; } } offset = track_end ; } if first_event_tick == u64 :: MAX { first_event_tick = 0 ; } let silence_threshold = options . silence_threshold_ticks . unwrap_or (DEFAULT_SILENCE_THRESHOLD_TICKS) as u64 ; let leading_silence = first_event_tick ; let trailing_silence = if last_event_tick > 0 && offset > 0 { silence_threshold . min (last_event_tick / 10) } else { 0 } ; let original_duration = last_event_tick . max (first_event_tick) ; let ppqn_val = options . ppqn . unwrap_or (ppqn) as f64 ; let original_duration_ms = (original_duration as f64 / ppqn_val) * 500.0 ; let needs_trimming = leading_silence > silence_threshold ; let estimated_trimmed_size = if needs_trimming { (data . len () as f64 * 0.95) as u64 } else { data . len () as u64 } ; let space_savings = if data . len () > 0 { ((data . len () as u64 - estimated_trimmed_size) as f32 / data . len () as f32) * 100.0 } else { 0.0 } ; Ok (TrimAnalysis { file_path : String :: new () , file_type : TrimFileType :: Midi , original_size : data . len () as u64 , original_duration , original_duration_ms , leading_silence , trailing_silence , content_start : first_event_tick , content_end : last_event_tick , recommended_start : first_event_tick , recommended_end : last_event_tick , estimated_trimmed_size , space_savings_percent : space_savings , event_count : Some (total_events) , track_count : Some (num_tracks) , sample_rate : None , channels : None , needs_trimming , warnings , }) }

- [ ] **Function 'trim_midi_file' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/trim.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Trim MIDI file by removing leading silence"] fn trim_midi_file (data : & [u8] , options : & TrimOptions , analysis : & TrimAnalysis ,) -> Result < Vec < u8 > , TrimError > { if data . len () < 14 || & data [0 .. 4] != MIDI_HEADER { return Err (TrimError :: InvalidFormat ("Not a valid MIDI file" . to_string () ,)) ; } let header_length = read_u32_be (data , 4) . ok_or_else (| | TrimError :: InvalidFormat ("Invalid header length" . to_string ())) ? ; let num_tracks = read_u16_be (data , 10) . ok_or_else (| | TrimError :: InvalidFormat ("Invalid track count" . to_string ())) ? ; let trim_start = match options . mode { TrimMode :: LeadingSilence | TrimMode :: BothSilence | TrimMode :: Normalize => { analysis . leading_silence } , TrimMode :: ToRange => options . start_position . unwrap_or (0) , _ => 0 , } ; if trim_start == 0 { return Ok (data . to_vec ()) ; } let mut output = Vec :: with_capacity (data . len ()) ; output . extend_from_slice (& data [0 .. 8 + header_length as usize]) ; let mut offset = 8 + header_length as usize ; for _track_idx in 0 .. num_tracks { if offset + 8 > data . len () { break ; } if & data [offset .. offset + 4] != TRACK_HEADER { break ; } let track_length = read_u32_be (data , offset + 4) . ok_or_else (| | TrimError :: InvalidFormat ("Invalid track length" . to_string ())) ? as usize ; let track_start = offset + 8 ; let track_end = track_start + track_length ; if track_end > data . len () { break ; } let mut new_track_data = Vec :: with_capacity (track_length) ; let mut pos = track_start ; let mut current_tick : u64 = 0 ; let mut running_status : u8 = 0 ; let mut first_event_in_track = true ; while pos < track_end { let event_start = pos ; if let Some ((delta , vlq_len)) = read_vlq (data , pos) { let new_tick = current_tick + delta as u64 ; pos += vlq_len ; if pos >= track_end { break ; } let status = data [pos] ; let event_data_start = pos ; let event_end ; if status == 0xFF { if pos + 2 >= track_end { break ; } let meta_type = data [pos + 1] ; if let Some ((length , vlq_len)) = read_vlq (data , pos + 2) { event_end = pos + 2 + vlq_len + length as usize ; let is_tempo_event = meta_type == 0x51 || meta_type == 0x58 ; let should_preserve = options . preserve_tempo_events && is_tempo_event ; if should_preserve || new_tick >= trim_start { let adjusted_tick = if new_tick >= trim_start { new_tick - trim_start } else { 0 } ; let new_delta = if first_event_in_track { adjusted_tick as u32 } else { (adjusted_tick - current_tick . saturating_sub (trim_start)) as u32 } ; new_track_data . extend (write_vlq (new_delta)) ; new_track_data . extend_from_slice (& data [event_data_start .. event_end]) ; first_event_in_track = false ; } if meta_type == 0x2F { pos = event_end ; break ; } } else { break ; } } else if status == 0xF0 || status == 0xF7 { if let Some ((length , vlq_len)) = read_vlq (data , pos + 1) { event_end = pos + 1 + vlq_len + length as usize ; if new_tick >= trim_start { let adjusted_delta = (new_tick - trim_start) as u32 ; let new_delta = if first_event_in_track { adjusted_delta } else { adjusted_delta . saturating_sub ((current_tick . saturating_sub (trim_start)) as u32 ,) } ; new_track_data . extend (write_vlq (new_delta)) ; new_track_data . extend_from_slice (& data [event_data_start .. event_end]) ; first_event_in_track = false ; } } else { break ; } } else if status & 0x80 != 0 { running_status = status ; let event_type = status & 0xF0 ; let data_bytes = match event_type { 0xC0 | 0xD0 => 1 , _ => 2 , } ; event_end = pos + 1 + data_bytes ; if new_tick >= trim_start { let adjusted_delta = (new_tick - trim_start) as u32 ; let new_delta = if first_event_in_track { adjusted_delta } else { adjusted_delta . saturating_sub ((current_tick . saturating_sub (trim_start)) as u32) } ; new_track_data . extend (write_vlq (new_delta)) ; new_track_data . extend_from_slice (& data [event_data_start .. event_end]) ; first_event_in_track = false ; } } else { let event_type = running_status & 0xF0 ; let data_bytes = match event_type { 0xC0 | 0xD0 => 1 , _ => 2 , } ; event_end = pos + data_bytes ; if new_tick >= trim_start { let adjusted_delta = (new_tick - trim_start) as u32 ; let new_delta = if first_event_in_track { adjusted_delta } else { adjusted_delta . saturating_sub ((current_tick . saturating_sub (trim_start)) as u32) } ; new_track_data . extend (write_vlq (new_delta)) ; new_track_data . extend_from_slice (& data [event_data_start .. event_end]) ; first_event_in_track = false ; } } current_tick = new_tick ; pos = event_end ; } else { break ; } } if ! new_track_data . ends_with (END_OF_TRACK) { new_track_data . extend (write_vlq (0)) ; new_track_data . extend_from_slice (END_OF_TRACK) ; } output . extend_from_slice (TRACK_HEADER) ; output . extend_from_slice (& write_u32_be (new_track_data . len () as u32)) ; output . extend (new_track_data) ; offset = track_end ; } Ok (output) }

- [ ] **Function 'current_timestamp_ms' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/trim.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Get current timestamp in milliseconds"] fn current_timestamp_ms () -> u64 { std :: time :: SystemTime :: now () . duration_since (std :: time :: UNIX_EPOCH) . map (| d | d . as_millis () as u64) . unwrap_or (0) }

- [ ] **Function 'analyze_file_impl' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/trim.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Analyze a file for potential trimming"] pub fn analyze_file_impl (path : & str , options : & TrimOptions) -> Result < TrimAnalysis , TrimError > { let file_path = Path :: new (path) ; let data = read_file_bytes (file_path) ? ; let file_type = match options . file_type { TrimFileType :: Auto => detect_file_type (file_path , & data) , ft => ft , } ; let mut analysis = match file_type { TrimFileType :: Midi => analyze_midi_file (& data , options) ? , TrimFileType :: Audio => { return Err (TrimError :: UnsupportedFileType ("Audio trimming not yet implemented" . to_string () ,)) ; } , TrimFileType :: Auto => { return Err (TrimError :: InvalidFormat ("Could not detect file type" . to_string () ,)) ; } , } ; analysis . file_path = path . to_string () ; analysis . file_type = file_type ; Ok (analysis) }

- [ ] **Function 'trim_file_impl' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/trim.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Trim a single file"] pub fn trim_file_impl (path : & str , options : & TrimOptions) -> Result < TrimResult , TrimError > { let start_time = current_timestamp_ms () ; let file_path = Path :: new (path) ; let data = read_file_bytes (file_path) ? ; let file_type = match options . file_type { TrimFileType :: Auto => detect_file_type (file_path , & data) , ft => ft , } ; let analysis = match file_type { TrimFileType :: Midi => analyze_midi_file (& data , options) ? , _ => { return Err (TrimError :: UnsupportedFileType ("Only MIDI files supported" . to_string () ,)) ; } , } ; if ! analysis . needs_trimming { return Ok (TrimResult { original_path : path . to_string () , output_path : path . to_string () , backup_path : None , success : true , error : None , original_size : data . len () as u64 , trimmed_size : data . len () as u64 , bytes_saved : 0 , original_duration : analysis . original_duration , trimmed_duration : analysis . original_duration , removed_from_start : 0 , removed_from_end : 0 , processing_time_ms : current_timestamp_ms () - start_time , }) ; } let backup_path = if options . create_backup { let suffix = options . backup_suffix . as_deref () . unwrap_or (".bak") ; let backup = format ! ("{}{}" , path , suffix) ; fs :: copy (file_path , & backup) . map_err (TrimError :: Io) ? ; Some (backup) } else { None } ; let trimmed_data = match file_type { TrimFileType :: Midi => trim_midi_file (& data , options , & analysis) ? , _ => data . clone () , } ; let output_path = options . output_path . clone () . unwrap_or_else (| | path . to_string ()) ; let output_file_path = Path :: new (& output_path) ; if output_file_path . exists () && ! options . overwrite && output_path != path { return Err (TrimError :: WriteError (format ! ("Output file already exists: {}" , output_path))) ; } fs :: write (output_file_path , & trimmed_data) . map_err (TrimError :: Io) ? ; let processing_time = current_timestamp_ms () - start_time ; Ok (TrimResult { original_path : path . to_string () , output_path , backup_path , success : true , error : None , original_size : data . len () as u64 , trimmed_size : trimmed_data . len () as u64 , bytes_saved : data . len () as i64 - trimmed_data . len () as i64 , original_duration : analysis . original_duration , trimmed_duration : analysis . original_duration - analysis . leading_silence , removed_from_start : analysis . leading_silence , removed_from_end : analysis . trailing_silence , processing_time_ms : processing_time , }) }

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/trim.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/trim.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/trim.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/trim.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/trim.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/trim.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/trim.rs`
  - Category: Performance

- [ ] **Function 'get_trim_modes' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/trim.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Get available trim modes"] # [command] pub fn get_trim_modes () -> Vec < String > { vec ! ["leading_silence" . to_string () , "trailing_silence" . to_string () , "both_silence" . to_string () , "to_range" . to_string () , "to_time_range" . to_string () , "to_loop_region" . to_string () , "to_selection" . to_string () , "normalize" . to_string () ,] }

- [ ] **Function 'get_default_trim_options' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/trim.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Get default trim options"] # [command] pub fn get_default_trim_options () -> TrimOptions { TrimOptions :: default () }

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/window.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/window.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/window.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/window.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/commands/window.rs`
  - Category: Performance

- [ ] **Function 'key_distance' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/core/compatibility/music.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Calculate distance between two keys in semitones"] # [doc = ""] # [doc = " Returns the minimum distance around the circle of fifths (0-6)."] # [doc = " Example: C to G is 5 semitones (perfect fifth)."] # [doc = ""] # [doc = " # Arguments"] # [doc = " * `key1` - First key"] # [doc = " * `key2` - Second key"] # [doc = ""] # [doc = " # Returns"] # [doc = " Minimum distance (0-6 semitones)"] pub fn key_distance (key1 : Key , key2 : Key) -> i32 { let diff = (key1 . semitone () - key2 . semitone ()) . abs () ; diff . min (12 - diff) }

- [ ] **Function 'keys_compatible' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/core/compatibility/music.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Check if two key signatures are compatible"] # [doc = ""] # [doc = " Keys are compatible if they:"] # [doc = " - Are the same key"] # [doc = " - Are relative major/minor (share the same notes)"] # [doc = " - Are a perfect fifth apart (circle of fifths)"] pub fn keys_compatible (ks1 : & KeySignature , ks2 : & KeySignature) -> bool { if ks1 . key == ks2 . key && ks1 . mode == ks2 . mode { return true ; } if is_relative_key (ks1 , ks2) { return true ; } let distance = key_distance (ks1 . key , ks2 . key) ; if distance == 5 { return true ; } false }

- [ ] **Function 'is_relative_key' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/core/compatibility/music.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Check if two keys are relative (share the same notes)"] # [doc = ""] # [doc = " Relative keys have different modes but share the same notes."] # [doc = " Example: C Major and A Minor are relative keys."] # [doc = ""] # [doc = " # Arguments"] # [doc = " * `ks1` - First key signature"] # [doc = " * `ks2` - Second key signature"] # [doc = ""] # [doc = " # Returns"] # [doc = " True if keys are relative (e.g., C Major and A Minor)"] pub fn is_relative_key (ks1 : & KeySignature , ks2 : & KeySignature) -> bool { if ks1 . mode == ks2 . mode { return false ; } let major = if ks1 . mode == Mode :: Major { ks1 } else { ks2 } ; let minor = if ks1 . mode == Mode :: Minor { ks1 } else { ks2 } ; let diff = (major . key . semitone () - minor . key . semitone () + 12) % 12 ; diff == 3 }

- [ ] **Function 'key_compatibility_score' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/core/compatibility/music.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Get compatibility score for two key signatures (0-100)"] # [doc = ""] # [doc = " Scoring:"] # [doc = " - 100: Same key and mode (perfect match)"] # [doc = " - 95: Relative major/minor (share notes)"] # [doc = " - 85: Perfect fifth apart (circle of fifths)"] # [doc = " - 70: Major/minor third apart"] # [doc = " - 55: Whole tone apart"] # [doc = " - 40: Semitone apart"] # [doc = " - 20: Tritone (augmented fourth)"] pub fn key_compatibility_score (ks1 : & KeySignature , ks2 : & KeySignature) -> f32 { if ks1 . key == ks2 . key && ks1 . mode == ks2 . mode { return 100.0 ; } if is_relative_key (ks1 , ks2) { return 95.0 ; } let distance = key_distance (ks1 . key , ks2 . key) ; if distance == 5 { return 85.0 ; } if distance == 3 || distance == 4 { return 70.0 ; } if distance == 2 { return 55.0 ; } if distance == 1 { return 40.0 ; } if distance == 6 { return 20.0 ; } 50.0 }

- [ ] **Function 'bpm_compatibility_score' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/core/compatibility/music.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Calculate BPM compatibility score (0-100)"] # [doc = ""] # [doc = " Scores tempo similarity for DJ mixing and mashups."] # [doc = ""] # [doc = " # Arguments"] # [doc = " * `bpm1` - First tempo in BPM"] # [doc = " * `bpm2` - Second tempo in BPM"] # [doc = ""] # [doc = " # Returns"] # [doc = " Compatibility score (0-100)"] pub fn bpm_compatibility_score (bpm1 : f32 , bpm2 : f32) -> f32 { let diff = (bpm1 - bpm2) . abs () ; if diff < 1.0 { return 100.0 ; } if diff < 5.0 { return 95.0 - (diff * 1.0) ; } if diff < 10.0 { return 90.0 - (diff * 0.5) ; } if diff < 20.0 { return 80.0 - (diff * 0.3) ; } if diff < 40.0 { return 70.0 - (diff * 0.2) ; } 30.0 }

- [ ] **Function 'bpm_time_stretchable' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/core/compatibility/music.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Check if BPMs can be time-stretched to match"] # [doc = ""] # [doc = " Returns true if the tempo ratio matches common musical ratios:"] # [doc = " - 2:1 (double-time)"] # [doc = " - 3:2 (sesquialtera)"] # [doc = " - 4:3 (perfect fourth)"] # [doc = " - And their inverses"] # [doc = ""] # [doc = " # Arguments"] # [doc = " * `bpm1` - First tempo"] # [doc = " * `bpm2` - Second tempo"] # [doc = ""] # [doc = " # Returns"] # [doc = " True if tempos can be time-stretched with minimal artifacts"] pub fn bpm_time_stretchable (bpm1 : f32 , bpm2 : f32) -> bool { let ratio = bpm1 / bpm2 ; let ratios = [2.0 , 1.5 , 1.333 , 0.5 , 0.667 , 0.75] ; for target_ratio in ratios { if (ratio - target_ratio) . abs () < 0.1 { return true ; } } false }

- [ ] **Function 'calculate_compatibility' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/core/compatibility/scoring.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Calculate overall compatibility score between two MIDI files"] # [doc = ""] # [doc = " This is the main entry point for compatibility calculation."] # [doc = " It combines multiple factors with weighted scoring:"] # [doc = " - 40% Key compatibility (harmonic compatibility)"] # [doc = " - 40% BPM compatibility (tempo matching)"] # [doc = " - 20% Category compatibility (style/instrument matching)"] # [doc = ""] # [doc = " # Arguments"] # [doc = " * `source` - The source file to compare against"] # [doc = " * `candidate` - The candidate file to score"] # [doc = ""] # [doc = " # Returns"] # [doc = " CompatibilityScore with detailed breakdown"] pub fn calculate_compatibility (source : & MidiFile , candidate : & MidiFile) -> CompatibilityScore { let mut total_score = 0.0 ; let mut explanations = Vec :: new () ; let key_score = if let (Some (key1_str) , Some (key2_str)) = (& source . key_signature , & candidate . key_signature) { if let (Some (key1) , Some (key2)) = (KeySignature :: parse (key1_str) , KeySignature :: parse (key2_str)) { let score = key_compatibility_score (& key1 , & key2) ; if score >= 95.0 { explanations . push ("Perfect key match" . to_string ()) ; } else if score >= 85.0 { explanations . push ("Excellent key compatibility" . to_string ()) ; } else if score >= 70.0 { explanations . push ("Good key compatibility" . to_string ()) ; } else if score < 50.0 { explanations . push ("Keys may clash" . to_string ()) ; } total_score += score * 0.4 ; score } else { 50.0 } } else { 50.0 } ; let bpm_score = if let (Some (bpm1) , Some (bpm2)) = (source . bpm , candidate . bpm) { let score = bpm_compatibility_score (bpm1 as f32 , bpm2 as f32) ; if score >= 95.0 { explanations . push ("Nearly identical tempo" . to_string ()) ; } else if score >= 80.0 { explanations . push ("Similar tempo" . to_string ()) ; } else if bpm_time_stretchable (bpm1 as f32 , bpm2 as f32) { explanations . push ("Tempo can be time-stretched" . to_string ()) ; } else if score < 50.0 { explanations . push ("Very different tempos" . to_string ()) ; } total_score += score * 0.4 ; score } else { 50.0 } ; let category_score = if let (Some (cat1) , Some (cat2)) = (& source . primary_category , & candidate . primary_category) { let score = if cat1 == cat2 { 100.0 } else { category_compatibility (cat1 , cat2) } ; if score >= 90.0 { explanations . push ("Same or complementary category" . to_string ()) ; } total_score += score * 0.2 ; score } else { 50.0 } ; let explanation = if explanations . is_empty () { "Limited metadata available" . to_string () } else { explanations . join (". ") } ; CompatibilityScore { total_score , key_score , bpm_score , category_score , explanation } }

- [ ] **Function 'category_compatibility' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/core/compatibility/scoring.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Determine category compatibility"] # [doc = ""] # [doc = " Scores how well two categories work together musically."] # [doc = " Same category = 100, complementary categories = 80, different = 50."] fn category_compatibility (cat1 : & str , cat2 : & str) -> f32 { let cat1 = cat1 . to_lowercase () ; let cat2 = cat2 . to_lowercase () ; if cat1 == cat2 { return 100.0 ; } let complementary_pairs = vec ! [("kick" , "bass") , ("kick" , "drum") , ("snare" , "hihat") , ("bass" , "chord") , ("chord" , "lead") , ("pad" , "lead") , ("melody" , "chord") , ("drum" , "percussion") ,] ; for (a , b) in complementary_pairs { if (cat1 . contains (a) && cat2 . contains (b)) || (cat1 . contains (b) && cat2 . contains (a)) { return 80.0 ; } } 50.0 }

- [ ] **Function 'explain_compatibility' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/core/compatibility/scoring.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Generate human-readable explanation for compatibility score"] # [doc = ""] # [doc = " Creates a summary explanation based on the overall score."] # [doc = ""] # [doc = " # Arguments"] # [doc = " * `source` - Source file (not currently used, but available for context)"] # [doc = " * `candidate` - Candidate file (not currently used, but available for context)"] # [doc = " * `score` - The compatibility score to explain"] # [doc = ""] # [doc = " # Returns"] # [doc = " Human-readable explanation string"] pub fn explain_compatibility (_source : & MidiFile , _candidate : & MidiFile , score : & CompatibilityScore ,) -> String { let mut parts = Vec :: new () ; if score . total_score >= 90.0 { parts . push ("Highly compatible" . to_string ()) ; } else if score . total_score >= 75.0 { parts . push ("Very compatible" . to_string ()) ; } else if score . total_score >= 60.0 { parts . push ("Compatible" . to_string ()) ; } else if score . total_score >= 50.0 { parts . push ("Somewhat compatible" . to_string ()) ; } else { parts . push ("Limited compatibility" . to_string ()) ; } parts . push (score . explanation . clone ()) ; parts . join (". ") }

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/core/compatibility/scoring.rs`
  - Category: Performance

- [ ] **Function 'create_test_file' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/core/compatibility/scoring.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn create_test_file () -> MidiFile { MidiFile { id : 1 , filename : "test.mid" . to_string () , filepath : "/test/test.mid" . to_string () , file_size_bytes : 1024 , content_hash : vec ! [] , is_multi_track : false , parent_file_id : None , track_number : None , total_tracks : None , manufacturer : None , collection_name : None , folder_tags : vec ! [] , parent_folder : None , num_tracks : 1 , created_at : chrono :: Utc :: now () , analyzed_at : None , bpm : Some (120.0) , key_signature : Some ("C" . to_string ()) , time_signature : Some ("4/4" . to_string ()) , duration_seconds : Some (10.0) , total_notes : 100 , primary_category : Some ("bass" . to_string ()) , } }

- [ ] **Function 'load_midi_file' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/core/midi/loader.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Load and parse a MIDI file from disk"] # [doc = ""] # [doc = " Returns all MIDI events with absolute tick positions."] # [doc = ""] # [doc = " # Arguments"] # [doc = " * `filepath` - Path to the MIDI file"] # [doc = ""] # [doc = " # Returns"] # [doc = " Result containing vector of parsed MIDI events with timing information"] pub fn load_midi_file (filepath : & str) -> Result < LoadedMidiFile , String > { let path = Path :: new (filepath) ; if ! path . exists () { return Err (format ! ("MIDI file not found: {}" , filepath)) ; } let bytes = fs :: read (path) . map_err (| e | format ! ("Failed to read MIDI file {}: {}" , filepath , e)) ? ; let smf = Smf :: parse (& bytes) . map_err (| e | format ! ("Failed to parse MIDI file {}: {}" , filepath , e)) ? ; let ticks_per_quarter = match smf . header . timing { Timing :: Metrical (tpq) => tpq . as_int () as u32 , Timing :: Timecode (fps , sub) => { let ticks_per_second = fps . as_f32 () * sub as f32 ; (ticks_per_second * 0.5) as u32 } , } ; let format_num = match smf . header . format { midly :: Format :: SingleTrack => 0 , midly :: Format :: Parallel => 1 , midly :: Format :: Sequential => 2 , } ; debug ! ("Loaded MIDI file: {} (format {}, {} tracks, {} ticks/quarter)" , filepath , format_num , smf . tracks . len () , ticks_per_quarter) ; let mut all_events = Vec :: new () ; for (track_idx , track) in smf . tracks . iter () . enumerate () { let track_events = parse_track_events (track , track_idx as u8 , ticks_per_quarter) ? ; all_events . extend (track_events) ; } all_events . sort_by_key (| e | e . tick) ; Ok (LoadedMidiFile { events : all_events , ticks_per_quarter , num_tracks : smf . tracks . len () as u16 , format : format_num , }) }

- [ ] **Function 'parse_track_events' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/core/midi/loader.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Parse events from a single MIDI track"] fn parse_track_events (track : & midly :: Track , default_channel : u8 , ticks_per_quarter : u32 ,) -> Result < Vec < MidiEvent > , String > { let mut events = Vec :: new () ; let mut absolute_tick : u64 = 0 ; let mut current_channel = default_channel ; for event in track . iter () { absolute_tick += event . delta . as_int () as u64 ; match event . kind { TrackEventKind :: Midi { channel , message } => { current_channel = channel . as_int () ; if let Some (midi_event) = convert_midi_message (message , current_channel , absolute_tick , ticks_per_quarter) { events . push (midi_event) ; } } , TrackEventKind :: Meta (_) => { } , TrackEventKind :: SysEx (_) => { } , TrackEventKind :: Escape (_) => { } , } } debug ! ("Parsed {} events from track (channel {})" , events . len () , current_channel) ; Ok (events) }

- [ ] **Function 'convert_midi_message' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/core/midi/loader.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Convert midly MIDI message to our MidiEvent format"] fn convert_midi_message (message : MidlyMessage , channel : u8 , tick : u64 , _ticks_per_quarter : u32 ,) -> Option < MidiEvent > { match message { MidlyMessage :: NoteOff { key , vel } => Some (MidiEvent { event_type : MidiEventType :: NoteOff , tick , channel , note : Some (key . as_int ()) , velocity : Some (vel . as_int ()) , controller : None , value : None , program : None , }) , MidlyMessage :: NoteOn { key , vel } => { let event_type = if vel . as_int () == 0 { MidiEventType :: NoteOff } else { MidiEventType :: NoteOn } ; Some (MidiEvent { event_type , tick , channel , note : Some (key . as_int ()) , velocity : Some (vel . as_int ()) , controller : None , value : None , program : None , }) } , MidlyMessage :: Aftertouch { key , vel } => Some (MidiEvent { event_type : MidiEventType :: Aftertouch , tick , channel , note : Some (key . as_int ()) , value : Some (vel . as_int ()) , velocity : None , controller : None , program : None , }) , MidlyMessage :: Controller { controller , value } => Some (MidiEvent { event_type : MidiEventType :: ControlChange , tick , channel , controller : Some (controller . as_int ()) , value : Some (value . as_int ()) , note : None , velocity : None , program : None , }) , MidlyMessage :: ProgramChange { program } => Some (MidiEvent { event_type : MidiEventType :: ProgramChange , tick , channel , program : Some (program . as_int ()) , note : None , velocity : None , controller : None , value : None , }) , MidlyMessage :: ChannelAftertouch { vel } => Some (MidiEvent { event_type : MidiEventType :: Aftertouch , tick , channel , value : Some (vel . as_int ()) , note : None , velocity : None , controller : None , program : None , }) , MidlyMessage :: PitchBend { bend } => { let bend_value = bend . as_int () as u16 ; Some (MidiEvent { event_type : MidiEventType :: PitchBend , tick , channel , value : Some ((bend_value & 0x7F) as u8) , velocity : Some (((bend_value >> 7) & 0x7F) as u8) , note : None , controller : None , program : None , }) } , } }

- [ ] **Function 'parse_midi' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/core/midi/parser.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Parse complete MIDI file"] pub fn parse_midi (data : & [u8]) -> Result < MidiPattern , ParseError > { if data . is_empty () { return Err (ParseError :: IncompleteData (0)) ; } let mut reader = MidiReader :: new (data) ; let header = parse_header (& mut reader) ? ; let mut all_events = Vec :: new () ; for _ in 0 .. header . num_tracks { let track_events = parse_track (& mut reader) ? ; all_events . extend (track_events) ; } all_events . sort_by_key (| e | e . tick) ; let total_ticks = all_events . last () . map (| e | e . tick) . unwrap_or (0) ; Ok (MidiPattern { events : all_events , ticks_per_quarter_note : header . ticks_per_quarter_note , total_ticks , }) }

- [ ] **Function 'parse_header' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/core/midi/parser.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Parse MIDI header (MThd chunk)"] fn parse_header (reader : & mut MidiReader) -> Result < MidiHeader , ParseError > { let chunk_type = reader . read_bytes (4) ? ; if chunk_type != b"MThd" { return Err (ParseError :: InvalidFormat ("Expected MThd header" . to_string () ,)) ; } let length = reader . read_u32 () ? ; if length != 6 { return Err (ParseError :: InvalidFormat (format ! ("Invalid header length: {}" , length))) ; } let format = reader . read_u16 () ? ; if format > 2 { return Err (ParseError :: UnsupportedFormat (format ! ("MIDI format {}" , format))) ; } let num_tracks = reader . read_u16 () ? ; let ticks_per_quarter_note = reader . read_u16 () ? ; Ok (MidiHeader { num_tracks , ticks_per_quarter_note }) }

- [ ] **Function 'parse_track' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/core/midi/parser.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Parse a single track (MTrk chunk)"] fn parse_track (reader : & mut MidiReader) -> Result < Vec < MidiEvent > , ParseError > { let chunk_type = reader . read_bytes (4) ? ; if chunk_type != b"MTrk" { return Err (ParseError :: InvalidTrack ("Expected MTrk header" . to_string ())) ; } let track_length = reader . read_u32 () ? as usize ; let track_end = reader . position () + track_length ; let mut events = Vec :: new () ; let mut current_tick : u64 = 0 ; let mut running_status : Option < u8 > = None ; while reader . position () < track_end { let delta_time = reader . read_variable_length () ? ; current_tick += delta_time ; let status_byte = reader . peek_u8 () ? ; let status = if status_byte & 0x80 == 0 { running_status . ok_or (ParseError :: InvalidTrack ("No running status available" . to_string () ,)) ? } else { let s = reader . read_u8 () ? ; if s != 0xFF && s != 0xF0 && s != 0xF7 { running_status = Some (s) ; } s } ; if status == 0xFF { let _meta_type = reader . read_u8 () ? ; let length = reader . read_variable_length () ? ; reader . skip (length as usize) ? ; } else if status == 0xF0 || status == 0xF7 { let length = reader . read_variable_length () ? ; reader . skip (length as usize) ? ; } else { let command = status & 0xF0 ; let channel = status & 0x0F ; let event = match command { 0x90 => { let note = reader . read_u8 () ? ; let velocity = reader . read_u8 () ? ; Some (MidiEvent { event_type : MidiEventType :: NoteOn , tick : current_tick , channel , note : Some (note) , velocity : Some (velocity) , controller : None , value : None , program : None , }) } , 0x80 => { let note = reader . read_u8 () ? ; let _velocity = reader . read_u8 () ? ; Some (MidiEvent { event_type : MidiEventType :: NoteOff , tick : current_tick , channel , note : Some (note) , velocity : Some (0) , controller : None , value : None , program : None , }) } , 0xB0 => { let controller = reader . read_u8 () ? ; let value = reader . read_u8 () ? ; Some (MidiEvent { event_type : MidiEventType :: ControlChange , tick : current_tick , channel , note : None , velocity : None , controller : Some (controller) , value : Some (value) , program : None , }) } , 0xC0 => { let program = reader . read_u8 () ? ; Some (MidiEvent { event_type : MidiEventType :: ProgramChange , tick : current_tick , channel , note : None , velocity : None , controller : None , value : None , program : Some (program) , }) } , 0xE0 => { let _lsb = reader . read_u8 () ? ; let _msb = reader . read_u8 () ? ; Some (MidiEvent { event_type : MidiEventType :: PitchBend , tick : current_tick , channel , note : None , velocity : None , controller : None , value : None , program : None , }) } , 0xD0 => { let _value = reader . read_u8 () ? ; Some (MidiEvent { event_type : MidiEventType :: Aftertouch , tick : current_tick , channel , note : None , velocity : None , controller : None , value : None , program : None , }) } , _ => None , } ; if let Some (e) = event { events . push (e) ; } } } Ok (events) }

- [ ] **Function 'make_valid_header' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/core/midi/parser.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn make_valid_header (format : u16 , num_tracks : u16 , ticks : u16) -> Vec < u8 > { let mut data = vec ! [] ; data . extend_from_slice (b"MThd") ; data . extend_from_slice (& 6u32 . to_be_bytes ()) ; data . extend_from_slice (& format . to_be_bytes ()) ; data . extend_from_slice (& num_tracks . to_be_bytes ()) ; data . extend_from_slice (& ticks . to_be_bytes ()) ; data }

- [ ] **Function 'make_track_header' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/core/midi/parser.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn make_track_header (length : u32) -> Vec < u8 > { let mut data = vec ! [] ; data . extend_from_slice (b"MTrk") ; data . extend_from_slice (& length . to_be_bytes ()) ; data }

- [ ] **Function 'make_simple_midi_file' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/core/midi/parser.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn make_simple_midi_file () -> Vec < u8 > { let mut data = vec ! [] ; data . extend_from_slice (& make_valid_header (1 , 1 , 480)) ; let mut track = vec ! [] ; track . extend_from_slice (& [0x00 , 0x90 , 0x3C , 0x64]) ; track . extend_from_slice (& [0x60 , 0x80 , 0x3C , 0x00]) ; data . extend_from_slice (& make_track_header (track . len () as u32)) ; data . extend_from_slice (& track) ; data }

- [ ] **Function 'validate_channel' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/core/midi/validator.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Validate MIDI channel (0-15)"] # [doc = ""] # [doc = " MIDI channels are 0-indexed (0-15 represent MIDI channels 1-16)."] pub fn validate_channel (channel : u8) -> Result < u8 , String > { if channel > 15 { Err (format ! ("Invalid MIDI channel: {}. Must be 0-15" , channel)) } else { Ok (channel) } }

- [ ] **Function 'validate_note' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/core/midi/validator.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Validate MIDI note (0-127)"] # [doc = ""] # [doc = " MIDI note numbers range from 0 to 127 (C-1 to G9)."] pub fn validate_note (note : u8) -> Result < u8 , String > { if note > 127 { Err (format ! ("Invalid MIDI note: {}. Must be 0-127" , note)) } else { Ok (note) } }

- [ ] **Function 'validate_velocity' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/core/midi/validator.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Validate MIDI velocity (0-127)"] # [doc = ""] # [doc = " Velocity 0 is treated as note off in some contexts."] pub fn validate_velocity (velocity : u8) -> Result < u8 , String > { if velocity > 127 { Err (format ! ("Invalid velocity: {}. Must be 0-127" , velocity)) } else { Ok (velocity) } }

- [ ] **Function 'validate_control_value' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/core/midi/validator.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Validate MIDI control value (0-127)"] # [doc = ""] # [doc = " Used for control change messages and other data values."] pub fn validate_control_value (value : u8) -> Result < u8 , String > { if value > 127 { Err (format ! ("Invalid control value: {}. Must be 0-127" , value)) } else { Ok (value) } }

- [ ] **Function 'validate_message' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/core/midi/validator.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Validate complete MIDI message"] # [doc = ""] # [doc = " Performs comprehensive validation of all message fields."] pub fn validate_message (msg : & MidiMessage) -> Result < () , String > { validate_channel (msg . channel) ? ; match msg . event_type { MidiEventType :: NoteOn | MidiEventType :: NoteOff => { validate_note (msg . data1) ? ; validate_velocity (msg . data2) ? ; } , MidiEventType :: ControlChange => { validate_control_value (msg . data1) ? ; validate_control_value (msg . data2) ? ; } , MidiEventType :: ProgramChange => { validate_control_value (msg . data1) ? ; } , MidiEventType :: Aftertouch => { validate_control_value (msg . data1) ? ; } , MidiEventType :: PitchBend => { } , } Ok (()) }

- [ ] **Function 'write_midi_file' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/core/midi/writer.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Write MIDI file from events"] # [doc = ""] # [doc = " Pure function that generates MIDI file bytes from event data."] # [doc = " Takes events, timing resolution, and tempo as input."] # [doc = ""] # [doc = " # Arguments"] # [doc = ""] # [doc = " * `events` - Slice of MIDI events to write"] # [doc = " * `ticks_per_quarter` - Timing resolution (typically 480 or 960)"] # [doc = " * `tempo_bpm` - Tempo in beats per minute (e.g., 120.0)"] # [doc = ""] # [doc = " # Returns"] # [doc = ""] # [doc = " * `Ok(Vec<u8>)` - Complete MIDI file as bytes"] # [doc = " * `Err(String)` - Error message if generation fails"] # [doc = ""] pub fn write_midi_file (events : & [MidiEvent] , ticks_per_quarter : u16 , tempo_bpm : f32 ,) -> Result < Vec < u8 > , String > { let mut data = Vec :: new () ; write_header (& mut data , 1 , 1 , ticks_per_quarter) ; write_track (& mut data , events , tempo_bpm , ticks_per_quarter) ; Ok (data) }

- [ ] **Function 'write_header' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/core/midi/writer.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Write MIDI header chunk (MThd)"] fn write_header (data : & mut Vec < u8 > , format : u16 , tracks : u16 , tpqn : u16) { data . extend_from_slice (b"MThd") ; data . extend_from_slice (& 6u32 . to_be_bytes ()) ; data . extend_from_slice (& format . to_be_bytes ()) ; data . extend_from_slice (& tracks . to_be_bytes ()) ; data . extend_from_slice (& tpqn . to_be_bytes ()) ; }

- [ ] **Function 'write_track' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/core/midi/writer.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Write MIDI track chunk (MTrk)"] fn write_track (data : & mut Vec < u8 > , events : & [MidiEvent] , tempo_bpm : f32 , _tpqn : u16) { let mut track_data = Vec :: new () ; write_tempo_event (& mut track_data , tempo_bpm) ; let mut last_tick = 0u64 ; for event in events { let delta = event . tick . saturating_sub (last_tick) ; write_variable_length (& mut track_data , delta) ; write_event (& mut track_data , event) ; last_tick = event . tick ; } write_variable_length (& mut track_data , 0) ; track_data . extend_from_slice (& [0xFF , 0x2F , 0x00]) ; data . extend_from_slice (b"MTrk") ; data . extend_from_slice (& (track_data . len () as u32) . to_be_bytes ()) ; data . extend_from_slice (& track_data) ; }

- [ ] **Function 'write_tempo_event' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/core/midi/writer.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Write tempo meta event"] # [doc = ""] # [doc = " MIDI tempo is stored as microseconds per quarter note."] # [doc = " Conversion: microseconds_per_quarter = 60,000,000 / BPM"] fn write_tempo_event (data : & mut Vec < u8 > , bpm : f32) { let microseconds_per_quarter = (60_000_000.0 / bpm) as u32 ; write_variable_length (data , 0) ; data . push (0xFF) ; data . push (0x51) ; data . push (0x03) ; data . extend_from_slice (& microseconds_per_quarter . to_be_bytes () [1 .. 4]) ; }

- [ ] **Function 'write_event' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/core/midi/writer.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Write single MIDI event"] fn write_event (data : & mut Vec < u8 > , event : & MidiEvent) { match event . event_type { MidiEventType :: NoteOn => { data . push (0x90 | (event . channel & 0x0F)) ; data . push (event . note . unwrap_or (0) & 0x7F) ; data . push (event . velocity . unwrap_or (100) & 0x7F) ; } , MidiEventType :: NoteOff => { data . push (0x80 | (event . channel & 0x0F)) ; data . push (event . note . unwrap_or (0) & 0x7F) ; data . push (0x00) ; } , MidiEventType :: ControlChange => { data . push (0xB0 | (event . channel & 0x0F)) ; data . push (event . controller . unwrap_or (0) & 0x7F) ; data . push (event . value . unwrap_or (0) & 0x7F) ; } , MidiEventType :: ProgramChange => { data . push (0xC0 | (event . channel & 0x0F)) ; data . push (event . program . unwrap_or (0) & 0x7F) ; } , MidiEventType :: PitchBend => { data . push (0xE0 | (event . channel & 0x0F)) ; data . push (0x00) ; data . push (0x40) ; } , MidiEventType :: Aftertouch => { data . push (0xD0 | (event . channel & 0x0F)) ; data . push (0x00) ; } , } }

- [ ] **Function 'write_variable_length' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/core/midi/writer.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Write variable-length quantity (MIDI standard encoding)"] # [doc = ""] # [doc = " MIDI uses variable-length quantities to save space."] # [doc = " - Values 0-127: single byte (0xxxxxxx)"] # [doc = " - Larger values: multiple bytes (1xxxxxxx 1xxxxxxx ... 0xxxxxxx)"] # [doc = " - Most significant bit = 1 means \"more bytes follow\""] # [doc = " - Each byte contributes 7 bits to the value"] # [doc = ""] # [doc = " Examples:"] # [doc = " - 0 â†’ [0x00]"] # [doc = " - 127 â†’ [0x7F]"] # [doc = " - 128 â†’ [0x81, 0x00]"] # [doc = " - 8192 â†’ [0xC0, 0x00]"] fn write_variable_length (data : & mut Vec < u8 > , mut value : u64) { let mut bytes = Vec :: new () ; bytes . push ((value & 0x7F) as u8) ; value >>= 7 ; while value > 0 { bytes . push (((value & 0x7F) | 0x80) as u8) ; value >>= 7 ; } bytes . reverse () ; data . extend_from_slice (& bytes) ; }

- [ ] **Function 'microseconds_per_tick' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/core/sequencer/timing.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Calculate microseconds per tick at given BPM"] # [doc = ""] # [doc = " Used for high-precision timing in MIDI playback."] # [doc = ""] # [doc = " # Arguments"] # [doc = " * `bpm` - Beats per minute"] # [doc = " * `ticks_per_quarter` - MIDI resolution (typically 480)"] # [doc = ""] # [doc = " # Returns"] # [doc = " Microseconds per tick as f64"] pub fn microseconds_per_tick (bpm : f32 , ticks_per_quarter : u16) -> f64 { let microseconds_per_minute = 60_000_000.0 ; let microseconds_per_beat = microseconds_per_minute / bpm as f64 ; microseconds_per_beat / ticks_per_quarter as f64 }

- [ ] **Function 'tick_to_bar_beat' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/core/sequencer/timing.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Calculate bar and beat from tick position"] # [doc = ""] # [doc = " Converts absolute tick position to musical bar:beat notation."] # [doc = ""] # [doc = " # Arguments"] # [doc = " * `tick` - Absolute tick position"] # [doc = " * `ticks_per_quarter` - MIDI resolution"] # [doc = " * `beats_per_bar` - Time signature numerator (typically 4)"] # [doc = ""] # [doc = " # Returns"] # [doc = " Tuple of (bar, beat) as (u32, u32)"] pub fn tick_to_bar_beat (tick : u64 , ticks_per_quarter : u16 , beats_per_bar : u8) -> (u32 , u32) { let ticks_per_beat = ticks_per_quarter as u64 ; let ticks_per_bar = ticks_per_beat * beats_per_bar as u64 ; let bar = (tick / ticks_per_bar) as u32 ; let beat = ((tick % ticks_per_bar) / ticks_per_beat) as u32 ; (bar , beat) }

- [ ] **Function 'bar_beat_to_tick' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/core/sequencer/timing.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Calculate tick position from bar and beat"] # [doc = ""] # [doc = " Converts musical bar:beat notation to absolute tick position."] # [doc = ""] # [doc = " # Arguments"] # [doc = " * `bar` - Bar number (0-indexed)"] # [doc = " * `beat` - Beat within bar (0-indexed)"] # [doc = " * `ticks_per_quarter` - MIDI resolution"] # [doc = " * `beats_per_bar` - Time signature numerator"] # [doc = ""] # [doc = " # Returns"] # [doc = " Absolute tick position as u64"] pub fn bar_beat_to_tick (bar : u32 , beat : u32 , ticks_per_quarter : u16 , beats_per_bar : u8) -> u64 { let ticks_per_beat = ticks_per_quarter as u64 ; let ticks_per_bar = ticks_per_beat * beats_per_bar as u64 ; (bar as u64 * ticks_per_bar) + (beat as u64 * ticks_per_beat) }

- [ ] **Function 'ticks_to_seconds' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/core/sequencer/timing.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Calculate seconds from ticks"] # [doc = ""] # [doc = " Converts MIDI ticks to real time in seconds."] # [doc = ""] # [doc = " # Arguments"] # [doc = " * `tick` - Absolute tick position"] # [doc = " * `bpm` - Current tempo"] # [doc = " * `ticks_per_quarter` - MIDI resolution"] # [doc = ""] # [doc = " # Returns"] # [doc = " Time in seconds as f64"] pub fn ticks_to_seconds (tick : u64 , bpm : f32 , ticks_per_quarter : u16) -> f64 { let us_per_tick = microseconds_per_tick (bpm , ticks_per_quarter) ; (tick as f64 * us_per_tick) / 1_000_000.0 }

- [ ] **Function 'seconds_to_ticks' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/core/sequencer/timing.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Calculate ticks from seconds"] # [doc = ""] # [doc = " Converts real time in seconds to MIDI ticks."] # [doc = ""] # [doc = " # Arguments"] # [doc = " * `seconds` - Time in seconds"] # [doc = " * `bpm` - Current tempo"] # [doc = " * `ticks_per_quarter` - MIDI resolution"] # [doc = ""] # [doc = " # Returns"] # [doc = " Absolute tick position as u64"] pub fn seconds_to_ticks (seconds : f64 , bpm : f32 , ticks_per_quarter : u16) -> u64 { let us_per_tick = microseconds_per_tick (bpm , ticks_per_quarter) ; ((seconds * 1_000_000.0) / us_per_tick) as u64 }

- [ ] **Function 'ticks_to_microseconds' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/core/sequencer/timing.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Convert ticks to microseconds"] # [doc = ""] # [doc = " Converts MIDI ticks to microseconds for precise timing."] # [doc = ""] # [doc = " # Arguments"] # [doc = " * `ticks` - Number of ticks"] # [doc = " * `tpqn` - Ticks per quarter note"] # [doc = " * `bpm` - Beats per minute"] # [doc = ""] # [doc = " # Returns"] # [doc = " Time in microseconds as u64"] pub fn ticks_to_microseconds (ticks : u64 , tpqn : u16 , bpm : f32) -> u64 { let us_per_tick = microseconds_per_tick (bpm , tpqn) ; (ticks as f64 * us_per_tick) as u64 }

- [ ] **Function 'microseconds_to_ticks' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/core/sequencer/timing.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Convert microseconds to ticks"] # [doc = ""] # [doc = " Converts microseconds to MIDI ticks."] # [doc = ""] # [doc = " # Arguments"] # [doc = " * `micros` - Time in microseconds"] # [doc = " * `tpqn` - Ticks per quarter note"] # [doc = " * `bpm` - Beats per minute"] # [doc = ""] # [doc = " # Returns"] # [doc = " Number of ticks as u64"] pub fn microseconds_to_ticks (micros : u64 , tpqn : u16 , bpm : f32) -> u64 { let us_per_tick = microseconds_per_tick (bpm , tpqn) ; (micros as f64 / us_per_tick) as u64 }

- [ ] **Function 'calculate_bar_position' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/core/sequencer/timing.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Calculate bar position from tick"] # [doc = ""] # [doc = " Converts absolute tick to bar:beat:tick position."] # [doc = ""] # [doc = " # Arguments"] # [doc = " * `tick` - Absolute tick position"] # [doc = " * `tpqn` - Ticks per quarter note"] # [doc = " * `time_sig_num` - Time signature numerator (e.g., 4 in 4/4)"] # [doc = " * `time_sig_denom` - Time signature denominator (e.g., 4 in 4/4)"] # [doc = ""] # [doc = " # Returns"] # [doc = " BarPosition with bar, beat, and tick within beat"] pub fn calculate_bar_position (tick : u64 , tpqn : u16 , time_sig_num : u8 , time_sig_denom : u8 ,) -> BarPosition { let ticks_per_beat = (tpqn as u64 * 4) / time_sig_denom as u64 ; let ticks_per_bar = ticks_per_beat * time_sig_num as u64 ; let bar = (tick / ticks_per_bar) as u32 ; let tick_in_bar = tick % ticks_per_bar ; let beat = (tick_in_bar / ticks_per_beat) as u32 ; let tick_in_beat = tick_in_bar % ticks_per_beat ; BarPosition { bar , beat , tick : tick_in_beat } }

- [ ] **Function 'ticks_per_bar' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/core/sequencer/timing.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Calculate ticks per bar"] # [doc = ""] # [doc = " Calculates the number of ticks in one bar based on time signature."] # [doc = ""] # [doc = " # Arguments"] # [doc = " * `tpqn` - Ticks per quarter note"] # [doc = " * `time_sig_num` - Time signature numerator (e.g., 4 in 4/4)"] # [doc = " * `time_sig_denom` - Time signature denominator (e.g., 4 in 4/4)"] # [doc = ""] # [doc = " # Returns"] # [doc = " Number of ticks per bar as u64"] # [doc = ""] # [doc = " # Examples"] # [doc = " - 4/4 time with 480 TPQN: 1920 ticks per bar (4 quarter notes)"] # [doc = " - 3/4 time with 480 TPQN: 1440 ticks per bar (3 quarter notes)"] # [doc = " - 6/8 time with 480 TPQN: 1440 ticks per bar (2 dotted quarter notes)"] pub fn ticks_per_bar (tpqn : u16 , time_sig_num : u8 , time_sig_denom : u8) -> u64 { let ticks_per_beat = (tpqn as u64 * 4) / time_sig_denom as u64 ; ticks_per_beat * time_sig_num as u64 }

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/hardware/device_manager.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/hardware/device_manager.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/hardware/device_manager.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/hardware/device_manager.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/hardware/midi_backend.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/hardware/midi_backend.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/hardware/midi_backend.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/hardware/midi_backend.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/hardware/midi_backend.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/hardware/midi_backend.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/hardware/midi_monitor.rs`
  - Category: Performance

- [ ] **Function 'parse_destination' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/hardware/midi_router.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Parse destination string into RouteDestination"] fn parse_destination (dest : & str) -> Result < RouteDestination > { if let Some (device_id) = dest . strip_prefix ("device:") { Ok (RouteDestination :: Device (device_id . to_string ())) } else if let Some (track_id) = dest . strip_prefix ("track:") { let track_num = track_id . parse :: < i32 > () . context ("Invalid track number") ? ; Ok (RouteDestination :: Track (track_num)) } else if let Some (virtual_id) = dest . strip_prefix ("virtual:") { Ok (RouteDestination :: Virtual (virtual_id . to_string ())) } else { Ok (RouteDestination :: Device (dest . to_string ())) } }

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/main.rs`
  - Category: Performance

- [ ] **Function 'init_logging' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/main.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Initialize logging/tracing system"] fn init_logging () { let log_dir = std :: env :: var ("LOG_DIR") . unwrap_or_else (| _ | "./logs" . to_string ()) ; std :: fs :: create_dir_all (& log_dir) . ok () ; let file_appender = tracing_appender :: rolling :: daily (log_dir , "daw.log") ; let (non_blocking , _guard) = tracing_appender :: non_blocking (file_appender) ; tracing_subscriber :: registry () . with (tracing_subscriber :: EnvFilter :: try_from_default_env () . unwrap_or_else (| _ | "info,midi_daw=debug" . into ()) ,) . with (tracing_subscriber :: fmt :: layer () . with_writer (std :: io :: stdout)) . with (tracing_subscriber :: fmt :: layer () . with_writer (non_blocking)) . init () ; }

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/midi/manager.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/midi/manager.rs`
  - Category: Performance

- [ ] **Function 'parse_manufacturer' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/midi/manager.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Parse manufacturer from device name"] # [doc = ""] # [doc = " Attempts to extract manufacturer name from MIDI device name."] # [doc = " This is a best-effort approach as device naming is not standardized."] fn parse_manufacturer (name : & str) -> Option < String > { if name . contains ("Steinberg") { Some ("Steinberg" . to_string ()) } else if name . contains ("Akai") { Some ("Akai" . to_string ()) } else if name . contains ("Roland") { Some ("Roland" . to_string ()) } else if name . contains ("Yamaha") { Some ("Yamaha" . to_string ()) } else if name . contains ("Korg") { Some ("Korg" . to_string ()) } else if name . contains ("Moog") { Some ("Moog" . to_string ()) } else if name . contains ("Arturia") { Some ("Arturia" . to_string ()) } else if name . contains ("Native Instruments") || name . contains ("NI") { Some ("Native Instruments" . to_string ()) } else { None } }

- [ ] **Function 'default_datetime' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/models/midi_file.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Default datetime for struct initialization (Unix epoch)"] fn default_datetime () -> chrono :: DateTime < chrono :: Utc > { chrono :: DateTime :: UNIX_EPOCH }

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/profiling/memory.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/profiling/memory.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/profiling/memory.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/profiling/memory.rs`
  - Category: Performance

- [ ] **Function 'format_bytes' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/profiling/memory.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Format bytes as human-readable string"] # [doc = ""] # [doc = " # Arguments"] # [doc = ""] # [doc = " * `bytes` - Number of bytes"] # [doc = ""] # [doc = " # Returns"] # [doc = ""] # [doc = " Formatted string (e.g., \"1.23 MB\")"] # [doc = ""] # [doc = " # Example"] # [doc = ""] # [doc = " ```"] # [doc = " use midi_daw::profiling::memory::format_bytes;"] # [doc = ""] # [doc = " assert_eq!(format_bytes(1024), \"1.00 KB\");"] # [doc = " assert_eq!(format_bytes(1024 * 1024), \"1.00 MB\");"] # [doc = " assert_eq!(format_bytes(1024 * 1024 * 1024), \"1.00 GB\");"] # [doc = " ```"] pub fn format_bytes (bytes : usize) -> String { const KB : usize = 1024 ; const MB : usize = KB * 1024 ; const GB : usize = MB * 1024 ; if bytes >= GB { format ! ("{:.2} GB" , bytes as f64 / GB as f64) } else if bytes >= MB { format ! ("{:.2} MB" , bytes as f64 / MB as f64) } else if bytes >= KB { format ! ("{:.2} KB" , bytes as f64 / KB as f64) } else { format ! ("{} B" , bytes) } }

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/profiling/memory.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/profiling/query_analyzer.rs`
  - Category: Performance

- [ ] **Function 'calculate_score_standalone' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/profiling/query_analyzer.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn calculate_score_standalone (execution_time : Duration , rows_affected : i64 , uses_index : bool , query_type : & QueryType ,) -> i32 { let mut score = 100i32 ; let time_ms = execution_time . as_millis () as i32 ; if time_ms > 500 { score -= 30 ; } else if time_ms > 100 { score -= 15 ; } else if time_ms > 50 { score -= 5 ; } if ! uses_index && rows_affected > 100 { score -= 25 ; } if rows_affected > 10000 { score -= 10 ; } match query_type { QueryType :: Insert | QueryType :: Update | QueryType :: Delete => { if time_ms > 100 { score -= 10 ; } } , _ => { } , } score . max (0) . min (100) }

- [ ] **Function 'identify_bottlenecks_standalone' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/profiling/query_analyzer.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn identify_bottlenecks_standalone (execution_time : Duration , rows_affected : i64 , uses_index : bool , explain_plan : & str ,) -> Vec < String > { let mut bottlenecks = Vec :: new () ; if execution_time . as_millis () > 500 { bottlenecks . push ("Slow execution time (>500ms)" . to_string ()) ; } if ! uses_index && rows_affected > 100 { bottlenecks . push ("No index used for large result set" . to_string ()) ; } if explain_plan . contains ("Seq Scan") { bottlenecks . push ("Sequential scan detected - consider adding index" . to_string ()) ; } if explain_plan . contains ("Sort") && ! explain_plan . contains ("Index") { bottlenecks . push ("In-memory sort without index" . to_string ()) ; } bottlenecks }

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/profiling/query_cache.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/profiling/query_cache.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/sequencer/engine.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/sequencer/engine.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/sequencer/engine.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/sequencer/engine.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/sequencer/engine.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/sequencer/engine.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/sequencer/engine.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/sequencer/engine.rs`
  - Category: Performance

- [ ] **Function 'create_test_message' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/sequencer/scheduler.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn create_test_message (note : u8 , velocity : u8) -> MidiMessage { MidiMessage { event_type : MidiEventType :: NoteOn , channel : 0 , data1 : note , data2 : velocity , timestamp : 0 , } }

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/sequencer/track.rs`
  - Category: Performance

- [ ] **Function 'create_test_event' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/sequencer/track.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn create_test_event (channel : u8) -> MidiEvent { use crate :: models :: midi :: MidiEventType ; MidiEvent { event_type : MidiEventType :: NoteOn , tick : 0 , channel , note : Some (60) , velocity : Some (100) , controller : None , value : None , program : None , } }

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/settings/keyboard.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/settings/keyboard.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/settings/keyboard.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/settings/keyboard.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/settings/keyboard.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/settings/keyboard.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/settings/keyboard.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/settings/keyboard.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/settings/keyboard.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/undo_redo/piano_roll.rs`
  - Category: Performance

- [ ] **Function 'create_test_state' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/undo_redo/piano_roll.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn create_test_state () -> Arc < Mutex < PianoRollState > > { Arc :: new (Mutex :: new (PianoRollState :: new ())) }

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/daw/src-tauri/src/windows/state.rs`
  - Category: Performance

- [ ] **Function 'main' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/build.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn main () { println ! ("cargo:rustc-link-lib=webkit2gtk-4.1") ; println ! ("cargo:rustc-link-lib=javascriptcoregtk-4.1") ; tauri_build :: build () }

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/analyze.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/analyze.rs`
  - Category: Performance

- [ ] **Function 'format_duration' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/analyze.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn format_duration (seconds : f64) -> String { if seconds < 60.0 { format ! ("{:.0}s" , seconds) } else if seconds < 3600.0 { let minutes = (seconds / 60.0) . floor () ; let secs = seconds % 60.0 ; format ! ("{}m {:.0}s" , minutes , secs) } else { let hours = (seconds / 3600.0) . floor () ; let minutes = ((seconds % 3600.0) / 60.0) . floor () ; format ! ("{}h {}m" , hours , minutes) } }

- [ ] **Function 'extract_metadata_from_filename' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/analyze_full_collection.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Extract metadata from filename"] fn extract_metadata_from_filename (filename : & str) -> FileMetadata { let lower = filename . to_lowercase () ; let mut metadata = FileMetadata :: default () ; if let Some (bpm) = extract_bpm (& lower) { metadata . bpm = Some (bpm) ; } if let Some (key) = extract_key (& lower) { metadata . key = Some (key) ; } if let Some (ts) = extract_time_signature (& lower) { metadata . time_signature = Some (ts) ; } metadata . instruments = extract_instruments (& lower) ; metadata . genres = extract_genres (& lower) ; metadata . patterns = extract_patterns (& lower) ; if metadata . instruments . iter () . any (| i | i . contains ("drum") || i == "percussion") { metadata . drum_elements = extract_drum_elements (& lower) ; metadata . is_drum = true ; } metadata }

- [ ] **Function 'extract_bpm' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/analyze_full_collection.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Extract BPM from filename"] fn extract_bpm (filename : & str) -> Option < u32 > { if let Some (bpm) = extract_bpm_pattern1 (filename) { return Some (bpm) ; } if let Some (bpm) = extract_bpm_pattern2 (filename) { return Some (bpm) ; } if let Some (bpm) = extract_bpm_pattern3 (filename) { return Some (bpm) ; } None }

- [ ] **Function 'extract_bpm_pattern1' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/analyze_full_collection.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn extract_bpm_pattern1 (filename : & str) -> Option < u32 > { use regex :: Regex ; let re = Regex :: new (r"[_\-](\d{2,3})[-_]?bpm[_\-]") . ok () ? ; re . captures (filename) . and_then (| cap | cap . get (1)) . and_then (| m | m . as_str () . parse :: < u32 > () . ok ()) . filter (| & bpm | (30 ..= 300) . contains (& bpm)) }

- [ ] **Function 'extract_bpm_pattern2' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/analyze_full_collection.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn extract_bpm_pattern2 (filename : & str) -> Option < u32 > { use regex :: Regex ; let re = Regex :: new (r"[_\-](\d{2,3})[_\-]") . ok () ? ; re . captures (filename) . and_then (| cap | cap . get (1)) . and_then (| m | m . as_str () . parse :: < u32 > () . ok ()) . filter (| & bpm | (30 ..= 300) . contains (& bpm)) }

- [ ] **Function 'extract_bpm_pattern3' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/analyze_full_collection.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn extract_bpm_pattern3 (filename : & str) -> Option < u32 > { use regex :: Regex ; let re = Regex :: new (r"^(\d{2,3})[-_\.]") . ok () ? ; re . captures (filename) . and_then (| cap | cap . get (1)) . and_then (| m | m . as_str () . parse :: < u32 > () . ok ()) . filter (| & bpm | (30 ..= 300) . contains (& bpm)) }

- [ ] **Function 'extract_key' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/analyze_full_collection.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Extract musical key from filename"] fn extract_key (filename : & str) -> Option < String > { use regex :: Regex ; let major_re = Regex :: new (r"[_\-]([A-G]#?b?)[_\-]") . ok () ? ; if let Some (cap) = major_re . captures (filename) { return Some (cap . get (1) ? . as_str () . to_string ()) ; } let minor_re = Regex :: new (r"[_\-]([A-G]#?b?m(?:in)?)[_\-]") . ok () ? ; if let Some (cap) = minor_re . captures (filename) { return Some (cap . get (1) ? . as_str () . to_string ()) ; } None }

- [ ] **Function 'extract_time_signature' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/analyze_full_collection.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Extract time signature from filename"] fn extract_time_signature (filename : & str) -> Option < String > { if filename . contains ("threefour") || filename . contains ("3-4") || filename . contains ("3_4") { return Some ("3/4" . to_string ()) ; } if filename . contains ("sixeight") || filename . contains ("6-8") || filename . contains ("6_8") { return Some ("6/8" . to_string ()) ; } if filename . contains ("fivefour") || filename . contains ("5-4") || filename . contains ("5_4") { return Some ("5/4" . to_string ()) ; } if filename . contains ("seveneight") || filename . contains ("7-8") || filename . contains ("7_8") { return Some ("7/8" . to_string ()) ; } None }

- [ ] **Function 'extract_instruments' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/analyze_full_collection.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Extract instruments from filename"] fn extract_instruments (filename : & str) -> Vec < String > { let mut instruments = Vec :: new () ; if filename . contains ("drum") && ! filename . contains ("syndrome") { instruments . push ("drums" . to_string ()) ; } if filename . contains ("percussion") { instruments . push ("percussion" . to_string ()) ; } if filename . contains ("snare") { instruments . push ("snare" . to_string ()) ; } if filename . contains ("kick") { instruments . push ("kick" . to_string ()) ; } if filename . contains ("hat") || filename . contains ("hihat") { instruments . push ("hat" . to_string ()) ; } if filename . contains ("cymbal") { instruments . push ("cymbal" . to_string ()) ; } if filename . contains ("tom") && ! filename . contains ("atom") && ! filename . contains ("custom") { instruments . push ("tom" . to_string ()) ; } if filename . contains ("ride") { instruments . push ("ride" . to_string ()) ; } if filename . contains ("bass") && ! filename . contains ("bass drum") { instruments . push ("bass" . to_string ()) ; } if filename . contains ("synth") { instruments . push ("synth" . to_string ()) ; } if filename . contains ("pad") { instruments . push ("pad" . to_string ()) ; } if filename . contains ("lead") { instruments . push ("lead" . to_string ()) ; } if filename . contains ("piano") { instruments . push ("piano" . to_string ()) ; } if filename . contains ("organ") { instruments . push ("organ" . to_string ()) ; } if filename . contains ("chord") { instruments . push ("chords" . to_string ()) ; } if filename . contains ("string") { instruments . push ("strings" . to_string ()) ; } if filename . contains ("brass") { instruments . push ("brass" . to_string ()) ; } if filename . contains ("guitar") { instruments . push ("guitar" . to_string ()) ; } instruments }

- [ ] **Function 'extract_genres' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/analyze_full_collection.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Extract genres from filename"] fn extract_genres (filename : & str) -> Vec < String > { let mut genres = Vec :: new () ; if filename . contains ("house") { genres . push ("house" . to_string ()) ; } if filename . contains ("techno") { genres . push ("techno" . to_string ()) ; } if filename . contains ("trance") { genres . push ("trance" . to_string ()) ; } if filename . contains ("dubstep") { genres . push ("dubstep" . to_string ()) ; } if filename . contains ("dnb") || filename . contains ("drum") && filename . contains ("bass") { genres . push ("dnb" . to_string ()) ; } if filename . contains ("jungle") { genres . push ("jungle" . to_string ()) ; } if filename . contains ("breakbeat") || filename . contains ("breaks") { genres . push ("breakbeat" . to_string ()) ; } if filename . contains ("garage") { genres . push ("garage" . to_string ()) ; } if filename . contains ("glitch") { genres . push ("glitch" . to_string ()) ; } if filename . contains ("ambient") { genres . push ("ambient" . to_string ()) ; } if filename . contains ("hiphop") || filename . contains ("hip-hop") { genres . push ("hip-hop" . to_string ()) ; } if filename . contains ("trap") { genres . push ("trap" . to_string ()) ; } if filename . contains ("rnb") || filename . contains ("r&b") { genres . push ("rnb" . to_string ()) ; } if filename . contains ("rock") { genres . push ("rock" . to_string ()) ; } if filename . contains ("metal") { genres . push ("metal" . to_string ()) ; } if filename . contains ("punk") { genres . push ("punk" . to_string ()) ; } if filename . contains ("blues") { genres . push ("blues" . to_string ()) ; } if filename . contains ("funk") { genres . push ("funk" . to_string ()) ; } if filename . contains ("jazz") { genres . push ("jazz" . to_string ()) ; } if filename . contains ("fusion") { genres . push ("fusion" . to_string ()) ; } if filename . contains ("latin") { genres . push ("latin" . to_string ()) ; } if filename . contains ("africa") { genres . push ("african" . to_string ()) ; } if filename . contains ("asia") { genres . push ("asian" . to_string ()) ; } if filename . contains ("world") { genres . push ("world" . to_string ()) ; } if filename . contains ("pop") { genres . push ("pop" . to_string ()) ; } if filename . contains ("disco") { genres . push ("disco" . to_string ()) ; } if filename . contains ("progressive") { genres . push ("progressive" . to_string ()) ; } genres }

- [ ] **Function 'extract_patterns' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/analyze_full_collection.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Extract pattern types from filename"] fn extract_patterns (filename : & str) -> Vec < String > { let mut patterns = Vec :: new () ; if filename . contains ("fill") { patterns . push ("fill" . to_string ()) ; } if filename . contains ("groove") { patterns . push ("groove" . to_string ()) ; } if filename . contains ("intro") { patterns . push ("intro" . to_string ()) ; } if filename . contains ("outro") || filename . contains ("ending") { patterns . push ("ending" . to_string ()) ; } if filename . contains ("breakdown") { patterns . push ("breakdown" . to_string ()) ; } if filename . contains ("turnaround") { patterns . push ("turnaround" . to_string ()) ; } if filename . contains ("verse") { patterns . push ("verse" . to_string ()) ; } if filename . contains ("chorus") { patterns . push ("chorus" . to_string ()) ; } if filename . contains ("bridge") { patterns . push ("bridge" . to_string ()) ; } if filename . contains ("loop") { patterns . push ("loop" . to_string ()) ; } patterns }

- [ ] **Function 'extract_drum_elements' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/analyze_full_collection.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Extract drum elements from filename"] fn extract_drum_elements (filename : & str) -> Vec < String > { let mut elements = Vec :: new () ; if filename . contains ("crash") { elements . push ("crash" . to_string ()) ; } if filename . contains ("ride") { elements . push ("ride" . to_string ()) ; } if filename . contains ("china") { elements . push ("china" . to_string ()) ; } if filename . contains ("splash") { elements . push ("splash" . to_string ()) ; } if filename . contains ("closed") && (filename . contains ("hat") || filename . contains ("hihat")) { elements . push ("closed-hat" . to_string ()) ; } if filename . contains ("open") && (filename . contains ("hat") || filename . contains ("hihat")) { elements . push ("open-hat" . to_string ()) ; } if filename . contains ("pedal") && (filename . contains ("hat") || filename . contains ("hihat")) { elements . push ("pedal-hat" . to_string ()) ; } if filename . contains ("ghost") { elements . push ("ghost-notes" . to_string ()) ; } if filename . contains ("double") && filename . contains ("bass") { elements . push ("double-bass" . to_string ()) ; } if filename . contains ("flam") { elements . push ("flam" . to_string ()) ; } if filename . contains ("roll") { elements . push ("roll" . to_string ()) ; } if filename . contains ("swing") { elements . push ("swing" . to_string ()) ; } if filename . contains ("shuffle") { elements . push ("shuffle" . to_string ()) ; } if filename . contains ("triplet") { elements . push ("triplet" . to_string ()) ; } elements }

- [ ] **Function 'analyze_file' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/analyze_full_collection.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Analyze a single MIDI file"] fn analyze_file (path : & Path , stats : & CollectionStats) { let filename = match path . file_name () . and_then (| n | n . to_str ()) { Some (name) => name , None => return , } ; stats . total_files . fetch_add (1 , Ordering :: Relaxed) ; let metadata = extract_metadata_from_filename (filename) ; if metadata . is_drum { stats . drum_files . fetch_add (1 , Ordering :: Relaxed) ; } for instrument in & metadata . instruments { stats . increment (& stats . instruments , instrument) ; } for genre in & metadata . genres { stats . increment (& stats . genres , genre) ; } for pattern in & metadata . patterns { stats . increment (& stats . patterns , pattern) ; } for element in & metadata . drum_elements { stats . increment (& stats . drum_elements , element) ; } if let Some (bpm) = metadata . bpm { stats . increment_bpm (bpm) ; } if let Some (key) = metadata . key { stats . increment (& stats . keys , & key) ; } if let Some (ts) = metadata . time_signature { stats . increment (& stats . time_signatures , & ts) ; } stats . analyzed_files . fetch_add (1 , Ordering :: Relaxed) ; }

- [ ] **Function 'find_midi_files' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/analyze_full_collection.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Recursively find all MIDI files"] fn find_midi_files (root : & Path) -> Vec < PathBuf > { println ! ("Scanning directory tree...") ; let start = Instant :: now () ; let files : Vec < PathBuf > = walkdir :: WalkDir :: new (root) . follow_links (false) . into_iter () . filter_map (| e | e . ok ()) . filter (| e | { e . path () . extension () . and_then (| ext | ext . to_str ()) . map (| ext | { let ext_lower = ext . to_lowercase () ; ext_lower == "mid" || ext_lower == "midi" }) . unwrap_or (false) }) . map (| e | e . path () . to_path_buf ()) . collect () ; println ! ("Found {} MIDI files in {:?}" , files . len () , start . elapsed ()) ; files }

- [ ] **Function 'generate_report' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/analyze_full_collection.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Generate markdown report"] fn generate_report (stats : & CollectionStats , output_path : & Path) -> std :: io :: Result < () > { let mut output = String :: new () ; output . push_str ("# Complete MIDI Collection Analysis\n\n") ; output . push_str (& format ! ("**Total Files Analyzed:** {}\n\n" , stats . total_files . load (Ordering :: Relaxed))) ; output . push_str (& format ! ("**Drum Files:** {} ({:.1}%)\n\n" , stats . drum_files . load (Ordering :: Relaxed) , stats . drum_files . load (Ordering :: Relaxed) as f64 / stats . total_files . load (Ordering :: Relaxed) as f64 * 100.0)) ; output . push_str ("---\n\n") ; output . push_str ("## Top Instruments Found\n\n") ; output . push_str ("| Instrument | Count | Percentage |\n") ; output . push_str ("|------------|-------|------------|\n") ; let mut instruments : Vec < _ > = stats . instruments . iter () . map (| r | (r . key () . clone () , * r . value ())) . collect () ; instruments . sort_by (| a , b | b . 1 . cmp (& a . 1)) ; let total = stats . total_files . load (Ordering :: Relaxed) ; for (instrument , count) in instruments . iter () . take (50) { output . push_str (& format ! ("| {} | {} | {:.2}% |\n" , instrument , count , * count as f64 / total as f64 * 100.0)) ; } output . push_str ("\n") ; output . push_str ("## Top Genres Found\n\n") ; output . push_str ("| Genre | Count | Percentage |\n") ; output . push_str ("|-------|-------|------------|\n") ; let mut genres : Vec < _ > = stats . genres . iter () . map (| r | (r . key () . clone () , * r . value ())) . collect () ; genres . sort_by (| a , b | b . 1 . cmp (& a . 1)) ; for (genre , count) in genres . iter () . take (50) { output . push_str (& format ! ("| {} | {} | {:.2}% |\n" , genre , count , * count as f64 / total as f64 * 100.0)) ; } output . push_str ("\n") ; output . push_str ("## Top Pattern Types\n\n") ; output . push_str ("| Pattern | Count | Percentage |\n") ; output . push_str ("|---------|-------|------------|\n") ; let mut patterns : Vec < _ > = stats . patterns . iter () . map (| r | (r . key () . clone () , * r . value ())) . collect () ; patterns . sort_by (| a , b | b . 1 . cmp (& a . 1)) ; for (pattern , count) in patterns . iter () . take (30) { output . push_str (& format ! ("| {} | {} | {:.2}% |\n" , pattern , count , * count as f64 / total as f64 * 100.0)) ; } output . push_str ("\n") ; output . push_str ("## Musical Keys Found\n\n") ; output . push_str ("| Key | Count | Percentage |\n") ; output . push_str ("|-----|-------|------------|\n") ; let mut keys : Vec < _ > = stats . keys . iter () . map (| r | (r . key () . clone () , * r . value ())) . collect () ; keys . sort_by (| a , b | b . 1 . cmp (& a . 1)) ; for (key , count) in keys . iter () . take (30) { output . push_str (& format ! ("| {} | {} | {:.2}% |\n" , key , count , * count as f64 / total as f64 * 100.0)) ; } output . push_str ("\n") ; output . push_str ("## BPM Distribution\n\n") ; output . push_str ("| BPM | Count | Percentage |\n") ; output . push_str ("|-----|-------|------------|\n") ; let mut bpms : Vec < _ > = stats . bpms . iter () . map (| r | (* r . key () , * r . value ())) . collect () ; bpms . sort_by (| a , b | b . 1 . cmp (& a . 1)) ; for (bpm , count) in bpms . iter () . take (50) { output . push_str (& format ! ("| {} | {} | {:.2}% |\n" , bpm , count , * count as f64 / total as f64 * 100.0)) ; } output . push_str ("\n") ; output . push_str ("## Time Signatures Found\n\n") ; output . push_str ("| Time Signature | Count | Percentage |\n") ; output . push_str ("|----------------|-------|------------|\n") ; let mut time_sigs : Vec < _ > = stats . time_signatures . iter () . map (| r | (r . key () . clone () , * r . value ())) . collect () ; time_sigs . sort_by (| a , b | b . 1 . cmp (& a . 1)) ; for (ts , count) in time_sigs . iter () { output . push_str (& format ! ("| {} | {} | {:.2}% |\n" , ts , count , * count as f64 / total as f64 * 100.0)) ; } output . push_str ("\n") ; if stats . drum_files . load (Ordering :: Relaxed) > 0 { output . push_str ("## Drum Elements & Techniques\n\n") ; output . push_str ("| Element | Count | Percentage (of drum files) |\n") ; output . push_str ("|---------|-------|---------------------------|\n") ; let mut elements : Vec < _ > = stats . drum_elements . iter () . map (| r | (r . key () . clone () , * r . value ())) . collect () ; elements . sort_by (| a , b | b . 1 . cmp (& a . 1)) ; let drum_total = stats . drum_files . load (Ordering :: Relaxed) ; for (element , count) in elements . iter () . take (50) { output . push_str (& format ! ("| {} | {} | {:.2}% |\n" , element , count , * count as f64 / drum_total as f64 * 100.0)) ; } output . push_str ("\n") ; } output . push_str ("## BPM Ranges Summary\n\n") ; let mut bpm_ranges : HashMap < & str , u64 > = HashMap :: new () ; for (bpm , count) in bpms . iter () { let range = match bpm { 30 ..= 60 => "Very Slow (30-60)" , 61 ..= 90 => "Slow (61-90)" , 91 ..= 120 => "Mid-Tempo (91-120)" , 121 ..= 140 => "Upbeat (121-140)" , 141 ..= 180 => "Fast (141-180)" , 181 ..= 300 => "Very Fast (181-300)" , _ => "Other" , } ; * bpm_ranges . entry (range) . or_insert (0) += count ; } output . push_str ("| BPM Range | Count | Percentage |\n") ; output . push_str ("|-----------|-------|------------|\n") ; let mut ranges : Vec < _ > = bpm_ranges . into_iter () . collect () ; ranges . sort_by (| a , b | b . 1 . cmp (& a . 1)) ; for (range , count) in ranges { output . push_str (& format ! ("| {} | {} | {:.2}% |\n" , range , count , count as f64 / total as f64 * 100.0)) ; } output . push_str ("\n") ; fs :: write (output_path , output) ? ; Ok (()) }

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/analyze_full_collection.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/analyze_full_collection.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/analyze_full_collection.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/analyze_full_collection.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/analyze_full_collection.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/analyze_full_collection.rs`
  - Category: Performance

- [ ] **Function 'main' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/analyze_full_collection.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn main () { let args : Vec < String > = std :: env :: args () . collect () ; let root_path = if args . len () > 1 { PathBuf :: from (& args [1]) } else { PathBuf :: from ("/home/dojevou/projects/midi-software-center/midi-library/archives") } ; let output_path = if args . len () > 2 { PathBuf :: from (& args [2]) } else { PathBuf :: from ("COMPLETE_COLLECTION_ANALYSIS.md") } ; println ! ("MIDI Collection Analysis") ; println ! ("========================") ; println ! ("Root path: {}" , root_path . display ()) ; println ! ("Output: {}" , output_path . display ()) ; println ! () ; let files = find_midi_files (& root_path) ; println ! ("Starting analysis of {} files...\n" , files . len ()) ; let stats = Arc :: new (CollectionStats :: new ()) ; let start = Instant :: now () ; let progress_interval = files . len () / 100 ; files . par_iter () . enumerate () . for_each (| (i , path) | { analyze_file (path , & stats) ; if i % progress_interval == 0 && i > 0 { let analyzed = stats . analyzed_files . load (Ordering :: Relaxed) ; let elapsed = start . elapsed () ; let rate = analyzed as f64 / elapsed . as_secs_f64 () ; println ! ("Progress: {:.1}% ({}/{} files) - {:.0} files/sec" , i as f64 / files . len () as f64 * 100.0 , analyzed , files . len () , rate) ; } }) ; let elapsed = start . elapsed () ; let total = stats . total_files . load (Ordering :: Relaxed) ; let rate = total as f64 / elapsed . as_secs_f64 () ; println ! ("\nAnalysis complete!") ; println ! ("Total files: {}" , total) ; println ! ("Time: {:?}" , elapsed) ; println ! ("Rate: {:.0} files/sec" , rate) ; println ! () ; println ! ("Generating report...") ; match generate_report (& stats , & output_path) { Ok (_) => println ! ("Report saved to: {}" , output_path . display ()) , Err (e) => eprintln ! ("Error generating report: {}" , e) , } }

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/batch_import.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/batch_import.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/batch_import.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/batch_import.rs`
  - Category: Performance

- [ ] **Function 'find_midi_files' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/batch_import.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Find all MIDI files in a directory"] fn find_midi_files (dir : & Path) -> Result < Vec < PathBuf > > { let mut files = Vec :: new () ; for entry in walkdir :: WalkDir :: new (dir) { let entry = entry ? ; let path = entry . path () ; if path . is_file () { if let Some (ext) = path . extension () { if ext . eq_ignore_ascii_case ("mid") || ext . eq_ignore_ascii_case ("midi") { files . push (path . to_path_buf ()) ; } } } } Ok (files) }

- [ ] **Function 'extract_time_signature' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/batch_import.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Extract time signature from MIDI file"] fn extract_time_signature (midi_file : & midi_library_shared :: core :: midi :: types :: MidiFile ,) -> (Option < i16 > , Option < i16 >) { use midi_library_shared :: core :: midi :: types :: Event ; for track in & midi_file . tracks { for timed_event in & track . events { if let Event :: TimeSignature { numerator , denominator , .. } = & timed_event . event { let denom_value = 2i16 . pow (* denominator as u32) ; return (Some (* numerator as i16) , Some (denom_value)) ; } } } (Some (4) , Some (4)) }

- [ ] **Function 'calculate_total_ticks' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/batch_import.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Calculate total ticks in MIDI file"] fn calculate_total_ticks (midi_file : & midi_library_shared :: core :: midi :: types :: MidiFile) -> i64 { let mut max_ticks = 0u32 ; for track in & midi_file . tracks { let mut track_ticks = 0u32 ; for timed_event in & track . events { track_ticks += timed_event . delta_ticks ; } max_ticks = max_ticks . max (track_ticks) ; } max_ticks as i64 }

- [ ] **Function 'analyze_notes' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/batch_import.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Analyze notes in MIDI file"] fn analyze_notes (midi_file : & midi_library_shared :: core :: midi :: types :: MidiFile) -> NoteStats { use midi_library_shared :: core :: midi :: types :: Event ; use std :: collections :: { HashMap , HashSet } ; let mut note_count = 0i32 ; let mut pitches = HashSet :: new () ; let mut min_pitch = 127u8 ; let mut max_pitch = 0u8 ; let mut velocity_sum = 0u32 ; let mut active_notes_per_tick : HashMap < u32 , usize > = HashMap :: new () ; for track in & midi_file . tracks { let mut current_tick = 0u32 ; let mut active_notes = HashSet :: new () ; for timed_event in & track . events { current_tick += timed_event . delta_ticks ; match & timed_event . event { Event :: NoteOn { note , velocity , .. } if * velocity > 0 => { note_count += 1 ; pitches . insert (* note) ; min_pitch = min_pitch . min (* note) ; max_pitch = max_pitch . max (* note) ; velocity_sum += * velocity as u32 ; active_notes . insert (* note) ; active_notes_per_tick . insert (current_tick , active_notes . len ()) ; } , Event :: NoteOff { note , .. } | Event :: NoteOn { note , velocity : 0 , .. } => { active_notes . remove (note) ; } , _ => { } , } } } let avg_velocity = if note_count > 0 { Some (BigDecimal :: from ((velocity_sum / note_count as u32) as i64)) } else { None } ; let polyphony_max = active_notes_per_tick . values () . max () . copied () . map (| v | v as i16) ; let (pitch_min , pitch_max) = if note_count > 0 { (Some (min_pitch as i16) , Some (max_pitch as i16)) } else { (None , None) } ; NoteStats { note_count , unique_pitches : Some (pitches . len () as i32) , pitch_min , pitch_max , avg_velocity , polyphony_max , } }

- [ ] **Function 'print_summary' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/batch_import.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Print final summary"] fn print_summary (stats : & ImportStats) { let elapsed = stats . start_time . map (| t | t . elapsed ()) . unwrap_or_else (| | std :: time :: Duration :: from_secs (0)) ; let duration_secs = elapsed . as_secs_f64 () ; let imported = stats . files_imported . load (Ordering :: SeqCst) ; let rate = if duration_secs > 0.0 { imported as f64 / duration_secs } else { 0.0 } ; println ! ("\n========================================") ; println ! ("BATCH IMPORT COMPLETE") ; println ! ("========================================") ; println ! ("Files found: {}" , stats . files_found . load (Ordering :: SeqCst)) ; println ! ("Successfully imported: {}" , imported) ; println ! ("Duplicates skipped: {}" , stats . files_duplicates . load (Ordering :: SeqCst)) ; println ! ("Errors: {}" , stats . files_errors . load (Ordering :: SeqCst)) ; println ! ("Time: {:.0}h {:.0}m {:.0}s" , duration_secs / 3600.0 , (duration_secs % 3600.0) / 60.0 , duration_secs % 60.0) ; println ! ("Avg speed: {:.0} files/sec" , rate) ; println ! ("========================================") ; println ! ("All files include: BPM, Key, Notes, Stats") ; println ! ("========================================\n") ; }

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/batch_split.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/batch_split.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/batch_split.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/batch_split.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/batch_split.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/batch_split.rs`
  - Category: Performance

- [ ] **Function 'sanitize_filename' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/batch_split.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn sanitize_filename (name : & str) -> String { name . chars () . map (| c | match c { '/' | '\\' | ':' | '*' | '?' | '"' | '<' | '>' | '|' => '_' , c if c . is_control () => '_' , c => c , }) . collect :: < String > () . trim () . to_string () }

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/batch_split_optimized.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/batch_split_optimized.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/batch_split_optimized.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/batch_split_optimized.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/batch_split_optimized.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/batch_split_optimized.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/batch_split_optimized.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/batch_split_optimized.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/batch_split_optimized.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/batch_split_optimized.rs`
  - Category: Performance

- [ ] **Function 'sanitize_filename' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/batch_split_optimized.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn sanitize_filename (name : & str) -> String { name . chars () . map (| c | match c { '/' | '\\' | ':' | '*' | '?' | '"' | '<' | '>' | '|' => '_' , c if c . is_control () => '_' , c => c , }) . collect :: < String > () . trim () . to_string () }

- [ ] **Function 'extract_instruments' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/extract_instruments.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Extract instruments from filename"] fn extract_instruments (filename : & str) -> Vec < String > { let filename_lower = filename . to_lowercase () ; let mut found = Vec :: new () ; for & keyword in INSTRUMENT_KEYWORDS { if filename_lower . contains (keyword) { found . push (keyword . to_string ()) ; } } found }

- [ ] **Function 'find_midi_files' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/extract_instruments.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Find all MIDI files recursively"] fn find_midi_files (root : & str) -> Vec < PathBuf > { println ! ("Scanning for MIDI files...") ; let start = Instant :: now () ; let files : Vec < PathBuf > = walkdir :: WalkDir :: new (root) . follow_links (false) . into_iter () . filter_map (| e | e . ok ()) . filter (| e | { e . path () . extension () . and_then (| ext | ext . to_str ()) . map (| ext | { let ext_lower = ext . to_lowercase () ; ext_lower == "mid" || ext_lower == "midi" }) . unwrap_or (false) }) . map (| e | e . path () . to_path_buf ()) . collect () ; println ! ("Found {} MIDI files in {:?}" , files . len () , start . elapsed ()) ; files }

- [ ] **Function 'process_files' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/extract_instruments.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Process files and extract instruments"] fn process_files (files : Vec < PathBuf >) -> DashMap < String , u64 > { println ! ("\nExtracting instruments from {} files..." , files . len ()) ; let start = Instant :: now () ; let instrument_counts : DashMap < String , u64 > = DashMap :: new () ; let processed = AtomicU64 :: new (0) ; files . par_iter () . for_each (| path | { if let Some (filename) = path . file_name () . and_then (| n | n . to_str ()) { let instruments = extract_instruments (filename) ; for instrument in instruments { instrument_counts . entry (instrument) . and_modify (| count | * count += 1) . or_insert (1) ; } } let count = processed . fetch_add (1 , Ordering :: Relaxed) + 1 ; if count % 10000 == 0 { let elapsed = start . elapsed () ; let rate = count as f64 / elapsed . as_secs_f64 () ; println ! ("Processed: {} files ({:.0} files/sec)" , count , rate) ; } }) ; let elapsed = start . elapsed () ; let total = processed . load (Ordering :: Relaxed) ; let rate = total as f64 / elapsed . as_secs_f64 () ; println ! ("\nProcessing complete: {} files in {:?} ({:.0} files/sec)" , total , elapsed , rate) ; instrument_counts }

- [ ] **Function 'generate_report' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/extract_instruments.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Generate report"] fn generate_report (instrument_counts : DashMap < String , u64 > , total_files : usize ,) -> std :: io :: Result < () > { println ! ("\nGenerating report...") ; let mut instruments : Vec < (String , u64) > = instrument_counts . into_iter () . collect () ; instruments . sort_by (| a , b | b . 1 . cmp (& a . 1)) ; let mut report = String :: new () ; report . push_str ("# MIDI Library Instrument Analysis\n\n") ; report . push_str (& format ! ("**Total Files Analyzed:** {}\n\n" , total_files)) ; report . push_str (& format ! ("**Unique Instruments Found:** {}\n\n" , instruments . len ())) ; report . push_str ("## Instrument Frequency\n\n") ; report . push_str ("| Rank | Instrument | Count | Percentage |\n") ; report . push_str ("|------|------------|-------|------------|\n") ; for (idx , (instrument , count)) in instruments . iter () . enumerate () { let percentage = (* count as f64 / total_files as f64) * 100.0 ; report . push_str (& format ! ("| {} | {} | {} | {:.2}% |\n" , idx + 1 , instrument , count , percentage)) ; } let report_path = "INSTRUMENT_ANALYSIS.md" ; std :: fs :: write (report_path , & report) ? ; println ! ("Report saved to: {}" , report_path) ; let mut instrument_list = String :: new () ; for (instrument , count) in & instruments { instrument_list . push_str (& format ! ("{}: {}\n" , instrument , count)) ; } let list_path = "INSTRUMENT_LIST.txt" ; std :: fs :: write (list_path , instrument_list) ? ; println ! ("Instrument list saved to: {}" , list_path) ; Ok (()) }

- [ ] **Function 'main' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/extract_instruments.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn main () { let args : Vec < String > = std :: env :: args () . collect () ; if args . len () < 2 { eprintln ! ("Usage: {} <midi-library-path>" , args [0]) ; eprintln ! ("\nExample:") ; eprintln ! ("  {} ~/projects/midi-software-center/midi-library/" , args [0]) ; std :: process :: exit (1) ; } let root_path = & args [1] ; println ! ("MIDI Instrument Extractor") ; println ! ("=========================") ; println ! ("Root path: {}" , root_path) ; println ! () ; let files = find_midi_files (root_path) ; if files . is_empty () { println ! ("No MIDI files found!") ; std :: process :: exit (0) ; } let total_files = files . len () ; let instrument_counts = process_files (files) ; match generate_report (instrument_counts , total_files) { Ok (_) => println ! ("\nâœ… Analysis complete!") , Err (e) => { eprintln ! ("\nâŒ Error generating report: {}" , e) ; std :: process :: exit (1) ; } , } }

- [ ] **Function 'normalize_keyword' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/fast_tagger.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Normalize keyword from text"] fn normalize_keyword (text : & str) -> HashSet < String > { let mut keywords = HashSet :: new () ; if text . is_empty () { return keywords ; } let text = text . to_lowercase () ; let re = Regex :: new (r"[_\-\(\)\[\]@#]") . unwrap () ; let text = re . replace_all (& text , " ") ; let noise_words : HashSet < & str > = ["the" , "and" , "for" , "with" , "from" , "midi" , "mid"] . iter () . cloned () . collect () ; for word in text . split_whitespace () { let word = word . trim () ; if word . len () < 3 || word . len () > 50 { continue ; } if word . chars () . all (| c | c . is_numeric ()) { continue ; } if noise_words . contains (word) { continue ; } keywords . insert (word . to_string ()) ; } keywords }

- [ ] **Function 'extract_path_components' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/fast_tagger.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Extract grandparent, parent, and filename from path"] fn extract_path_components (file_id : i64 , filepath : & str) -> PathComponents { let path = Path :: new (filepath) ; let filename = path . file_stem () . and_then (| s | s . to_str ()) . unwrap_or ("") . to_string () ; let parent = path . parent () . and_then (| p | p . file_name ()) . and_then (| n | n . to_str ()) . unwrap_or ("") . to_string () ; let grandparent = path . parent () . and_then (| p | p . parent ()) . and_then (| p | p . file_name ()) . and_then (| n | n . to_str ()) . unwrap_or ("") . to_string () ; PathComponents { file_id , filepath : filepath . to_string () , grandparent , parent , filename } }

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/fast_tagger.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/fast_tagger.rs`
  - Category: Performance

- [ ] **Function 'process_files_for_tags' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/fast_tagger.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Process files and extract matching tags"] fn process_files_for_tags (files : Vec < PathComponents > , tag_map : & HashMap < String , i64 > , stats : Arc < TaggingStats > ,) -> Vec < FileTag > { println ! ("âš™ï¸ Processing files for tag matching...") ; let file_tags : Vec < FileTag > = files . par_iter () . flat_map (| file | { stats . processed . fetch_add (1 , Ordering :: Relaxed) ; let mut keywords = HashSet :: new () ; keywords . extend (normalize_keyword (& file . grandparent)) ; keywords . extend (normalize_keyword (& file . parent)) ; keywords . extend (normalize_keyword (& file . filename)) ; let mut file_tags = Vec :: new () ; for keyword in keywords { if let Some (& tag_id) = tag_map . get (& keyword) { file_tags . push (FileTag { file_id : file . file_id , tag_id }) ; } } if ! file_tags . is_empty () { stats . tagged . fetch_add (1 , Ordering :: Relaxed) ; stats . total_tags_inserted . fetch_add (file_tags . len () as u64 , Ordering :: Relaxed) ; } file_tags }) . collect () ; println ! ("âœ… Matched {} tag relationships" , file_tags . len ()) ; file_tags }

- [ ] **Function 'normalize_keyword' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/fast_tagger_full.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Normalize keyword from text"] fn normalize_keyword (text : & str) -> HashSet < String > { let mut keywords = HashSet :: new () ; if text . is_empty () { return keywords ; } let text = text . to_lowercase () ; let re = Regex :: new (r"[_\-\(\)\[\]@#/\\]") . unwrap () ; let text = re . replace_all (& text , " ") ; let noise_words : HashSet < & str > = ["the" , "and" , "for" , "with" , "from" , "midi" , "mid" , "extracted" , "archive" , "archives" , "files" , "file" , "pack" , "collection" ,] . iter () . cloned () . collect () ; for word in text . split_whitespace () { let word = word . trim () ; if word . len () < 2 || word . len () > 50 { continue ; } if word . chars () . all (| c | c . is_numeric ()) { continue ; } if noise_words . contains (word) { continue ; } keywords . insert (word . to_string ()) ; } keywords }

- [ ] **Function 'extract_path_components' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/fast_tagger_full.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Extract grandparent, parent, and filename from path"] fn extract_path_components (file_id : i64 , filepath : & str) -> PathComponents { let path = Path :: new (filepath) ; let filename = path . file_stem () . and_then (| s | s . to_str ()) . unwrap_or ("") . to_string () ; let parent = path . parent () . and_then (| p | p . file_name ()) . and_then (| n | n . to_str ()) . unwrap_or ("") . to_string () ; let grandparent = path . parent () . and_then (| p | p . parent ()) . and_then (| p | p . file_name ()) . and_then (| n | n . to_str ()) . unwrap_or ("") . to_string () ; PathComponents { file_id , filepath : filepath . to_string () , grandparent , parent , filename } }

- [ ] **Function 'load_keywords_from_file' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/fast_tagger_full.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Load keywords from frequency file (format: \"count keyword\")"] fn load_keywords_from_file (file_path : & str , min_freq : usize ,) -> Result < HashSet < String > , Box < dyn std :: error :: Error > > { println ! ("ğŸ“‹ Loading keywords from: {}" , file_path) ; let start = Instant :: now () ; let content = fs :: read_to_string (file_path) ? ; let mut keywords = HashSet :: new () ; let mut total_count = 0 ; let mut filtered_count = 0 ; let mut parse_errors = 0 ; for line in content . lines () { let line = line . trim () ; if line . is_empty () { continue ; } total_count += 1 ; if let Some (first_space) = line . find (char :: is_whitespace) { let count_str = line [.. first_space] . trim () ; let keyword = line [first_space ..] . trim () ; if keyword . is_empty () { parse_errors += 1 ; continue ; } match count_str . parse :: < usize > () { Ok (freq) if freq >= min_freq => { for kw in normalize_keyword (keyword) { keywords . insert (kw) ; } filtered_count += 1 ; } , Ok (_) => { } , Err (_) => { parse_errors += 1 ; } , } } else { parse_errors += 1 ; } } println ! ("âœ… Loaded {} keywords ({} filtered from {} total, {} parse errors) in {:.2}s" , keywords . len () , filtered_count , total_count , parse_errors , start . elapsed () . as_secs_f64 ()) ; if ! keywords . is_empty () { let sample : Vec < String > = keywords . iter () . take (5) . cloned () . collect () ; println ! ("  Sample keywords: {:?}" , sample) ; } Ok (keywords) }

- [ ] **Function 'load_all_keywords' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/fast_tagger_full.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Load ALL keywords from the three source files"] fn load_all_keywords (args : & Args) -> Result < HashSet < String > , Box < dyn std :: error :: Error > > { println ! ("\nğŸ“š Loading ALL keywords from collection...") ; let start = Instant :: now () ; let mut all_keywords = HashSet :: new () ; println ! ("\n1ï¸âƒ£ Grandparent Folder Keywords:") ; let grandparent_kw = load_keywords_from_file (& args . grandparent_file , args . min_frequency) ? ; all_keywords . extend (grandparent_kw) ; println ! ("\n2ï¸âƒ£ Parent Folder Keywords:") ; let parent_kw = load_keywords_from_file (& args . parent_file , args . min_frequency) ? ; all_keywords . extend (parent_kw) ; println ! ("\n3ï¸âƒ£ Filename Keywords:") ; let filename_kw = load_keywords_from_file (& args . filename_file , args . min_frequency) ? ; all_keywords . extend (filename_kw) ; println ! ("\nâœ… Total unique keywords loaded: {} (in {:.2}s)" , all_keywords . len () , start . elapsed () . as_secs_f64 ()) ; Ok (all_keywords) }

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/fast_tagger_full.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/fast_tagger_full.rs`
  - Category: Performance

- [ ] **Function 'process_files_for_tags' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/fast_tagger_full.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Process files and extract matching tags"] fn process_files_for_tags (files : Vec < PathComponents > , tag_map : & HashMap < String , i64 > , stats : Arc < TaggingStats > ,) -> Vec < FileTag > { println ! ("âš™ï¸ Processing files for tag matching...") ; let file_tags : Vec < FileTag > = files . par_iter () . flat_map (| file | { stats . processed . fetch_add (1 , Ordering :: Relaxed) ; let mut keywords = HashSet :: new () ; keywords . extend (normalize_keyword (& file . grandparent)) ; keywords . extend (normalize_keyword (& file . parent)) ; keywords . extend (normalize_keyword (& file . filename)) ; let mut file_tags = Vec :: new () ; for keyword in keywords { if let Some (& tag_id) = tag_map . get (& keyword) { file_tags . push (FileTag { file_id : file . file_id , tag_id }) ; } } if ! file_tags . is_empty () { stats . tagged . fetch_add (1 , Ordering :: Relaxed) ; stats . total_tags_inserted . fetch_add (file_tags . len () as u64 , Ordering :: Relaxed) ; } file_tags }) . collect () ; println ! ("âœ… Matched {} tag relationships" , file_tags . len ()) ; file_tags }

- [ ] **Function 'hash_file' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/find_duplicates.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Calculate BLAKE3 hash of a file"] fn hash_file (path : & Path) -> Result < String , std :: io :: Error > { let mut file = fs :: File :: open (path) ? ; let mut hasher = blake3 :: Hasher :: new () ; let mut buffer = vec ! [0 ; 65536] ; loop { let bytes_read = file . read (& mut buffer) ? ; if bytes_read == 0 { break ; } hasher . update (& buffer [.. bytes_read]) ; } Ok (hasher . finalize () . to_hex () . to_string ()) }

- [ ] **Function 'find_midi_files' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/find_duplicates.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Find all MIDI files recursively"] fn find_midi_files (root : & Path) -> Vec < PathBuf > { println ! ("Scanning for MIDI files...") ; let start = Instant :: now () ; let files : Vec < PathBuf > = walkdir :: WalkDir :: new (root) . follow_links (false) . into_iter () . filter_map (| e | e . ok ()) . filter (| e | { e . path () . extension () . and_then (| ext | ext . to_str ()) . map (| ext | { let ext_lower = ext . to_lowercase () ; ext_lower == "mid" || ext_lower == "midi" }) . unwrap_or (false) }) . map (| e | e . path () . to_path_buf ()) . collect () ; println ! ("Found {} MIDI files in {:?}" , files . len () , start . elapsed ()) ; files }

- [ ] **Function 'detect_duplicates' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/find_duplicates.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Process files and detect duplicates"] fn detect_duplicates (files : Vec < PathBuf >) -> (HashMap < String , Vec < FileInfo > > , Arc < DuplicateStats >) { println ! ("\nHashing {} files..." , files . len ()) ; let start = Instant :: now () ; let file_map : DashMap < String , Vec < FileInfo > > = DashMap :: new () ; let stats = Arc :: new (DuplicateStats :: new ()) ; let processed = AtomicU64 :: new (0) ; files . par_iter () . for_each (| path | { let size = match fs :: metadata (path) { Ok (metadata) => metadata . len () , Err (_) => return , } ; let hash = match hash_file (path) { Ok (h) => h , Err (_) => return , } ; let info = FileInfo { path : path . clone () , size , hash : hash . clone () } ; file_map . entry (hash) . or_insert_with (Vec :: new) . push (info) ; stats . total_files . fetch_add (1 , Ordering :: Relaxed) ; stats . total_bytes . fetch_add (size , Ordering :: Relaxed) ; let count = processed . fetch_add (1 , Ordering :: Relaxed) + 1 ; if count % 10000 == 0 { let elapsed = start . elapsed () ; let rate = count as f64 / elapsed . as_secs_f64 () ; println ! ("Processed: {}   files ({:.0} files/sec)" , count , rate) ; } }) ; let elapsed = start . elapsed () ; let total = stats . total_files . load (Ordering :: Relaxed) ; let rate = total as f64 / elapsed . as_secs_f64 () ; println ! ("\nHashing complete: {}   files in {:?} ({:.0} files/sec)" , total , elapsed , rate) ; let mut result = HashMap :: new () ; for entry in file_map . into_iter () { result . insert (entry . 0 , entry . 1) ; } (result , stats) }

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/find_duplicates.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/find_duplicates.rs`
  - Category: Performance

- [ ] **Function 'analyze_duplicates' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/find_duplicates.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Analyze duplicates and update stats"] fn analyze_duplicates (file_map : & HashMap < String , Vec < FileInfo > > , stats : & DuplicateStats ,) -> Vec < (String , Vec < FileInfo >) > { let mut duplicates = Vec :: new () ; for (hash , files) in file_map { if files . len () > 1 { stats . unique_files . fetch_add (1 , Ordering :: Relaxed) ; let dup_count = files . len () as u64 - 1 ; stats . duplicate_files . fetch_add (dup_count , Ordering :: Relaxed) ; let file_size = files [0] . size ; stats . duplicate_bytes . fetch_add (file_size * dup_count , Ordering :: Relaxed) ; duplicates . push ((hash . clone () , files . clone ())) ; } else { stats . unique_files . fetch_add (1 , Ordering :: Relaxed) ; } } duplicates . sort_by (| a , b | b . 1 . len () . cmp (& a . 1 . len ())) ; duplicates }

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/find_duplicates.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/find_duplicates.rs`
  - Category: Performance

- [ ] **Function 'format_number' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/find_duplicates.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Format number with thousand separators"] fn format_number (n : u64) -> String { n . to_string () . as_bytes () . rchunks (3) . rev () . map (std :: str :: from_utf8) . collect :: < Result < Vec < & str > , _ > > () . unwrap () . join (",") }

- [ ] **Function 'generate_report' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/find_duplicates.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Generate duplicate report"] fn generate_report (duplicates : & [(String , Vec < FileInfo >)] , stats : & DuplicateStats , output_path : & Path ,) -> std :: io :: Result < () > { let mut output = String :: new () ; output . push_str ("# MIDI Duplicate Files Report\n\n") ; let total_files = stats . total_files . load (Ordering :: Relaxed) ; let total_bytes = stats . total_bytes . load (Ordering :: Relaxed) ; let unique_files = stats . unique_files . load (Ordering :: Relaxed) ; let duplicate_files = stats . duplicate_files . load (Ordering :: Relaxed) ; let duplicate_bytes = stats . duplicate_bytes . load (Ordering :: Relaxed) ; output . push_str ("## Summary Statistics\n\n") ; output . push_str (& format ! ("- **Total files scanned:** {}  \n" , total_files)) ; output . push_str (& format ! ("- **Total size:** {:.2} GB\n" , total_bytes as f64 / 1_073_741_824.0)) ; output . push_str (& format ! ("- **Unique files:** {}  \n" , unique_files)) ; output . push_str (& format ! ("- **Duplicate files:** {}   ({:.1}%)\n" , duplicate_files , duplicate_files as f64 / total_files as f64 * 100.0)) ; output . push_str (& format ! ("- **Space wasted by duplicates:** {:.2} GB\n" , duplicate_bytes as f64 / 1_073_741_824.0)) ; output . push_str (& format ! ("- **Duplicate groups:** {}  \n\n" , duplicates . len ())) ; output . push_str ("## Duplicate Groups\n\n") ; output . push_str ("Each group shows files with identical content. The **first file** in each group will be **KEPT**, all others will be **DELETED**.\n\n") ; for (i , (hash , files)) in duplicates . iter () . enumerate () { output . push_str (& format ! ("### Group {} ({} duplicates)\n\n" , i + 1 , files . len () - 1)) ; output . push_str (& format ! ("**Hash:** `{}`\n" , & hash [.. 16])) ; output . push_str (& format ! ("**Size:** {:.2} KB\n\n" , files [0] . size as f64 / 1024.0)) ; output . push_str ("| Status | Path |\n") ; output . push_str ("|--------|------|\n") ; for (j , file) in files . iter () . enumerate () { let status = if j == 0 { "âœ… KEEP" } else { "âŒ DELETE" } ; output . push_str (& format ! ("| {} | `{}` |\n" , status , file . path . display ())) ; } output . push_str ("\n") ; if i >= 99 { output . push_str (& format ! ("\n*Note: Only showing first 100 groups. Total groups: {}*\n\n" , duplicates . len ())) ; break ; } } output . push_str ("\n---\n\n") ; output . push_str ("## Deletion Summary\n\n") ; output . push_str (& format ! ("Total files to delete: **{}  **\n" , duplicate_files)) ; output . push_str (& format ! ("Space to recover: **{:.2} GB**\n\n" , duplicate_bytes as f64 / 1_073_741_824.0)) ; fs :: write (output_path , output) ? ; let delete_list_path = output_path . with_extension ("delete.txt") ; let mut delete_list = String :: new () ; for (_hash , files) in duplicates { for file in files . iter () . skip (1) { delete_list . push_str (& format ! ("{}\n" , file . path . display ())) ; } } fs :: write (& delete_list_path , delete_list) ? ; println ! ("\nDeletion list saved to: {}" , delete_list_path . display ()) ; Ok (()) }

- [ ] **Function 'execute_deletion' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/find_duplicates.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Execute deletion"] fn execute_deletion (delete_list_path : & Path) -> std :: io :: Result < u64 > { println ! ("\nâš ï¸  EXECUTING DELETION...") ; let content = fs :: read_to_string (delete_list_path) ? ; let files : Vec < & str > = content . lines () . collect () ; let deleted = AtomicU64 :: new (0) ; let failed = AtomicU64 :: new (0) ; files . par_iter () . for_each (| path | { match fs :: remove_file (path) { Ok (_) => { deleted . fetch_add (1 , Ordering :: Relaxed) ; } , Err (e) => { eprintln ! ("Failed to delete {}: {}" , path , e) ; failed . fetch_add (1 , Ordering :: Relaxed) ; } , } let count = deleted . load (Ordering :: Relaxed) ; if count % 1000 == 0 { println ! ("Deleted: {}   files" , count) ; } }) ; let total_deleted = deleted . load (Ordering :: Relaxed) ; let total_failed = failed . load (Ordering :: Relaxed) ; println ! ("\nâœ… Deletion complete!") ; println ! ("Files deleted: {}  " , total_deleted) ; if total_failed > 0 { println ! ("âš ï¸  Failed to delete: {}  " , total_failed) ; } Ok (total_deleted) }

- [ ] **Function 'main' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/find_duplicates.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn main () { let args : Vec < String > = std :: env :: args () . collect () ; if args . len () < 2 { eprintln ! ("Usage: {} <path> [--delete]" , args [0]) ; eprintln ! ("\nOptions:") ; eprintln ! ("  <path>      Path to MIDI directory") ; eprintln ! ("  --delete    Execute deletion (use with caution!)") ; eprintln ! ("\nExample:") ; eprintln ! ("  {} /path/to/midi/files" , args [0]) ; eprintln ! ("  {} /path/to/midi/files --delete" , args [0]) ; std :: process :: exit (1) ; } let root_path = PathBuf :: from (& args [1]) ; let delete_mode = args . len () > 2 && args [2] == "--delete" ; if ! root_path . exists () { eprintln ! ("Error: Path does not exist: {}" , root_path . display ()) ; std :: process :: exit (1) ; } println ! ("MIDI Duplicate Finder") ; println ! ("=====================") ; println ! ("Root path: {}" , root_path . display ()) ; if delete_mode { println ! ("âš ï¸  DELETE MODE ENABLED - Files will be deleted!") ; } else { println ! ("Mode: Analysis only (no deletion)") ; } println ! () ; let files = find_midi_files (& root_path) ; if files . is_empty () { println ! ("No MIDI files found!") ; std :: process :: exit (0) ; } let (file_map , stats) = detect_duplicates (files) ; let duplicates = analyze_duplicates (& file_map , & stats) ; if duplicates . is_empty () { println ! ("\nâœ… No duplicates found! All files are unique.") ; std :: process :: exit (0) ; } let report_path = PathBuf :: from ("DUPLICATE_REPORT.md") ; println ! ("\nGenerating report...") ; match generate_report (& duplicates , & stats , & report_path) { Ok (_) => println ! ("Report saved to: {}" , report_path . display ()) , Err (e) => { eprintln ! ("Error generating report: {}" , e) ; std :: process :: exit (1) ; } , } if delete_mode { println ! ("\nâš ï¸  âš ï¸  âš ï¸  WARNING âš ï¸  âš ï¸  âš ï¸") ; println ! ("You are about to DELETE {}   files!" , stats . duplicate_files . load (Ordering :: Relaxed)) ; println ! ("This will free {:.2} GB of space." , stats . duplicate_bytes . load (Ordering :: Relaxed) as f64 / 1_073_741_824.0) ; println ! ("\nPress Ctrl+C within 10 seconds to cancel...") ; std :: thread :: sleep (std :: time :: Duration :: from_secs (10)) ; let delete_list_path = report_path . with_extension ("delete.txt") ; match execute_deletion (& delete_list_path) { Ok (deleted) => println ! ("\nâœ… Successfully deleted {}   duplicate files!" , deleted) , Err (e) => eprintln ! ("\nâŒ Error during deletion: {}" , e) , } } else { println ! ("\nğŸ“‹ Review the report and deletion list.") ; println ! ("To execute deletion, run:") ; println ! ("  {} {} --delete" , args [0] , root_path . display ()) ; } }

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/import.rs`
  - Category: Performance

- [ ] **Function 'hash_file' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/import_split_files.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Calculate BLAKE3 hash of a file (returns raw bytes)"] fn hash_file (path : & Path) -> Result < Vec < u8 > , std :: io :: Error > { let mut file = fs :: File :: open (path) ? ; let mut hasher = blake3 :: Hasher :: new () ; let mut buffer = vec ! [0 ; 65536] ; loop { let bytes_read = file . read (& mut buffer) ? ; if bytes_read == 0 { break ; } hasher . update (& buffer [.. bytes_read]) ; } Ok (hasher . finalize () . as_bytes () . to_vec ()) }

- [ ] **Function 'extract_parent_info' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/import_split_files.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Extract parent file ID and track number from split filename"] # [doc = " Format: {parent_id}_{original_name}_{track_num}_{instrument}.mid"] fn extract_parent_info (filename : & str) -> (Option < i64 > , Option < i16 >) { if let Some (caps) = regex :: Regex :: new (r"^(\d+)_") . unwrap () . captures (filename) { let parent_id = caps . get (1) . and_then (| m | m . as_str () . parse :: < i64 > () . ok ()) ; let track_number = regex :: Regex :: new (r"_(\d{2})_") . unwrap () . captures (filename) . and_then (| caps | caps . get (1)) . and_then (| m | m . as_str () . parse :: < i16 > () . ok ()) ; return (parent_id , track_number) ; } (None , None) }

- [ ] **Function 'parse_midi_basic' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/import_split_files.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Parse MIDI file for basic metadata"] fn parse_midi_basic (path : & Path) -> Result < (i16 , i16 , i32 , i64) , String > { let data = fs :: read (path) . map_err (| e | format ! ("Failed to read file: {}" , e)) ? ; let smf = Smf :: parse (& data) . map_err (| e | format ! ("Failed to parse MIDI: {}" , e)) ? ; let midi_format = match smf . header . format { midly :: Format :: SingleTrack => 0 , midly :: Format :: Parallel => 1 , midly :: Format :: Sequential => 2 , } ; let num_tracks = smf . tracks . len () as i16 ; let ticks_per_quarter = match smf . header . timing { Timing :: Metrical (tpq) => tpq . as_int () as i32 , Timing :: Timecode (fps , sub) => { let ticks_per_second = fps . as_f32 () * sub as f32 ; (ticks_per_second * 0.5) as i32 } , } ; let mut max_ticks = 0i64 ; for track in & smf . tracks { let mut track_ticks = 0i64 ; for event in track { track_ticks += event . delta . as_int () as i64 ; } if track_ticks > max_ticks { max_ticks = track_ticks ; } } Ok ((midi_format , num_tracks , ticks_per_quarter , max_ticks)) }

- [ ] **Function 'find_midi_files' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/import_split_files.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Find all MIDI files in directory"] fn find_midi_files (root : & Path) -> Vec < PathBuf > { println ! ("ğŸ” Scanning for MIDI files in: {}" , root . display ()) ; let start = Instant :: now () ; let files : Vec < PathBuf > = walkdir :: WalkDir :: new (root) . follow_links (false) . into_iter () . filter_map (| e | e . ok ()) . filter (| e | { e . path () . extension () . and_then (| ext | ext . to_str ()) . map (| ext | { let ext_lower = ext . to_lowercase () ; ext_lower == "mid" || ext_lower == "midi" }) . unwrap_or (false) }) . map (| e | e . path () . to_path_buf ()) . collect () ; println ! ("âœ… Found {} MIDI files in {:.2}s" , files . len () , start . elapsed () . as_secs_f64 ()) ; files }

- [ ] **Function 'process_files' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/import_split_files.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Process files in parallel and extract metadata"] fn process_files (files : Vec < PathBuf > , existing_hashes : Arc < DashMap < Vec < u8 > , () > > , stats : Arc < ImportStats > , skip_existing : bool ,) -> Vec < FileRecord > { println ! ("âš™ï¸ Processing {} files with rayon..." , files . len ()) ; let records : Vec < FileRecord > = files . par_iter () . filter_map (| path | { stats . processed . fetch_add (1 , Ordering :: Relaxed) ; let content_hash = match hash_file (path) { Ok (h) => h , Err (e) => { eprintln ! ("âŒ Hash error for {}: {}" , path . display () , e) ; stats . errors . fetch_add (1 , Ordering :: Relaxed) ; return None ; } , } ; if skip_existing && existing_hashes . contains_key (& content_hash) { stats . skipped . fetch_add (1 , Ordering :: Relaxed) ; return None ; } let file_size_bytes = match fs :: metadata (path) { Ok (m) => m . len () as i64 , Err (e) => { eprintln ! ("âŒ Metadata error for {}: {}" , path . display () , e) ; stats . errors . fetch_add (1 , Ordering :: Relaxed) ; return None ; } , } ; let (format , num_tracks , ticks_per_quarter , duration_ticks) = match parse_midi_basic (path) { Ok (data) => data , Err (e) => { eprintln ! ("âŒ MIDI parse error for {}: {}" , path . display () , e) ; stats . errors . fetch_add (1 , Ordering :: Relaxed) ; return None ; } , } ; let filename = path . file_name () ? . to_str () ? . to_string () ; let (parent_file_id , track_number) = extract_parent_info (& filename) ; Some (FileRecord { filepath : path . to_str () ? . to_string () , filename : filename . clone () , original_filename : filename , content_hash , file_size_bytes , parent_file_id , track_number , format , num_tracks , ticks_per_quarter_note : ticks_per_quarter , duration_ticks , }) }) . collect () ; println ! ("âœ… Processed {} valid records" , records . len ()) ; records }

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/import_split_files.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/import_unified.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/import_unified.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/import_unified.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/import_unified.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/import_unified.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/import_unified.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/import_unified.rs`
  - Category: Performance

- [ ] **Function 'analyze_notes' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/import_unified.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn analyze_notes (midi_file : & MidiFile) -> NoteStats { let mut note_count = 0 ; let mut min_pitch = 127u8 ; let mut max_pitch = 0u8 ; let mut min_velocity = 127u8 ; let mut max_velocity = 0u8 ; let mut velocity_sum = 0u32 ; let mut active_notes_per_tick : std :: collections :: HashMap < u32 , usize > = std :: collections :: HashMap :: new () ; for track in & midi_file . tracks { let mut current_tick = 0u32 ; let mut active_notes = std :: collections :: HashSet :: new () ; for timed_event in & track . events { current_tick += timed_event . delta_ticks ; match & timed_event . event { Event :: NoteOn { note , velocity , .. } if * velocity > 0 => { note_count += 1 ; min_pitch = min_pitch . min (* note) ; max_pitch = max_pitch . max (* note) ; min_velocity = min_velocity . min (* velocity) ; max_velocity = max_velocity . max (* velocity) ; velocity_sum += * velocity as u32 ; active_notes . insert (* note) ; active_notes_per_tick . insert (current_tick , active_notes . len ()) ; } , Event :: NoteOff { note , .. } | Event :: NoteOn { note , velocity : 0 , .. } => { active_notes . remove (note) ; } , _ => { } , } } } let avg_velocity = if note_count > 0 { Some (velocity_sum as f64 / note_count as f64) } else { None } ; let polyphony_max = active_notes_per_tick . values () . max () . copied () . map (| v | v as i16) ; let (pitch_range_low , pitch_range_high , pitch_range_semitones) = if note_count > 0 { let semitones = max_pitch . saturating_sub (min_pitch) as i16 ; (Some (min_pitch as i16) , Some (max_pitch as i16) , Some (semitones) ,) } else { (None , None , None) } ; let (velocity_range_low , velocity_range_high) = if note_count > 0 { (Some (min_velocity as i16) , Some (max_velocity as i16)) } else { (None , None) } ; NoteStats { note_count , pitch_range_low , pitch_range_high , pitch_range_semitones , avg_velocity , velocity_range_low , velocity_range_high , polyphony_max , } }

- [ ] **Function 'extract_time_signature' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/import_unified.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn extract_time_signature (midi_file : & MidiFile) -> (Option < i16 > , Option < i16 >) { for track in & midi_file . tracks { for timed_event in & track . events { if let Event :: TimeSignature { numerator , denominator , .. } = & timed_event . event { let denom_value = 2i16 . pow (* denominator as u32) ; return (Some (* numerator as i16) , Some (denom_value)) ; } } } (Some (4) , Some (4)) }

- [ ] **Function 'calculate_total_ticks' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/import_unified.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn calculate_total_ticks (midi_file : & MidiFile) -> i32 { let mut max_ticks = 0u32 ; for track in & midi_file . tracks { let mut track_ticks = 0u32 ; for timed_event in & track . events { track_ticks += timed_event . delta_ticks ; } max_ticks = max_ticks . max (track_ticks) ; } max_ticks as i32 }

- [ ] **Function 'calculate_duration_seconds' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/import_unified.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn calculate_duration_seconds (midi_file : & MidiFile , bpm : f64) -> Option < f64 > { let total_ticks = calculate_total_ticks (midi_file) as f64 ; let ticks_per_quarter = midi_file . header . ticks_per_quarter_note as f64 ; if total_ticks > 0.0 && ticks_per_quarter > 0.0 && bpm > 0.0 { let quarters = total_ticks / ticks_per_quarter ; let minutes = quarters / bpm ; let seconds = minutes * 60.0 ; Some (seconds) } else { None } }

- [ ] **Function 'extract_instrument_names' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/import_unified.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn extract_instrument_names (midi_file : & MidiFile) -> Vec < String > { let mut instruments = Vec :: new () ; for track in & midi_file . tracks { for timed_event in & track . events { match & timed_event . event { Event :: Text { text_type , text } => { if matches ! (text_type , TextType :: InstrumentName | TextType :: TrackName) && ! instruments . contains (text) { instruments . push (text . clone ()) ; } } , Event :: ProgramChange { program , .. } => { if let Some (instrument_name) = program_to_instrument_name (* program) { if ! instruments . contains (& instrument_name) { instruments . push (instrument_name) ; } } } , _ => { } , } } } instruments }

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/import_unified.rs`
  - Category: Performance

- [ ] **Function 'program_to_instrument_name' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/import_unified.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn program_to_instrument_name (program : u8) -> Option < String > { match program { 0 ..= 7 => Some ("Piano" . to_string ()) , 8 ..= 15 => Some ("Keys" . to_string ()) , 16 ..= 23 => Some ("Organ" . to_string ()) , 24 ..= 31 => Some ("Guitar" . to_string ()) , 32 ..= 39 => Some ("Bass" . to_string ()) , 40 ..= 47 => Some ("Strings" . to_string ()) , 48 ..= 55 => Some ("Ensemble" . to_string ()) , 56 ..= 63 => Some ("Brass" . to_string ()) , 64 ..= 71 => Some ("Woodwind" . to_string ()) , 72 ..= 79 => Some ("Flute" . to_string ()) , 80 ..= 87 => Some ("Lead" . to_string ()) , 88 ..= 95 => Some ("Pad" . to_string ()) , 96 ..= 103 => Some ("FX" . to_string ()) , 104 ..= 111 => Some ("Ethnic" . to_string ()) , 112 ..= 119 => Some ("Percussion" . to_string ()) , 120 ..= 127 => Some ("FX" . to_string ()) , _ => None , } }

- [ ] **Function 'detect_pitch_bend' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/import_unified.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn detect_pitch_bend (midi_file : & MidiFile) -> bool { for track in & midi_file . tracks { for timed_event in & track . events { if matches ! (& timed_event . event , Event :: PitchBend { .. }) { return true ; } } } false }

- [ ] **Function 'detect_cc_messages' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/import_unified.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn detect_cc_messages (midi_file : & MidiFile) -> bool { for track in & midi_file . tracks { for timed_event in & track . events { if matches ! (& timed_event . event , Event :: ControlChange { .. }) { return true ; } } } false }

- [ ] **Function 'calculate_complexity_score' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/import_unified.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn calculate_complexity_score (note_stats : & NoteStats , midi_file : & MidiFile) -> Option < f64 > { if note_stats . note_count == 0 { return Some (0.0) ; } let mut score = 0.0 ; let duration_est = calculate_total_ticks (midi_file) as f64 / (midi_file . header . ticks_per_quarter_note as f64 * 2.0) ; if duration_est > 0.0 { let note_density = note_stats . note_count as f64 / duration_est ; score += (note_density / 10.0) . min (30.0) ; } if let Some (semitones) = note_stats . pitch_range_semitones { score += (semitones as f64 / 2.0) . min (20.0) ; } if let Some (polyphony) = note_stats . polyphony_max { score += (polyphony as f64 * 5.0) . min (25.0) ; } let track_count = midi_file . tracks . len () as f64 ; score += (track_count * 2.0) . min (15.0) ; if let (Some (low) , Some (high)) = (note_stats . velocity_range_low , note_stats . velocity_range_high ,) { let velocity_range = (high - low) as f64 ; score += (velocity_range / 10.0) . min (10.0) ; } Some (score . min (100.0)) }

- [ ] **Function 'print_progress_summary' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/import_unified.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn print_progress_summary (stats : & ImportStats) { let elapsed = stats . start_time . map (| t | t . elapsed () . as_secs_f64 ()) . unwrap_or (0.0) ; let imported = stats . files_imported . load (Ordering :: SeqCst) ; let rate = if elapsed > 0.0 { imported as f64 / elapsed } else { 0.0 } ; println ! ("  ğŸ“Š Progress:") ; println ! ("    Archives: {}/{}" , stats . archives_processed . load (Ordering :: SeqCst) , stats . archives_total . load (Ordering :: SeqCst)) ; println ! ("    Imported: {}" , imported) ; println ! ("    Duplicates: {}" , stats . files_duplicates . load (Ordering :: SeqCst)) ; println ! ("    Errors: {}" , stats . files_errors . load (Ordering :: SeqCst)) ; println ! ("    Rate: {:.1} files/sec" , rate) ; }

- [ ] **Function 'print_final_summary' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/import_unified.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn print_final_summary (stats : & ImportStats) { let elapsed = stats . start_time . map (| t | t . elapsed ()) . unwrap_or_else (| | std :: time :: Duration :: from_secs (0)) ; let duration_secs = elapsed . as_secs_f64 () ; let imported = stats . files_imported . load (Ordering :: SeqCst) ; let rate = if duration_secs > 0.0 { imported as f64 / duration_secs } else { 0.0 } ; println ! ("\n========================================") ; println ! ("UNIFIED IMPORT COMPLETE") ; println ! ("========================================") ; println ! ("Archives processed: {}/{}" , stats . archives_processed . load (Ordering :: SeqCst) , stats . archives_total . load (Ordering :: SeqCst)) ; println ! ("MIDI files found: {}" , stats . files_found . load (Ordering :: SeqCst)) ; println ! ("Successfully imported: {}" , imported) ; println ! ("  With full analysis: {}" , imported) ; println ! ("Duplicates skipped: {}" , stats . files_duplicates . load (Ordering :: SeqCst)) ; println ! ("Errors: {}" , stats . files_errors . load (Ordering :: SeqCst)) ; println ! ("Time: {:.0}h {:.0}m {:.0}s" , duration_secs / 3600.0 , (duration_secs % 3600.0) / 60.0 , duration_secs % 60.0) ; println ! ("Avg speed: {:.0} files/sec" , rate) ; println ! ("========================================") ; println ! ("All files include: BPM, Key, Tags, Complexity") ; println ! ("Ready to use in DAW!") ; println ! ("========================================\n") ; }

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/infer_instruments.rs`
  - Category: Performance

- [ ] **Function 'attempt_repair' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/midi_doctor.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Attempt to repair common MIDI file issues"] fn attempt_repair (data : & [u8]) -> Result < (Vec < u8 > , String) , String > { let mut repaired = data . to_vec () ; let mut fixes = Vec :: new () ; if repaired . len () >= 14 { if & repaired [0 .. 4] == b"MThd" { let mut pos = 14 ; while pos < repaired . len () { if pos + 8 > repaired . len () { break ; } if & repaired [pos .. pos + 4] == b"MTrk" { let track_len = u32 :: from_be_bytes ([repaired [pos + 4] , repaired [pos + 5] , repaired [pos + 6] , repaired [pos + 7] ,]) as usize ; let track_end = pos + 8 + track_len ; if track_end <= repaired . len () { let has_eot = if track_end >= 3 { & repaired [track_end - 3 .. track_end] == & [0xFF , 0x2F , 0x00] } else { false } ; if ! has_eot && track_end < repaired . len () { repaired . splice (track_end .. track_end , [0xFF , 0x2F , 0x00] . iter () . cloned ()) ; let new_len = track_len + 3 ; let len_bytes = new_len . to_be_bytes () ; repaired [pos + 4] = len_bytes [0] ; repaired [pos + 5] = len_bytes [1] ; repaired [pos + 6] = len_bytes [2] ; repaired [pos + 7] = len_bytes [3] ; fixes . push ("Added missing End-of-Track marker" . to_string ()) ; } pos = track_end ; } else { break ; } } else { pos += 1 ; } } } } if repaired . len () > 14 && & repaired [0 .. 4] == b"MThd" { let header_len = u32 :: from_be_bytes ([repaired [4] , repaired [5] , repaired [6] , repaired [7]]) as usize ; if header_len == 6 { let num_tracks = u16 :: from_be_bytes ([repaired [10] , repaired [11]]) as usize ; let mut expected_size = 14 ; let mut pos = 14 ; for _ in 0 .. num_tracks { if pos + 8 > repaired . len () { break ; } if & repaired [pos .. pos + 4] == b"MTrk" { let track_len = u32 :: from_be_bytes ([repaired [pos + 4] , repaired [pos + 5] , repaired [pos + 6] , repaired [pos + 7] ,]) as usize ; expected_size = pos + 8 + track_len ; pos = expected_size ; } else { break ; } } if expected_size < repaired . len () { let trimmed = repaired . len () - expected_size ; repaired . truncate (expected_size) ; fixes . push (format ! ("Trimmed {} bytes of trailing garbage" , trimmed)) ; } } } if fixes . is_empty () { Err ("No repairs needed or possible" . to_string ()) } else { Ok ((repaired , fixes . join (", "))) } }

- [ ] **Function 'diagnose_midi_file' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/midi_doctor.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Diagnose a MIDI file and attempt repair if needed"] fn diagnose_midi_file (path : & Path , repair_dir : Option < & Path >) -> MidiStatus { let data = match fs :: read (path) { Ok (d) => d , Err (_) => return MidiStatus :: Corrupt ("Cannot read file" . to_string ()) , } ; if data . len () < 14 { return MidiStatus :: Corrupt (format ! ("File too small ({} bytes, need 14+)" , data . len ())) ; } if & data [0 .. 4] != b"MThd" { return MidiStatus :: NotMidi ; } match parse_midi_file (& data) { Ok (_) => MidiStatus :: Valid , Err (e) => { match attempt_repair (& data) { Ok ((repaired_data , fix_description)) => { match parse_midi_file (& repaired_data) { Ok (_) => { if let Some (repair_dir) = repair_dir { let filename = path . file_name () . unwrap () ; let output_path = repair_dir . join (filename) ; if let Ok (()) = fs :: write (& output_path , & repaired_data) { MidiStatus :: Repaired (format ! ("{} (saved to repair dir)" , fix_description)) } else { MidiStatus :: Repaired (format ! ("{} (could not save)" , fix_description)) } } else { MidiStatus :: Repaired (fix_description) } } , Err (e2) => { MidiStatus :: Corrupt (format ! ("Repair failed: {} (original: {})" , e2 , e)) } , } } , Err (_) => MidiStatus :: Corrupt (format ! ("{}" , e)) , } } , } }

- [ ] **Function 'main' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/midi_doctor.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn main () { let args : Vec < String > = std :: env :: args () . collect () ; if args . len () < 2 { eprintln ! ("Usage: {} <directory> [repair-output-dir] [workers]" , args [0]) ; eprintln ! ("Example: {} /path/to/midi /path/to/repaired 64" , args [0]) ; eprintln ! () ; eprintln ! ("If repair-output-dir is provided, repaired files will be saved there.") ; std :: process :: exit (1) ; } let scan_dir = & args [1] ; let repair_dir = if args . len () > 2 && ! args [2] . parse :: < usize > () . is_ok () { Some (args [2] . as_str ()) } else { None } ; let workers = if args . len () > 3 { args [3] . parse :: < usize > () . unwrap_or_else (| _ | num_cpus :: get ()) } else if args . len () > 2 && args [2] . parse :: < usize > () . is_ok () { args [2] . parse :: < usize > () . unwrap () } else { num_cpus :: get () } ; println ! ("ğŸ¥ MIDI DOCTOR - Diagnostic and Repair Tool") ; println ! ("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•") ; println ! () ; println ! ("ğŸ“‚ Scan directory: {}" , scan_dir) ; if let Some (repair_dir) = repair_dir { println ! ("ğŸ”§ Repair output:  {}" , repair_dir) ; if let Err (e) = fs :: create_dir_all (repair_dir) { eprintln ! ("âŒ Failed to create repair directory: {}" , e) ; std :: process :: exit (1) ; } } else { println ! ("ğŸ”§ Repair output:  Disabled (diagnostics only)") ; } println ! ("âš¡ Parallel workers: {}" , workers) ; println ! () ; rayon :: ThreadPoolBuilder :: new () . num_threads (workers) . build_global () . unwrap () ; let start = Instant :: now () ; let stats = DiagnosticStats :: default () ; println ! ("ğŸ“Š Scanning for MIDI files...") ; let scan_start = Instant :: now () ; let files : Vec < PathBuf > = WalkDir :: new (scan_dir) . follow_links (false) . into_iter () . filter_map (| e | e . ok ()) . filter (| e | e . file_type () . is_file ()) . filter (| e | { let name = e . file_name () . to_string_lossy () . to_lowercase () ; name . ends_with (".mid") || name . ends_with (".midi") }) . map (| e | e . path () . to_path_buf ()) . collect () ; let scan_elapsed = scan_start . elapsed () . as_secs_f64 () ; println ! ("âœ“ Found {} MIDI files in {:.2}s" , files . len () , scan_elapsed) ; println ! () ; println ! ("ğŸ” Diagnosing MIDI files...") ; let repair_path = repair_dir . map (PathBuf :: from) ; files . par_iter () . for_each (| path | { let status = diagnose_midi_file (path , repair_path . as_deref ()) ; match & status { MidiStatus :: Valid => { stats . valid_files . fetch_add (1 , Ordering :: Relaxed) ; } , MidiStatus :: Repaired (desc) => { stats . repaired_files . fetch_add (1 , Ordering :: Relaxed) ; println ! ("ğŸ”§ REPAIRED: {} - {}" , path . display () , desc) ; } , MidiStatus :: Corrupt (reason) => { stats . corrupt_files . fetch_add (1 , Ordering :: Relaxed) ; println ! ("âŒ CORRUPT:  {} - {}" , path . display () , reason) ; } , MidiStatus :: NotMidi => { stats . not_midi . fetch_add (1 , Ordering :: Relaxed) ; println ! ("âš ï¸  NOT MIDI: {}" , path . display ()) ; } , } stats . total_files . fetch_add (1 , Ordering :: Relaxed) ; let total = stats . total_files . load (Ordering :: Relaxed) ; if total % 10000 == 0 { println ! ("  Progress: {} files scanned..." , total) ; } }) ; println ! ("âœ“ Diagnosis complete") ; println ! () ; let total_elapsed = start . elapsed () . as_secs_f64 () ; println ! ("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•") ; println ! ("âœ… MIDI DOCTOR COMPLETE!") ; stats . print_progress (total_elapsed) ; println ! () ; let repaired_count = stats . repaired_files . load (Ordering :: Relaxed) ; let corrupt_count = stats . corrupt_files . load (Ordering :: Relaxed) ; if repaired_count > 0 && repair_dir . is_some () { println ! ("ğŸ”§ Repaired files saved to: {}" , repair_dir . unwrap ()) ; } if corrupt_count > 0 { println ! ("âŒ {} files are truly corrupt and cannot be automatically repaired" , corrupt_count) ; println ! ("   These files may need manual inspection or re-downloading") ; } println ! () ; }

- [ ] **Function 'convert_midi_to_mpcpattern' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/midi_to_mpcpattern.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn convert_midi_to_mpcpattern (midi_path : & Path) -> Result < MpcPattern > { let midi_data = fs :: read (midi_path) . with_context (| | format ! ("Failed to read MIDI file: {}" , midi_path . display ())) ? ; let midi_file = parse_midi_file (& midi_data) . context ("Failed to parse MIDI file") ? ; let mut mpc_events = Vec :: new () ; let mut active_notes : HashMap < u8 , ActiveNote > = HashMap :: new () ; mpc_events . push (MpcEvent :: init_event (0 , 0.0)) ; mpc_events . push (MpcEvent :: init_event (32 , 0.0)) ; let init_velocity = 0.787401556968689 ; mpc_events . push (MpcEvent :: init_event (130 , init_velocity)) ; for track in & midi_file . tracks { let mut current_time = 0i64 ; for timed_event in & track . events { current_time += timed_event . delta_ticks as i64 ; let scaled_time = current_time * 2 ; match & timed_event . event { Event :: NoteOn { channel : _ , note , velocity } => { if * velocity > 0 { active_notes . insert (* note , ActiveNote { note : * note , velocity : * velocity , start_time : scaled_time , } ,) ; } else { if let Some (active) = active_notes . remove (note) { let duration = scaled_time - active . start_time ; let normalized_velocity = active . velocity as f64 / 127.0 ; mpc_events . push (MpcEvent :: note_on (active . start_time , duration , * note , normalized_velocity ,)) ; } } } , Event :: NoteOff { channel : _ , note , velocity : _ } => { if let Some (active) = active_notes . remove (note) { let duration = scaled_time - active . start_time ; let normalized_velocity = active . velocity as f64 / 127.0 ; mpc_events . push (MpcEvent :: note_on (active . start_time , duration , * note , normalized_velocity ,)) ; } } , _ => { } , } } } let max_time = mpc_events . iter () . filter (| e | e . event_type == 2) . map (| e | e . time + e . len) . max () . unwrap_or (0) ; for active in active_notes . values () { let duration = max_time - active . start_time ; let normalized_velocity = active . velocity as f64 / 127.0 ; mpc_events . push (MpcEvent :: note_on (active . start_time , duration , active . note , normalized_velocity ,)) ; } mpc_events . sort_by_key (| e | (e . time , e . event_type , e . field1)) ; Ok (MpcPattern { pattern : Pattern { length : i64 :: MAX , events : mpc_events , } , }) }

- [ ] **Function 'convert_file' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/midi_to_mpcpattern.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn convert_file (input : & Path , output : & Path) -> Result < () > { println ! ("Converting: {} -> {}" , input . display () , output . display ()) ; let pattern = convert_midi_to_mpcpattern (input) ? ; let json = serde_json :: to_string_pretty (& pattern) . context ("Failed to serialize pattern to JSON") ? ; fs :: write (output , json) . with_context (| | format ! ("Failed to write output file: {}" , output . display ())) ? ; println ! ("  âœ“ Created {} events" , pattern . pattern . events . len ()) ; Ok (()) }

- [ ] **Function 'batch_convert' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/midi_to_mpcpattern.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn batch_convert (input_dir : & Path , output_dir : & Path , limit : Option < usize >) -> Result < () > { println ! ("Batch converting MIDI files...") ; println ! ("  Input:  {}" , input_dir . display ()) ; println ! ("  Output: {}" , output_dir . display ()) ; if let Some (lim) = limit { println ! ("  Limit:  {} files" , lim) ; } println ! () ; fs :: create_dir_all (output_dir) . with_context (| | { format ! ("Failed to create output directory: {}" , output_dir . display ()) }) ? ; let mut midi_files = Vec :: new () ; for entry in walkdir :: WalkDir :: new (input_dir) . follow_links (true) . into_iter () . filter_map (| e | e . ok ()) { if entry . file_type () . is_file () { let path = entry . path () ; if let Some (ext) = path . extension () { if ext . eq_ignore_ascii_case ("mid") || ext . eq_ignore_ascii_case ("midi") { midi_files . push (path . to_path_buf ()) ; } } } } println ! ("Found {} MIDI files" , midi_files . len ()) ; if let Some (lim) = limit { midi_files . truncate (lim) ; println ! ("Processing first {} files" , midi_files . len ()) ; } println ! () ; let mut success = 0 ; let mut failed = 0 ; for (i , input_path) in midi_files . iter () . enumerate () { let file_stem = input_path . file_stem () . unwrap () . to_string_lossy () ; let output_path = output_dir . join (format ! ("{}.mpcpattern" , file_stem)) ; print ! ("[{}/{}] " , i + 1 , midi_files . len ()) ; match convert_file (input_path , & output_path) { Ok (_) => success += 1 , Err (e) => { println ! ("  âœ— Error: {}" , e) ; failed += 1 ; } , } } println ! () ; println ! ("Conversion complete:") ; println ! ("  Success: {}" , success) ; println ! ("  Failed:  {}" , failed) ; Ok (()) }

- [ ] **Function 'main' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/midi_to_mpcpattern.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn main () -> Result < () > { let args : Vec < String > = std :: env :: args () . collect () ; if args . len () < 3 { eprintln ! ("Usage:") ; eprintln ! ("  {} <input.mid> <output.mpcpattern>" , args [0]) ; eprintln ! ("  {} --batch <input_dir> <output_dir> [limit]" , args [0]) ; std :: process :: exit (1) ; } if args [1] == "--batch" { if args . len () < 4 { eprintln ! ("Batch mode requires input and output directories") ; std :: process :: exit (1) ; } let input_dir = Path :: new (& args [2]) ; let output_dir = Path :: new (& args [3]) ; let limit = args . get (4) . and_then (| s | s . parse :: < usize > () . ok ()) ; batch_convert (input_dir , output_dir , limit) ? ; } else { let input = Path :: new (& args [1]) ; let output = Path :: new (& args [2]) ; convert_file (input , output) ? ; } Ok (()) }

- [ ] **Function 'convert_file_fast' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/midi_to_mpcpattern_parallel.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Convert single file with memory-mapped I/O"] fn convert_file_fast (input : & Path , output : & Path) -> Result < usize > { let file = fs :: File :: open (input) . with_context (| | format ! ("Failed to open: {}" , input . display ())) ? ; let mmap = unsafe { memmap2 :: Mmap :: map (& file) ? } ; let pattern = convert_midi_to_mpcpattern (& mmap) ? ; let event_count = pattern . pattern . events . len () ; let json = serde_json :: to_string_pretty (& pattern) . context ("Failed to serialize") ? ; let mut f = fs :: File :: create (output) . with_context (| | format ! ("Failed to create: {}" , output . display ())) ? ; f . write_all (json . as_bytes ()) ? ; Ok (event_count) }

- [ ] **Function 'batch_convert_parallel' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/midi_to_mpcpattern_parallel.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Parallel batch converter with progress tracking"] fn batch_convert_parallel (input_paths : Vec < PathBuf > , output_dir : & Path , show_progress : bool ,) -> Result < () > { let start = Instant :: now () ; fs :: create_dir_all (output_dir) . with_context (| | format ! ("Failed to create output dir: {}" , output_dir . display ())) ? ; let total = input_paths . len () ; println ! ("\nğŸš€ MAXIMUM SPEED PARALLEL CONVERSION") ; println ! ("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”") ; println ! ("ğŸ“Š Files to process: {}" , total) ; println ! ("ğŸ”§ CPU cores available: {}" , num_cpus :: get ()) ; println ! ("ğŸ’¾ Allocator: jemalloc (high-performance)") ; println ! ("âš¡ Optimizations: rayon + memmap2 + LTO") ; println ! ("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n") ; let progress = if show_progress { let pb = ProgressBar :: new (total as u64) ; pb . set_style (ProgressStyle :: default_bar () . template ("[{elapsed_precise}] [{bar:40.cyan/blue}] {pos}/{len} ({per_sec}) {msg}") . unwrap () . progress_chars ("â–ˆâ–“â–’â–‘ ") ,) ; Some (pb) } else { None } ; let success = Arc :: new (AtomicUsize :: new (0)) ; let failed = Arc :: new (AtomicUsize :: new (0)) ; input_paths . par_iter () . for_each (| input_path | { let file_stem = input_path . file_stem () . unwrap () . to_string_lossy () ; let output_path = output_dir . join (format ! ("{}.mpcpattern" , file_stem)) ; match convert_file_fast (input_path , & output_path) { Ok (_events) => { success . fetch_add (1 , Ordering :: Relaxed) ; } , Err (e) => { eprintln ! ("âŒ Failed: {} - {}" , input_path . display () , e) ; failed . fetch_add (1 , Ordering :: Relaxed) ; } , } if let Some (ref pb) = progress { pb . inc (1) ; } }) ; if let Some (pb) = progress { pb . finish_with_message ("âœ… Complete") ; } let elapsed = start . elapsed () ; let success_count = success . load (Ordering :: Relaxed) ; let failed_count = failed . load (Ordering :: Relaxed) ; let files_per_sec = success_count as f64 / elapsed . as_secs_f64 () ; println ! ("\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”") ; println ! ("âœ… CONVERSION COMPLETE") ; println ! ("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”") ; println ! ("â±ï¸  Total time: {:.2}s" , elapsed . as_secs_f64 ()) ; println ! ("âœ… Success: {}" , success_count) ; println ! ("âŒ Failed: {}" , failed_count) ; println ! ("âš¡ Speed: {:.0} files/sec" , files_per_sec) ; println ! ("ğŸ¯ Throughput: {:.2} MB/s (estimated)" , files_per_sec * 0.005) ; println ! ("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n") ; Ok (()) }

- [ ] **Function 'find_midi_files' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/midi_to_mpcpattern_parallel.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Find all MIDI files in directory (parallel walk)"] fn find_midi_files (input_dir : & Path , limit : Option < usize >) -> Result < Vec < PathBuf > > { use jwalk :: WalkDir ; println ! ("ğŸ” Scanning for MIDI files...") ; let files : Vec < PathBuf > = WalkDir :: new (input_dir) . into_iter () . filter_map (| e | e . ok ()) . filter (| e | e . file_type () . is_file ()) . filter (| e | { e . path () . extension () . map (| ext | ext . eq_ignore_ascii_case ("mid") || ext . eq_ignore_ascii_case ("midi")) . unwrap_or (false) }) . map (| e | e . path ()) . take (limit . unwrap_or (usize :: MAX)) . collect () ; println ! ("âœ… Found {} MIDI files\n" , files . len ()) ; Ok (files) }

- [ ] **Function 'main' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/midi_to_mpcpattern_parallel.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn main () -> Result < () > { let args : Vec < String > = std :: env :: args () . collect () ; if args . len () < 3 { eprintln ! ("MIDI to .mpcpattern Converter (MAXIMUM SPEED EDITION)") ; eprintln ! () ; eprintln ! ("Usage:") ; eprintln ! ("  {} <input.mid> <output.mpcpattern>" , args [0]) ; eprintln ! ("  {} --batch <input_dir> <output_dir> [limit]" , args [0]) ; eprintln ! () ; eprintln ! ("Features:") ; eprintln ! ("  â€¢ Parallel processing (all CPU cores)") ; eprintln ! ("  â€¢ Memory-mapped I/O (zero-copy)") ; eprintln ! ("  â€¢ jemalloc allocator") ; eprintln ! ("  â€¢ 2,000-5,000 files/sec throughput") ; std :: process :: exit (1) ; } if args [1] == "--batch" { if args . len () < 4 { eprintln ! ("Batch mode requires input and output directories") ; std :: process :: exit (1) ; } let input_dir = Path :: new (& args [2]) ; let output_dir = Path :: new (& args [3]) ; let limit = args . get (4) . and_then (| s | s . parse :: < usize > () . ok ()) ; let files = find_midi_files (input_dir , limit) ? ; if files . is_empty () { eprintln ! ("âŒ No MIDI files found in {}" , input_dir . display ()) ; std :: process :: exit (1) ; } batch_convert_parallel (files , output_dir , true) ? ; } else { let input = Path :: new (& args [1]) ; let output = Path :: new (& args [2]) ; println ! ("Converting: {}" , input . display ()) ; let start = Instant :: now () ; let events = convert_file_fast (input , output) ? ; let elapsed = start . elapsed () ; println ! ("âœ… Created {} events in {:.3}s" , events , elapsed . as_secs_f64 ()) ; println ! ("ğŸ“ Output: {}" , output . display ()) ; } Ok (()) }

- [ ] **Function 'calculate_bars' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/mpc_backup.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Calculate number of bars from duration, BPM, and time signature"] fn calculate_bars (duration : f64 , bpm : f64 , time_sig_numerator : i16) -> i32 { let beats_per_bar = time_sig_numerator as f64 ; let seconds_per_beat = 60.0 / bpm ; let seconds_per_bar = seconds_per_beat * beats_per_bar ; let bars = (duration / seconds_per_bar) . round () as i32 ; bars . max (1) . min (999) }

- [ ] **Function 'format_key' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/mpc_backup.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Convert musical key to MPC format"] # [doc = " Examples: \"C\" â†’ \"c+\", \"Cm\" â†’ \"c-\", \"F#\" â†’ \"fs+\", \"F#m\" â†’ \"fs-\""] fn format_key (key : & str) -> String { let is_minor = key . ends_with ('m') ; let note = key . trim_end_matches ('m') . replace ('#' , "s") . replace ('b' , "s") . to_lowercase () ; if is_minor { format ! ("{}-" , note) } else { format ! ("{}+" , note) } }

- [ ] **Function 'extract_folder' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/mpc_backup.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Extract parent folder name from filepath"] fn extract_folder (filepath : & str) -> String { let path = Path :: new (filepath) ; let parent = path . parent () . and_then (| p | p . file_name ()) . and_then (| n | n . to_str ()) . unwrap_or ("Unknown") ; sanitize_camelcase (parent , 20) }

- [ ] **Function 'sanitize_mpc' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/mpc_backup.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Sanitize string to keep only: a-z, A-Z, 0-9, _, -, +"] fn sanitize_mpc (input : & str) -> String { input . chars () . filter (| c | c . is_alphanumeric () || * c == '_' || * c == '-' || * c == '+') . collect () }

- [ ] **Function 'sanitize_camelcase' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/mpc_backup.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Convert to CamelCase and truncate to max_len"] fn sanitize_camelcase (input : & str , max_len : usize) -> String { let words : Vec < String > = input . split (| c : char | ! c . is_alphanumeric ()) . filter (| w | ! w . is_empty ()) . map (| w | { let mut chars = w . to_lowercase () . chars () . collect :: < Vec < _ > > () ; if let Some (first) = chars . first_mut () { * first = first . to_uppercase () . next () . unwrap_or (* first) ; } chars . into_iter () . collect () }) . collect () ; let camelcase = words . join ("") ; let sanitized = sanitize_mpc (& camelcase) ; sanitized . chars () . take (max_len) . collect () }

- [ ] **Function 'generate_mpc_filename' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/mpc_backup.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Generate MPC-compatible filename"] # [doc = " Format: {BARS}{KEY}{BPM}{FOLDER}{FILENAME}.mid"] # [doc = " Example: 8c+80VirusMelodies01.mid"] fn generate_mpc_filename (file : & MidiFileWithMetadata) -> Option < String > { let bpm = file . bpm ? ; let key = file . key_signature . as_ref () ? ; let duration = file . duration_seconds ? ; let time_sig_numerator = file . time_signature_numerator . unwrap_or (4) ; let bars = calculate_bars (duration , bpm , time_sig_numerator) ; let key_formatted = format_key (key) ; let folder = extract_folder (& file . filepath) ; let filename_stem = Path :: new (& file . filename) . file_stem () . and_then (| s | s . to_str ()) . unwrap_or ("Unknown") ; let filename_sanitized = sanitize_mpc (filename_stem) . chars () . take (15) . collect :: < String > () ; let mpc_name = format ! ("{}{}{}{}{}.mid" , bars , key_formatted , bpm . round () as i32 , folder , filename_sanitized) ; Some (mpc_name) }

- [ ] **Function 'get_output_folder' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/mpc_backup.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Determine output folder based on organization strategy"] fn get_output_folder (base_dir : & Path , organize_by : & str , file : & MidiFileWithMetadata) -> PathBuf { match organize_by { "by_bpm" | "bpm" => { let bpm = file . bpm . unwrap_or (120.0) . round () as i32 ; let bpm_range = match bpm { 0 ..= 80 => "000-080" , 81 ..= 100 => "081-100" , 101 ..= 120 => "101-120" , 121 ..= 140 => "121-140" , 141 ..= 160 => "141-160" , _ => "160-999" , } ; base_dir . join (bpm_range) } , "by_key" | "key" => { let key = file . key_signature . as_ref () . map (| k | sanitize_mpc (k)) . unwrap_or_else (| | "Unknown" . to_string ()) ; base_dir . join (key) } , "by_instrument" | "instrument" => { let path_lower = file . filepath . to_lowercase () ; let filename_lower = file . filename . to_lowercase () ; let (group , subgroup) = if file . is_percussive == Some (true) { if filename_lower . contains ("kick") || path_lower . contains ("kick") { ("DRUMS" , "KICKS") } else if filename_lower . contains ("snare") || path_lower . contains ("snare") { ("DRUMS" , "SNARES") } else if filename_lower . contains ("hihat") || filename_lower . contains ("hat") || path_lower . contains ("hihat") || path_lower . contains ("hat") { ("DRUMS" , "HIHATS") } else if filename_lower . contains ("cymbal") || filename_lower . contains ("crash") || filename_lower . contains ("ride") || path_lower . contains ("cymbal") || path_lower . contains ("crash") || path_lower . contains ("ride") { ("DRUMS" , "CYMBALS") } else if filename_lower . contains ("tom") || path_lower . contains ("tom") { ("DRUMS" , "TOMS") } else if filename_lower . contains ("percussion") || filename_lower . contains ("perc") || path_lower . contains ("percussion") || path_lower . contains ("perc") { ("DRUMS" , "PERCUSSION") } else { ("DRUMS" , "OTHER") } } else if file . has_chords == Some (true) { if filename_lower . contains ("piano") || path_lower . contains ("piano") { ("KEYS" , "PIANO") } else if filename_lower . contains ("organ") || path_lower . contains ("organ") { ("KEYS" , "ORGAN") } else if filename_lower . contains ("synth") || path_lower . contains ("synth") { ("KEYS" , "SYNTH") } else { ("KEYS" , "CHORDS") } } else if file . has_melody == Some (true) { if file . is_monophonic == Some (true) { if filename_lower . contains ("bass") || path_lower . contains ("bass") { ("BASS" , "BASS") } else if filename_lower . contains ("lead") || path_lower . contains ("lead") { ("LEADS" , "LEAD") } else { ("LEADS" , "MELODY") } } else { if filename_lower . contains ("arp") || path_lower . contains ("arp") { ("LEADS" , "ARP") } else { ("LEADS" , "POLYPHONIC") } } } else if file . is_monophonic == Some (true) && file . polyphony_avg . unwrap_or (0.0) < 2.0 { if filename_lower . contains ("bass") || path_lower . contains ("bass") { ("BASS" , "BASS") } else { ("BASS" , "MONOPHONIC") } } else if filename_lower . contains ("loop") || path_lower . contains ("loop") { ("LOOPS" , "LOOPS") } else { if filename_lower . contains ("bass") || path_lower . contains ("bass") { ("BASS" , "BASS") } else if filename_lower . contains ("piano") || path_lower . contains ("piano") { ("KEYS" , "PIANO") } else if filename_lower . contains ("synth") || path_lower . contains ("synth") { ("KEYS" , "SYNTH") } else if filename_lower . contains ("organ") || path_lower . contains ("organ") { ("KEYS" , "ORGAN") } else if filename_lower . contains ("lead") || path_lower . contains ("lead") { ("LEADS" , "LEAD") } else if filename_lower . contains ("melody") || path_lower . contains ("melody") { ("LEADS" , "MELODY") } else { ("OTHER" , "OTHER") } } ; let bars = if let (Some (duration) , Some (bpm) , Some (time_sig)) = (file . duration_seconds , file . bpm , file . time_signature_numerator ,) { calculate_bars (duration , bpm , time_sig) } else { 0 } ; let bar_range = match bars { 0 => "000-BARS" , 1 ..= 2 => "001-002-BARS" , 3 ..= 4 => "003-004-BARS" , 5 ..= 8 => "005-008-BARS" , 9 ..= 16 => "009-016-BARS" , 17 ..= 32 => "017-032-BARS" , _ => "033-PLUS-BARS" , } ; let key_folder = file . key_signature . as_ref () . map (| k | format_key (k) . to_uppercase ()) . unwrap_or_else (| | "UNKNOWN" . to_string ()) ; base_dir . join (group) . join (subgroup) . join (bar_range) . join (key_folder) } , _ => base_dir . to_path_buf () , } }

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/mpc_backup.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/mpc_backup.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/mpc_backup.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/mpc_backup.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/mpc_backup.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/mpc_backup.rs`
  - Category: Performance

- [ ] **Function 'normalize_file' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/normalize_filenames.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Normalize a single MIDI file using strict sanitization"] fn normalize_file (path : & Path , stats : & NormalizationStats ,) -> Result < () , Box < dyn std :: error :: Error > > { let parent = path . parent () . ok_or ("No parent directory") ? ; let filename = path . file_name () . ok_or ("No filename") ? . to_string_lossy () ; let new_filename = sanitize_strict (& filename) ; let changed = new_filename != filename . as_ref () ; if changed { if filename . to_lowercase () . ends_with (".midi") || (filename . to_lowercase () . ends_with (".mid") && ! filename . ends_with (".mid")) { stats . extensions_fixed . fetch_add (1 , Ordering :: Relaxed) ; } if filename . contains (' ') { stats . spaces_fixed . fetch_add (1 , Ordering :: Relaxed) ; } if filename . chars () . any (| c | ! c . is_alphanumeric () && c != '_' && c != '-' && c != '.') { stats . encoding_fixed . fetch_add (1 , Ordering :: Relaxed) ; } } if changed { let new_path = parent . join (& new_filename) ; let mut final_path = new_path . clone () ; let mut counter = 1 ; while final_path . exists () && final_path != path { let stem = Path :: new (& new_filename) . file_stem () . unwrap () . to_string_lossy () ; let ext = Path :: new (& new_filename) . extension () . map (| e | e . to_string_lossy ()) . unwrap_or_default () ; final_path = parent . join (format ! ("{}_{}.{}" , stem , counter , ext)) ; counter += 1 ; } if final_path != path { fs :: rename (path , & final_path) ? ; } } stats . total_files . fetch_add (1 , Ordering :: Relaxed) ; Ok (()) }

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/normalize_filenames.rs`
  - Category: Performance

- [ ] **Function 'main' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/normalize_filenames.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn main () { let args : Vec < String > = std :: env :: args () . collect () ; if args . len () < 2 { eprintln ! ("Usage: {} <directory> [workers]" , args [0]) ; eprintln ! ("Example: {} /home/dojevou/tmp 32" , args [0]) ; std :: process :: exit (1) ; } let dir = & args [1] ; let workers = if args . len () > 2 { args [2] . parse :: < usize > () . unwrap_or_else (| _ | { eprintln ! ("Invalid workers count, using default") ; num_cpus :: get () }) } else { num_cpus :: get () } ; println ! ("ğŸ§¹ ULTRA-FAST MIDI FILENAME NORMALIZATION") ; println ! ("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•") ; println ! () ; println ! ("ğŸ“‚ Target directory: {}" , dir) ; println ! ("âš¡ Parallel workers: {}" , workers) ; println ! () ; rayon :: ThreadPoolBuilder :: new () . num_threads (workers) . build_global () . unwrap () ; let start = Instant :: now () ; let stats = NormalizationStats :: default () ; println ! ("ğŸ“Š Scanning for MIDI files...") ; let scan_start = Instant :: now () ; let files : Vec < PathBuf > = WalkDir :: new (dir) . follow_links (false) . into_iter () . filter_map (| e | e . ok ()) . filter (| e | e . file_type () . is_file ()) . filter (| e | { let name = e . file_name () . to_string_lossy () . to_lowercase () ; name . ends_with (".mid") || name . ends_with (".midi") }) . map (| e | e . path () . to_path_buf ()) . collect () ; let scan_elapsed = scan_start . elapsed () . as_secs_f64 () ; println ! ("âœ“ Found {} MIDI files in {:.2}s ({:.0} files/sec)" , files . len () , scan_elapsed , files . len () as f64 / scan_elapsed) ; println ! () ; println ! ("âš¡ Normalizing filenames...") ; let process_start = Instant :: now () ; files . par_iter () . for_each (| path | { if let Err (e) = normalize_file (path , & stats) { eprintln ! ("Error processing {:?}: {}" , path , e) ; stats . errors . fetch_add (1 , Ordering :: Relaxed) ; } }) ; println ! ("âœ“ Processing complete") ; println ! () ; let total_elapsed = start . elapsed () . as_secs_f64 () ; println ! ("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•") ; println ! ("âœ… NORMALIZATION COMPLETE!") ; stats . print_progress (total_elapsed) ; println ! () ; println ! ("All .mid files now have:") ; println ! ("  âœ“ Lowercase .mid extension") ; println ! ("  âœ“ Underscores instead of spaces") ; println ! ("  âœ“ Clean UTF-8 encoding") ; println ! () ; }

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/orchestrator.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/orchestrator.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/orchestrator.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/orchestrator.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/orchestrator.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/orchestrator.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/orchestrator.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/orchestrator.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/orchestrator.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/orchestrator.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/orchestrator.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/orchestrator.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/orchestrator.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/orchestrator.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/orchestrator.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/orchestrator.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/orchestrator.rs`
  - Category: Performance

- [ ] **Function 'spawn_import_phase' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/orchestrator.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn spawn_import_phase (source : PathBuf , pool : Pool < Postgres > , batch_size : usize , stats : Arc < Stats > , shutdown : Arc < AtomicBool > , multi_progress : Arc < MultiProgress > ,) -> JoinHandle < Result < () > > { tokio :: spawn (async move { let pb = multi_progress . add (ProgressBar :: new (0)) ; pb . set_style (ProgressStyle :: default_bar () . template ("[{elapsed_precise}] {bar:40.cyan/blue} {pos}/{len} {msg}") . unwrap () . progress_chars ("=>-") ,) ; pb . set_message ("Importing files...") ; let files = scan_directory (& source) ? ; pb . set_length (files . len () as u64) ; for batch in files . chunks (batch_size) { if shutdown . load (Ordering :: Relaxed) { break ; } import_batch (& pool , batch , & stats , & pb) . await ? ; } pb . finish_with_message ("Import complete") ; Ok (()) }) }

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/orchestrator.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/orchestrator.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/orchestrator.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/orchestrator.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/orchestrator.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/orchestrator.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/orchestrator.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/orchestrator.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/orchestrator.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/orchestrator.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/orchestrator.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/orchestrator.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/orchestrator.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/orchestrator.rs`
  - Category: Performance

- [ ] **Function 'spawn_rename_filesystem_phase' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/orchestrator.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn spawn_rename_filesystem_phase (source : PathBuf , worker_count : usize , stats : Arc < Stats > , shutdown : Arc < AtomicBool > , multi_progress : Arc < MultiProgress > ,) -> JoinHandle < Result < () > > { tokio :: spawn (async move { let pb = multi_progress . add (ProgressBar :: new (0)) ; pb . set_style (ProgressStyle :: default_bar () . template ("[{elapsed_precise}] {bar:40.cyan/blue} {pos}/{len} {msg}") . unwrap () . progress_chars ("=>-") ,) ; pb . set_message ("Scanning and renaming files...") ; let files = scan_directory (& source) ? ; pb . set_length (files . len () as u64) ; use rayon :: prelude :: * ; files . par_iter () . for_each (| filepath | { if shutdown . load (Ordering :: Relaxed) { return ; } match rename_file_filesystem (filepath) { Ok (renamed) => { if renamed { stats . rename_file () ; } pb . inc (1) ; } , Err (e) => { error ! ("Rename failed for {:?}: {}" , filepath , e) ; stats . rename_error () ; pb . inc (1) ; } , } }) ; pb . finish_with_message ("Rename complete") ; Ok (()) }) }

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/orchestrator.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/orchestrator.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/orchestrator.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/orchestrator.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/orchestrator.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/orchestrator.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/orchestrator.rs`
  - Category: Performance

- [ ] **Function 'scan_directory' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/orchestrator.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn scan_directory (path : & Path) -> Result < Vec < PathBuf > > { use jwalk :: WalkDir ; let files : Vec < PathBuf > = WalkDir :: new (path) . into_iter () . filter_map (| entry | entry . ok ()) . filter (| entry | entry . file_type () . is_file ()) . filter (| entry | { entry . path () . extension () . and_then (| e | e . to_str ()) . map (| e | e . eq_ignore_ascii_case ("mid") || e . eq_ignore_ascii_case ("midi")) . unwrap_or (false) }) . map (| entry | entry . path ()) . collect () ; Ok (files) }

- [ ] **Function 'rename_file_filesystem' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/orchestrator.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Rename a file on the filesystem (no database operations)"] # [doc = " Returns true if file was renamed, false if no rename needed"] fn rename_file_filesystem (filepath : & Path) -> Result < bool > { let filename = filepath . file_name () . and_then (| n | n . to_str ()) . ok_or_else (| | anyhow :: anyhow ! ("Invalid filename")) ? ; let mut needs_rename = false ; let mut new_filename = filename . to_string () ; if let Some (ext) = filepath . extension () . and_then (| e | e . to_str ()) { if ext . eq_ignore_ascii_case ("midi") { new_filename = new_filename . replace (".midi" , ".mid") . replace (".MIDI" , ".mid") ; needs_rename = true ; } } if new_filename . contains (' ') { new_filename = new_filename . replace (' ' , "_") ; needs_rename = true ; } if ! needs_rename { return Ok (false) ; } let parent_dir = filepath . parent () . ok_or_else (| | anyhow :: anyhow ! ("Cannot get parent directory")) ? ; let new_filepath = parent_dir . join (& new_filename) ; std :: fs :: rename (filepath , & new_filepath) ? ; Ok (true) }

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/orchestrator.rs`
  - Category: Performance

- [ ] **Function 'sanitize_filename' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/orchestrator.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Sanitize filename component by removing problematic characters"] fn sanitize_filename (s : & str) -> String { s . chars () . map (| c | match c { '/' | '\\' | ':' | '*' | '?' | '"' | '<' | '>' | '|' => '_' , ' ' => '_' , _ => c , }) . collect () }

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/organize_files.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/organize_files.rs`
  - Category: Performance

- [ ] **Function 'extract_zip_archive' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/parallel_extract.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Extract a single ZIP archive using ultra-fast decompression"] fn extract_zip_archive (archive_path : & Path , output_dir : & Path , stats : & Arc < ExtractionStats > , progress : & Option < ProgressBar > ,) -> Result < usize > { let file = File :: open (archive_path) . with_context (| | format ! ("Failed to open archive: {}" , archive_path . display ())) ? ; let mmap = unsafe { Mmap :: map (& file) . with_context (| | format ! ("Failed to mmap archive: {}" , archive_path . display ())) ? } ; let cursor = std :: io :: Cursor :: new (& mmap [..]) ; let mut zip = ZipArchive :: new (cursor) . with_context (| | format ! ("Failed to read ZIP: {}" , archive_path . display ())) ? ; let file_count = zip . len () ; if let Some (pb) = progress { pb . set_length (file_count as u64) ; } let mut extracted = 0 ; for i in 0 .. zip . len () { let mut file = match zip . by_index (i) { Ok (f) => f , Err (e) => { eprintln ! ("âš ï¸  Failed to read entry {}: {}" , i , e) ; stats . error_occurred () ; continue ; } , } ; if file . is_dir () { continue ; } let file_name = file . name () . to_string () ; if ! file_name . ends_with (".mid") && ! file_name . ends_with (".midi") { continue ; } let output_path = output_dir . join (& file_name) ; if let Some (parent) = output_path . parent () { fs :: create_dir_all (parent) . ok () ; } match std :: io :: copy (& mut file , & mut File :: create (& output_path) ?) { Ok (size) => { stats . file_extracted (size) ; extracted += 1 ; if let Some (pb) = progress { pb . inc (1) ; } } , Err (e) => { eprintln ! ("âš ï¸  Failed to extract {}: {}" , file_name , e) ; stats . error_occurred () ; } , } } stats . archive_done () ; Ok (extracted) }

- [ ] **Function 'extract_rar_archive' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/parallel_extract.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Extract RAR archive (basic wrapper around unrar)"] fn extract_rar_archive (archive_path : & Path , output_dir : & Path , stats : & Arc < ExtractionStats > ,) -> Result < usize > { use std :: process :: Command ; let output = Command :: new ("unrar") . arg ("x") . arg ("-o+") . arg ("-inul") . arg (archive_path) . arg (output_dir) . output () ? ; if ! output . status . success () { stats . error_occurred () ; anyhow :: bail ! ("unrar failed for {}" , archive_path . display ()) ; } stats . archive_done () ; let count = walkdir :: WalkDir :: new (output_dir) . into_iter () . filter_map (| e | e . ok ()) . filter (| e | { e . path () . extension () . and_then (| s | s . to_str ()) . map (| ext | ext == "mid" || ext == "midi") . unwrap_or (false) }) . count () ; stats . file_extracted (count as u64) ; Ok (count) }

- [ ] **Function 'extract_7z_archive' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/parallel_extract.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Extract 7z archive (basic wrapper around 7z)"] fn extract_7z_archive (archive_path : & Path , output_dir : & Path , stats : & Arc < ExtractionStats > ,) -> Result < usize > { use std :: process :: Command ; let output = Command :: new ("7z") . arg ("x") . arg (format ! ("-o{}" , output_dir . display ())) . arg ("-y") . arg (archive_path) . output () ? ; if ! output . status . success () { stats . error_occurred () ; anyhow :: bail ! ("7z failed for {}" , archive_path . display ()) ; } stats . archive_done () ; let count = walkdir :: WalkDir :: new (output_dir) . into_iter () . filter_map (| e | e . ok ()) . filter (| e | { e . path () . extension () . and_then (| s | s . to_str ()) . map (| ext | ext == "mid" || ext == "midi") . unwrap_or (false) }) . count () ; stats . file_extracted (count as u64) ; Ok (count) }

- [ ] **Function 'find_archives' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/parallel_extract.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Find all archives in directory"] fn find_archives (dir : & Path) -> Result < Vec < PathBuf > > { let mut archives = Vec :: new () ; for entry in fs :: read_dir (dir) ? { let entry = entry ? ; let path = entry . path () ; if path . is_file () { if let Some (ext) = path . extension () { let ext = ext . to_string_lossy () . to_lowercase () ; if ext == "zip" || ext == "rar" || ext == "7z" { archives . push (path) ; } } } } Ok (archives) }

- [ ] **Function 'main' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/parallel_extract.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn main () -> Result < () > { let args = Args :: parse () ; let start_time = Instant :: now () ; println ! ("ğŸš€ ULTRA-FAST PARALLEL ARCHIVE EXTRACTION") ; println ! ("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•") ; println ! () ; fs :: create_dir_all (& args . output_dir) ? ; let archives = find_archives (& args . archive_dir) ? ; let total_archives = archives . len () ; if total_archives == 0 { println ! ("âŒ No archives found in {}" , args . archive_dir . display ()) ; return Ok (()) ; } println ! ("ğŸ“¦ Found {} archives" , total_archives) ; println ! () ; let max_parallel = args . max_parallel . unwrap_or_else (num_cpus :: get) ; println ! ("âš¡ Using {} parallel extraction threads" , max_parallel) ; println ! () ; rayon :: ThreadPoolBuilder :: new () . num_threads (max_parallel) . build_global () . ok () ; let stats = Arc :: new (ExtractionStats :: new ()) ; let multi_progress = if args . verbose { Some (MultiProgress :: new ()) } else { None } ; archives . par_iter () . for_each (| archive_path | { let filename = archive_path . file_name () . unwrap_or_default () . to_string_lossy () ; let progress_bar = if let Some (ref mp) = multi_progress { let pb = mp . add (ProgressBar :: new (0)) ; pb . set_style (ProgressStyle :: default_bar () . template ("{msg} [{bar:40.cyan/blue}] {pos}/{len} files") . unwrap () . progress_chars ("#>-") ,) ; pb . set_message (filename . to_string ()) ; Some (pb) } else { println ! ("ğŸ”„ Extracting: {}" , filename) ; None } ; let result = if archive_path . extension () . unwrap () . to_string_lossy () == "zip" { extract_zip_archive (archive_path , & args . output_dir , & stats , & progress_bar) } else if archive_path . extension () . unwrap () . to_string_lossy () == "rar" { extract_rar_archive (archive_path , & args . output_dir , & stats) } else { extract_7z_archive (archive_path , & args . output_dir , & stats) } ; match result { Ok (count) => { if let Some (pb) = progress_bar { pb . finish_with_message (format ! ("âœ“ {} ({} files)" , filename , count)) ; } else { println ! ("âœ“ Complete: {} ({} files)" , filename , count) ; } } , Err (e) => { eprintln ! ("âŒ Failed {}: {}" , filename , e) ; stats . error_occurred () ; } , } }) ; println ! () ; println ! ("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•") ; let (archives_done , files , bytes , errors) = stats . report () ; let elapsed = start_time . elapsed () ; println ! ("âœ… Extraction Complete!") ; println ! () ; println ! ("ğŸ“Š Statistics:") ; println ! ("   Archives processed: {}/{}" , archives_done , total_archives) ; println ! ("   MIDI files extracted: {}" , files) ; println ! ("   Total size: {:.2} GB" , bytes as f64 / 1_073_741_824.0) ; println ! ("   Errors: {}" , errors) ; println ! () ; println ! ("â±ï¸  Time: {:.2}s" , elapsed . as_secs_f64 ()) ; println ! ("ğŸš€ Speed: {:.0} files/sec" , files as f64 / elapsed . as_secs_f64 ()) ; println ! () ; println ! ("ğŸ“‚ Output: {}" , args . output_dir . display ()) ; Ok (()) }

- [ ] **Function 'print_usage' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/pipeline-cli.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn print_usage () { println ! ("MIDI Pipeline CLI") ; println ! () ; println ! ("Usage:") ; println ! ("  pipeline-cli import <directory>  - Import MIDI files from directory") ; println ! ("  pipeline-cli analyze             - Analyze all unanalyzed files") ; println ! ("  pipeline-cli stats               - Show database statistics") ; println ! ("  pipeline-cli help                - Show this help message") ; println ! () ; println ! ("Environment Variables:") ; println ! ("  DATABASE_URL - PostgreSQL connection string") ; println ! ("                 Default: postgresql://midiuser:145278963@localhost:5433/midi_library") ; }

- [ ] **Function 'parse_worker_counts' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/pipeline-orchestrator.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Parse custom worker counts from string: \"16,32,16,24,32,8\""] fn parse_worker_counts (workers_str : & str , config : & mut PipelineConfig ,) -> Result < () , Box < dyn std :: error :: Error > > { let counts : Vec < usize > = workers_str . split (',') . map (| s | s . trim () . parse ()) . collect :: < Result < Vec < _ > , _ > > () ? ; if counts . len () != 6 { return Err ("Worker counts must be 6 values: import,sanitize,split,analyze,rename,export" . into () ,) ; } config . import_workers = counts [0] ; config . sanitize_workers = counts [1] ; config . split_workers = counts [2] ; config . analyze_workers = counts [3] ; config . rename_workers = counts [4] ; config . export_workers = counts [5] ; info ! ("Custom worker counts:") ; info ! ("  Import: {}" , counts [0]) ; info ! ("  Sanitize: {}" , counts [1]) ; info ! ("  Split: {}" , counts [2]) ; info ! ("  Analyze: {}" , counts [3]) ; info ! ("  Rename: {}" , counts [4]) ; info ! ("  Export: {}" , counts [5]) ; Ok (()) }

- [ ] **Function 'sanitize_filename' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/split.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Sanitize a filename by removing/replacing invalid characters"] fn sanitize_filename (name : & str) -> String { name . chars () . map (| c | match c { '/' | '\\' | ':' | '*' | '?' | '"' | '<' | '>' | '|' => '_' , c if c . is_control () => '_' , c => c , }) . collect :: < String > () . trim () . to_string () }

- [ ] **Function 'serialize_midi_file' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/split.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Serialize a MIDI file back to bytes"] fn serialize_midi_file (midi_file : & midi_library_shared :: core :: midi :: types :: MidiFile ,) -> Result < Vec < u8 > > { let mut buffer = Vec :: new () ; buffer . extend_from_slice (b"MThd") ; buffer . extend_from_slice (& 6u32 . to_be_bytes ()) ; buffer . extend_from_slice (& midi_file . header . format . to_be_bytes ()) ; buffer . extend_from_slice (& (midi_file . tracks . len () as u16) . to_be_bytes ()) ; buffer . extend_from_slice (& midi_file . header . ticks_per_quarter_note . to_be_bytes ()) ; for track in & midi_file . tracks { let track_data = serialize_track (track) ? ; buffer . extend_from_slice (b"MTrk") ; buffer . extend_from_slice (& (track_data . len () as u32) . to_be_bytes ()) ; buffer . extend_from_slice (& track_data) ; } Ok (buffer) }

- [ ] **Function 'serialize_track' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/split.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Serialize a track to bytes"] fn serialize_track (track : & midi_library_shared :: core :: midi :: types :: Track) -> Result < Vec < u8 > > { use midi_library_shared :: core :: midi :: Event ; let mut buffer = Vec :: new () ; for timed_event in & track . events { write_variable_length (& mut buffer , timed_event . delta_ticks) ; match & timed_event . event { Event :: NoteOn { channel , note , velocity } => { buffer . push (0x90 | channel) ; buffer . push (* note) ; buffer . push (* velocity) ; } , Event :: NoteOff { channel , note , velocity } => { buffer . push (0x80 | channel) ; buffer . push (* note) ; buffer . push (* velocity) ; } , _ => { buffer . push (0xFF) ; buffer . push (0x00) ; buffer . push (0x00) ; } , } } buffer . push (0x00) ; buffer . push (0xFF) ; buffer . push (0x2F) ; buffer . push (0x00) ; Ok (buffer) }

- [ ] **Function 'write_variable_length' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/split.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Write a variable-length quantity (MIDI format)"] fn write_variable_length (buffer : & mut Vec < u8 > , mut value : u32) { let mut bytes = Vec :: new () ; bytes . push ((value & 0x7F) as u8) ; value >>= 7 ; while value > 0 { bytes . push (((value & 0x7F) | 0x80) as u8) ; value >>= 7 ; } for byte in bytes . iter () . rev () { buffer . push (* byte) ; } }

- [ ] **Function 'find_first_note_on' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/trim_split_tracks.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Find the first note-on event in the MIDI file and return its absolute tick position"] fn find_first_note_on (smf : & Smf) -> Option < u32 > { let mut first_note_tick = None ; for track in & smf . tracks { let mut current_tick = 0u32 ; for event in track { current_tick = current_tick . saturating_add (event . delta . as_int ()) ; if let TrackEventKind :: Midi { message , .. } = & event . kind { if let MidiMessage :: NoteOn { vel , .. } = message { if vel . as_int () > 0 { match first_note_tick { None => first_note_tick = Some (current_tick) , Some (tick) => { if current_tick < tick { first_note_tick = Some (current_tick) ; } } , } } } } } } first_note_tick }

- [ ] **Function 'trim_midi_file' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/trim_split_tracks.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Trim the MIDI file by shifting all events back by the given offset"] fn trim_midi_file (smf : & mut Smf , trim_ticks : u32) { for track in & mut smf . tracks { let mut current_tick = 0u32 ; let mut trimmed_events = Vec :: new () ; let mut last_output_tick = 0u32 ; for event in track . iter () { current_tick = current_tick . saturating_add (event . delta . as_int ()) ; let new_tick = current_tick . saturating_sub (trim_ticks) ; let new_delta = new_tick . saturating_sub (last_output_tick) ; let new_event = TrackEvent { delta : midly :: num :: u28 :: new (new_delta) , kind : event . kind . clone () } ; trimmed_events . push (new_event) ; last_output_tick = new_tick ; } * track = trimmed_events ; } }

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/trim_split_tracks.rs`
  - Category: Performance

- [ ] **Function 'process_file' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/trim_split_tracks.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Process a single MIDI file"] fn process_file (path : & Path , args : & Args , stats : & TrimStats) -> Result < () > { stats . files_processed . fetch_add (1 , Ordering :: Relaxed) ; let data = fs :: read (path) . with_context (| | format ! ("Failed to read file: {}" , path . display ())) ? ; let mut smf = Smf :: parse (& data) . with_context (| | format ! ("Failed to parse MIDI: {}" , path . display ())) ? ; let first_note_tick = match find_first_note_on (& smf) { Some (tick) => tick , None => { if args . verbose { eprintln ! ("No note-on events found: {}" , path . display ()) ; } stats . files_skipped . fetch_add (1 , Ordering :: Relaxed) ; return Ok (()) ; } , } ; if first_note_tick < args . min_trim_ticks { if args . verbose { eprintln ! ("Leading silence too small ({} ticks): {}" , first_note_tick , path . display ()) ; } stats . files_skipped . fetch_add (1 , Ordering :: Relaxed) ; return Ok (()) ; } if args . verbose { eprintln ! ("Trimming {} ticks from: {}" , first_note_tick , path . display ()) ; } trim_midi_file (& mut smf , first_note_tick) ; if ! args . dry_run { let mut output = Vec :: new () ; smf . write (& mut output) . map_err (| e | anyhow :: anyhow ! ("Failed to encode MIDI: {} - {}" , path . display () , e)) ? ; fs :: write (path , output) . with_context (| | format ! ("Failed to write file: {}" , path . display ())) ? ; } stats . files_trimmed . fetch_add (1 , Ordering :: Relaxed) ; stats . total_ticks_trimmed . fetch_add (first_note_tick as usize , Ordering :: Relaxed) ; Ok (()) }

- [ ] **Function 'main' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/bin/trim_split_tracks.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn main () -> Result < () > { let args = Args :: parse () ; println ! ("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”") ; println ! ("  MIDI Track Trimming Tool") ; println ! ("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”") ; println ! ("Input directory:  {}" , args . input_dir . display ()) ; println ! ("Workers:          {}" , args . workers) ; println ! ("Min trim ticks:   {}" , args . min_trim_ticks) ; println ! ("Dry run:          {}" , if args . dry_run { "YES" } else { "NO" }) ; println ! () ; rayon :: ThreadPoolBuilder :: new () . num_threads (args . workers) . build_global () . context ("Failed to build thread pool") ? ; println ! ("Scanning for MIDI files...") ; let mut midi_files = Vec :: new () ; for entry in walkdir :: WalkDir :: new (& args . input_dir) . follow_links (false) . into_iter () . filter_map (| e | e . ok ()) { let path = entry . path () ; if path . is_file () { if let Some (ext) = path . extension () { if ext == "mid" || ext == "midi" { midi_files . push (path . to_path_buf ()) ; } } } } let total_files = midi_files . len () ; println ! ("Found {} MIDI files" , total_files) ; println ! () ; if total_files == 0 { println ! ("No MIDI files found!") ; return Ok (()) ; } let stats = TrimStats :: default () ; let start = Instant :: now () ; midi_files . par_iter () . for_each (| path | { if let Err (e) = process_file (path , & args , & stats) { eprintln ! ("Error processing {}: {}" , path . display () , e) ; stats . files_error . fetch_add (1 , Ordering :: Relaxed) ; } stats . print_progress (total_files) ; }) ; let elapsed = start . elapsed () . as_secs_f64 () ; stats . print_final (elapsed) ; Ok (()) }

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/analyze.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/analyze.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/analyze.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/analyze.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/analyze.rs`
  - Category: Performance

- [ ] **Function 'analyze_notes' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/analyze.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Analyze notes in MIDI file"] fn analyze_notes (midi_file : & MidiFile) -> NoteStats { let mut note_count = 0 ; let mut unique_pitch_set = std :: collections :: HashSet :: new () ; let mut min_pitch = 127u8 ; let mut max_pitch = 0u8 ; let mut min_velocity = 127u8 ; let mut max_velocity = 0u8 ; let mut velocity_sum = 0u32 ; let mut active_notes_per_tick : std :: collections :: HashMap < u32 , usize > = std :: collections :: HashMap :: new () ; let mut max_tick = 0u32 ; let mut percussive_note_count = 0 ; for track in & midi_file . tracks { let mut current_tick = 0u32 ; let mut active_notes = std :: collections :: HashSet :: new () ; for timed_event in & track . events { current_tick += timed_event . delta_ticks ; max_tick = max_tick . max (current_tick) ; match & timed_event . event { Event :: NoteOn { note , velocity , channel } if * velocity > 0 => { note_count += 1 ; unique_pitch_set . insert (* note) ; min_pitch = min_pitch . min (* note) ; max_pitch = max_pitch . max (* note) ; min_velocity = min_velocity . min (* velocity) ; max_velocity = max_velocity . max (* velocity) ; velocity_sum += * velocity as u32 ; if * channel == 9 { percussive_note_count += 1 ; } active_notes . insert (* note) ; active_notes_per_tick . insert (current_tick , active_notes . len ()) ; } , Event :: NoteOff { note , .. } | Event :: NoteOn { note , velocity : 0 , .. } => { active_notes . remove (note) ; } , _ => { } , } } } let unique_pitches = if note_count > 0 { Some (unique_pitch_set . len () as i32) } else { None } ; let avg_velocity = if note_count > 0 { Some (velocity_sum as f64 / note_count as f64) } else { None } ; let polyphony_max = active_notes_per_tick . values () . max () . copied () . map (| v | v as i16) ; let polyphony_avg = if ! active_notes_per_tick . is_empty () { let sum : usize = active_notes_per_tick . values () . sum () ; Some (sum as f64 / active_notes_per_tick . len () as f64) } else { None } ; let is_monophonic = polyphony_max == Some (1) ; let is_polyphonic = polyphony_max . map_or (false , | p | p > 1) ; let is_percussive = if note_count > 0 { let drum_ratio = percussive_note_count as f64 / note_count as f64 ; let in_drum_range = min_pitch >= 27 && max_pitch <= 87 ; drum_ratio > 0.5 || in_drum_range } else { false } ; let duration_seconds = if max_tick > 0 { let ticks_per_beat = midi_file . header . ticks_per_quarter_note as f64 ; let seconds_per_beat = 0.5 ; Some ((max_tick as f64 / ticks_per_beat) * seconds_per_beat) } else { None } ; let note_density = if let Some (duration) = duration_seconds { if duration > 0.0 { Some (note_count as f64 / duration) } else { None } } else { None } ; let (pitch_range_low , pitch_range_high , pitch_range_semitones) = if note_count > 0 { let semitones = max_pitch . saturating_sub (min_pitch) as i16 ; (Some (min_pitch as i16) , Some (max_pitch as i16) , Some (semitones) ,) } else { (None , None , None) } ; let (velocity_range_low , velocity_range_high) = if note_count > 0 { (Some (min_velocity as i16) , Some (max_velocity as i16)) } else { (None , None) } ; NoteStats { note_count , unique_pitches , pitch_range_low , pitch_range_high , pitch_range_semitones , avg_velocity , velocity_range_low , velocity_range_high , note_density , polyphony_max , polyphony_avg , is_monophonic , is_polyphonic , is_percussive , } }

- [ ] **Function 'extract_time_signature' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/analyze.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Extract time signature from MIDI file"] fn extract_time_signature (midi_file : & MidiFile) -> (Option < i16 > , Option < i16 >) { for track in & midi_file . tracks { for timed_event in & track . events { if let Event :: TimeSignature { numerator , denominator , .. } = & timed_event . event { let denom_value = 2i16 . pow (* denominator as u32) ; return (Some (* numerator as i16) , Some (denom_value)) ; } } } (Some (4) , Some (4)) }

- [ ] **Function 'calculate_total_ticks' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/analyze.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Calculate total number of ticks in MIDI file"] fn calculate_total_ticks (midi_file : & MidiFile) -> i32 { let mut max_ticks = 0u32 ; for track in & midi_file . tracks { let mut track_ticks = 0u32 ; for timed_event in & track . events { track_ticks += timed_event . delta_ticks ; } max_ticks = max_ticks . max (track_ticks) ; } max_ticks as i32 }

- [ ] **Function 'calculate_duration_seconds' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/analyze.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Calculate duration in seconds"] fn calculate_duration_seconds (midi_file : & MidiFile , bpm : f64) -> Option < f64 > { let total_ticks = calculate_total_ticks (midi_file) as f64 ; let ticks_per_quarter = midi_file . header . ticks_per_quarter_note as f64 ; if total_ticks > 0.0 && ticks_per_quarter > 0.0 && bpm > 0.0 { let quarters = total_ticks / ticks_per_quarter ; let minutes = quarters / bpm ; let seconds = minutes * 60.0 ; Some (seconds) } else { None } }

- [ ] **Function 'extract_instrument_names' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/analyze.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Extract instrument names from MIDI file"] fn extract_instrument_names (midi_file : & MidiFile) -> Vec < String > { let mut instruments = Vec :: new () ; for track in & midi_file . tracks { for timed_event in & track . events { match & timed_event . event { Event :: Text { text_type , text } => { if matches ! (text_type , TextType :: InstrumentName | TextType :: TrackName) && ! instruments . contains (text) { instruments . push (text . clone ()) ; } } , Event :: ProgramChange { program , .. } => { if let Some (instrument_name) = program_to_instrument_name (* program) { if ! instruments . contains (& instrument_name) { instruments . push (instrument_name) ; } } } , _ => { } , } } } instruments }

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/analyze.rs`
  - Category: Performance

- [ ] **Function 'program_to_instrument_name' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/analyze.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Map MIDI General MIDI program number to instrument name"] fn program_to_instrument_name (program : u8) -> Option < String > { match program { 0 ..= 7 => Some ("Piano" . to_string ()) , 8 ..= 15 => Some ("Keys" . to_string ()) , 16 ..= 23 => Some ("Organ" . to_string ()) , 24 ..= 31 => Some ("Guitar" . to_string ()) , 32 ..= 39 => Some ("Bass" . to_string ()) , 40 ..= 47 => Some ("Strings" . to_string ()) , 48 ..= 55 => Some ("Ensemble" . to_string ()) , 56 ..= 63 => Some ("Brass" . to_string ()) , 64 ..= 71 => Some ("Woodwind" . to_string ()) , 72 ..= 79 => Some ("Flute" . to_string ()) , 80 ..= 87 => Some ("Lead" . to_string ()) , 88 ..= 95 => Some ("Pad" . to_string ()) , 96 ..= 103 => Some ("FX" . to_string ()) , 104 ..= 111 => Some ("Ethnic" . to_string ()) , 112 ..= 119 => Some ("Percussion" . to_string ()) , 120 ..= 127 => Some ("FX" . to_string ()) , _ => None , } }

- [ ] **Function 'detect_pitch_bend' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/analyze.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Detect if MIDI file contains pitch bend events"] fn detect_pitch_bend (midi_file : & MidiFile) -> bool { for track in & midi_file . tracks { for timed_event in & track . events { if matches ! (& timed_event . event , Event :: PitchBend { .. }) { return true ; } } } false }

- [ ] **Function 'detect_cc_messages' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/analyze.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Detect if MIDI file contains control change messages"] fn detect_cc_messages (midi_file : & MidiFile) -> bool { for track in & midi_file . tracks { for timed_event in & track . events { if matches ! (& timed_event . event , Event :: ControlChange { .. }) { return true ; } } } false }

- [ ] **Function 'analyze_tracks' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/analyze.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Analyze tracks and extract per-channel instrument information"] fn analyze_tracks (midi_file : & MidiFile) -> Vec < TrackInstrument > { let mut channel_data : std :: collections :: HashMap < u8 , TrackInstrument > = std :: collections :: HashMap :: new () ; for track in & midi_file . tracks { let mut current_programs : std :: collections :: HashMap < u8 , u8 > = std :: collections :: HashMap :: new () ; for timed_event in & track . events { match & timed_event . event { Event :: ProgramChange { channel , program } => { current_programs . insert (* channel , * program) ; } , Event :: NoteOn { channel , note , velocity } if * velocity > 0 => { let program = current_programs . get (channel) . copied () . unwrap_or (0) ; let entry = channel_data . entry (* channel) . or_insert_with (| | { let (name , family , inst_type) = get_instrument_info (program) ; TrackInstrument { channel : * channel as i16 , program_number : program as i16 , program_name : name , instrument_family : family , instrument_type : inst_type , note_count : 0 , avg_velocity : None , pitch_range_low : None , pitch_range_high : None , is_primary : false , } }) ; entry . note_count += 1 ; entry . pitch_range_low = Some (entry . pitch_range_low . map_or (* note as i16 , | l | l . min (* note as i16))) ; entry . pitch_range_high = Some (entry . pitch_range_high . map_or (* note as i16 , | h | h . max (* note as i16))) ; if let Some (avg) = entry . avg_velocity { entry . avg_velocity = Some ((avg * (entry . note_count - 1) as f64 + * velocity as f64) / entry . note_count as f64 ,) ; } else { entry . avg_velocity = Some (* velocity as f64) ; } } , _ => { } , } } } let mut instruments : Vec < TrackInstrument > = channel_data . into_values () . collect () ; if let Some (max_notes) = instruments . iter () . map (| i | i . note_count) . max () { for inst in & mut instruments { if inst . note_count == max_notes { inst . is_primary = true ; break ; } } } instruments }

- [ ] **Function 'extract_tempo_changes' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/analyze.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Extract tempo changes from MIDI meta events"] fn extract_tempo_changes (midi_file : & MidiFile) -> Option < String > { let mut tempo_changes = Vec :: new () ; let mut current_tick = 0u32 ; for track in & midi_file . tracks { let mut track_tick = 0u32 ; for timed_event in & track . events { track_tick += timed_event . delta_ticks ; if let Event :: TempoChange { microseconds_per_quarter } = & timed_event . event { let bpm = 60_000_000.0 / * microseconds_per_quarter as f64 ; tempo_changes . push (serde_json :: json ! ({ "tick" : track_tick , "bpm" : ((bpm * 100.0) as f64) . round () / 100.0 })) ; } } current_tick = current_tick . max (track_tick) ; } if tempo_changes . is_empty () { None } else { Some (serde_json :: to_string (& tempo_changes) . unwrap_or_default ()) } }

- [ ] **Function 'extract_key_changes' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/analyze.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Extract key signature changes from MIDI meta events"] fn extract_key_changes (midi_file : & MidiFile) -> Option < String > { let mut key_changes = Vec :: new () ; let mut current_tick = 0u32 ; for track in & midi_file . tracks { let mut track_tick = 0u32 ; for timed_event in & track . events { track_tick += timed_event . delta_ticks ; if let Event :: KeySignature { sharps_flats , is_minor } = & timed_event . event { let key_name = get_key_name (* sharps_flats , * is_minor) ; key_changes . push (serde_json :: json ! ({ "tick" : track_tick , "key" : key_name })) ; } } current_tick = current_tick . max (track_tick) ; } if key_changes . is_empty () { None } else { Some (serde_json :: to_string (& key_changes) . unwrap_or_default ()) } }

- [ ] **Function 'extract_time_signature_changes' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/analyze.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Extract time signature changes from MIDI meta events"] fn extract_time_signature_changes (midi_file : & MidiFile) -> Option < String > { let mut time_sig_changes = Vec :: new () ; let mut current_tick = 0u32 ; for track in & midi_file . tracks { let mut track_tick = 0u32 ; for timed_event in & track . events { track_tick += timed_event . delta_ticks ; if let Event :: TimeSignature { numerator , denominator , .. } = & timed_event . event { let denom_value = 2i32 . pow (* denominator as u32) ; time_sig_changes . push (serde_json :: json ! ({ "tick" : track_tick , "numerator" : numerator , "denominator" : denom_value })) ; } } current_tick = current_tick . max (track_tick) ; } if time_sig_changes . is_empty () { None } else { Some (serde_json :: to_string (& time_sig_changes) . unwrap_or_default ()) } }

- [ ] **Function 'get_key_name' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/analyze.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Convert sharps/flats to key name"] fn get_key_name (sharps_flats : i8 , is_minor : bool) -> String { let major_keys = ["C" , "G" , "D" , "A" , "E" , "B" , "F#" , "C#" , "F" , "Bb" , "Eb" , "Ab" , "Db" , "Gb" , "Cb" ,] ; let minor_keys = ["Am" , "Em" , "Bm" , "F#m" , "C#m" , "G#m" , "D#m" , "A#m" , "Dm" , "Gm" , "Cm" , "Fm" , "Bbm" , "Ebm" , "Abm" ,] ; let index = if sharps_flats >= 0 { sharps_flats as usize } else { (8 - sharps_flats - 1) as usize } ; if is_minor { minor_keys . get (index) . unwrap_or (& "Unknown") . to_string () } else { major_keys . get (index) . unwrap_or (& "Unknown") . to_string () } }

- [ ] **Function 'analyze_controllers' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/analyze.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Analyze MIDI controller (CC) messages"] fn analyze_controllers (midi_file : & MidiFile) -> Option < String > { use std :: collections :: HashMap ; let mut controller_data : HashMap < u8 , (u32 , u8 , u8 , u64) > = HashMap :: new () ; let priority_controllers = [1 , 2 , 7 , 10 , 11 , 64] ; for track in & midi_file . tracks { for timed_event in & track . events { if let Event :: ControlChange { controller , value , .. } = & timed_event . event { let entry = controller_data . entry (* controller) . or_insert ((0 , 255 , 0 , 0)) ; entry . 0 += 1 ; entry . 1 = entry . 1 . min (* value) ; entry . 2 = entry . 2 . max (* value) ; entry . 3 += * value as u64 ; } } } if controller_data . is_empty () { return None ; } let mut controllers = Vec :: new () ; for & cc in & priority_controllers { if let Some (& (count , min , max , sum)) = controller_data . get (& cc) { let avg = sum as f64 / count as f64 ; controllers . push (serde_json :: json ! ({ "cc" : cc , "name" : get_cc_name (cc) , "count" : count , "min" : min , "max" : max , "avg" : (avg * 100.0) . round () / 100.0 })) ; } } for (& cc , & (count , min , max , sum)) in & controller_data { if ! priority_controllers . contains (& cc) && count > 10 { let avg = sum as f64 / count as f64 ; controllers . push (serde_json :: json ! ({ "cc" : cc , "name" : get_cc_name (cc) , "count" : count , "min" : min , "max" : max , "avg" : (avg * 100.0) . round () / 100.0 })) ; } } if controllers . is_empty () { None } else { Some (serde_json :: to_string (& controllers) . unwrap_or_default ()) } }

- [ ] **Function 'get_cc_name' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/analyze.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Get human-readable name for CC number"] fn get_cc_name (cc : u8) -> & 'static str { match cc { 0 => "Bank Select" , 1 => "Modulation Wheel" , 2 => "Breath Controller" , 4 => "Foot Controller" , 5 => "Portamento Time" , 6 => "Data Entry" , 7 => "Channel Volume" , 8 => "Balance" , 10 => "Pan" , 11 => "Expression" , 64 => "Sustain Pedal" , 65 => "Portamento" , 66 => "Sostenuto" , 67 => "Soft Pedal" , 68 => "Legato Footswitch" , 69 => "Hold 2" , 71 => "Resonance" , 72 => "Release Time" , 73 => "Attack Time" , 74 => "Cutoff Frequency" , 84 => "Portamento Control" , 91 => "Reverb" , 92 => "Tremolo" , 93 => "Chorus" , 94 => "Detune" , 95 => "Phaser" , _ => "Other" , } }

- [ ] **Function 'analyze_articulation' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/analyze.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Analyze articulation and performance characteristics"] fn analyze_articulation (midi_file : & MidiFile , tempo_us_per_qn : u32) -> Option < String > { let tpq = midi_file . header . ticks_per_quarter_note as f64 ; let us_per_tick = tempo_us_per_qn as f64 / tpq ; let ms_per_tick = us_per_tick / 1000.0 ; let mut note_events : std :: collections :: HashMap < (u8 , u8) , (u32 , u8) > = std :: collections :: HashMap :: new () ; let mut note_durations : Vec < f64 > = Vec :: new () ; let mut note_velocities : Vec < u8 > = Vec :: new () ; let mut timing_deviations : Vec < f64 > = Vec :: new () ; let mut legato_count = 0 ; let mut staccato_count = 0 ; let mut total_notes = 0 ; for track in & midi_file . tracks { let mut current_tick = 0u32 ; let mut active_notes : std :: collections :: HashSet < (u8 , u8) > = std :: collections :: HashSet :: new () ; for timed_event in & track . events { current_tick += timed_event . delta_ticks ; match & timed_event . event { Event :: NoteOn { channel , note , velocity } if * velocity > 0 => { if ! active_notes . is_empty () { legato_count += 1 ; } active_notes . insert ((* channel , * note)) ; note_events . insert ((* channel , * note) , (current_tick , * velocity)) ; note_velocities . push (* velocity) ; let grid_size = (tpq / 4.0) as u32 ; let deviation = (current_tick % grid_size) as f64 ; let normalized_deviation = if deviation > grid_size as f64 / 2.0 { grid_size as f64 - deviation } else { deviation } ; timing_deviations . push (normalized_deviation * ms_per_tick) ; total_notes += 1 ; } , Event :: NoteOff { channel , note , .. } | Event :: NoteOn { channel , note , velocity : 0 } => { if let Some ((start_tick , _)) = note_events . remove (& (* channel , * note)) { let duration_ticks = current_tick . saturating_sub (start_tick) ; let duration_ms = duration_ticks as f64 * ms_per_tick ; note_durations . push (duration_ms) ; if duration_ms < 100.0 { staccato_count += 1 ; } } active_notes . remove (& (* channel , * note)) ; } , _ => { } , } } } if total_notes == 0 { return None ; } let legato_percentage = (legato_count as f64 / total_notes as f64) * 100.0 ; let staccato_percentage = (staccato_count as f64 / total_notes as f64) * 100.0 ; let avg_note_duration = note_durations . iter () . sum :: < f64 > () / note_durations . len () . max (1) as f64 ; let avg_timing_deviation = timing_deviations . iter () . sum :: < f64 > () / timing_deviations . len () . max (1) as f64 ; let min_velocity = * note_velocities . iter () . min () . unwrap_or (& 0) ; let max_velocity = * note_velocities . iter () . max () . unwrap_or (& 127) ; let dynamic_range = max_velocity . saturating_sub (min_velocity) ; let avg_velocity = note_velocities . iter () . map (| & v | v as f64) . sum :: < f64 > () / note_velocities . len () . max (1) as f64 ; let velocity_variance = note_velocities . iter () . map (| & v | { let diff = v as f64 - avg_velocity ; diff * diff }) . sum :: < f64 > () / note_velocities . len () . max (1) as f64 ; let result = serde_json :: json ! ({ "legato_percentage" : (legato_percentage * 100.0) . round () / 100.0 , "staccato_percentage" : (staccato_percentage * 100.0) . round () / 100.0 , "avg_note_duration_ms" : (avg_note_duration * 100.0) . round () / 100.0 , "timing_deviation_ms" : (avg_timing_deviation * 100.0) . round () / 100.0 , "dynamic_range" : dynamic_range , "velocity_variance" : (velocity_variance * 100.0) . round () / 100.0 , "is_humanized" : avg_timing_deviation > 2.0 , "is_legato" : legato_percentage > 30.0 , "is_staccato" : staccato_percentage > 50.0 , }) ; Some (serde_json :: to_string (& result) . unwrap_or_default ()) }

- [ ] **Function 'analyze_structure' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/analyze.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Analyze musical structure and form"] fn analyze_structure (midi_file : & MidiFile) -> Option < String > { let tpq = midi_file . header . ticks_per_quarter_note as u32 ; let segment_size = tpq * 16 ; let mut max_tick = 0u32 ; for track in & midi_file . tracks { let mut current_tick = 0u32 ; for event in & track . events { current_tick += event . delta_ticks ; } max_tick = max_tick . max (current_tick) ; } if max_tick < segment_size { return None ; } let num_segments = (max_tick / segment_size) as usize ; let mut segment_hashes : Vec < u64 > = vec ! [0 ; num_segments] ; for track in & midi_file . tracks { let mut current_tick = 0u32 ; for event in & track . events { current_tick += event . delta_ticks ; if let Event :: NoteOn { note , velocity , .. } = & event . event { if * velocity > 0 { let segment_idx = (current_tick / segment_size) as usize ; if segment_idx < num_segments { let position = current_tick % segment_size ; let hash = ((* note as u64) << 32) | position as u64 ; segment_hashes [segment_idx] ^= hash ; } } } } } let mut pattern_map : std :: collections :: HashMap < u64 , Vec < usize > > = std :: collections :: HashMap :: new () ; for (idx , & hash) in segment_hashes . iter () . enumerate () { if hash != 0 { pattern_map . entry (hash) . or_insert_with (Vec :: new) . push (idx) ; } } let mut repeated_sections : Vec < (usize , usize) > = Vec :: new () ; let mut pattern_id = 0 ; for (_hash , positions) in pattern_map . iter () { if positions . len () >= 2 { repeated_sections . push ((pattern_id , positions . len ())) ; pattern_id += 1 ; } } let total_repeated : usize = repeated_sections . iter () . map (| (_ , count) | count) . sum () ; let repetition_percentage = if num_segments > 0 { (total_repeated as f64 / num_segments as f64) * 100.0 } else { 0.0 } ; let num_unique = pattern_map . len () ; let estimated_form = if num_unique <= 2 { "Simple (AA or AB)" } else if num_unique <= 4 { "Song Form (AABA or ABAB)" } else if num_unique <= 6 { "Complex (ABABCB or similar)" } else { "Through-composed" } ; let result = serde_json :: json ! ({ "num_segments" : num_segments , "num_unique_patterns" : num_unique , "num_repeated_patterns" : repeated_sections . len () , "repetition_percentage" : (repetition_percentage * 100.0) . round () / 100.0 , "estimated_form" : estimated_form , "has_repetition" : repetition_percentage > 20.0 , "is_through_composed" : num_unique > 6 , }) ; Some (serde_json :: to_string (& result) . unwrap_or_default ()) }

- [ ] **Function 'get_instrument_info' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/analyze.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Get instrument information from GM program number"] fn get_instrument_info (program : u8) -> (String , String , String) { match program { 0 ..= 7 => ("Piano" . to_string () , "Keyboard" . to_string () , "Acoustic Piano" . to_string () ,) , 8 ..= 15 => ("Chromatic Percussion" . to_string () , "Keyboard" . to_string () , "Celesta/Glockenspiel" . to_string () ,) , 16 ..= 23 => ("Organ" . to_string () , "Keyboard" . to_string () , "Drawbar Organ" . to_string () ,) , 24 ..= 31 => ("Guitar" . to_string () , "Strings" . to_string () , "Acoustic Guitar" . to_string () ,) , 32 ..= 39 => ("Bass" . to_string () , "Strings" . to_string () , "Electric Bass" . to_string () ,) , 40 ..= 47 => ("Strings" . to_string () , "Strings" . to_string () , "Violin/Viola" . to_string () ,) , 48 ..= 55 => ("Ensemble" . to_string () , "Ensemble" . to_string () , "String Ensemble" . to_string () ,) , 56 ..= 63 => ("Brass" . to_string () , "Brass" . to_string () , "Trumpet/Trombone" . to_string () ,) , 64 ..= 71 => ("Reed" . to_string () , "Reed" . to_string () , "Saxophone" . to_string () ,) , 72 ..= 79 => ("Pipe" . to_string () , "Pipe" . to_string () , "Flute/Piccolo" . to_string () ,) , 80 ..= 87 => ("Synth Lead" . to_string () , "Synth" . to_string () , "Lead Synth" . to_string () ,) , 88 ..= 95 => ("Synth Pad" . to_string () , "Synth" . to_string () , "Pad Synth" . to_string () ,) , 96 ..= 103 => ("Synth Effects" . to_string () , "Synth" . to_string () , "FX Synth" . to_string () ,) , 104 ..= 111 => ("Ethnic" . to_string () , "Ethnic" . to_string () , "Sitar/Shamisen" . to_string () ,) , 112 ..= 119 => ("Percussive" . to_string () , "Percussion" . to_string () , "Timpani/Taiko" . to_string () ,) , 120 ..= 127 => ("Sound Effects" . to_string () , "SFX" . to_string () , "Sound Effect" . to_string () ,) , _ => ("Unknown" . to_string () , "Unknown" . to_string () , "Unknown" . to_string () ,) , } }

- [ ] **Function 'calculate_complexity_score' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/analyze.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Calculate complexity score based on various factors"] fn calculate_complexity_score (note_stats : & NoteStats , midi_file : & MidiFile) -> Option < f64 > { if note_stats . note_count == 0 { return Some (0.0) ; } let mut score = 0.0 ; let duration_est = calculate_total_ticks (midi_file) as f64 / (midi_file . header . ticks_per_quarter_note as f64 * 2.0) ; if duration_est > 0.0 { let note_density = note_stats . note_count as f64 / duration_est ; score += (note_density / 10.0) . min (30.0) ; } if let Some (semitones) = note_stats . pitch_range_semitones { score += (semitones as f64 / 2.0) . min (20.0) ; } if let Some (polyphony) = note_stats . polyphony_max { score += (polyphony as f64 * 5.0) . min (25.0) ; } let track_count = midi_file . tracks . len () as f64 ; score += (track_count * 2.0) . min (15.0) ; if let (Some (low) , Some (high)) = (note_stats . velocity_range_low , note_stats . velocity_range_high ,) { let velocity_range = (high - low) as f64 ; score += (velocity_range / 10.0) . min (10.0) ; } Some (score . min (100.0)) }

- [ ] **Function 'cleanup_temp_dir' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/archive_import.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Helper function to cleanup temp directories with proper error logging"] fn cleanup_temp_dir (path : & Path) { if let Err (e) = std :: fs :: remove_dir_all (path) { eprintln ! ("WARNING: Failed to cleanup temp directory {}: {}" , path . display () , e) ; eprintln ! ("  This may lead to disk space accumulation - manual cleanup may be required") ; } }

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/archive_import.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/archive_import.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/archive_import.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/archive_import.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/archive_import.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/file_import.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/file_import.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/file_import.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/file_import.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/file_import.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/file_import.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/file_import.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/file_import.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/file_import.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/file_import.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/file_import.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/file_import.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/file_import.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/file_import.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/file_import.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/file_import.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/file_import.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/file_import.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/file_import.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/file_import.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/file_import.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/file_import.rs`
  - Category: Performance

- [ ] **Function 'extract_instrument_names' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/file_import.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Extract instrument names from MIDI file for tag extraction"] fn extract_instrument_names (midi : & midi_library_shared :: core :: midi :: types :: MidiFile ,) -> Vec < String > { use midi_library_shared :: core :: midi :: types :: { Event , TextType } ; let mut instruments = Vec :: new () ; for track in & midi . tracks { for timed_event in & track . events { match & timed_event . event { Event :: Text { text_type , text } => { if matches ! (text_type , TextType :: InstrumentName | TextType :: TrackName) { instruments . push (text . clone ()) ; } } , Event :: ProgramChange { program , .. } => { if let Some (instrument_name) = program_to_instrument_name (* program) { instruments . push (instrument_name) ; } } , _ => { } , } } } instruments }

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/file_import.rs`
  - Category: Performance

- [ ] **Function 'extract_time_signature' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/file_import.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Extract time signature from MIDI file events"] # [doc = " Returns format like \"4-4\" for 4/4 time, or None if not found"] fn extract_time_signature (midi : & midi_library_shared :: core :: midi :: types :: MidiFile ,) -> Option < String > { use midi_library_shared :: core :: midi :: types :: Event ; for track in & midi . tracks { for timed_event in & track . events { if let Event :: TimeSignature { numerator , denominator , .. } = & timed_event . event { let denom_value = 2_u8 . pow (* denominator as u32) ; return Some (format ! ("{}-{}" , numerator , denom_value)) ; } } } None }

- [ ] **Function 'program_to_instrument_name' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/file_import.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Map MIDI General MIDI program number to instrument name"] fn program_to_instrument_name (program : u8) -> Option < String > { match program { 0 ..= 7 => Some ("Piano" . to_string ()) , 8 ..= 15 => Some ("Keys" . to_string ()) , 16 ..= 23 => Some ("Organ" . to_string ()) , 24 ..= 31 => Some ("Guitar" . to_string ()) , 32 ..= 39 => Some ("Bass" . to_string ()) , 40 ..= 47 => Some ("Strings" . to_string ()) , 48 ..= 55 => Some ("Ensemble" . to_string ()) , 56 ..= 63 => Some ("Brass" . to_string ()) , 64 ..= 71 => Some ("Woodwind" . to_string ()) , 72 ..= 79 => Some ("Flute" . to_string ()) , 80 ..= 87 => Some ("Lead" . to_string ()) , 88 ..= 95 => Some ("Pad" . to_string ()) , 96 ..= 103 => Some ("FX" . to_string ()) , 104 ..= 111 => Some ("Ethnic" . to_string ()) , 112 ..= 119 => Some ("Percussion" . to_string ()) , 120 ..= 127 => Some ("FX" . to_string ()) , _ => None , } }

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/file_import.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/file_import.rs`
  - Category: Performance

- [ ] **Function 'find_midi_files_recursive' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/file_import.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Recursively collect all MIDI files in a directory"] fn find_midi_files_recursive (dir : & Path) -> Result < Vec < PathBuf > , std :: io :: Error > { let mut files = Vec :: new () ; for entry in std :: fs :: read_dir (dir) ? { let entry = entry ? ; let path = entry . path () ; if path . is_dir () { match find_midi_files_recursive (& path) { Ok (subfiles) => files . extend (subfiles) , Err (e) => { eprintln ! ("Warning: Failed to read directory {}: {}" , path . display () , e) ; } , } } else if is_midi_file (& path) { files . push (path) ; } } Ok (files) }

- [ ] **Function 'find_midi_files_shallow' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/file_import.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Finds MIDI files in directory (non-recursive)"] fn find_midi_files_shallow (dir : & Path) -> Result < Vec < PathBuf > , std :: io :: Error > { let mut files = Vec :: new () ; for entry in std :: fs :: read_dir (dir) ? { let entry = entry ? ; let path = entry . path () ; if path . is_file () && is_midi_file (& path) { files . push (path) ; } } Ok (files) }

- [ ] **Function 'is_midi_file' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/file_import.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Check if a file is a MIDI file based on extension"] fn is_midi_file (path : & Path) -> bool { path . extension () . and_then (| ext | ext . to_str ()) . map (| ext | ext . eq_ignore_ascii_case ("mid") || ext . eq_ignore_ascii_case ("midi")) . unwrap_or (false) }

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/progress.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/progress.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/split_file.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/split_file.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/split_file.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/split_file.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/split_file.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/split_file.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/split_file.rs`
  - Category: Performance

- [ ] **Function 'generate_split_filename' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/split_file.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Generate a filename for a split track based on metadata."] # [doc = ""] # [doc = " Format: `{base}_track_{num:02}_{instrument}.mid`"] # [doc = ""] # [doc = " If instrument is not available, uses track name. If neither available,"] # [doc = " uses just track number."] # [doc = ""] # [doc = " Sanitizes all components to ensure valid filenames."] # [doc = ""] # [doc = " # Arguments"] # [doc = ""] # [doc = " * `base_filename` - Base filename from the parent file (without extension)"] # [doc = " * `split_track` - Metadata about the split track"] # [doc = ""] # [doc = " # Returns"] # [doc = ""] # [doc = " Sanitized filename with .mid extension"] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " ```"] # [doc = " use pipeline::commands::split_file::generate_split_filename;"] # [doc = " use pipeline::core::splitting::track_splitter::SplitTrack;"] # [doc = ""] # [doc = " let track = SplitTrack {"] # [doc = "     track_number: 1,"] # [doc = "     track_name: Some(\"Piano\".to_string()),"] # [doc = "     channel: Some(0),"] # [doc = "     instrument: Some(\"Acoustic Grand Piano\".to_string()),"] # [doc = "     note_count: 100,"] # [doc = "     midi_bytes: vec![],"] # [doc = " };"] # [doc = ""] # [doc = " let filename = generate_split_filename(\"my_song\", &track);"] # [doc = " assert_eq!(filename, \"my_song_track_01_Acoustic_Grand_Piano.mid\");"] # [doc = " ```"] pub fn generate_split_filename (base_filename : & str , split_track : & SplitTrack) -> String { let base = sanitize_filename (base_filename) ; let track_num = format ! ("{:02}" , split_track . track_number) ; let suffix = if let Some (ref instrument) = split_track . instrument { sanitize_filename (instrument) } else if let Some (ref track_name) = split_track . track_name { sanitize_filename (track_name) } else { String :: new () } ; if suffix . is_empty () { format ! ("{}_track_{}.mid" , base , track_num) } else { format ! ("{}_track_{}_{}.mid" , base , track_num , suffix) } }

- [ ] **Function 'sanitize_filename' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/split_file.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Sanitize a string to be used as a filename component."] # [doc = ""] # [doc = " Removes or replaces problematic characters:"] # [doc = " - Replaces spaces with underscores"] # [doc = " - Removes: / \\ : * ? \" < > | (filesystem-unsafe characters)"] # [doc = " - Removes: control characters, non-ASCII if problematic"] # [doc = " - Collapses multiple underscores to single underscore"] # [doc = " - Trims underscores from start and end"] # [doc = ""] # [doc = " # Arguments"] # [doc = ""] # [doc = " * `name` - String to sanitize"] # [doc = ""] # [doc = " # Returns"] # [doc = ""] # [doc = " Sanitized string safe for use in filenames"] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " ```"] # [doc = " use pipeline::commands::split_file::sanitize_filename;"] # [doc = ""] # [doc = " assert_eq!(sanitize_filename(\"Piano Track\"), \"Piano_Track\");"] # [doc = " assert_eq!(sanitize_filename(\"Track: 1 (Lead)\"), \"Track_1_Lead\");"] # [doc = " assert_eq!(sanitize_filename(\"Bass/Guitar\"), \"BassGuitar\");"] # [doc = " assert_eq!(sanitize_filename(\"  Piano  \"), \"Piano\");"] # [doc = " ```"] pub fn sanitize_filename (name : & str) -> String { name . chars () . map (| c | match c { ' ' => '_' , '/' | '\\' | ':' | '*' | '?' | '"' | '<' | '>' | '|' => '_' , c if c . is_alphanumeric () || c == '_' || c == '-' || c == '.' || c == '(' || c == ')' => c , _ => '_' , }) . collect :: < String > () . split ('_') . filter (| s | ! s . is_empty ()) . collect :: < Vec < _ > > () . join ("_") }

- [ ] **Function 'extract_time_signature_from_midi' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/commands/split_file.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Extract time signature from MIDI file events"] # [doc = " Returns format like \"4-4\" for 4/4 time, or None if not found"] fn extract_time_signature_from_midi (midi : & midi_library_shared :: core :: midi :: types :: MidiFile ,) -> Option < String > { use midi_library_shared :: core :: midi :: types :: Event ; for track in & midi . tracks { for timed_event in & track . events { if let Event :: TimeSignature { numerator , denominator , .. } = & timed_event . event { let denom_value = 2_u8 . pow (* denominator as u32) ; return Some (format ! ("{}-{}" , numerator , denom_value)) ; } } } None }

- [ ] **Function 'create_minimal_midi' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/arena_midi.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn create_minimal_midi () -> Vec < u8 > { vec ! [b'M' , b'T' , b'h' , b'd' , 0 , 0 , 0 , 6 , 0 , 0 , 0 , 1 , 0 , 96 , b'M' , b'T' , b'r' , b'k' , 0 , 0 , 0 , 4 , 0x00 , 0xFF , 0x2F , 0x00 ,] }

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/auto_tagger.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/auto_tagger.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/auto_tagger.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/auto_tagger.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/auto_tagger.rs`
  - Category: Performance

- [ ] **Function 'detect_bpm' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/bpm_detector.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Detects BPM from a parsed MIDI file using tempo events"] # [doc = ""] # [doc = " This is the legacy tempo-event-based detection. For SIMD-accelerated"] # [doc = " onset detection, use `detect_bpm_with_onsets` or `detect_bpm_hybrid`."] # [doc = ""] # [doc = " # Arguments"] # [doc = " * `midi_file` - Parsed MIDI file structure"] # [doc = ""] # [doc = " # Returns"] # [doc = " * `BpmDetectionResult` - Detection result with confidence and metadata"] # [doc = ""] # [doc = " # Examples"] # [doc = " ```no_run"] # [doc = " use pipeline::core::analysis::bpm_detector::detect_bpm;"] # [doc = " use pipeline::core::midi::types::MidiFile;"] # [doc = ""] # [doc = " # fn example() -> Result<(), Box<dyn std::error::Error>> {"] # [doc = " # let midi_file = MidiFile {"] # [doc = " #     header: pipeline::core::midi::types::Header {"] # [doc = " #         format: 1,"] # [doc = " #         num_tracks: 1,"] # [doc = " #         ticks_per_quarter_note: 480,"] # [doc = " #     },"] # [doc = " #     tracks: vec![],"] # [doc = " # };"] # [doc = " let result = detect_bpm(&midi_file);"] # [doc = " println!(\"Detected BPM: {:.2}\", result.bpm);"] # [doc = " # Ok(())"] # [doc = " # }"] # [doc = " ```"] pub fn detect_bpm (midi_file : & MidiFile) -> BpmDetectionResult { let tempo_events = extract_tempo_events (midi_file) ; if tempo_events . is_empty () { return BpmDetectionResult { bpm : DEFAULT_BPM , confidence : 0.3 , method : BpmDetectionMethod :: DefaultTempo , metadata : BpmMetadata { tempo_changes : vec ! [] , is_constant : true , tempo_range : None } , onset_result : None , } ; } let tempo_changes : Vec < TempoChange > = tempo_events . into_iter () . map (| (tick , microseconds_per_quarter) | TempoChange { tick , bpm : microseconds_to_bpm (microseconds_per_quarter) , }) . collect () ; let is_constant = tempo_changes . len () == 1 ; let bpms : Vec < f64 > = tempo_changes . iter () . map (| tc | tc . bpm) . collect () ; let total_ticks = calculate_total_ticks (midi_file) ; let avg_bpm = calculate_weighted_average (& tempo_changes , total_ticks) ; let tempo_range = if tempo_changes . len () > 1 { let min = bpms . iter () . cloned () . fold (f64 :: INFINITY , f64 :: min) ; let max = bpms . iter () . cloned () . fold (f64 :: NEG_INFINITY , f64 :: max) ; Some ((min , max)) } else { None } ; let confidence = calculate_confidence (& tempo_changes) ; let method = if tempo_changes . len () == 1 { BpmDetectionMethod :: SingleTempo } else { BpmDetectionMethod :: WeightedAverage } ; BpmDetectionResult { bpm : avg_bpm , confidence , method , metadata : BpmMetadata { tempo_changes , is_constant , tempo_range } , onset_result : None , } }

- [ ] **Function 'detect_bpm_with_onsets' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/bpm_detector.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Detects BPM using SIMD-accelerated onset detection only"] # [doc = ""] # [doc = " This function uses SIMD-optimized onset detection to analyze rhythmic patterns"] # [doc = " and calculate BPM. It's faster than tempo-event analysis and works even when"] # [doc = " no tempo events are present in the MIDI file."] # [doc = ""] # [doc = " # Arguments"] # [doc = " * `midi_file` - Parsed MIDI file structure"] # [doc = ""] # [doc = " # Returns"] # [doc = " * `Option<BpmDetectionResult>` - Detection result, or None if insufficient onsets"] # [doc = ""] # [doc = " # Performance"] # [doc = " - Uses SIMD vectorization for 2-4x speedup"] # [doc = " - Processes 32 velocities per SIMD operation"] # [doc = " - Optimized for files with many note events"] # [doc = ""] # [doc = " # Examples"] # [doc = " ```no_run"] # [doc = " use pipeline::core::analysis::bpm_detector::detect_bpm_with_onsets;"] # [doc = " use midi_library_shared::core::midi::types::MidiFile;"] # [doc = ""] # [doc = " # fn example(midi_file: MidiFile) -> Result<(), Box<dyn std::error::Error>> {"] # [doc = " if let Some(result) = detect_bpm_with_onsets(&midi_file) {"] # [doc = "     println!(\"Onset-based BPM: {:.2} (confidence: {:.2})\", result.bpm, result.confidence);"] # [doc = " }"] # [doc = " # Ok(())"] # [doc = " # }"] # [doc = " ```"] pub fn detect_bpm_with_onsets (midi_file : & MidiFile) -> Option < BpmDetectionResult > { let onset_result = detect_bpm_from_onsets (midi_file) ? ; Some (BpmDetectionResult { bpm : onset_result . bpm , confidence : onset_result . confidence , method : BpmDetectionMethod :: OnsetDetection , metadata : BpmMetadata { tempo_changes : vec ! [] , is_constant : false , tempo_range : None } , onset_result : Some (onset_result) , }) }

- [ ] **Function 'detect_bpm_hybrid' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/bpm_detector.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Hybrid BPM detection combining tempo events and SIMD onset analysis"] # [doc = ""] # [doc = " This function uses both tempo event analysis and SIMD-accelerated onset detection,"] # [doc = " then combines the results using weighted averaging based on confidence scores."] # [doc = " This provides the most robust BPM detection across different MIDI file types."] # [doc = ""] # [doc = " # Arguments"] # [doc = " * `midi_file` - Parsed MIDI file structure"] # [doc = ""] # [doc = " # Returns"] # [doc = " * `BpmDetectionResult` - Combined detection result with highest confidence"] # [doc = ""] # [doc = " # Strategy"] # [doc = " - If tempo events exist with high confidence: use tempo-based BPM"] # [doc = " - If onsets detected with high confidence: use onset-based BPM"] # [doc = " - If both available: weighted average based on confidence scores"] # [doc = " - Fallback to default if neither method succeeds"] # [doc = ""] # [doc = " # Performance"] # [doc = " - SIMD-optimized onset detection: 2-4x speedup"] # [doc = " - Minimal overhead when combining methods"] # [doc = ""] # [doc = " # Examples"] # [doc = " ```no_run"] # [doc = " use pipeline::core::analysis::bpm_detector::detect_bpm_hybrid;"] # [doc = " use midi_library_shared::core::midi::types::MidiFile;"] # [doc = ""] # [doc = " # fn example(midi_file: MidiFile) -> Result<(), Box<dyn std::error::Error>> {"] # [doc = " let result = detect_bpm_hybrid(&midi_file);"] # [doc = " println!(\"Hybrid BPM: {:.2} (confidence: {:.2})\", result.bpm, result.confidence);"] # [doc = " # Ok(())"] # [doc = " # }"] # [doc = " ```"] pub fn detect_bpm_hybrid (midi_file : & MidiFile) -> BpmDetectionResult { let tempo_result = detect_bpm (midi_file) ; let onset_result_opt = detect_bpm_from_onsets (midi_file) ; match onset_result_opt { Some (onset_result) => { let tempo_confidence = tempo_result . confidence ; let onset_confidence = onset_result . confidence ; if matches ! (tempo_result . method , BpmDetectionMethod :: DefaultTempo) { return BpmDetectionResult { bpm : onset_result . bpm , confidence : onset_result . confidence , method : BpmDetectionMethod :: OnsetDetection , metadata : tempo_result . metadata , onset_result : Some (onset_result) , } ; } let total_confidence = tempo_confidence + onset_confidence ; let weighted_bpm = if total_confidence > 0.0 { (tempo_result . bpm * tempo_confidence + onset_result . bpm * onset_confidence) / total_confidence } else { (tempo_result . bpm + onset_result . bpm) / 2.0 } ; let combined_confidence = tempo_confidence . max (onset_confidence) ; BpmDetectionResult { bpm : weighted_bpm . clamp (MIN_BPM , MAX_BPM) , confidence : combined_confidence , method : BpmDetectionMethod :: Hybrid , metadata : tempo_result . metadata , onset_result : Some (onset_result) , } } , None => { tempo_result } , } }

- [ ] **Function 'extract_tempo_events' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/bpm_detector.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Extracts tempo events from all tracks in the MIDI file"] fn extract_tempo_events (midi_file : & MidiFile) -> Vec < (u32 , u32) > { let mut tempo_events = Vec :: new () ; for track in & midi_file . tracks { let mut current_tick = 0u32 ; for timed_event in & track . events { current_tick += timed_event . delta_ticks ; if let Event :: TempoChange { microseconds_per_quarter } = timed_event . event { tempo_events . push ((current_tick , microseconds_per_quarter)) ; } } } tempo_events . sort_by_key (| (tick , _) | * tick) ; tempo_events }

- [ ] **Function 'calculate_total_ticks' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/bpm_detector.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Calculates the total number of ticks in the MIDI file"] fn calculate_total_ticks (midi_file : & MidiFile) -> u32 { let mut max_ticks = 0u32 ; for track in & midi_file . tracks { let mut track_ticks = 0u32 ; for timed_event in & track . events { track_ticks += timed_event . delta_ticks ; } max_ticks = max_ticks . max (track_ticks) ; } max_ticks }

- [ ] **Function 'microseconds_to_bpm' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/bpm_detector.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Converts microseconds per quarter note to BPM"] fn microseconds_to_bpm (microseconds_per_quarter : u32) -> f64 { let bpm = 60_000_000.0 / microseconds_per_quarter as f64 ; bpm . clamp (MIN_BPM , MAX_BPM) }

- [ ] **Function 'calculate_weighted_average' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/bpm_detector.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Calculates weighted average BPM based on duration each tempo is active"] fn calculate_weighted_average (tempo_changes : & [TempoChange] , total_ticks : u32) -> f64 { if tempo_changes . is_empty () { return DEFAULT_BPM ; } if tempo_changes . len () == 1 { return tempo_changes [0] . bpm ; } let mut weighted_sum = 0.0 ; let mut total_weight = 0.0 ; for (i , tempo_change) in tempo_changes . iter () . enumerate () { let duration = if i + 1 < tempo_changes . len () { tempo_changes [i + 1] . tick - tempo_change . tick } else { total_ticks . saturating_sub (tempo_change . tick) } ; let weight = duration as f64 ; weighted_sum += tempo_change . bpm * weight ; total_weight += weight ; } if total_weight > 0.0 { weighted_sum / total_weight } else { tempo_changes [0] . bpm } }

- [ ] **Function 'calculate_confidence' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/bpm_detector.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Calculates confidence score based on tempo consistency"] fn calculate_confidence (tempo_changes : & [TempoChange]) -> f64 { if tempo_changes . is_empty () { return 0.3 ; } if tempo_changes . len () == 1 { return 1.0 ; } let bpms : Vec < f64 > = tempo_changes . iter () . map (| tc | tc . bpm) . collect () ; let mean = bpms . iter () . sum :: < f64 > () / bpms . len () as f64 ; let variance = bpms . iter () . map (| bpm | (bpm - mean) . powi (2)) . sum :: < f64 > () / bpms . len () as f64 ; let std_dev = variance . sqrt () ; let cv = std_dev / mean ; (1.0 - cv) . clamp (0.5 , 1.0) }

- [ ] **Function 'analyze_chords' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/chord_analyzer.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Main chord analysis function"] pub fn analyze_chords (midi_file : & MidiFile , ticks_per_quarter : u32) -> ChordAnalysis { let note_events = extract_note_events (midi_file) ; if note_events . is_empty () { return ChordAnalysis { progression : Vec :: new () , types : Vec :: new () , has_sevenths : false , has_extended : false , change_rate : None , complexity_score : 0.0 , } ; } let window_size = ticks_per_quarter / 2 ; let chords = detect_chords_in_windows (& note_events , window_size) ; let progression : Vec < String > = chords . iter () . map (| c | c . name . clone ()) . collect () ; let types : Vec < String > = chords . iter () . map (| c | c . chord_type . clone ()) . collect () ; let has_sevenths = chords . iter () . any (| c | c . is_seventh) ; let has_extended = chords . iter () . any (| c | c . is_extended) ; let ticks_per_measure = ticks_per_quarter * 4 ; let total_ticks = note_events . last () . map (| (t , _ , _) | * t) . unwrap_or (0) ; let total_measures = if total_ticks > 0 { (total_ticks as f32 / ticks_per_measure as f32) . max (1.0) } else { 1.0 } ; let change_rate = if chords . len () > 1 { Some (chords . len () as f32 / total_measures) } else { None } ; let complexity_score = calculate_complexity (& chords) ; ChordAnalysis { progression , types , has_sevenths , has_extended , change_rate , complexity_score } }

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/chord_analyzer.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/chord_analyzer.rs`
  - Category: Performance

- [ ] **Function 'extract_note_events' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/chord_analyzer.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Extract all note-on events with timing and channel"] fn extract_note_events (midi_file : & MidiFile) -> Vec < (u32 , u8 , u8) > { let mut events = Vec :: new () ; let mut cumulative_tick = 0u32 ; for track in & midi_file . tracks { let mut track_tick = 0u32 ; for event in & track . events { track_tick += event . delta_ticks ; match & event . event { Event :: NoteOn { channel , note , velocity } if * velocity > 0 => { events . push ((track_tick , * note , * channel)) ; } , _ => { } , } } cumulative_tick = cumulative_tick . max (track_tick) ; } events . sort_by_key (| (tick , _ , _) | * tick) ; events }

- [ ] **Function 'detect_chords_in_windows' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/chord_analyzer.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Group notes into time windows and detect chords"] fn detect_chords_in_windows (note_events : & [(u32 , u8 , u8)] , window_size : u32) -> Vec < DetectedChord > { let mut chords : Vec < DetectedChord > = Vec :: new () ; let mut current_window_start = 0u32 ; let mut current_notes = Vec :: new () ; for (tick , note , channel) in note_events { if * channel == 9 { continue ; } while * tick >= current_window_start + window_size { if current_notes . len () >= 3 { if let Some (chord) = identify_chord (& current_notes) { if chords . is_empty () || chords . last () . unwrap () . name != chord . name { chords . push (chord) ; } } } current_notes . clear () ; current_window_start += window_size ; } current_notes . push (* note) ; } if current_notes . len () >= 3 { if let Some (chord) = identify_chord (& current_notes) { if chords . is_empty () || chords . last () . unwrap () . name != chord . name { chords . push (chord) ; } } } chords }

- [ ] **Function 'identify_chord' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/chord_analyzer.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Identify chord from a collection of MIDI notes"] fn identify_chord (notes : & [u8]) -> Option < DetectedChord > { if notes . len () < 3 { return None ; } let unique_notes : Vec < u8 > = { let set : HashSet < u8 > = notes . iter () . map (| n | n % 12) . collect () ; let mut vec : Vec < u8 > = set . into_iter () . collect () ; vec . sort () ; vec } ; if unique_notes . len () < 3 { return None ; } match identify_chord_type (& unique_notes) { Some ((root , chord_type , is_seventh , is_extended)) => { let name = format ! ("{}{}" , root , chord_type) ; Some (DetectedChord { tick : 0 , notes : notes . to_vec () , name , chord_type , is_seventh , is_extended , }) } , None => None , } }

- [ ] **Function 'identify_chord_type' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/chord_analyzer.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Identify chord type from pitch classes"] fn identify_chord_type (pitch_classes : & [u8]) -> Option < (String , String , bool , bool) > { if pitch_classes . len () < 3 { return None ; } let root = pitch_classes [0] ; let root_name = note_name_from_pitch (root) ; let intervals : Vec < u8 > = pitch_classes . iter () . map (| & p | (p + 12 - root) % 12) . collect () ; let (chord_type , is_seventh , is_extended) = match intervals . as_slice () { [0 , 4 , 7] => ("" . to_string () , false , false) , [0 , 3 , 7] => ("m" . to_string () , false , false) , [0 , 3 , 6] => ("dim" . to_string () , false , false) , [0 , 4 , 8] => ("aug" . to_string () , false , false) , [0 , 4 , 7 , 11] => ("maj7" . to_string () , true , false) , [0 , 3 , 7 , 10] => ("m7" . to_string () , true , false) , [0 , 4 , 7 , 10] => ("7" . to_string () , true , false) , [0 , 3 , 6 , 9] => ("dim7" . to_string () , true , false) , [0 , 3 , 6 , 10] => ("m7b5" . to_string () , true , false) , [0 , 4 , 7 , 11 , 2] | [0 , 2 , 4 , 7 , 11] => ("maj9" . to_string () , true , true) , [0 , 3 , 7 , 10 , 2] | [0 , 2 , 3 , 7 , 10] => ("m9" . to_string () , true , true) , [0 , 4 , 7 , 10 , 2] | [0 , 2 , 4 , 7 , 10] => ("9" . to_string () , true , true) , _ => { let has_major_third = intervals . contains (& 4) ; let has_minor_third = intervals . contains (& 3) ; let has_seventh = intervals . contains (& 10) || intervals . contains (& 11) ; let has_ninth = intervals . contains (& 2) ; let has_eleventh = intervals . contains (& 5) ; let has_thirteenth = intervals . contains (& 9) ; let quality = if has_major_third { "" . to_string () } else if has_minor_third { "m" . to_string () } else { return None ; } ; let is_extended = has_ninth || has_eleventh || has_thirteenth ; (quality , has_seventh , is_extended) } , } ; Some ((root_name , chord_type , is_seventh , is_extended)) }

- [ ] **Function 'note_name_from_pitch' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/chord_analyzer.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Convert MIDI pitch (0-11) to note name"] fn note_name_from_pitch (pitch : u8) -> String { let names = ["C" , "C#" , "D" , "D#" , "E" , "F" , "F#" , "G" , "G#" , "A" , "A#" , "B"] ; names [(pitch % 12) as usize] . to_string () }

- [ ] **Function 'calculate_complexity' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/chord_analyzer.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Calculate complexity score based on chord types"] fn calculate_complexity (chords : & [DetectedChord]) -> f32 { if chords . is_empty () { return 0.0 ; } let mut total_score = 0.0 ; for chord in chords { let score = if chord . is_extended { 1.0 } else if chord . is_seventh { 0.6 } else { 0.3 } ; total_score += score ; } (total_score / chords . len () as f32) . min (1.0) }

- [ ] **Function 'analyze_drum_midi' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/drum_analyzer.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Analyze MIDI file for drum-specific characteristics"] # [doc = ""] # [doc = " **Trusty Module**: Pure function, no I/O, no side effects"] pub fn analyze_drum_midi (midi_file : & MidiFile) -> DrumAnalysis { let drum_channel_detected = has_drum_channel (midi_file) ; let drum_notes = extract_drum_notes (midi_file) ; let cymbal_types = detect_cymbal_types (& drum_notes) ; let time_signature = extract_time_signature_from_meta (midi_file) ; let techniques = detect_techniques (midi_file , & drum_notes) ; DrumAnalysis { is_drum_file : drum_channel_detected || ! drum_notes . is_empty () , drum_channel_detected , drum_notes , pattern_type : None , rhythmic_feel : None , time_signature , bpm : None , cymbal_types , techniques , song_structure : None , } }

- [ ] **Function 'has_drum_channel' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/drum_analyzer.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Check if MIDI file uses channel 10 (GM drum channel)"] # [doc = ""] # [doc = " **Trusty Module**: Pure function"] pub fn has_drum_channel (midi_file : & MidiFile) -> bool { for track in & midi_file . tracks { for timed_event in & track . events { match timed_event . event { Event :: NoteOn { channel , .. } | Event :: NoteOff { channel , .. } => { if channel == 9 { return true ; } } , _ => { } , } } } false }

- [ ] **Function 'extract_drum_notes' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/drum_analyzer.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Extract all GM drum notes and their frequencies"] # [doc = ""] # [doc = " **Trusty Module**: Pure function"] pub fn extract_drum_notes (midi_file : & MidiFile) -> HashMap < DrumNote , usize > { let mut note_counts = HashMap :: new () ; for track in & midi_file . tracks { for timed_event in & track . events { if let Event :: NoteOn { channel , note , velocity } = timed_event . event { if (channel == 9 || (35 ..= 81) . contains (& note)) && velocity > 0 { if let Some (drum_note) = note_to_drum_type (note) { * note_counts . entry (drum_note) . or_insert (0) += 1 ; } } } } } note_counts }

- [ ] **Function 'note_to_drum_type' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/drum_analyzer.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Map MIDI note number to GM drum type"] # [doc = ""] # [doc = " **Trusty Module**: Pure function"] pub fn note_to_drum_type (note : u8) -> Option < DrumNote > { match note { 35 => Some (DrumNote :: AcousticBassDrum) , 36 => Some (DrumNote :: BassDrum1) , 37 => Some (DrumNote :: SideStick) , 38 => Some (DrumNote :: AcousticSnare) , 39 => Some (DrumNote :: HandClap) , 40 => Some (DrumNote :: ElectricSnare) , 41 => Some (DrumNote :: LowFloorTom) , 42 => Some (DrumNote :: ClosedHiHat) , 43 => Some (DrumNote :: HighFloorTom) , 44 => Some (DrumNote :: PedalHiHat) , 45 => Some (DrumNote :: LowTom) , 46 => Some (DrumNote :: OpenHiHat) , 47 => Some (DrumNote :: LowMidTom) , 48 => Some (DrumNote :: HighMidTom) , 49 => Some (DrumNote :: CrashCymbal1) , 50 => Some (DrumNote :: HighTom) , 51 => Some (DrumNote :: RideCymbal1) , 52 => Some (DrumNote :: ChineseCymbal) , 53 => Some (DrumNote :: RideBell) , 54 => Some (DrumNote :: Tambourine) , 55 => Some (DrumNote :: SplashCymbal) , 56 => Some (DrumNote :: Cowbell) , 57 => Some (DrumNote :: CrashCymbal2) , 59 => Some (DrumNote :: RideCymbal2) , 60 => Some (DrumNote :: HighBongo) , 61 => Some (DrumNote :: LowBongo) , 62 => Some (DrumNote :: MuteHighConga) , 63 => Some (DrumNote :: OpenHighConga) , 64 => Some (DrumNote :: LowConga) , 65 => Some (DrumNote :: HighTimbale) , 66 => Some (DrumNote :: LowTimbale) , 67 => Some (DrumNote :: HighAgogo) , 68 => Some (DrumNote :: LowAgogo) , 69 => Some (DrumNote :: Cabasa) , 70 => Some (DrumNote :: Maracas) , 71 => Some (DrumNote :: ShortWhistle) , 72 => Some (DrumNote :: LongWhistle) , 73 => Some (DrumNote :: ShortGuiro) , 74 => Some (DrumNote :: LongGuiro) , 75 => Some (DrumNote :: Claves) , 76 => Some (DrumNote :: HighWoodBlock) , 77 => Some (DrumNote :: LowWoodBlock) , 78 => Some (DrumNote :: MuteCuica) , 79 => Some (DrumNote :: OpenCuica) , 80 => Some (DrumNote :: MuteTriangle) , 81 => Some (DrumNote :: OpenTriangle) , _ => None , } }

- [ ] **Function 'detect_cymbal_types' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/drum_analyzer.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Detect cymbal types from drum notes"] # [doc = ""] # [doc = " **Trusty Module**: Pure function"] pub fn detect_cymbal_types (drum_notes : & HashMap < DrumNote , usize >) -> Vec < CymbalType > { let mut cymbals = Vec :: new () ; if drum_notes . contains_key (& DrumNote :: ClosedHiHat) { cymbals . push (CymbalType :: ClosedHat) ; } if drum_notes . contains_key (& DrumNote :: PedalHiHat) { cymbals . push (CymbalType :: PedalHat) ; } if drum_notes . contains_key (& DrumNote :: OpenHiHat) { cymbals . push (CymbalType :: OpenHat) ; } if drum_notes . contains_key (& DrumNote :: RideCymbal1) || drum_notes . contains_key (& DrumNote :: RideCymbal2) { cymbals . push (CymbalType :: Ride) ; } if drum_notes . contains_key (& DrumNote :: RideBell) { cymbals . push (CymbalType :: RideBell) ; } if drum_notes . contains_key (& DrumNote :: CrashCymbal1) || drum_notes . contains_key (& DrumNote :: CrashCymbal2) { cymbals . push (CymbalType :: Crash) ; } if drum_notes . contains_key (& DrumNote :: ChineseCymbal) { cymbals . push (CymbalType :: China) ; } if drum_notes . contains_key (& DrumNote :: SplashCymbal) { cymbals . push (CymbalType :: Splash) ; } cymbals }

- [ ] **Function 'extract_time_signature_from_meta' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/drum_analyzer.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Extract time signature from MIDI meta events"] # [doc = ""] # [doc = " **Trusty Module**: Pure function"] pub fn extract_time_signature_from_meta (midi_file : & MidiFile) -> Option < TimeSignature > { for track in & midi_file . tracks { for timed_event in & track . events { if let Event :: TimeSignature { numerator , denominator , .. } = timed_event . event { return Some (TimeSignature { numerator , denominator : 2u8 . saturating_pow (denominator as u32) , }) ; } } } None }

- [ ] **Function 'detect_techniques' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/drum_analyzer.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Detect drum techniques from note patterns"] # [doc = ""] # [doc = " **Trusty Module**: Pure function"] pub fn detect_techniques (midi_file : & MidiFile , drum_notes : & HashMap < DrumNote , usize > ,) -> Vec < DrumTechnique > { let mut techniques = Vec :: new () ; if has_ghost_notes (midi_file) { techniques . push (DrumTechnique :: GhostNotes) ; } let kick_count_1 = drum_notes . get (& DrumNote :: BassDrum1) . copied () . unwrap_or (0) ; let kick_count_2 = drum_notes . get (& DrumNote :: AcousticBassDrum) . copied () . unwrap_or (0) ; let kick_count = kick_count_1 + kick_count_2 ; if kick_count > 100 { techniques . push (DrumTechnique :: DoubleBass) ; } techniques }

- [ ] **Function 'has_ghost_notes' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/drum_analyzer.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Check for ghost notes (low-velocity snare hits)"] # [doc = ""] # [doc = " **Trusty Module**: Pure function"] fn has_ghost_notes (midi_file : & MidiFile) -> bool { let mut ghost_count = 0 ; let mut total_snare = 0 ; for track in & midi_file . tracks { for timed_event in & track . events { if let Event :: NoteOn { note , velocity , .. } = timed_event . event { if note == 38 || note == 40 { total_snare += 1 ; if velocity > 0 && velocity < 40 { ghost_count += 1 ; } } } } } total_snare > 0 && (ghost_count as f64 / total_snare as f64) >= 0.3 }

- [ ] **Function 'extract_time_signature_from_path' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/drum_analyzer.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Extract time signature from filename or path"] # [doc = ""] # [doc = " **Trusty Module**: Pure function"] # [doc = ""] # [doc = " Patterns:"] # [doc = " - \"9-8 Straight Kick.mid\""] # [doc = " - \"Jazz Parts 2/12-8 Swing/...\""] # [doc = " - \"6-8_groove.mid\""] pub fn extract_time_signature_from_path (file_path : & str , file_name : & str) -> Option < TimeSignature > { let combined = format ! ("{}/{}" , file_path , file_name) ; let patterns = [("12-8" , (12 , 8)) , ("12/8" , (12 , 8)) , ("9-8" , (9 , 8)) , ("9/8" , (9 , 8)) , ("6-8" , (6 , 8)) , ("6/8" , (6 , 8)) , ("7-8" , (7 , 8)) , ("7/8" , (7 , 8)) , ("11-8" , (11 , 8)) , ("11/8" , (11 , 8)) , ("15-8" , (15 , 8)) , ("15/8" , (15 , 8)) , ("7-4" , (7 , 4)) , ("7/4" , (7 , 4)) , ("5-4" , (5 , 4)) , ("5/4" , (5 , 4)) , ("3-4" , (3 , 4)) , ("3/4" , (3 , 4)) , ("4-4" , (4 , 4)) , ("4/4" , (4 , 4)) , ("2-4" , (2 , 4)) , ("2/4" , (2 , 4)) ,] ; for (pattern , (num , denom)) in & patterns { if combined . contains (pattern) { return Some (TimeSignature { numerator : * num , denominator : * denom }) ; } } None }

- [ ] **Function 'extract_bpm_from_filename' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/drum_analyzer.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Extract BPM from filename"] # [doc = ""] # [doc = " **Trusty Module**: Pure function"] # [doc = ""] # [doc = " Patterns:"] # [doc = " - \"174_Gmin_Bass.mid\""] # [doc = " - \"140bpm_Kick.mid\""] # [doc = " - \"120 BPM Groove.mid\""] # [doc = " - \"jazz_136_swing.mid\""] pub fn extract_bpm_from_filename (file_name : & str) -> Option < f64 > { let name_lower = file_name . to_lowercase () ; if let Some (pos) = name_lower . find ("bpm") { let before_bpm = & name_lower [.. pos] . trim () ; if let Some (num_start) = before_bpm . rfind (| c : char | ! c . is_ascii_digit ()) { if let Ok (bpm) = before_bpm [num_start + 1 ..] . parse :: < f64 > () { if (40.0 ..= 220.0) . contains (& bpm) { return Some (bpm) ; } } } } if file_name . len () >= 4 && file_name . chars () . nth (3) == Some ('_') { if let Ok (bpm) = file_name [.. 3] . parse :: < f64 > () { if (40.0 ..= 220.0) . contains (& bpm) { return Some (bpm) ; } } } if file_name . len () >= 4 && file_name . chars () . nth (3) == Some (' ') { if let Ok (bpm) = file_name [.. 3] . parse :: < f64 > () { if (40.0 ..= 220.0) . contains (& bpm) { return Some (bpm) ; } } } for segment in file_name . split ('_') { if segment . len () == 3 && segment . chars () . all (| c | c . is_ascii_digit ()) { if let Ok (bpm) = segment . parse :: < f64 > () { if (40.0 ..= 220.0) . contains (& bpm) { return Some (bpm) ; } } } } None }

- [ ] **Function 'extract_pattern_type' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/drum_analyzer.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Extract pattern type from filename/path"] # [doc = ""] # [doc = " **Trusty Module**: Pure function"] pub fn extract_pattern_type (file_path : & str , file_name : & str) -> Option < PatternType > { let combined = format ! ("{}/{}" , file_path , file_name) . to_lowercase () ; if combined . contains ("groove") || combined . contains (" gr ") { Some (PatternType :: Groove) } else if combined . contains ("fill") { Some (PatternType :: Fill) } else if combined . contains ("intro") { Some (PatternType :: Intro) } else if combined . contains ("ending") || combined . contains ("outro") { Some (PatternType :: Ending) } else if combined . contains ("breakdown") || combined . contains ("bkdn") { Some (PatternType :: Breakdown) } else if combined . contains ("turnaround") || combined . contains (" ta ") { Some (PatternType :: Turnaround) } else if combined . contains ("sequence") || combined . contains (" seq ") { Some (PatternType :: Sequence) } else if combined . contains ("one-shot") || combined . contains ("oneshot") { Some (PatternType :: OneShot) } else { None } }

- [ ] **Function 'extract_rhythmic_feel' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/drum_analyzer.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Extract rhythmic feel from filename/path"] # [doc = ""] # [doc = " **Trusty Module**: Pure function"] pub fn extract_rhythmic_feel (file_path : & str , file_name : & str) -> Option < RhythmicFeel > { let combined = format ! ("{}/{}" , file_path , file_name) . to_lowercase () ; if combined . contains ("swing") { Some (RhythmicFeel :: Swing) } else if combined . contains ("shuffle") { Some (RhythmicFeel :: Shuffle) } else if combined . contains ("straight") { Some (RhythmicFeel :: Straight) } else if combined . contains ("triplet") { Some (RhythmicFeel :: Triplet) } else if combined . contains ("half-time") || combined . contains ("halftime") { Some (RhythmicFeel :: Half) } else if combined . contains ("double-time") || combined . contains ("doubletime") { Some (RhythmicFeel :: Double) } else if combined . contains ("pocket") { Some (RhythmicFeel :: Pocket) } else { None } }

- [ ] **Function 'extract_song_structure' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/drum_analyzer.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Extract song structure from filename/path"] # [doc = ""] # [doc = " **Trusty Module**: Pure function"] pub fn extract_song_structure (file_path : & str , file_name : & str) -> Option < SongStructure > { let combined = format ! ("{}/{}" , file_path , file_name) . to_lowercase () ; if combined . contains ("verse") { Some (SongStructure :: Verse) } else if combined . contains ("chorus") { Some (SongStructure :: Chorus) } else if combined . contains ("bridge") { Some (SongStructure :: Bridge) } else if combined . contains ("intro") { Some (SongStructure :: Intro) } else if combined . contains ("outro") { Some (SongStructure :: Outro) } else if combined . contains ("pre-chorus") || combined . contains ("prechorus") { Some (SongStructure :: PreChorus) } else if combined . contains ("breakdown") { Some (SongStructure :: Breakdown) } else if combined . contains ("turnaround") { Some (SongStructure :: Turnaround) } else if combined . contains ("middle-8") || combined . contains ("mid-8") { Some (SongStructure :: MiddleEight) } else { None } }

- [ ] **Function 'drum_note_to_tag' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/drum_analyzer.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn drum_note_to_tag (drum_note : DrumNote) -> (& 'static str , & 'static str) { match drum_note { DrumNote :: AcousticBassDrum | DrumNote :: BassDrum1 => ("kick" , "instrument") , DrumNote :: AcousticSnare | DrumNote :: ElectricSnare => ("snare" , "instrument") , DrumNote :: ClosedHiHat | DrumNote :: OpenHiHat | DrumNote :: PedalHiHat => { ("hihat" , "instrument") } , DrumNote :: LowFloorTom | DrumNote :: HighFloorTom | DrumNote :: LowTom | DrumNote :: LowMidTom | DrumNote :: HighMidTom | DrumNote :: HighTom => ("toms" , "instrument") , DrumNote :: CrashCymbal1 | DrumNote :: CrashCymbal2 => ("crash" , "instrument") , DrumNote :: RideCymbal1 | DrumNote :: RideCymbal2 => ("ride" , "instrument") , DrumNote :: ChineseCymbal => ("china" , "instrument") , DrumNote :: SplashCymbal => ("splash" , "instrument") , DrumNote :: RideBell => ("ride-bell" , "instrument") , DrumNote :: SideStick => ("sidestick" , "instrument") , DrumNote :: HandClap => ("clap" , "instrument") , DrumNote :: Cowbell => ("cowbell" , "instrument") , DrumNote :: Tambourine => ("tambourine" , "instrument") , DrumNote :: HighBongo | DrumNote :: LowBongo => ("bongo" , "instrument") , DrumNote :: MuteHighConga | DrumNote :: OpenHighConga | DrumNote :: LowConga => { ("conga" , "instrument") } , _ => ("percussion" , "instrument") , } }

- [ ] **Function 'cymbal_to_tag_name' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/drum_analyzer.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn cymbal_to_tag_name (cymbal : & CymbalType) -> & 'static str { match cymbal { CymbalType :: ClosedHat => "closed-hat" , CymbalType :: PedalHat => "pedal-hat" , CymbalType :: OpenHat => "open-hat" , CymbalType :: Ride => "ride" , CymbalType :: RideBell => "ride-bell" , CymbalType :: Crash => "crash" , CymbalType :: China => "china" , CymbalType :: Splash => "splash" , } }

- [ ] **Function 'pattern_type_to_tag' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/drum_analyzer.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn pattern_type_to_tag (pattern : & PatternType) -> & 'static str { match pattern { PatternType :: Groove => "groove" , PatternType :: Fill => "fill" , PatternType :: Intro => "intro" , PatternType :: Ending => "ending" , PatternType :: Breakdown => "breakdown" , PatternType :: Turnaround => "turnaround" , PatternType :: Sequence => "sequence" , PatternType :: OneShot => "one-shot" , } }

- [ ] **Function 'rhythmic_feel_to_tag' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/drum_analyzer.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn rhythmic_feel_to_tag (feel : & RhythmicFeel) -> & 'static str { match feel { RhythmicFeel :: Straight => "straight" , RhythmicFeel :: Swing => "swing" , RhythmicFeel :: Shuffle => "shuffle" , RhythmicFeel :: Triplet => "triplet" , RhythmicFeel :: Half => "half-time" , RhythmicFeel :: Double => "double-time" , RhythmicFeel :: Pocket => "pocket" , } }

- [ ] **Function 'song_structure_to_tag' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/drum_analyzer.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn song_structure_to_tag (structure : & SongStructure) -> & 'static str { match structure { SongStructure :: Verse => "verse" , SongStructure :: Chorus => "chorus" , SongStructure :: Bridge => "bridge" , SongStructure :: Intro => "intro" , SongStructure :: Outro => "outro" , SongStructure :: PreChorus => "pre-chorus" , SongStructure :: Breakdown => "breakdown" , SongStructure :: Turnaround => "turnaround" , SongStructure :: MiddleEight => "middle-8" , } }

- [ ] **Function 'technique_to_tag_name' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/drum_analyzer.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn technique_to_tag_name (technique : & DrumTechnique) -> & 'static str { match technique { DrumTechnique :: GhostNotes => "ghost-notes" , DrumTechnique :: Linear => "linear" , DrumTechnique :: DoubleBass => "double-bass" , DrumTechnique :: BlastBeat => "blast-beat" , DrumTechnique :: Paradiddle => "paradiddle" , DrumTechnique :: Flam => "flam" , DrumTechnique :: Roll => "roll" , } }

- [ ] **Function 'generate_drum_tags' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/drum_analyzer.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Generate drum-specific tags from analysis results"] # [doc = ""] # [doc = " **Trusty Module**: Pure function"] # [doc = ""] # [doc = " Returns tags compatible with AutoTagger Tag structure"] pub fn generate_drum_tags (analysis : & DrumAnalysis , file_path : & str , file_name : & str) -> Vec < Tag > { let mut tags = Vec :: new () ; if analysis . is_drum_file { tags . push (Tag :: with_metadata ("drums" . to_string () , Some ("instrument" . to_string ()) , 0.90 , 20 , "midi_channel_10" . to_string () ,)) ; } for (drum_note , count) in & analysis . drum_notes { if * count > 5 { let (tag_name , category) = drum_note_to_tag (* drum_note) ; tags . push (Tag :: with_metadata (tag_name . to_string () , Some (category . to_string ()) , 0.85 , 20 , "midi_drum_notes" . to_string () ,)) ; } } for cymbal in & analysis . cymbal_types { tags . push (Tag :: with_metadata (cymbal_to_tag_name (cymbal) . to_string () , Some ("cymbal-type" . to_string ()) , 0.85 , 25 , "midi_drum_notes" . to_string () ,)) ; } if let Some (ref time_sig) = analysis . time_signature { let ts_tag = format ! ("{}-{}" , time_sig . numerator , time_sig . denominator) ; tags . push (Tag :: with_metadata (ts_tag , Some ("time-signature" . to_string ()) , 0.90 , 35 , "midi_meta_event" . to_string () ,)) ; if [6 , 9 , 12] . contains (& time_sig . numerator) && time_sig . denominator == 8 { tags . push (Tag :: with_metadata ("compound-meter" . to_string () , Some ("rhythm-style" . to_string ()) , 0.80 , 40 , "time_sig_derived" . to_string () ,)) ; } } if let Some (pattern) = extract_pattern_type (file_path , file_name) { tags . push (Tag :: with_metadata (pattern_type_to_tag (& pattern) . to_string () , Some ("pattern-type" . to_string ()) , 0.85 , 30 , "filename_exact" . to_string () ,)) ; } if let Some (feel) = extract_rhythmic_feel (file_path , file_name) { tags . push (Tag :: with_metadata (rhythmic_feel_to_tag (& feel) . to_string () , Some ("rhythm-feel" . to_string ()) , 0.85 , 40 , "filename_exact" . to_string () ,)) ; } if let Some (structure) = extract_song_structure (file_path , file_name) { tags . push (Tag :: with_metadata (song_structure_to_tag (& structure) . to_string () , Some ("structure" . to_string ()) , 0.85 , 80 , "filename_exact" . to_string () ,)) ; } if let Some (bpm) = extract_bpm_from_filename (file_name) { let bpm_rounded = bpm . round () as i32 ; tags . push (Tag :: with_metadata (bpm_rounded . to_string () , Some ("tempo" . to_string ()) , 0.85 , 50 , "filename_bpm" . to_string () ,)) ; } for technique in & analysis . techniques { tags . push (Tag :: with_metadata (technique_to_tag_name (technique) . to_string () , Some ("technique" . to_string ()) , 0.75 , 45 , "midi_pattern_analysis" . to_string () ,)) ; } tags }

- [ ] **Function 'get_bpm_regex' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/filename_metadata.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn get_bpm_regex () -> & 'static Regex { BPM_REGEX . get_or_init (| | { Regex :: new (r"(?i)([0-9]{2,3})[\s_]*(bpm|beats|tempo)|(?:^|_|\s|-|/)([0-9]{2,3})(?:_|\s|-|/|\.)" ,) . expect ("BPM regex should be valid") }) }

- [ ] **Function 'extract_bpm_from_filename' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/filename_metadata.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Extracts BPM value from filename"] # [doc = ""] # [doc = " Recognizes patterns:"] # [doc = " - Explicit: \"120_BPM_house_loop.mid\", \"Drums_140bpm.mid\""] # [doc = " - Implicit: \"house_120.mid\", \"bass_140.mid\""] # [doc = ""] # [doc = " Valid range: 40-220 BPM"] # [doc = ""] # [doc = " # Examples"] # [doc = " ```"] # [doc = " use pipeline::core::analysis::filename_metadata::extract_bpm_from_filename;"] # [doc = ""] # [doc = " assert_eq!(extract_bpm_from_filename(\"house_120_loop.mid\"), Some(120.0));"] # [doc = " assert_eq!(extract_bpm_from_filename(\"140bpm_trap.mid\"), Some(140.0));"] # [doc = " assert_eq!(extract_bpm_from_filename(\"drums_128_beats.mid\"), Some(128.0));"] # [doc = " assert_eq!(extract_bpm_from_filename(\"no_bpm_here.mid\"), None);"] # [doc = " ```"] pub fn extract_bpm_from_filename (filename : & str) -> Option < f64 > { let regex = get_bpm_regex () ; for caps in regex . captures_iter (filename) { if let Some (m) = caps . get (1) { if let Ok (bpm) = m . as_str () . parse :: < f64 > () { if (40.0 ..= 220.0) . contains (& bpm) { return Some (bpm) ; } } } } for caps in regex . captures_iter (filename) { if let Some (m) = caps . get (3) { if let Ok (bpm) = m . as_str () . parse :: < f64 > () { if (40.0 ..= 220.0) . contains (& bpm) { return Some (bpm) ; } } } } None }

- [ ] **Function 'get_key_regex' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/filename_metadata.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn get_key_regex () -> & 'static Regex { KEY_REGEX . get_or_init (| | { Regex :: new (r"(?i)(?:^|_|\s|-|/)([A-G](?:#|b)?m?)(?:_|\s|-|/|\.)|([A-G]\s?(maj|min|major|minor))" ,) . expect ("Key regex should be valid") }) }

- [ ] **Function 'get_key_map' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/filename_metadata.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn get_key_map () -> & 'static HashMap < & 'static str , & 'static str > { KEY_NORMALIZATION_MAP . get_or_init (| | { HashMap :: from ([("amin" , "Am") , ("am" , "Am") , ("bmin" , "Bm") , ("bm" , "Bm") , ("cmin" , "Cm") , ("cm" , "Cm") , ("dmin" , "Dm") , ("dm" , "Dm") , ("emin" , "Em") , ("em" , "Em") , ("fmin" , "Fm") , ("fm" , "Fm") , ("gmin" , "Gm") , ("gm" , "Gm") , ("amaj" , "A") , ("cmaj" , "C") , ("dmaj" , "D") , ("emaj" , "E") , ("fmaj" , "F") , ("gmaj" , "G") , ("bmaj" , "B") , ("bb" , "Bb") , ("a#" , "A#") , ("c#" , "C#") , ("d#" , "D#") , ("f#" , "F#") , ("g#" , "G#") , ("ab" , "Ab") , ("db" , "Db") , ("eb" , "Eb") , ("gb" , "Gb") , ("a" , "A") , ("b" , "B") , ("c" , "C") , ("d" , "D") , ("e" , "E") , ("f" , "F") , ("g" , "G") ,]) }) }

- [ ] **Function 'normalize_key_signature' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/filename_metadata.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Normalizes raw key signature to canonical form"] # [doc = ""] # [doc = " # Examples"] # [doc = " ```"] # [doc = " use pipeline::core::analysis::filename_metadata::normalize_key_signature;"] # [doc = ""] # [doc = " assert_eq!(normalize_key_signature(\"amin\"), Some(\"Am\".to_string()));"] # [doc = " assert_eq!(normalize_key_signature(\"Cmaj\"), Some(\"C\".to_string()));"] # [doc = " assert_eq!(normalize_key_signature(\"f#\"), Some(\"F#\".to_string()));"] # [doc = " assert_eq!(normalize_key_signature(\"a\"), Some(\"A\".to_string()));"] # [doc = " ```"] pub fn normalize_key_signature (raw_key : & str) -> Option < String > { get_key_map () . get (raw_key . to_lowercase () . as_str ()) . map (| & s | s . to_string ()) }

- [ ] **Function 'extract_key_from_filename' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/filename_metadata.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Extracts key signature from filename and normalizes it"] # [doc = ""] # [doc = " # Examples"] # [doc = " ```"] # [doc = " use pipeline::core::analysis::filename_metadata::extract_key_from_filename;"] # [doc = ""] # [doc = " assert_eq!(extract_key_from_filename(\"Cm_bass.mid\"), Some(\"Cm\".to_string()));"] # [doc = " assert_eq!(extract_key_from_filename(\"16_Dm_Bass.mid\"), Some(\"Dm\".to_string()));"] # [doc = " assert_eq!(extract_key_from_filename(\"melody_in_A_major.mid\"), Some(\"A\".to_string()));"] # [doc = " ```"] pub fn extract_key_from_filename (filename : & str) -> Option < String > { get_key_regex () . captures (filename) . and_then (| caps | caps . get (1) . or_else (| | caps . get (3))) . and_then (| m | normalize_key_signature (m . as_str ())) }

- [ ] **Function 'get_genre_regex' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/filename_metadata.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn get_genre_regex () -> & 'static Regex { GENRE_REGEX . get_or_init (| | { Regex :: new (r"(?i)(house|techno|trance|hip.?hop|trap|dubstep|dnb|drum.?n.?bass|jazz|funk|soul|rock|pop|edm|ambient|downtempo|break|jungle|garage|electro|acid|minimal|deep|progressive)" ,) . expect ("Genre regex should be valid") }) }

- [ ] **Function 'normalize_genre' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/filename_metadata.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Normalizes genre variants to canonical form"] fn normalize_genre (raw : & str) -> String { match raw { "hip hop" | "hiphop" | "hip-hop" => "hip-hop" . to_string () , "dnb" | "drum n bass" | "drum and bass" | "drum-n-bass" | "drum_n_bass" => { "dnb" . to_string () } , genre => genre . to_string () , } }

- [ ] **Function 'extract_genres_from_filename' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/filename_metadata.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Extracts genre tags from filename"] # [doc = ""] # [doc = " # Examples"] # [doc = " ```"] # [doc = " use pipeline::core::analysis::filename_metadata::extract_genres_from_filename;"] # [doc = ""] # [doc = " let genres = extract_genres_from_filename(\"deep_house_120.mid\");"] # [doc = " assert!(genres.contains(&\"deep\".to_string()));"] # [doc = " assert!(genres.contains(&\"house\".to_string()));"] # [doc = ""] # [doc = " let genres = extract_genres_from_filename(\"drum_n_bass_170.mid\");"] # [doc = " assert!(genres.contains(&\"dnb\".to_string()));"] # [doc = " ```"] pub fn extract_genres_from_filename (filename : & str) -> Vec < String > { get_genre_regex () . find_iter (filename) . map (| m | m . as_str () . to_lowercase ()) . map (| g | normalize_genre (& g)) . collect () }

- [ ] **Function 'get_structure_regex' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/filename_metadata.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn get_structure_regex () -> & 'static Regex { STRUCTURE_REGEX . get_or_init (| | { Regex :: new (r"(?i)(verse|chorus|bridge|intro|outro|drop|build|breakdown|fill|loop|one.?shot|sample|melody|hook|riff|lick|main|full|short|long)" ,) . expect ("Structure regex should be valid") }) }

- [ ] **Function 'normalize_structure_tag' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/filename_metadata.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Normalizes structure tag variants"] fn normalize_structure_tag (raw : & str) -> String { match raw { "one shot" | "one-shot" | "oneshot" => "oneshot" . to_string () , tag => tag . to_string () , } }

- [ ] **Function 'extract_structure_tags' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/filename_metadata.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Extracts structure tags from filename"] # [doc = ""] # [doc = " # Examples"] # [doc = " ```"] # [doc = " use pipeline::core::analysis::filename_metadata::extract_structure_tags;"] # [doc = ""] # [doc = " let tags = extract_structure_tags(\"drum_fill_120bpm.mid\");"] # [doc = " assert!(tags.contains(&\"fill\".to_string()));"] # [doc = ""] # [doc = " let tags = extract_structure_tags(\"verse_melody_loop.mid\");"] # [doc = " assert!(tags.contains(&\"verse\".to_string()));"] # [doc = " assert!(tags.contains(&\"melody\".to_string()));"] # [doc = " assert!(tags.contains(&\"loop\".to_string()));"] # [doc = " ```"] pub fn extract_structure_tags (filename : & str) -> Vec < String > { get_structure_regex () . find_iter (filename) . map (| m | m . as_str () . to_lowercase ()) . map (| s | normalize_structure_tag (& s)) . collect () }

- [ ] **Function 'get_leading_number_regex' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/filename_metadata.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn get_leading_number_regex () -> & 'static Regex { LEADING_NUMBER_REGEX . get_or_init (| | Regex :: new (r"^([0-9]+)") . expect ("Leading number regex should be valid")) }

- [ ] **Function 'extract_leading_number' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/filename_metadata.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Extracts leading number from filename"] # [doc = ""] # [doc = " Common uses:"] # [doc = " - Track ordering (01-99)"] # [doc = " - Kit numbers (001-999)"] # [doc = " - Version numbers (v1, v2, v3)"] # [doc = ""] # [doc = " # Examples"] # [doc = " ```"] # [doc = " use pipeline::core::analysis::filename_metadata::extract_leading_number;"] # [doc = ""] # [doc = " assert_eq!(extract_leading_number(\"01_kick.mid\"), Some(1));"] # [doc = " assert_eq!(extract_leading_number(\"125_melody.mid\"), Some(125));"] # [doc = " assert_eq!(extract_leading_number(\"kick_01.mid\"), None);"] # [doc = " ```"] pub fn extract_leading_number (filename : & str) -> Option < u32 > { get_leading_number_regex () . captures (filename) . and_then (| caps | caps . get (1)) . and_then (| m | m . as_str () . parse :: < u32 > () . ok ()) }

- [ ] **Function 'classify_leading_number' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/filename_metadata.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Classifies the purpose of a leading number"] # [doc = ""] # [doc = " # Examples"] # [doc = " ```"] # [doc = " use pipeline::core::analysis::filename_metadata::{classify_leading_number, NumberType};"] # [doc = ""] # [doc = " assert_eq!(classify_leading_number(1), NumberType::TrackNumber);"] # [doc = " assert_eq!(classify_leading_number(42), NumberType::TrackNumber);"] # [doc = " assert_eq!(classify_leading_number(120), NumberType::PossibleBPM);"] # [doc = " assert_eq!(classify_leading_number(500), NumberType::Unknown);"] # [doc = " ```"] pub fn classify_leading_number (num : u32) -> NumberType { match num { 1 ..= 99 => NumberType :: TrackNumber , 100 ..= 220 => NumberType :: PossibleBPM , _ => NumberType :: Unknown , } }

- [ ] **Function 'validate_key_signature' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/filename_metadata.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Cross-validates key signature from analysis and filename"] # [doc = ""] # [doc = " # Examples"] # [doc = " ```"] # [doc = " use pipeline::core::analysis::filename_metadata::{validate_key_signature, KeyValidationResult};"] # [doc = ""] # [doc = " // Agreement - validated"] # [doc = " match validate_key_signature(Some(\"Cm\"), Some(\"Cm\")) {"] # [doc = "     KeyValidationResult::Validated(key) => assert_eq!(key, \"Cm\"),"] # [doc = "     _ => panic!(\"Expected validated\"),"] # [doc = " }"] # [doc = ""] # [doc = " // Conflict"] # [doc = " match validate_key_signature(Some(\"Cm\"), Some(\"Dm\")) {"] # [doc = "     KeyValidationResult::Conflict { analyzed, filename } => {"] # [doc = "         assert_eq!(analyzed, \"Cm\");"] # [doc = "         assert_eq!(filename, \"Dm\");"] # [doc = "     }"] # [doc = "     _ => panic!(\"Expected conflict\"),"] # [doc = " }"] # [doc = " ```"] pub fn validate_key_signature (analyzed_key : Option < & str > , filename_key : Option < & str > ,) -> KeyValidationResult { match (analyzed_key , filename_key) { (Some (a) , Some (f)) if a == f => KeyValidationResult :: Validated (a . to_string ()) , (Some (a) , Some (f)) => { KeyValidationResult :: Conflict { analyzed : a . to_string () , filename : f . to_string () } } , (Some (a) , None) => KeyValidationResult :: AnalyzedOnly (a . to_string ()) , (None , Some (f)) => KeyValidationResult :: FilenameOnly (f . to_string ()) , (None , None) => KeyValidationResult :: Unknown , } }

- [ ] **Function 'validate_bpm' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/filename_metadata.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Validates BPM from analysis against filename metadata"] # [doc = ""] # [doc = " Tolerance: Â±5 BPM (accounts for detection variance)"] # [doc = ""] # [doc = " # Examples"] # [doc = " ```"] # [doc = " use pipeline::core::analysis::filename_metadata::validate_bpm;"] # [doc = ""] # [doc = " assert!(validate_bpm(Some(120.0), Some(120.0)));  // Exact match"] # [doc = " assert!(validate_bpm(Some(120.0), Some(123.0)));  // Within tolerance"] # [doc = " assert!(!validate_bpm(Some(120.0), Some(140.0))); // Out of tolerance"] # [doc = " ```"] pub fn validate_bpm (analyzed_bpm : Option < f32 > , filename_bpm : Option < f32 >) -> bool { match (analyzed_bpm , filename_bpm) { (Some (a) , Some (f)) => (a - f) . abs () <= 5.0 , _ => false , } }

- [ ] **Function 'validate_bpm_for_genre' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/filename_metadata.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Genre-specific BPM range validation"] # [doc = ""] # [doc = " # Examples"] # [doc = " ```"] # [doc = " use pipeline::core::analysis::filename_metadata::validate_bpm_for_genre;"] # [doc = ""] # [doc = " assert!(validate_bpm_for_genre(120.0, \"house\"));   // House: 120-128 BPM"] # [doc = " assert!(!validate_bpm_for_genre(80.0, \"house\"));   // Too slow for house"] # [doc = " assert!(validate_bpm_for_genre(170.0, \"dnb\"));     // DNB: 160-180 BPM"] # [doc = " ```"] pub fn validate_bpm_for_genre (bpm : f32 , genre : & str) -> bool { let ranges : HashMap < & str , (f32 , f32) > = [("house" , (120.0 , 128.0)) , ("techno" , (125.0 , 135.0)) , ("trance" , (128.0 , 140.0)) , ("dubstep" , (138.0 , 142.0)) , ("dnb" , (160.0 , 180.0)) , ("drum-n-bass" , (160.0 , 180.0)) , ("trap" , (135.0 , 145.0)) , ("hip-hop" , (70.0 , 100.0)) , ("funk" , (90.0 , 120.0)) , ("rock" , (100.0 , 140.0)) , ("pop" , (100.0 , 130.0)) ,] . iter () . cloned () . collect () ; ranges . get (genre) . map (| & (min , max) | bpm >= min && bpm <= max) . unwrap_or (true) }

- [ ] **Function 'detect_key' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/key_detector.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Detects the musical key from a parsed MIDI file"] # [doc = ""] # [doc = " # Arguments"] # [doc = " * `midi_file` - Parsed MIDI file structure"] # [doc = ""] # [doc = " # Returns"] # [doc = " * `KeyDetectionResult` - Detection result with confidence and alternatives"] # [doc = ""] # [doc = " # Algorithm"] # [doc = " Uses Krumhansl-Schmuckler key-finding algorithm:"] # [doc = " 1. Extract all notes and build pitch class histogram"] # [doc = " 2. Normalize histogram to probability distribution"] # [doc = " 3. Correlate with all 24 key profiles (12 major + 12 minor)"] # [doc = " 4. Return key with highest correlation"] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " ```"] # [doc = " use pipeline::core::midi::types::MidiFile;"] # [doc = " use pipeline::core::analysis::key_detector::detect_key;"] # [doc = ""] # [doc = " // Assuming you have a parsed MIDI file"] # [doc = " // let midi_file = parse_midi_file(&data)?;"] # [doc = " // let result = detect_key(&midi_file);"] # [doc = " // println!(\"Detected key: {} ({})\", result.key, result.scale_type);"] # [doc = " ```"] pub fn detect_key (midi_file : & MidiFile) -> KeyDetectionResult { let pitch_class_counts = build_pitch_class_histogram (midi_file) ; let pitch_class_distribution = normalize_histogram (& pitch_class_counts) ; let mut correlations = Vec :: new () ; for pitch_class in 0 .. 12 { let major_correlation = calculate_correlation (& pitch_class_distribution , & rotate_profile (& MAJOR_PROFILE , pitch_class) ,) ; correlations . push ((pitch_class , ScaleType :: Major , major_correlation)) ; let minor_correlation = calculate_correlation (& pitch_class_distribution , & rotate_profile (& MINOR_PROFILE , pitch_class) ,) ; correlations . push ((pitch_class , ScaleType :: Minor , minor_correlation)) ; } correlations . sort_by (| a , b | b . 2 . partial_cmp (& a . 2) . unwrap_or (std :: cmp :: Ordering :: Equal)) ; let (best_pitch_class , best_scale_type , _best_correlation) = correlations [0] ; let key_name = format_key_name (best_pitch_class , best_scale_type) ; let confidence = calculate_confidence (& correlations) ; let alternatives : Vec < KeyAlternative > = correlations [1 .. 4] . iter () . map (| (pc , st , corr) | KeyAlternative { key : format_key_name (* pc , * st) , scale_type : * st , correlation : * corr , }) . collect () ; KeyDetectionResult { key : key_name , scale_type : best_scale_type , confidence , alternatives , pitch_class_distribution , } }

- [ ] **Function 'build_pitch_class_histogram' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/key_detector.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Builds a histogram of pitch class occurrences"] fn build_pitch_class_histogram (midi_file : & MidiFile) -> [u32 ; 12] { let mut histogram = [0u32 ; 12] ; for track in & midi_file . tracks { for timed_event in & track . events { if let Event :: NoteOn { note , velocity , .. } = timed_event . event { if velocity > 0 { let pitch_class = (note % 12) as usize ; histogram [pitch_class] += 1 ; } } } } histogram }

- [ ] **Function 'normalize_histogram' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/key_detector.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Normalizes histogram to probability distribution"] fn normalize_histogram (histogram : & [u32 ; 12]) -> [f64 ; 12] { let total : u32 = histogram . iter () . sum () ; if total == 0 { return [0.0 ; 12] ; } let mut normalized = [0.0 ; 12] ; for i in 0 .. 12 { normalized [i] = histogram [i] as f64 / total as f64 ; } normalized }

- [ ] **Function 'rotate_profile' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/key_detector.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Rotates a key profile to a different tonic"] # [doc = ""] # [doc = " Takes a profile defined for C (pitch class 0) and rotates it to be"] # [doc = " defined for a different pitch class. The rotation shifts the profile"] # [doc = " so that the tonic weight appears at the target pitch class."] fn rotate_profile (profile : & [f64 ; 12] , rotation : usize) -> [f64 ; 12] { let mut rotated = [0.0 ; 12] ; for i in 0 .. 12 { rotated [i] = profile [(i + 12 - rotation) % 12] ; } rotated }

- [ ] **Function 'calculate_correlation' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/key_detector.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Calculates Pearson correlation coefficient between two distributions"] fn calculate_correlation (distribution : & [f64 ; 12] , profile : & [f64 ; 12]) -> f64 { let mean_dist = distribution . iter () . sum :: < f64 > () / 12.0 ; let mean_prof = profile . iter () . sum :: < f64 > () / 12.0 ; let mut covariance = 0.0 ; let mut var_dist = 0.0 ; let mut var_prof = 0.0 ; for i in 0 .. 12 { let diff_dist = distribution [i] - mean_dist ; let diff_prof = profile [i] - mean_prof ; covariance += diff_dist * diff_prof ; var_dist += diff_dist * diff_dist ; var_prof += diff_prof * diff_prof ; } let std_dist = var_dist . sqrt () ; let std_prof = var_prof . sqrt () ; if std_dist == 0.0 || std_prof == 0.0 { return 0.0 ; } covariance / (std_dist * std_prof) }

- [ ] **Function 'calculate_confidence' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/key_detector.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Calculates confidence based on separation between best and second-best keys"] fn calculate_confidence (correlations : & [(usize , ScaleType , f64)]) -> f64 { if correlations . len () < 2 { return 0.5 ; } let best = correlations [0] . 2 ; let second_best = correlations [1] . 2 ; let gap = best - second_best ; let confidence = 0.5 + (gap * 2.5) . min (0.5) ; confidence . clamp (0.5 , 1.0) }

- [ ] **Function 'format_key_name' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/key_detector.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Formats key name based on pitch class and scale type"] fn format_key_name (pitch_class : usize , scale_type : ScaleType) -> String { let base_name = pitch_class_to_key_name (pitch_class) ; match scale_type { ScaleType :: Major => base_name . to_string () , ScaleType :: Minor => format ! ("{}m" , base_name) , } }

- [ ] **Function 'create_test_midi_with_notes' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/key_detector.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Create a MIDI file with specific notes"] # [doc = " Each note is (pitch, velocity) - velocity 0 means note off"] fn create_test_midi_with_notes (notes : Vec < (u8 , u8) >) -> MidiFile { let mut events : Vec < TimedEvent > = Vec :: new () ; for (pitch , velocity) in notes { events . push (TimedEvent { delta_ticks : 10 , event : Event :: NoteOn { note : pitch , velocity , channel : 0 } , }) ; } events . push (TimedEvent { delta_ticks : 0 , event : Event :: EndOfTrack }) ; MidiFile { header : Header { format : 1 , num_tracks : 1 , ticks_per_quarter_note : 480 } , tracks : vec ! [Track { events }] , } }

- [ ] **Function 'create_major_scale' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/key_detector.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Create a major scale starting from a given root note"] fn create_major_scale (root : u8) -> Vec < u8 > { let intervals = [0 , 2 , 4 , 5 , 7 , 9 , 11 , 12] ; intervals . iter () . map (| & i | root + i) . collect () }

- [ ] **Function 'create_minor_scale' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/key_detector.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Create a minor scale starting from a given root note"] fn create_minor_scale (root : u8) -> Vec < u8 > { let intervals = [0 , 2 , 3 , 5 , 7 , 8 , 10 , 12] ; intervals . iter () . map (| & i | root + i) . collect () }

- [ ] **Function 'create_chromatic_scale' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/key_detector.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Create chromatic scale (all 12 pitches)"] fn create_chromatic_scale (root : u8) -> Vec < u8 > { (0 .. 12) . map (| i | root + i) . collect () }

- [ ] **Function 'assert_correlation_approx' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/key_detector.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Assert correlation is within tolerance"] # [allow (dead_code)] fn assert_correlation_approx (actual : f64 , expected : f64 , tolerance : f64) { assert ! ((actual - expected) . abs () < tolerance , "Correlation mismatch: expected {}, got {} (tolerance: {})" , expected , actual , tolerance) ; }

- [ ] **Function 'pitch_class_to_key_name' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/key_profiles.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Maps pitch class to key name"] pub fn pitch_class_to_key_name (pitch_class : usize) -> & 'static str { match pitch_class { 0 => "C" , 1 => "C#" , 2 => "D" , 3 => "D#" , 4 => "E" , 5 => "F" , 6 => "F#" , 7 => "G" , 8 => "G#" , 9 => "A" , 10 => "A#" , 11 => "B" , _ => "UNKNOWN" , } }

- [ ] **Function 'pitch_class_to_minor_key_name' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/key_profiles.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Returns the minor key name for a given pitch class"] pub fn pitch_class_to_minor_key_name (pitch_class : usize) -> String { format ! ("{}m" , pitch_class_to_key_name (pitch_class)) }

- [ ] **Function 'analyze_file_mmap' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/optimized_analyzer.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Phase 2: Memory-mapped file analysis (zero-copy)"] # [doc = ""] # [doc = " Uses standard heap allocation for MIDI events. For files with 10K+ events,"] # [doc = " consider using `analyze_file_arena()` for 5-15% better performance."] pub fn analyze_file_mmap (file : & FileToAnalyze) -> Result < AnalysisResult > { let file_handle = File :: open (& file . filepath) ? ; let mmap = unsafe { Mmap :: map (& file_handle) ? } ; let midi_file = parse_midi_file (& mmap) ? ; let bpm_result = detect_bpm (& midi_file) ; let bpm = if bpm_result . confidence > 0.3 { Some (bpm_result . bpm) } else { None } ; let has_tempo_changes = ! bpm_result . metadata . is_constant ; let key_result = detect_key (& midi_file) ; let ticks_per_quarter = midi_file . header . ticks_per_quarter_note as u32 ; let chord_analysis = analyze_chords (& midi_file , ticks_per_quarter) ; let chord_progression = if ! chord_analysis . progression . is_empty () { Some (serde_json :: json ! (chord_analysis . progression)) } else { None } ; let duration_seconds = Some (midi_file . duration_seconds (120.0)) ; Ok (AnalysisResult { file_id : file . id , bpm , bpm_confidence : Some (bpm_result . confidence) , has_tempo_changes , detected_key : key_result . key , key_confidence : Some (key_result . confidence) , duration_seconds , chord_progression , chord_types : chord_analysis . types , has_seventh_chords : chord_analysis . has_sevenths , has_extended_chords : chord_analysis . has_extended , chord_change_rate : chord_analysis . change_rate , chord_complexity_score : Some (chord_analysis . complexity_score as f64) , }) }

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/optimized_analyzer.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/optimized_analyzer.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/optimized_analyzer.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/optimized_analyzer.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/optimized_analyzer.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/optimized_analyzer.rs`
  - Category: Performance

- [ ] **Function 'detect_bpm_from_onsets' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/simd_bpm.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Detects BPM from note onsets using SIMD-optimized velocity analysis"] # [doc = ""] # [doc = " This function analyzes note-on events to detect rhythmic patterns and calculate BPM."] # [doc = " It uses SIMD vectorization for fast velocity threshold checks."] # [doc = ""] # [doc = " # Arguments"] # [doc = " * `midi_file` - Parsed MIDI file structure"] # [doc = ""] # [doc = " # Returns"] # [doc = " * `Option<OnsetBpmResult>` - Detection result, or None if insufficient onsets found"] # [doc = ""] # [doc = " # Examples"] # [doc = " ```no_run"] # [doc = " use pipeline::core::analysis::simd_bpm::detect_bpm_from_onsets;"] # [doc = " use midi_library_shared::core::midi::types::MidiFile;"] # [doc = ""] # [doc = " # fn example(midi_file: MidiFile) -> Result<(), Box<dyn std::error::Error>> {"] # [doc = " if let Some(result) = detect_bpm_from_onsets(&midi_file) {"] # [doc = "     println!(\"Onset-based BPM: {:.2} (confidence: {:.2})\", result.bpm, result.confidence);"] # [doc = " }"] # [doc = " # Ok(())"] # [doc = " # }"] # [doc = " ```"] pub fn detect_bpm_from_onsets (midi_file : & MidiFile) -> Option < OnsetBpmResult > { let onsets = extract_onsets_simd (midi_file) ; if onsets . len () < 8 { return None ; } let iois = calculate_inter_onset_intervals (& onsets) ; if iois . is_empty () { return None ; } let avg_ioi = calculate_mean (& iois) ; let std_dev = calculate_std_dev (& iois , avg_ioi) ; let ticks_per_quarter = midi_file . header . ticks_per_quarter_note as f64 ; let bpm = ticks_to_bpm (avg_ioi , ticks_per_quarter) ; let confidence = calculate_ioi_confidence (& iois , avg_ioi , std_dev) ; let bpm = bpm . clamp (MIN_BPM , MAX_BPM) ; Some (OnsetBpmResult { bpm , confidence , onset_count : onsets . len () , avg_ioi_ticks : avg_ioi , ioi_std_dev : std_dev , }) }

- [ ] **Function 'extract_onsets_simd' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/simd_bpm.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Extracts onsets from MIDI file using SIMD-optimized velocity processing"] # [doc = ""] # [doc = " This function processes note-on events and uses compiler auto-vectorization"] # [doc = " hints to optimize velocity threshold checks."] # [doc = ""] # [doc = " # Arguments"] # [doc = " * `midi_file` - Parsed MIDI file structure"] # [doc = ""] # [doc = " # Returns"] # [doc = " * `Vec<Onset>` - List of detected onsets sorted by tick position"] pub fn extract_onsets_simd (midi_file : & MidiFile) -> Vec < Onset > { let mut onsets = Vec :: new () ; for track in & midi_file . tracks { let mut current_tick = 0u32 ; for timed_event in & track . events { current_tick = current_tick . saturating_add (timed_event . delta_ticks) ; if let Event :: NoteOn { channel , velocity , .. } = timed_event . event { if velocity >= ONSET_THRESHOLD { onsets . push (Onset { tick : current_tick , velocity , channel }) ; } } } } onsets . sort_by_key (| onset | onset . tick) ; onsets }

- [ ] **Function 'calculate_inter_onset_intervals' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/simd_bpm.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Calculates inter-onset intervals (IOIs) from a list of onsets"] # [doc = ""] # [doc = " IOIs represent the time difference between consecutive onsets,"] # [doc = " which form the basis for rhythmic pattern analysis."] # [doc = ""] # [doc = " # Arguments"] # [doc = " * `onsets` - Sorted list of onsets by tick position"] # [doc = ""] # [doc = " # Returns"] # [doc = " * `Vec<f64>` - List of IOIs in ticks, filtered by minimum threshold"] fn calculate_inter_onset_intervals (onsets : & [Onset]) -> Vec < f64 > { let mut iois = Vec :: with_capacity (onsets . len () . saturating_sub (1)) ; for window in onsets . windows (2) { let ioi = window [1] . tick . saturating_sub (window [0] . tick) ; if ioi >= MIN_IOI_TICKS { iois . push (ioi as f64) ; } } iois }

- [ ] **Function 'ticks_to_bpm' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/simd_bpm.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Converts average inter-onset interval to BPM"] # [doc = ""] # [doc = " # Arguments"] # [doc = " * `avg_ioi_ticks` - Average inter-onset interval in ticks"] # [doc = " * `ticks_per_quarter` - MIDI file ticks per quarter note"] # [doc = ""] # [doc = " # Returns"] # [doc = " * `f64` - Calculated BPM"] fn ticks_to_bpm (avg_ioi_ticks : f64 , ticks_per_quarter : f64) -> f64 { if avg_ioi_ticks <= 0.0 || ticks_per_quarter <= 0.0 { return 120.0 ; } let beats_per_tick = ticks_per_quarter / avg_ioi_ticks ; beats_per_tick * 60.0 }

- [ ] **Function 'calculate_ioi_confidence' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/simd_bpm.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Calculates confidence score based on IOI consistency"] # [doc = ""] # [doc = " Higher consistency (lower coefficient of variation) yields higher confidence."] # [doc = ""] # [doc = " # Arguments"] # [doc = " * `iois` - List of inter-onset intervals"] # [doc = " * `mean` - Mean IOI value"] # [doc = " * `std_dev` - Standard deviation of IOIs"] # [doc = ""] # [doc = " # Returns"] # [doc = " * `f64` - Confidence score (0.0 to 1.0)"] fn calculate_ioi_confidence (iois : & [f64] , mean : f64 , std_dev : f64) -> f64 { if iois . is_empty () || mean <= 0.0 { return 0.0 ; } let cv = std_dev / mean ; (1.0 - cv . min (1.0)) . max (0.3) }

- [ ] **Function 'calculate_mean' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/simd_bpm.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Calculates mean of a slice of f64 values"] fn calculate_mean (values : & [f64]) -> f64 { if values . is_empty () { return 0.0 ; } let sum : f64 = values . iter () . sum () ; sum / values . len () as f64 }

- [ ] **Function 'calculate_std_dev' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/simd_bpm.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Calculates standard deviation of a slice of f64 values"] fn calculate_std_dev (values : & [f64] , mean : f64) -> f64 { if values . is_empty () { return 0.0 ; } let variance : f64 = values . iter () . map (| & v | (v - mean) . powi (2)) . sum :: < f64 > () / values . len () as f64 ; variance . sqrt () }

- [ ] **Function 'batch_detect_onsets_simd' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/simd_bpm.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " SIMD-accelerated batch onset detection for multiple MIDI files"] # [doc = ""] # [doc = " Processes velocity arrays in parallel using compiler vectorization,"] # [doc = " optimized for batch operations."] # [doc = ""] # [doc = " # Arguments"] # [doc = " * `velocity_arrays` - Vector of velocity arrays from different MIDI files"] # [doc = ""] # [doc = " # Returns"] # [doc = " * `Vec<Vec<usize>>` - Onset indices for each input array"] pub fn batch_detect_onsets_simd (velocity_arrays : & [Vec < u8 >]) -> Vec < Vec < usize > > { velocity_arrays . iter () . map (| vels | detect_onsets_simd_vectorized (vels)) . collect () }

- [ ] **Function 'create_test_midi_file' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/analysis/simd_bpm.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn create_test_midi_file (note_ticks : Vec < (u32 , u8) >) -> MidiFile { let mut events = Vec :: new () ; for (tick , velocity) in note_ticks { events . push (TimedEvent { delta_ticks : tick , event : Event :: NoteOn { channel : 0 , note : 60 , velocity } , }) ; } MidiFile { header : Header { format : 1 , num_tracks : 1 , ticks_per_quarter_note : 480 } , tracks : vec ! [Track { events }] , } }

- [ ] **Function 'calculate_content_hash' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/hash/blake3.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Calculate BLAKE3 hash of byte content."] # [doc = ""] # [doc = " This is a **pure function** with no side effects (TRUSTY MODULE pattern)."] # [doc = ""] # [doc = " # Arguments"] # [doc = ""] # [doc = " * `data` - Byte slice to hash"] # [doc = ""] # [doc = " # Returns"] # [doc = ""] # [doc = " 32-byte BLAKE3 hash"] # [doc = ""] # [doc = " # Performance"] # [doc = ""] # [doc = " - Single-threaded: ~3,000 MB/s"] # [doc = " - For data larger than 128 KB, BLAKE3 automatically uses parallel tree hashing"] # [doc = " - Significantly faster than SHA-256 (~400 MB/s)"] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " ```rust"] # [doc = " use pipeline::core::hash::blake3::calculate_content_hash;"] # [doc = ""] # [doc = " let data = b\"MIDI file content\";"] # [doc = " let hash = calculate_content_hash(data);"] # [doc = " assert_eq!(hash.len(), 32);"] # [doc = " ```"] pub fn calculate_content_hash (data : & [u8]) -> [u8 ; 32] { blake3 :: hash (data) . into () }

- [ ] **Function 'calculate_file_hash' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/hash/blake3.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Calculate BLAKE3 hash of a file."] # [doc = ""] # [doc = " This is a **convenience wrapper** that performs file I/O."] # [doc = " For pure hashing logic, use `calculate_content_hash()`."] # [doc = ""] # [doc = " # Arguments"] # [doc = ""] # [doc = " * `path` - Path to file to hash"] # [doc = ""] # [doc = " # Returns"] # [doc = ""] # [doc = " 32-byte BLAKE3 hash or error if file cannot be read"] # [doc = ""] # [doc = " # Errors"] # [doc = ""] # [doc = " - `HashError::IoError` - File cannot be opened or read"] # [doc = " - `HashError::InvalidPath` - Path is invalid or does not exist"] # [doc = ""] # [doc = " # Performance"] # [doc = ""] # [doc = " For large files (>10 MB), consider using memory-mapped files for better performance."] # [doc = " This implementation reads the file into memory, which is optimal for files <100 MB."] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " ```rust,no_run"] # [doc = " use std::path::Path;"] # [doc = " use pipeline::core::hash::blake3::calculate_file_hash;"] # [doc = ""] # [doc = " let path = Path::new(\"test.mid\");"] # [doc = " let hash = calculate_file_hash(path)?;"] # [doc = " # Ok::<(), Box<dyn std::error::Error>>(())"] # [doc = " ```"] pub fn calculate_file_hash (path : & Path) -> Result < [u8 ; 32] > { if ! path . exists () { return Err (HashError :: InvalidPath (format ! ("File does not exist: {}" , path . display ()))) ; } if ! path . is_file () { return Err (HashError :: InvalidPath (format ! ("Path is not a file: {}" , path . display ()))) ; } let mut file = File :: open (path) ? ; let mut buffer = Vec :: new () ; file . read_to_end (& mut buffer) ? ; Ok (calculate_content_hash (& buffer)) }

- [ ] **Function 'hash_to_hex' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/hash/blake3.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Convert 32-byte hash to hexadecimal string."] # [doc = ""] # [doc = " This is a **pure function** with no side effects (TRUSTY MODULE pattern)."] # [doc = ""] # [doc = " # Arguments"] # [doc = ""] # [doc = " * `hash` - 32-byte hash to convert"] # [doc = ""] # [doc = " # Returns"] # [doc = ""] # [doc = " 64-character lowercase hexadecimal string"] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " ```rust"] # [doc = " use pipeline::core::hash::blake3::{calculate_content_hash, hash_to_hex};"] # [doc = ""] # [doc = " let data = b\"test\";"] # [doc = " let hash = calculate_content_hash(data);"] # [doc = " let hex = hash_to_hex(&hash);"] # [doc = ""] # [doc = " assert_eq!(hex.len(), 64); // 32 bytes = 64 hex characters"] # [doc = " assert!(hex.chars().all(|c| c.is_ascii_hexdigit()));"] # [doc = " ```"] pub fn hash_to_hex (hash : & [u8 ; 32]) -> String { blake3 :: Hash :: from (* hash) . to_hex () . to_string () }

- [ ] **Function 'hex_to_hash' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/hash/blake3.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Convert hexadecimal string back to 32-byte hash."] # [doc = ""] # [doc = " This is a **pure function** with no side effects (TRUSTY MODULE pattern)."] # [doc = ""] # [doc = " # Arguments"] # [doc = ""] # [doc = " * `hex` - 64-character hexadecimal string"] # [doc = ""] # [doc = " # Returns"] # [doc = ""] # [doc = " 32-byte hash or error if hex string is invalid"] # [doc = ""] # [doc = " # Errors"] # [doc = ""] # [doc = " Returns error if:"] # [doc = " - String is not exactly 64 characters"] # [doc = " - String contains non-hexadecimal characters"] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " ```rust"] # [doc = " use pipeline::core::hash::blake3::{hash_to_hex, hex_to_hash};"] # [doc = ""] # [doc = " let original = [0u8; 32];"] # [doc = " let hex = hash_to_hex(&original);"] # [doc = " let decoded = hex_to_hash(&hex)?;"] # [doc = " assert_eq!(original, decoded);"] # [doc = " # Ok::<(), Box<dyn std::error::Error>>(())"] # [doc = " ```"] pub fn hex_to_hash (hex : & str) -> Result < [u8 ; 32] > { if hex . len () != 64 { return Err (HashError :: InvalidPath (format ! ("Hex string must be exactly 64 characters, got {}" , hex . len ()))) ; } let mut hash = [0u8 ; 32] ; for i in 0 .. 32 { let byte_str = & hex [i * 2 .. i * 2 + 2] ; hash [i] = u8 :: from_str_radix (byte_str , 16) . map_err (| _ | { HashError :: InvalidPath (format ! ("Invalid hex character in string: {}" , byte_str)) }) ? ; } Ok (hash) }

- [ ] **Function 'generate_filename' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/naming/generator.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Generates a new filename from metadata"] # [doc = ""] # [doc = " # Arguments"] # [doc = " * `metadata` - File metadata"] # [doc = " * `config` - Naming configuration"] # [doc = ""] # [doc = " # Returns"] # [doc = " * Generated filename with .mid extension"] # [doc = ""] # [doc = " # Examples"] # [doc = " ```"] # [doc = " use pipeline::core::naming::generator::*;"] # [doc = ""] # [doc = " let metadata = FileMetadata {"] # [doc = "     category: \"BASS\".to_string(),"] # [doc = "     bpm: 140.0,"] # [doc = "     key: \"Cm\".to_string(),"] # [doc = "     description: Some(\"Deep Rolling\".to_string()),"] # [doc = "     file_id: \"001\".to_string(),"] # [doc = " };"] # [doc = ""] # [doc = " let filename = generate_filename(&metadata, &NamingConfig::default());"] # [doc = " // Result: \"BASS_Cm_140BPM_Deep_Rolling_001.mid\""] # [doc = " ```"] pub fn generate_filename (metadata : & FileMetadata , config : & NamingConfig) -> String { let category = sanitizer :: sanitize_filename (& metadata . category . to_uppercase ()) ; let key = sanitizer :: sanitize_filename (& metadata . key) ; let description = if config . include_description { process_description (& metadata . description , config . max_description_length) } else { String :: new () } ; let filename_base = templates :: apply_template (& config . template , & category , & key , metadata . bpm , & description , & metadata . file_id ,) ; let sanitized = sanitizer :: sanitize_filename (& filename_base) ; sanitizer :: ensure_mid_extension (& sanitized) }

- [ ] **Function 'process_description' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/naming/generator.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Processes description text"] fn process_description (description : & Option < String > , max_length : usize) -> String { match description { None => String :: new () , Some (desc) => { let sanitized = sanitizer :: sanitize_filename (desc) ; let cleaned = sanitizer :: clean_description (& sanitized) ; if cleaned . len () > max_length { cleaned [.. max_length] . to_string () } else { cleaned } } , } }

- [ ] **Function 'generate_from_analysis' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/naming/generator.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Generates filename from analysis results (convenience function)"] # [doc = ""] # [doc = " # Arguments"] # [doc = " * `category` - File category (BASS, KICK, etc.)"] # [doc = " * `bpm_result` - BPM detection result"] # [doc = " * `key_result` - Key detection result"] # [doc = " * `original_filename` - Original filename to extract description from"] # [doc = " * `file_id` - Unique file identifier"] # [doc = " * `config` - Naming configuration"] # [doc = ""] # [doc = " # Returns"] # [doc = " * Generated filename with .mid extension"] pub fn generate_from_analysis (category : & str , bpm_result : & BpmDetectionResult , key_result : & KeyDetectionResult , original_filename : & str , file_id : & str , config : & NamingConfig ,) -> String { let description = extract_useful_description (original_filename) ; let metadata = FileMetadata { category : category . to_string () , bpm : bpm_result . bpm , key : key_result . key . clone () , description , file_id : file_id . to_string () , } ; generate_filename (& metadata , config) }

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/naming/generator.rs`
  - Category: Performance

- [ ] **Function 'generate_production_filename' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/naming/generator.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Generates production filename with pack name and original filename"] # [doc = ""] # [doc = " # Arguments"] # [doc = " * `category` - File category"] # [doc = " * `bpm` - Beats per minute"] # [doc = " * `key` - Musical key"] # [doc = " * `file_id` - Zero-padded file ID (e.g., \"000001\")"] # [doc = " * `timesig` - Time signature (e.g., \"4-4\", \"6-8\")"] # [doc = " * `pack_name` - Name of the pack/folder"] # [doc = " * `original_name` - Original filename (cleaned)"] # [doc = ""] # [doc = " # Returns"] # [doc = " * Formatted filename: {CATEGORY}_{TIMESIG}_{BPM}BPM_{KEY}_{ID}_{PACK}_{ORIGINAL}.mid"] # [doc = ""] # [doc = " # Examples"] # [doc = " ```"] # [doc = " use pipeline::core::naming::generator::generate_production_filename;"] # [doc = ""] # [doc = " let filename = generate_production_filename("] # [doc = "     \"KICK\","] # [doc = "     120.0,"] # [doc = "     \"C\","] # [doc = "     \"000001\","] # [doc = "     \"4-4\","] # [doc = "     \"DrumPack2024\","] # [doc = "     \"Heavy_Boom\""] # [doc = " );"] # [doc = " assert_eq!(filename, \"KICK_4-4_120BPM_C_000001_DrumPack2024_Heavy_Boom.mid\");"] # [doc = " ```"] pub fn generate_production_filename (category : & str , bpm : f64 , key : & str , file_id : & str , timesig : & str , pack_name : & str , original_name : & str ,) -> String { let sanitized_category = sanitizer :: sanitize_filename (& category . to_uppercase ()) ; let sanitized_key = sanitizer :: sanitize_filename (key) ; let sanitized_pack = sanitizer :: sanitize_filename (pack_name) ; let sanitized_original = sanitizer :: sanitize_filename (original_name) ; let filename_base = templates :: apply_template_extended (& templates :: NamingTemplate :: Production , & sanitized_category , & sanitized_key , bpm , "" , file_id , Some (timesig) , Some (& sanitized_pack) , Some (& sanitized_original) , None ,) ; sanitizer :: ensure_mid_extension (& filename_base) }

- [ ] **Function 'generate_production_layer_filename' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/naming/generator.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Generates production filename for split/layer files"] # [doc = ""] # [doc = " # Arguments"] # [doc = " * `category` - File category"] # [doc = " * `bpm` - Beats per minute"] # [doc = " * `key` - Musical key"] # [doc = " * `file_id` - Zero-padded file ID"] # [doc = " * `timesig` - Time signature"] # [doc = " * `pack_name` - Name of the pack/folder"] # [doc = " * `layer_name` - Name of the layer (e.g., \"OpenHat\", \"ClosedHat\")"] # [doc = " * `layer_number` - Layer number (1-based)"] # [doc = ""] # [doc = " # Returns"] # [doc = " * Formatted filename: {CATEGORY}_{TIMESIG}_{BPM}BPM_{KEY}_{ID}_{PACK}_{LAYER}_L{NUM}.mid"] # [doc = ""] # [doc = " # Examples"] # [doc = " ```"] # [doc = " use pipeline::core::naming::generator::generate_production_layer_filename;"] # [doc = ""] # [doc = " let filename = generate_production_layer_filename("] # [doc = "     \"HIHAT\","] # [doc = "     140.0,"] # [doc = "     \"Am\","] # [doc = "     \"000123\","] # [doc = "     \"6-8\","] # [doc = "     \"VintageDrums\","] # [doc = "     \"OpenHat\","] # [doc = "     1"] # [doc = " );"] # [doc = " assert_eq!(filename, \"HIHAT_6-8_140BPM_Am_000123_VintageDrums_OpenHat_L01.mid\");"] # [doc = " ```"] pub fn generate_production_layer_filename (category : & str , bpm : f64 , key : & str , file_id : & str , timesig : & str , pack_name : & str , layer_name : & str , layer_number : usize ,) -> String { let sanitized_category = sanitizer :: sanitize_filename (& category . to_uppercase ()) ; let sanitized_key = sanitizer :: sanitize_filename (key) ; let sanitized_pack = sanitizer :: sanitize_filename (pack_name) ; let sanitized_layer = sanitizer :: sanitize_filename (layer_name) ; let filename_base = templates :: apply_template_extended (& templates :: NamingTemplate :: Production , & sanitized_category , & sanitized_key , bpm , "" , file_id , Some (timesig) , Some (& sanitized_pack) , None , Some ((& sanitized_layer , layer_number)) ,) ; sanitizer :: ensure_mid_extension (& filename_base) }

- [ ] **Function 'extract_useful_description' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/naming/generator.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Extracts useful parts from original filename"] fn extract_useful_description (original_filename : & str) -> Option < String > { let without_ext = original_filename . trim_end_matches (".mid") . trim_end_matches (".MID") ; let prefixes = ["MIDI_" , "Track_" , "File_" , "Song_"] ; let mut cleaned = without_ext . to_string () ; for prefix in & prefixes { if cleaned . starts_with (prefix) { cleaned = cleaned [prefix . len () ..] . to_string () ; } } if ! cleaned . is_empty () && cleaned . len () > 3 { Some (cleaned) } else { None } }

- [ ] **Function 'resolve_naming_conflict' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/naming/generator.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Handles naming conflicts by appending counter"] # [doc = ""] # [doc = " # Arguments"] # [doc = " * `base_filename` - The desired filename"] # [doc = " * `existing_files` - List of existing filenames to check against"] # [doc = ""] # [doc = " # Returns"] # [doc = " * Unique filename that doesn't conflict with existing files"] pub fn resolve_naming_conflict (base_filename : & str , existing_files : & [String]) -> String { let without_ext = base_filename . trim_end_matches (".mid") ; if ! existing_files . contains (& base_filename . to_string ()) { return base_filename . to_string () ; } for i in 1 .. 1000 { let candidate = format ! ("{}_v{}.mid" , without_ext , i) ; if ! existing_files . contains (& candidate) { return candidate ; } } let timestamp = std :: time :: SystemTime :: now () . duration_since (std :: time :: UNIX_EPOCH) . unwrap_or_else (| _ | std :: time :: Duration :: from_secs (0)) . as_secs () ; format ! ("{}_{}.mid" , without_ext , timestamp) }

- [ ] **Function 'sanitize_filename' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/naming/sanitizer.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Filename Sanitization"] # [doc = ""] # [doc = " Ensures filenames are valid across all operating systems."] # [doc = " Sanitizes a string for use in filenames"] # [doc = ""] # [doc = " # Rules"] # [doc = " - Removes/replaces invalid characters"] # [doc = " - Limits length to 255 characters"] # [doc = " - Removes leading/trailing spaces"] # [doc = " - Converts to ASCII where possible"] # [doc = ""] # [doc = " # Arguments"] # [doc = " * `input` - String to sanitize"] # [doc = ""] # [doc = " # Returns"] # [doc = " * Sanitized string safe for filenames"] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " ```"] # [doc = " use pipeline::core::naming::sanitizer::sanitize_filename;"] # [doc = ""] # [doc = " let sanitized = sanitize_filename(\"my file<name>\");"] # [doc = " assert_eq!(sanitized, \"my_file_name_\");"] # [doc = " ```"] pub fn sanitize_filename (input : & str) -> String { let mut sanitized = input . to_string () ; sanitized = sanitized . chars () . map (| c | match c { '<' | '>' | ':' | '"' | '/' | '\\' | '|' | '?' | '*' => '_' , c if c . is_control () => '_' , c => c , }) . collect () ; sanitized = sanitized . trim () . to_string () ; while sanitized . contains ("  ") { sanitized = sanitized . replace ("  " , " ") ; } sanitized = sanitized . replace (' ' , "_") ; while sanitized . contains ("__") { sanitized = sanitized . replace ("__" , "_") ; } if sanitized . len () > 250 { sanitized . truncate (250) ; } sanitized = sanitized . trim_matches ('_') . to_string () ; if sanitized . is_empty () { sanitized = "untitled" . to_string () ; } sanitized }

- [ ] **Function 'clean_description' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/naming/sanitizer.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Removes common filler words from descriptions"] # [doc = ""] # [doc = " # Arguments"] # [doc = " * `description` - Description text to clean"] # [doc = ""] # [doc = " # Returns"] # [doc = " * Description with filler words removed"] pub fn clean_description (description : & str) -> String { let filler_words = ["untitled" , "new" , "midi" , "file" , "song" , "track" , "the" , "a" , "an" , "and" , "or" , "but" ,] ; let words : Vec < & str > = description . split ('_') . filter (| word | { let lower = word . to_lowercase () ; ! filler_words . contains (& lower . as_str ()) && ! lower . is_empty () }) . collect () ; words . join ("_") }

- [ ] **Function 'ensure_mid_extension' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/naming/sanitizer.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Ensures filename has .mid extension (converts .midi to .mid)"] # [doc = ""] # [doc = " # Arguments"] # [doc = " * `filename` - Filename to check"] # [doc = ""] # [doc = " # Returns"] # [doc = " * Filename with .mid extension"] pub fn ensure_mid_extension (filename : & str) -> String { if filename . to_lowercase () . ends_with (".mid") { filename . to_string () } else if filename . to_lowercase () . ends_with (".midi") { let stem = & filename [.. filename . len () - 5] ; format ! ("{}.mid" , stem) } else { format ! ("{}.mid" , filename) } }

- [ ] **Function 'sanitize_strict' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/naming/sanitizer.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Phase 0 Sanitization: Strict filename cleaning for post-extraction"] # [doc = ""] # [doc = " This is the FIRST renaming phase, applied immediately after archive extraction."] # [doc = " Rules:"] # [doc = " - Replace spaces with underscores"] # [doc = " - Convert .midi to .mid"] # [doc = " - Convert .MID to .mid (force lowercase)"] # [doc = " - Keep ONLY: letters, numbers, underscores, hyphens"] # [doc = " - Remove all other special characters"] # [doc = ""] # [doc = " # Arguments"] # [doc = " * `filename` - Original filename from archive"] # [doc = ""] # [doc = " # Returns"] # [doc = " * Sanitized filename safe for filesystem operations"] # [doc = ""] # [doc = " # Examples"] # [doc = " ```"] # [doc = " use pipeline::core::naming::sanitizer::sanitize_strict;"] # [doc = ""] # [doc = " assert_eq!(sanitize_strict(\"My Song (2023).midi\"), \"My_Song_2023.mid\");"] # [doc = " assert_eq!(sanitize_strict(\"My Song (2023).MID\"), \"My_Song_2023.mid\");"] # [doc = " assert_eq!(sanitize_strict(\"bass & lead!.mid\"), \"bass_lead.mid\");"] # [doc = " assert_eq!(sanitize_strict(\"file#1@test.mid\"), \"file1test.mid\");"] # [doc = " ```"] pub fn sanitize_strict (filename : & str) -> String { let (name , ext) = if let Some (pos) = filename . rfind ('.') { (& filename [.. pos] , & filename [pos ..]) } else { (filename , "") } ; let mut sanitized = name . replace (' ' , "_") ; sanitized = sanitized . chars () . filter (| c | c . is_alphanumeric () || * c == '_' || * c == '-' || * c == '.') . collect () ; loop { let before = sanitized . clone () ; sanitized = sanitized . replace ("__" , "_") ; sanitized = sanitized . replace ("--" , "-") ; sanitized = sanitized . replace (".." , ".") ; sanitized = sanitized . replace ("_-" , "_") ; sanitized = sanitized . replace ("-_" , "_") ; sanitized = sanitized . replace ("_." , "_") ; sanitized = sanitized . replace ("._" , "_") ; sanitized = sanitized . replace ("-." , "-") ; sanitized = sanitized . replace (".-" , "-") ; if before == sanitized { break ; } } sanitized = sanitized . trim_matches (| c | c == '_' || c == '-') . to_string () ; if sanitized . len () > 250 { sanitized . truncate (250) ; sanitized = sanitized . trim_matches (| c | c == '_' || c == '-') . to_string () ; } if sanitized . is_empty () { sanitized = "untitled" . to_string () ; } let final_ext = if ext . to_lowercase () == ".midi" || ext . to_lowercase () == ".mid" { ".mid" } else if ! ext . is_empty () { ext } else { ".mid" } ; format ! ("{}{}" , sanitized , final_ext) }

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/naming/sanitizer.rs`
  - Category: Performance

- [ ] **Function 'apply_template' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/naming/templates.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Applies template to metadata"] # [doc = ""] # [doc = " # Arguments"] # [doc = " * `template` - The naming template to use"] # [doc = " * `category` - File category (e.g., BASS, KICK, CHORD)"] # [doc = " * `key` - Musical key (e.g., C, Am, F#)"] # [doc = " * `bpm` - Beats per minute"] # [doc = " * `description` - Optional description text"] # [doc = " * `id` - File identifier"] # [doc = ""] # [doc = " # Returns"] # [doc = " * Formatted filename string (without extension)"] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " ```"] # [doc = " use pipeline::core::naming::templates::{NamingTemplate, apply_template};"] # [doc = ""] # [doc = " let result = apply_template("] # [doc = "     &NamingTemplate::Standard,"] # [doc = "     \"BASS\","] # [doc = "     \"Cm\","] # [doc = "     140.0,"] # [doc = "     \"Deep_Rolling\","] # [doc = "     \"001\""] # [doc = " );"] # [doc = " assert_eq!(result, \"BASS_Cm_140BPM_Deep_Rolling_001\");"] # [doc = " ```"] pub fn apply_template (template : & NamingTemplate , category : & str , key : & str , bpm : f64 , description : & str , id : & str ,) -> String { apply_template_extended (template , category , key , bpm , description , id , None , None , None , None ,) }

- [ ] **Function 'apply_template_extended' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/naming/templates.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Extended template application with additional metadata"] # [doc = ""] # [doc = " # Arguments"] # [doc = " * `template` - The naming template to use"] # [doc = " * `category` - File category"] # [doc = " * `key` - Musical key"] # [doc = " * `bpm` - Beats per minute"] # [doc = " * `description` - Optional description"] # [doc = " * `id` - File identifier"] # [doc = " * `timesig` - Optional time signature (e.g., \"4-4\", \"6-8\")"] # [doc = " * `pack` - Optional pack/folder name"] # [doc = " * `original` - Optional original filename"] # [doc = " * `layer_info` - Optional (layer_name, layer_number) for split files"] # [doc = ""] # [doc = " # Returns"] # [doc = " * Formatted filename string (without extension)"] pub fn apply_template_extended (template : & NamingTemplate , category : & str , key : & str , bpm : f64 , description : & str , id : & str , timesig : Option < & str > , pack : Option < & str > , original : Option < & str > , layer_info : Option < (& str , usize) > ,) -> String { match template { NamingTemplate :: Standard => { format ! ("{}_{}_{:.0}BPM_{}_{}" , category , key , bpm , description , id) } , NamingTemplate :: Compact => { format ! ("{}_{}_{:.0}BPM_{}" , category , key , bpm , id) } , NamingTemplate :: BpmFirst => { format ! ("{:.0}BPM_{}_{}_{}" , bpm , key , category , description) } , NamingTemplate :: Production => { let timesig_str = timesig . unwrap_or ("4-4") ; let pack_str = pack . unwrap_or ("Unknown") ; let mut result = format ! ("{}_{}_{:.0}BPM_{}_{}_{}" , category , timesig_str , bpm , key , id , pack_str) ; if let Some ((layer_name , layer_num)) = layer_info { result . push_str (& format ! ("_{}_L{:02}" , layer_name , layer_num)) ; } else if let Some (orig) = original { result . push_str (& format ! ("_{}" , orig)) ; } result } , NamingTemplate :: Custom (template_str) => template_str . replace ("{CATEGORY}" , category) . replace ("{KEY}" , key) . replace ("{BPM}" , & format ! ("{:.0}" , bpm)) . replace ("{DESCRIPTION}" , description) . replace ("{ID}" , id) . replace ("{TIMESIG}" , timesig . unwrap_or ("4-4")) . replace ("{PACK}" , pack . unwrap_or ("Unknown")) . replace ("{ORIGINAL}" , original . unwrap_or ("")) , } }

- [ ] **Function 'sanitize_mpc_compatible' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/normalization/filename.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Sanitize filename to MPC-compatible characters only"] # [doc = ""] # [doc = " MPC ONE/Live/X allowed characters:"] # [doc = " - Letters: A-Z, a-z"] # [doc = " - Numbers: 0-9"] # [doc = " - Hyphens: -"] # [doc = " - Underscores: _"] # [doc = " - Periods: . (for extension only)"] # [doc = ""] # [doc = " All other characters (parentheses, brackets, symbols, etc.) are replaced with underscores"] fn sanitize_mpc_compatible (s : & str) -> String { s . chars () . map (| c | { if c . is_ascii_alphanumeric () || c == '-' || c == '_' || c == '.' { c } else { '_' } }) . collect () }

- [ ] **Function 'normalize_file' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/normalization/filename.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Normalize a single MIDI file on disk"] fn normalize_file (path : & Path , stats : & NormalizationStats ,) -> Result < () , Box < dyn std :: error :: Error > > { let parent = path . parent () . ok_or ("No parent directory") ? ; let filename = path . file_name () . ok_or ("No filename") ? . to_string_lossy () ; let mut new_filename = filename . to_string () ; let mut changed = false ; let lowercase = filename . to_lowercase () ; if filename . ends_with (".MIDI") { new_filename = filename [.. filename . len () - 5] . to_string () + ".mid" ; changed = true ; stats . extensions_fixed . fetch_add (1 , Ordering :: Relaxed) ; } else if filename . ends_with (".MID") && ! lowercase . ends_with (".mid") { new_filename = filename [.. filename . len () - 4] . to_string () + ".mid" ; changed = true ; stats . extensions_fixed . fetch_add (1 , Ordering :: Relaxed) ; } else if filename . ends_with (".midi") && filename != lowercase { new_filename = filename [.. filename . len () - 5] . to_string () + ".mid" ; changed = true ; stats . extensions_fixed . fetch_add (1 , Ordering :: Relaxed) ; } else if filename . ends_with (".MiD") || filename . ends_with (".Midi") { let stem_len = if filename . ends_with (".MiD") { 4 } else { 5 } ; new_filename = filename [.. filename . len () - stem_len] . to_string () + ".mid" ; changed = true ; stats . extensions_fixed . fetch_add (1 , Ordering :: Relaxed) ; } if new_filename . contains (' ') { new_filename = new_filename . replace (' ' , "_") ; changed = true ; stats . spaces_fixed . fetch_add (1 , Ordering :: Relaxed) ; } let sanitized = sanitize_mpc_compatible (& new_filename) ; if sanitized != new_filename { new_filename = sanitized ; changed = true ; stats . encoding_fixed . fetch_add (1 , Ordering :: Relaxed) ; } if changed { let mut final_path = parent . join (& new_filename) ; let mut counter = 1 ; while final_path . exists () && final_path != path { let stem = Path :: new (& new_filename) . file_stem () . unwrap () . to_string_lossy () ; let ext = Path :: new (& new_filename) . extension () . map (| e | e . to_string_lossy ()) . unwrap_or_default () ; final_path = parent . join (format ! ("{}_{}.{}" , stem , counter , ext)) ; counter += 1 ; } if final_path != path { fs :: rename (path , & final_path) ? ; } } stats . total_files . fetch_add (1 , Ordering :: Relaxed) ; Ok (()) }

- [ ] **Function 'normalize_directory' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/normalization/filename.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Normalize all MIDI files in a directory (recursive)"] # [doc = ""] # [doc = " # Arguments"] # [doc = " * `dir` - Directory to normalize"] # [doc = " * `workers` - Number of parallel workers (0 = auto-detect CPU cores)"] # [doc = ""] # [doc = " # Returns"] # [doc = " * `NormalizationStats` - Statistics about the normalization"] pub fn normalize_directory (dir : & Path , workers : usize ,) -> Result < NormalizationStats , Box < dyn std :: error :: Error > > { if workers > 0 { rayon :: ThreadPoolBuilder :: new () . num_threads (workers) . build_global () . ok () ; } let stats = NormalizationStats :: default () ; let files : Vec < PathBuf > = WalkDir :: new (dir) . follow_links (false) . into_iter () . filter_map (| e | e . ok ()) . filter (| e | e . file_type () . is_file ()) . filter (| e | { let name = e . file_name () . to_string_lossy () . to_lowercase () ; name . ends_with (".mid") || name . ends_with (".midi") }) . map (| e | e . path () . to_path_buf ()) . collect () ; files . par_iter () . for_each (| path | { if let Err (e) = normalize_file (path , & stats) { eprintln ! ("  âš ï¸  Error normalizing {:?}: {}" , path , e) ; stats . errors . fetch_add (1 , Ordering :: Relaxed) ; } }) ; Ok (stats) }

- [ ] **Function 'detect_system_resources' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/performance/concurrency.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Automatically detect system resources."] # [doc = ""] # [doc = " This function queries the operating system to determine:"] # [doc = " - CPU core count (logical cores including hyperthreading)"] # [doc = " - Available system memory"] # [doc = " - Primary disk type (SSD vs HDD)"] # [doc = ""] # [doc = " # Returns"] # [doc = ""] # [doc = " A `SystemResources` struct with detected values."] # [doc = ""] # [doc = " # Fallback Behavior"] # [doc = ""] # [doc = " If detection fails:"] # [doc = " - CPU cores: Falls back to 4"] # [doc = " - Memory: Falls back to 8.0 GB"] # [doc = " - SSD: Assumes true (conservative for performance)"] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " ```"] # [doc = " use pipeline::core::performance::concurrency::detect_system_resources;"] # [doc = ""] # [doc = " let resources = detect_system_resources();"] # [doc = " println!(\"Detected {} CPU cores\", resources.cpu_cores);"] # [doc = " println!(\"Available memory: {:.2} GB\", resources.available_memory_gb);"] # [doc = " println!(\"SSD: {}\", resources.is_ssd);"] # [doc = " ```"] pub fn detect_system_resources () -> SystemResources { let cpu_cores = thread :: available_parallelism () . map (| n | n . get ()) . unwrap_or (4) ; let sys = System :: new_all () ; let total_memory_bytes = sys . total_memory () ; let available_memory_gb = (total_memory_bytes as f64) / (1024.0 * 1024.0 * 1024.0) ; let is_ssd = true ; SystemResources { cpu_cores , available_memory_gb , is_ssd } }

- [ ] **Function 'calculate_optimal_concurrency' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/performance/concurrency.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Calculate the optimal concurrency limit based on system resources."] # [doc = ""] # [doc = " This function implements a multi-factor formula to determine the ideal"] # [doc = " number of concurrent file processing workers."] # [doc = ""] # [doc = " # Algorithm"] # [doc = ""] # [doc = " 1. Start with CPU-based baseline: `cpu_cores Ã— 2`"] # [doc = " 2. Apply memory constraints:"] # [doc = "    - If RAM < 4GB: divide by 4"] # [doc = "    - If RAM < 6GB: divide by 2"] # [doc = "    - If RAM >= 8GB: no reduction"] # [doc = " 3. Apply storage type cap:"] # [doc = "    - HDD: cap at 50"] # [doc = "    - SSD: cap at 100"] # [doc = " 4. Clamp to absolute bounds [10, 100]"] # [doc = ""] # [doc = " # Arguments"] # [doc = ""] # [doc = " * `resources` - System resource information"] # [doc = ""] # [doc = " # Returns"] # [doc = ""] # [doc = " Optimal concurrency limit (10-100)"] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " ```"] # [doc = " use pipeline::core::performance::concurrency::{SystemResources, calculate_optimal_concurrency};"] # [doc = ""] # [doc = " // High-end system: 16 cores, 32GB RAM, SSD"] # [doc = " let resources = SystemResources::new(16, 32.0, true);"] # [doc = " let concurrency = calculate_optimal_concurrency(&resources);"] # [doc = " assert_eq!(concurrency, 32); // 16 Ã— 2, no constraints"] # [doc = ""] # [doc = " // Low-end system: 4 cores, 4GB RAM, HDD"] # [doc = " let resources = SystemResources::new(4, 4.0, false);"] # [doc = " let concurrency = calculate_optimal_concurrency(&resources);"] # [doc = " assert_eq!(concurrency, 10); // Limited by memory and minimum bound"] # [doc = " ```"] pub fn calculate_optimal_concurrency (resources : & SystemResources) -> usize { let mut concurrency = resources . cpu_cores * 2 ; if resources . available_memory_gb < 4.0 { concurrency /= 4 ; } else if resources . available_memory_gb < 6.0 { concurrency /= 2 ; } let storage_cap = if resources . is_ssd { 100 } else { 50 } ; concurrency = concurrency . min (storage_cap) ; concurrency . clamp (10 , 100) }

- [ ] **Function 'calculate_database_pool_size' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/performance/concurrency.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Calculate the optimal database connection pool size."] # [doc = ""] # [doc = " The pool size should support concurrent operations plus some overhead"] # [doc = " for connection management and potential contention."] # [doc = ""] # [doc = " # Formula"] # [doc = ""] # [doc = " `pool_size = (concurrency Ã— 1.5).clamp(20, 200)`"] # [doc = ""] # [doc = " - 1.5Ã— multiplier: Provides headroom for connection recycling"] # [doc = " - Minimum 20: Ensures adequate connections even on small systems"] # [doc = " - Maximum 200: Prevents PostgreSQL connection exhaustion"] # [doc = ""] # [doc = " # Arguments"] # [doc = ""] # [doc = " * `concurrency` - Target concurrency limit"] # [doc = ""] # [doc = " # Returns"] # [doc = ""] # [doc = " Optimal database connection pool size (20-200)"] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " ```"] # [doc = " use pipeline::core::performance::concurrency::calculate_database_pool_size;"] # [doc = ""] # [doc = " let pool_size = calculate_database_pool_size(50);"] # [doc = " assert_eq!(pool_size, 75); // 50 Ã— 1.5"] # [doc = ""] # [doc = " let pool_size = calculate_database_pool_size(10);"] # [doc = " assert_eq!(pool_size, 20); // Clamped to minimum"] # [doc = ""] # [doc = " let pool_size = calculate_database_pool_size(150);"] # [doc = " assert_eq!(pool_size, 200); // Clamped to maximum"] # [doc = " ```"] pub fn calculate_database_pool_size (concurrency : usize) -> usize { let pool_size = (concurrency as f64 * 1.5) as usize ; pool_size . clamp (20 , 200) }

- [ ] **Function 'calculate_batch_size' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/performance/concurrency.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Calculate the optimal batch size for database operations."] # [doc = ""] # [doc = " Larger batches reduce transaction overhead but increase memory usage"] # [doc = " and potential lock contention. The optimal size balances these factors."] # [doc = ""] # [doc = " # Formula"] # [doc = ""] # [doc = " `batch_size = (concurrency Ã— 100).clamp(500, 10000)`"] # [doc = ""] # [doc = " - 100Ã— multiplier: Each worker can handle ~100 records per batch"] # [doc = " - Minimum 500: Ensures meaningful batch performance improvement"] # [doc = " - Maximum 10,000: Prevents excessive memory usage and lock duration"] # [doc = ""] # [doc = " # Arguments"] # [doc = ""] # [doc = " * `concurrency` - Target concurrency limit"] # [doc = ""] # [doc = " # Returns"] # [doc = ""] # [doc = " Optimal batch size for database inserts (500-10,000)"] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " ```"] # [doc = " use pipeline::core::performance::concurrency::calculate_batch_size;"] # [doc = ""] # [doc = " let batch_size = calculate_batch_size(50);"] # [doc = " assert_eq!(batch_size, 5000); // 50 Ã— 100"] # [doc = ""] # [doc = " let batch_size = calculate_batch_size(10);"] # [doc = " assert_eq!(batch_size, 1000); // 10 Ã— 100"] # [doc = ""] # [doc = " let batch_size = calculate_batch_size(150);"] # [doc = " assert_eq!(batch_size, 10000); // Clamped to maximum"] # [doc = " ```"] pub fn calculate_batch_size (concurrency : usize) -> usize { let batch_size = concurrency * 100 ; batch_size . clamp (500 , 10_000) }

- [ ] **Function 'calculate_all_settings' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/performance/concurrency.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Calculate all performance settings in one call."] # [doc = ""] # [doc = " This is a convenience function that calculates optimal concurrency,"] # [doc = " database pool size, and batch size based on detected system resources."] # [doc = ""] # [doc = " # Returns"] # [doc = ""] # [doc = " Tuple of (concurrency, pool_size, batch_size)"] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " ```"] # [doc = " use pipeline::core::performance::concurrency::calculate_all_settings;"] # [doc = ""] # [doc = " let (concurrency, pool_size, batch_size) = calculate_all_settings();"] # [doc = " println!(\"Concurrency: {}\", concurrency);"] # [doc = " println!(\"DB Pool: {}\", pool_size);"] # [doc = " println!(\"Batch Size: {}\", batch_size);"] # [doc = " ```"] pub fn calculate_all_settings () -> (usize , usize , usize) { let resources = detect_system_resources () ; let concurrency = calculate_optimal_concurrency (& resources) ; let pool_size = calculate_database_pool_size (concurrency) ; let batch_size = calculate_batch_size (concurrency) ; (concurrency , pool_size , batch_size) }

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/pipeline/orchestrator.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/pipeline/orchestrator.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/pipeline/orchestrator.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/pipeline/orchestrator.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/pipeline/orchestrator.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/pipeline/orchestrator.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/pipeline/orchestrator.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/pipeline/orchestrator.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/pipeline/orchestrator.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/pipeline/workers/analyze.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/pipeline/workers/export.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/pipeline/workers/export.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/pipeline/workers/export.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/pipeline/workers/import.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/pipeline/workers/import.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/pipeline/workers/import.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/pipeline/workers/import.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/pipeline/workers/rename.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/pipeline/workers/sanitize.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/pipeline/workers/sanitize.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/pipeline/workers/split.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/pipeline/workers/split.rs`
  - Category: Performance

- [ ] **Function 'split_tracks_with_repair' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/splitting/auto_repair.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Split tracks with automatic repair on failure."] # [doc = ""] # [doc = " This function attempts to split MIDI tracks, and if that fails due to"] # [doc = " corruption, it automatically attempts to repair the file and retry the split."] # [doc = ""] # [doc = " # Workflow"] # [doc = " 1. Try to split tracks normally"] # [doc = " 2. If split fails, attempt to repair the file"] # [doc = " 3. If repair succeeds, retry the split operation"] # [doc = " 4. Return split tracks with repair information"] # [doc = ""] # [doc = " # Arguments"] # [doc = ""] # [doc = " * `midi_bytes` - Complete MIDI file as byte slice"] # [doc = ""] # [doc = " # Returns"] # [doc = ""] # [doc = " `Ok((tracks, repair_result))` with the split tracks and repair status"] # [doc = " `Err(AutoRepairError)` if the file is corrupt and unrepairable"] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " ```"] # [doc = " use pipeline::core::splitting::auto_repair::split_tracks_with_repair;"] # [doc = ""] # [doc = " let midi_bytes = include_bytes!(\"test_data/corrupt.mid\");"] # [doc = " match split_tracks_with_repair(midi_bytes) {"] # [doc = "     Ok((tracks, repair_result)) => {"] # [doc = "         println!(\"Split {} tracks\", tracks.len());"] # [doc = "         match repair_result {"] # [doc = "             RepairResult::Valid => println!(\"File was valid\"),"] # [doc = "             RepairResult::Repaired { fix_description, .. } => {"] # [doc = "                 println!(\"Repaired: {}\", fix_description);"] # [doc = "             },"] # [doc = "             _ => {}"] # [doc = "         }"] # [doc = "     },"] # [doc = "     Err(e) => eprintln!(\"Failed to split: {}\", e),"] # [doc = " }"] # [doc = " # Ok::<(), pipeline::core::splitting::auto_repair::AutoRepairError>(())"] # [doc = " ```"] pub fn split_tracks_with_repair (midi_bytes : & [u8] ,) -> Result < (Vec < SplitTrack > , RepairResult) , AutoRepairError > { match split_tracks (midi_bytes) { Ok (tracks) => Ok ((tracks , RepairResult :: Valid)) , Err (original_error) => { match attempt_repair (midi_bytes) { Ok ((repaired_bytes , fix_description)) => { match split_tracks (& repaired_bytes) { Ok (tracks) => Ok ((tracks , RepairResult :: Repaired { fix_description : fix_description . clone () , repaired_bytes : repaired_bytes . clone () , } ,)) , Err (repair_split_error) => Err (AutoRepairError :: RepairFailed (format ! ("Original error: {}. Repair attempted: {}. Post-repair error: {}" , original_error , fix_description , repair_split_error))) , } } , Err (repair_error) => Err (AutoRepairError :: UnrepairableCorruption (format ! ("Original error: {}. Repair error: {}" , original_error , repair_error))) , } } , } }

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/splitting/auto_repair.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/splitting/auto_repair.rs`
  - Category: Performance

- [ ] **Function 'attempt_repair' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/splitting/auto_repair.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Attempt to repair common MIDI file corruption issues."] # [doc = ""] # [doc = " Applies the following fixes in order:"] # [doc = " 1. Add missing End-of-Track markers (0xFF 0x2F 0x00)"] # [doc = " 2. Trim trailing garbage data after the last track"] # [doc = ""] # [doc = " # Arguments"] # [doc = ""] # [doc = " * `data` - Original MIDI file bytes"] # [doc = ""] # [doc = " # Returns"] # [doc = ""] # [doc = " `Ok((repaired_bytes, fix_description))` if repair was successful"] # [doc = " `Err(reason)` if no repair was needed or possible"] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " ```"] # [doc = " use pipeline::core::splitting::auto_repair::attempt_repair;"] # [doc = ""] # [doc = " let corrupt_midi = b\"MThd...\"; // Corrupt MIDI bytes"] # [doc = " match attempt_repair(corrupt_midi) {"] # [doc = "     Ok((repaired, desc)) => println!(\"Fixed: {}\", desc),"] # [doc = "     Err(e) => println!(\"Cannot repair: {}\", e),"] # [doc = " }"] # [doc = " ```"] pub fn attempt_repair (data : & [u8]) -> Result < (Vec < u8 > , String) , String > { let mut repaired = data . to_vec () ; let mut fixes = Vec :: new () ; if repaired . len () < 14 { return Err (format ! ("File too small ({} bytes, need 14+)" , repaired . len ())) ; } if & repaired [0 .. 4] != b"MThd" { return Err ("Not a MIDI file (missing MThd header)" . to_string ()) ; } if repaired . len () >= 14 { if & repaired [0 .. 4] == b"MThd" { let mut pos = 14 ; while pos < repaired . len () { if pos + 8 > repaired . len () { break ; } if & repaired [pos .. pos + 4] == b"MTrk" { let track_len = u32 :: from_be_bytes ([repaired [pos + 4] , repaired [pos + 5] , repaired [pos + 6] , repaired [pos + 7] ,]) as usize ; let track_end = pos + 8 + track_len ; if track_end <= repaired . len () { let has_eot = if track_end >= 3 { & repaired [track_end - 3 .. track_end] == & [0xFF , 0x2F , 0x00] } else { false } ; if ! has_eot && track_end < repaired . len () { repaired . splice (track_end .. track_end , [0xFF , 0x2F , 0x00] . iter () . cloned ()) ; let new_len = track_len + 3 ; let len_bytes = (new_len as u32) . to_be_bytes () ; repaired [pos + 4] = len_bytes [0] ; repaired [pos + 5] = len_bytes [1] ; repaired [pos + 6] = len_bytes [2] ; repaired [pos + 7] = len_bytes [3] ; fixes . push ("Added missing End-of-Track marker" . to_string ()) ; } pos = track_end ; } else { break ; } } else { pos += 1 ; } } } } if repaired . len () > 14 && & repaired [0 .. 4] == b"MThd" { let header_len = u32 :: from_be_bytes ([repaired [4] , repaired [5] , repaired [6] , repaired [7]]) as usize ; if header_len == 6 { let num_tracks = u16 :: from_be_bytes ([repaired [10] , repaired [11]]) as usize ; let mut expected_size = 14 ; let mut pos = 14 ; for _ in 0 .. num_tracks { if pos + 8 > repaired . len () { break ; } if & repaired [pos .. pos + 4] == b"MTrk" { let track_len = u32 :: from_be_bytes ([repaired [pos + 4] , repaired [pos + 5] , repaired [pos + 6] , repaired [pos + 7] ,]) as usize ; expected_size = pos + 8 + track_len ; pos = expected_size ; } else { break ; } } if expected_size < repaired . len () { let trimmed = repaired . len () - expected_size ; repaired . truncate (expected_size) ; fixes . push (format ! ("Trimmed {} bytes of trailing garbage" , trimmed)) ; } } } if fixes . is_empty () { Err ("No repairs needed or possible" . to_string ()) } else { Ok ((repaired , fixes . join (", "))) } }

- [ ] **Function 'split_tracks' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/splitting/track_splitter.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Split multi-track MIDI file into individual single-track files."] # [doc = ""] # [doc = " Parses a MIDI file and creates separate Format 0 (single-track) MIDI files"] # [doc = " for each music track. Skips tempo-only tracks (Track 0 in Format 1 files)."] # [doc = " Preserves tempo, time signature, and key signature from the original file."] # [doc = ""] # [doc = " # Arguments"] # [doc = ""] # [doc = " * `original_midi_bytes` - Complete MIDI file as byte slice"] # [doc = ""] # [doc = " # Returns"] # [doc = ""] # [doc = " Vector of `SplitTrack` structs, one for each music track found."] # [doc = " Returns error if parsing fails or no music tracks exist."] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " ```"] # [doc = " use pipeline::core::splitting::track_splitter::split_tracks;"] # [doc = ""] # [doc = " // Parse multi-track MIDI"] # [doc = " let midi_bytes = include_bytes!(\"test_data/multitrack.mid\");"] # [doc = " let tracks = split_tracks(midi_bytes)?;"] # [doc = ""] # [doc = " for track in tracks {"] # [doc = "     println!(\"Track {}: {} notes\", track.track_number, track.note_count);"] # [doc = "     if let Some(name) = track.track_name {"] # [doc = "         println!(\"  Name: {}\", name);"] # [doc = "     }"] # [doc = " }"] # [doc = " # Ok::<(), pipeline::core::splitting::track_splitter::SplitError>(())"] # [doc = " ```"] pub fn split_tracks (original_midi_bytes : & [u8]) -> Result < Vec < SplitTrack > , SplitError > { let smf = Smf :: parse (original_midi_bytes) . map_err (| e | SplitError :: ParseError (format ! ("midly parse error: {}" , e))) ? ; if smf . header . format == Format :: SingleTrack { let track = & smf . tracks [0] ; let note_count = count_notes (track) ; if note_count == 0 { return Err (SplitError :: NoTracksToSplit) ; } return Ok (vec ! [SplitTrack { track_number : 0 , track_name : extract_track_name (track) , channel : extract_primary_channel (track) , instrument : extract_instrument (track) , note_count , midi_bytes : original_midi_bytes . to_vec () , }]) ; } let mut split_tracks = Vec :: new () ; for (idx , track) in smf . tracks . iter () . enumerate () { if is_tempo_track (track) { continue ; } let note_count = count_notes (track) ; if note_count == 0 { continue ; } let midi_bytes = create_single_track_midi (& smf , track , idx) ? ; split_tracks . push (SplitTrack { track_number : idx , track_name : extract_track_name (track) , channel : extract_primary_channel (track) , instrument : extract_instrument (track) , note_count , midi_bytes , }) ; } if split_tracks . is_empty () { return Err (SplitError :: NoTracksToSplit) ; } Ok (split_tracks) }

- [ ] **Function 'is_tempo_track' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/splitting/track_splitter.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Check if a track is a tempo-only track."] # [doc = ""] # [doc = " Tempo tracks contain only meta events (tempo, time signature, key signature)"] # [doc = " and no note events. Common in Format 1 MIDI files as Track 0."] # [doc = ""] # [doc = " # Arguments"] # [doc = ""] # [doc = " * `track` - MIDI track to analyze"] # [doc = ""] # [doc = " # Returns"] # [doc = ""] # [doc = " `true` if track contains only meta events, `false` otherwise"] pub fn is_tempo_track (track : & Track) -> bool { let mut has_meta_events = false ; let mut has_note_events = false ; for event in track . iter () { match event . kind { TrackEventKind :: Meta (_) => has_meta_events = true , TrackEventKind :: Midi { message , .. } => { use midly :: MidiMessage ; match message { MidiMessage :: NoteOn { .. } | MidiMessage :: NoteOff { .. } => { has_note_events = true ; break ; } , _ => { } , } } , _ => { } , } } has_meta_events && ! has_note_events }

- [ ] **Function 'create_single_track_midi' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/splitting/track_splitter.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Create a Format 0 (single-track) MIDI file from a single track."] # [doc = ""] # [doc = " Merges tempo/time signature/key signature events from Track 0 (if Format 1)"] # [doc = " with the music events from the specified track. Creates a valid Format 0 MIDI file."] # [doc = ""] # [doc = " # Arguments"] # [doc = ""] # [doc = " * `original` - Original parsed MIDI file"] # [doc = " * `track` - Track to extract"] # [doc = " * `track_idx` - Index of the track (for reference)"] # [doc = ""] # [doc = " # Returns"] # [doc = ""] # [doc = " Complete Format 0 MIDI file as bytes"] pub fn create_single_track_midi (original : & Smf , track : & Track , track_idx : usize ,) -> Result < Vec < u8 > , SplitError > { let new_header = Header { format : Format :: SingleTrack , timing : original . header . timing } ; let mut new_track_events = Vec :: new () ; if original . header . format == Format :: Parallel && track_idx > 0 && ! original . tracks . is_empty () { let track_0 = & original . tracks [0] ; for event in track_0 . iter () { match event . kind { TrackEventKind :: Meta (MetaMessage :: Tempo (_)) | TrackEventKind :: Meta (MetaMessage :: TimeSignature (..)) | TrackEventKind :: Meta (MetaMessage :: KeySignature (..)) => { new_track_events . push (* event) ; } , _ => { } , } } } new_track_events . extend (track . iter () . cloned ()) ; let has_end_of_track = new_track_events . iter () . any (| e | matches ! (e . kind , TrackEventKind :: Meta (MetaMessage :: EndOfTrack))) ; if ! has_end_of_track { new_track_events . push (TrackEvent { delta : 0 . into () , kind : TrackEventKind :: Meta (MetaMessage :: EndOfTrack) , }) ; } let new_smf = Smf { header : new_header , tracks : vec ! [new_track_events] } ; let mut bytes = Vec :: new () ; new_smf . write_std (& mut bytes) . map_err (| e | SplitError :: WriteError (format ! ("midly write error: {}" , e))) ? ; Ok (bytes) }

- [ ] **Function 'extract_track_name' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/splitting/track_splitter.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Extract track name from meta events."] # [doc = ""] # [doc = " Searches for TrackName or InstrumentName meta events."] # [doc = ""] # [doc = " # Arguments"] # [doc = ""] # [doc = " * `track` - MIDI track to analyze"] # [doc = ""] # [doc = " # Returns"] # [doc = ""] # [doc = " Track name if found, `None` otherwise"] pub fn extract_track_name (track : & Track) -> Option < String > { for event in track . iter () { if let TrackEventKind :: Meta (MetaMessage :: TrackName (name) | MetaMessage :: InstrumentName (name) ,) = & event . kind { if let Ok (name_str) = String :: from_utf8 (name . to_vec ()) { let trimmed = name_str . trim () ; if ! trimmed . is_empty () { return Some (trimmed . to_string ()) ; } } } } None }

- [ ] **Function 'extract_primary_channel' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/splitting/track_splitter.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Extract the primary MIDI channel used by this track."] # [doc = ""] # [doc = " Analyzes all MIDI messages and returns the most frequently used channel."] # [doc = ""] # [doc = " # Arguments"] # [doc = ""] # [doc = " * `track` - MIDI track to analyze"] # [doc = ""] # [doc = " # Returns"] # [doc = ""] # [doc = " Most frequently used channel (0-15), or `None` if no MIDI messages found"] pub fn extract_primary_channel (track : & Track) -> Option < u8 > { let mut channel_counts = [0u32 ; 16] ; for event in track . iter () { if let TrackEventKind :: Midi { channel , .. } = event . kind { channel_counts [channel . as_int () as usize] += 1 ; } } let max_channel = channel_counts . iter () . enumerate () . max_by_key (| (_ , & count) | count) ? ; if max_channel . 1 > & 0 { Some (max_channel . 0 as u8) } else { None } }

- [ ] **Function 'extract_instrument' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/splitting/track_splitter.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Extract instrument name from Program Change events."] # [doc = ""] # [doc = " Searches for the first Program Change event and maps to General MIDI instrument name."] # [doc = ""] # [doc = " # Arguments"] # [doc = ""] # [doc = " * `track` - MIDI track to analyze"] # [doc = ""] # [doc = " # Returns"] # [doc = ""] # [doc = " General MIDI instrument name, or `None` if no Program Change found"] pub fn extract_instrument (track : & Track) -> Option < String > { for event in track . iter () { if let TrackEventKind :: Midi { message , .. } = & event . kind { use midly :: MidiMessage ; if let MidiMessage :: ProgramChange { program } = message { return Some (get_instrument_name (program . as_int ())) ; } } } None }

- [ ] **Function 'count_notes' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/splitting/track_splitter.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Count note-on events in a track."] # [doc = ""] # [doc = " # Arguments"] # [doc = ""] # [doc = " * `track` - MIDI track to analyze"] # [doc = ""] # [doc = " # Returns"] # [doc = ""] # [doc = " Number of note-on events with velocity > 0"] pub fn count_notes (track : & Track) -> usize { let mut count = 0 ; for event in track . iter () { if let TrackEventKind :: Midi { message , .. } = & event . kind { use midly :: MidiMessage ; if let MidiMessage :: NoteOn { vel , .. } = message { if vel . as_int () > 0 { count += 1 ; } } } } count }

- [ ] **Function 'get_instrument_name' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/splitting/track_splitter.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Get General MIDI instrument name from program number."] # [doc = ""] # [doc = " Maps GM program numbers (0-127) to standard instrument names."] # [doc = ""] # [doc = " # Arguments"] # [doc = ""] # [doc = " * `program` - GM program number (0-127)"] # [doc = ""] # [doc = " # Returns"] # [doc = ""] # [doc = " General MIDI instrument name"] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " ```"] # [doc = " use pipeline::core::splitting::track_splitter::get_instrument_name;"] # [doc = ""] # [doc = " assert_eq!(get_instrument_name(0), \"Acoustic Grand Piano\");"] # [doc = " assert_eq!(get_instrument_name(25), \"Acoustic Guitar (nylon)\");"] # [doc = " assert_eq!(get_instrument_name(127), \"Gunshot\");"] # [doc = " ```"] pub fn get_instrument_name (program : u8) -> String { match program { 0 => "Acoustic Grand Piano" , 1 => "Bright Acoustic Piano" , 2 => "Electric Grand Piano" , 3 => "Honky-tonk Piano" , 4 => "Electric Piano 1" , 5 => "Electric Piano 2" , 6 => "Harpsichord" , 7 => "Clavinet" , 8 => "Celesta" , 9 => "Glockenspiel" , 10 => "Music Box" , 11 => "Vibraphone" , 12 => "Marimba" , 13 => "Xylophone" , 14 => "Tubular Bells" , 15 => "Dulcimer" , 16 => "Drawbar Organ" , 17 => "Percussive Organ" , 18 => "Rock Organ" , 19 => "Church Organ" , 20 => "Reed Organ" , 21 => "Accordion" , 22 => "Harmonica" , 23 => "Tango Accordion" , 24 => "Acoustic Guitar (nylon)" , 25 => "Acoustic Guitar (steel)" , 26 => "Electric Guitar (jazz)" , 27 => "Electric Guitar (clean)" , 28 => "Electric Guitar (muted)" , 29 => "Overdriven Guitar" , 30 => "Distortion Guitar" , 31 => "Guitar Harmonics" , 32 => "Acoustic Bass" , 33 => "Electric Bass (finger)" , 34 => "Electric Bass (pick)" , 35 => "Fretless Bass" , 36 => "Slap Bass 1" , 37 => "Slap Bass 2" , 38 => "Synth Bass 1" , 39 => "Synth Bass 2" , 40 => "Violin" , 41 => "Viola" , 42 => "Cello" , 43 => "Contrabass" , 44 => "Tremolo Strings" , 45 => "Pizzicato Strings" , 46 => "Orchestral Harp" , 47 => "Timpani" , 48 => "String Ensemble 1" , 49 => "String Ensemble 2" , 50 => "Synth Strings 1" , 51 => "Synth Strings 2" , 52 => "Choir Aahs" , 53 => "Voice Oohs" , 54 => "Synth Voice" , 55 => "Orchestra Hit" , 56 => "Trumpet" , 57 => "Trombone" , 58 => "Tuba" , 59 => "Muted Trumpet" , 60 => "French Horn" , 61 => "Brass Section" , 62 => "Synth Brass 1" , 63 => "Synth Brass 2" , 64 => "Soprano Sax" , 65 => "Alto Sax" , 66 => "Tenor Sax" , 67 => "Baritone Sax" , 68 => "Oboe" , 69 => "English Horn" , 70 => "Bassoon" , 71 => "Clarinet" , 72 => "Piccolo" , 73 => "Flute" , 74 => "Recorder" , 75 => "Pan Flute" , 76 => "Blown Bottle" , 77 => "Shakuhachi" , 78 => "Whistle" , 79 => "Ocarina" , 80 => "Lead 1 (square)" , 81 => "Lead 2 (sawtooth)" , 82 => "Lead 3 (calliope)" , 83 => "Lead 4 (chiff)" , 84 => "Lead 5 (charang)" , 85 => "Lead 6 (voice)" , 86 => "Lead 7 (fifths)" , 87 => "Lead 8 (bass + lead)" , 88 => "Pad 1 (new age)" , 89 => "Pad 2 (warm)" , 90 => "Pad 3 (polysynth)" , 91 => "Pad 4 (choir)" , 92 => "Pad 5 (bowed)" , 93 => "Pad 6 (metallic)" , 94 => "Pad 7 (halo)" , 95 => "Pad 8 (sweep)" , 96 => "FX 1 (rain)" , 97 => "FX 2 (soundtrack)" , 98 => "FX 3 (crystal)" , 99 => "FX 4 (atmosphere)" , 100 => "FX 5 (brightness)" , 101 => "FX 6 (goblins)" , 102 => "FX 7 (echoes)" , 103 => "FX 8 (sci-fi)" , 104 => "Sitar" , 105 => "Banjo" , 106 => "Shamisen" , 107 => "Koto" , 108 => "Kalimba" , 109 => "Bag pipe" , 110 => "Fiddle" , 111 => "Shanai" , 112 => "Tinkle Bell" , 113 => "Agogo" , 114 => "Steel Drums" , 115 => "Woodblock" , 116 => "Taiko Drum" , 117 => "Melodic Tom" , 118 => "Synth Drum" , 119 => "Reverse Cymbal" , 120 => "Guitar Fret Noise" , 121 => "Breath Noise" , 122 => "Seashore" , 123 => "Bird Tweet" , 124 => "Telephone Ring" , 125 => "Helicopter" , 126 => "Applause" , 127 => "Gunshot" , _ => "Unknown Instrument" , } . to_string () }

- [ ] **Function 'create_test_track' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/core/splitting/track_splitter.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn create_test_track (events : Vec < TrackEvent >) -> Track { events }

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/database/batch_insert.rs`
  - Category: Performance

- [ ] **Function 'calculate_optimal_batch_size' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/database/batch_insert.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Calculate optimal batch size based on system memory"] # [doc = ""] # [doc = " This function provides a dynamically calculated batch size based on"] # [doc = " detected system resources (CPU cores, RAM, storage type)."] # [doc = ""] # [doc = " # Returns"] # [doc = ""] # [doc = " Recommended batch size (between 500 and 10,000)"] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " ```rust"] # [doc = " let batch_size = calculate_optimal_batch_size();"] # [doc = " let inserter = BatchInserter::new(pool, batch_size);"] # [doc = " ```"] pub fn calculate_optimal_batch_size () -> usize { let (_ , _ , batch_size) = calculate_all_settings () ; batch_size }

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/database/mod.rs`
  - Category: Performance

- [ ] **Function 'is_transient_error' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/database/mod.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Check if error is transient and can be retried"] # [doc = ""] # [doc = " Transient errors are temporary failures that may succeed on retry."] # [doc = " Non-transient errors are permanent failures that won't change on retry."] # [doc = ""] # [doc = " # Arguments"] # [doc = ""] # [doc = " * `error` - Database error to check"] # [doc = ""] # [doc = " # Returns"] # [doc = ""] # [doc = " * `bool` - True if error is transient and should be retried"] fn is_transient_error (error : & sqlx :: Error) -> bool { match error { sqlx :: Error :: PoolTimedOut => true , sqlx :: Error :: PoolClosed => true , sqlx :: Error :: Io (_) => true , _ => false , } }

- [ ] **Function 'is_connection_error' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/database/mod.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Check if error is a connection error that requires reconnection"] # [doc = ""] # [doc = " Connection errors indicate the database connection is broken and"] # [doc = " needs to be re-established before operations can continue."] # [doc = ""] # [doc = " # Arguments"] # [doc = ""] # [doc = " * `error` - Database error to check"] # [doc = ""] # [doc = " # Returns"] # [doc = ""] # [doc = " * `bool` - True if error indicates connection loss"] fn is_connection_error (error : & sqlx :: Error) -> bool { match error { sqlx :: Error :: PoolClosed => true , sqlx :: Error :: Io (_) => true , sqlx :: Error :: Database (db_err) => { let code = db_err . code () . unwrap_or_default () ; matches ! (code . as_ref () , "08000" | "08003" | "08006" | "57P01" | "57P02" | "57P03") } , _ => false , } }

- [ ] **Function 'bigdecimal_to_f64' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/db/models.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Convert BigDecimal to f64"] pub fn bigdecimal_to_f64 (bd : Option < BigDecimal >) -> Option < f64 > { bd . and_then (| b | b . to_f64 ()) }

- [ ] **Function 'f64_to_bigdecimal' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/db/models.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Convert f64 to BigDecimal"] pub fn f64_to_bigdecimal (val : Option < f64 >) -> Option < BigDecimal > { use num_traits :: FromPrimitive ; val . and_then (BigDecimal :: from_f64) }

- [ ] **Function 'extract_archive' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/io/decompressor/extractor.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Extracts MIDI files from an archive"] # [doc = ""] # [doc = " # Arguments"] # [doc = " * `archive_path` - Path to archive file"] # [doc = " * `output_dir` - Where to extract files"] # [doc = " * `config` - Extraction configuration"] # [doc = ""] # [doc = " # Returns"] # [doc = " * `ExtractionResult` - List of extracted MIDI files"] # [doc = ""] # [doc = " # Examples"] # [doc = " ```no_run"] # [doc = " use std::path::Path;"] # [doc = " use pipeline::io::decompressor::extractor::*;"] # [doc = ""] # [doc = " let config = ExtractionConfig::default();"] # [doc = " let result = extract_archive("] # [doc = "     Path::new(\"samples.zip\"),"] # [doc = "     Path::new(\"/output\"),"] # [doc = "     &config"] # [doc = " ).unwrap();"] # [doc = ""] # [doc = " println!(\"Extracted {} MIDI files\", result.midi_files.len());"] # [doc = " ```"] pub fn extract_archive (archive_path : & Path , output_dir : & Path , config : & ExtractionConfig ,) -> Result < ExtractionResult > { let format = formats :: detect_format (archive_path) . ok_or_else (| | IoError :: UnsupportedFormat { path : archive_path . to_path_buf () }) ? ; let mut result = ExtractionResult { midi_files : Vec :: new () , archives_processed : 0 , errors : Vec :: new () } ; extract_recursive (archive_path , output_dir , config , 0 , & mut result , format) ? ; Ok (result) }

- [ ] **Function 'extract_recursive' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/io/decompressor/extractor.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Internal recursive extraction function"] fn extract_recursive (archive_path : & Path , output_dir : & Path , config : & ExtractionConfig , current_depth : usize , result : & mut ExtractionResult , format : formats :: ArchiveFormat ,) -> Result < () > { if current_depth >= config . max_depth { result . errors . push (format ! ("Max depth reached at: {}" , archive_path . display ())) ; return Ok (()) ; } result . archives_processed += 1 ; match format { formats :: ArchiveFormat :: Zip => { extract_zip (archive_path , output_dir , config , current_depth , result) ? ; } , _ => { result . errors . push (format ! ("Format {:?} not yet implemented" , format)) ; } , } Ok (()) }

- [ ] **Function 'extract_zip' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/io/decompressor/extractor.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Extracts ZIP archive"] fn extract_zip (archive_path : & Path , output_dir : & Path , config : & ExtractionConfig , current_depth : usize , result : & mut ExtractionResult ,) -> Result < () > { let file = File :: open (archive_path) ? ; let mut archive = ZipArchive :: new (file) ? ; fs :: create_dir_all (output_dir) ? ; for i in 0 .. archive . len () { let mut file = archive . by_index (i) ? ; let outpath = match file . enclosed_name () { Some (path) => output_dir . join (path) , None => continue , } ; if file . name () . ends_with ('/') { fs :: create_dir_all (& outpath) ? ; } else { if let Some (parent) = outpath . parent () { fs :: create_dir_all (parent) ? ; } let mut outfile = File :: create (& outpath) ? ; io :: copy (& mut file , & mut outfile) ? ; if is_target_file (& outpath , & config . target_extensions) { result . midi_files . push (outpath . clone ()) ; } if config . recursive && formats :: is_archive (& outpath) { if let Some (nested_format) = formats :: detect_format (& outpath) { let nested_dir = if let Some (stem) = outpath . file_stem () { output_dir . join (format ! ("{}_extracted" , stem . to_string_lossy ())) } else { output_dir . join (format ! ("nested_{}" , current_depth + 1)) } ; let _ = extract_recursive (& outpath , & nested_dir , config , current_depth + 1 , result , nested_format ,) ; } } } } Ok (()) }

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/io/decompressor/extractor.rs`
  - Category: Performance

- [ ] **Function 'is_target_file' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/io/decompressor/extractor.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Checks if file has target extension"] fn is_target_file (path : & Path , target_extensions : & [String]) -> bool { path . extension () . and_then (| ext | ext . to_str ()) . map (| ext_str | { let ext_lower = ext_str . to_lowercase () ; target_extensions . iter () . any (| target | target == & ext_lower) }) . unwrap_or (false) }

- [ ] **Function 'extract_to_temp' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/io/decompressor/extractor.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Convenience function for extracting to temporary directory"] # [doc = ""] # [doc = " # Arguments"] # [doc = " * `archive_path` - Path to archive file"] # [doc = " * `config` - Extraction configuration"] # [doc = ""] # [doc = " # Returns"] # [doc = " * `(ExtractionResult, PathBuf)` - Extraction result and temp directory path"] pub fn extract_to_temp (archive_path : & Path , config : & ExtractionConfig ,) -> Result < (ExtractionResult , PathBuf) > { let mut temp_mgr = temp_manager :: TempManager :: new () ? ; let temp_dir = temp_mgr . create_temp_dir () ? ; let result = extract_archive (archive_path , & temp_dir , config) ? ; std :: mem :: forget (temp_mgr) ; Ok ((result , temp_dir)) }

- [ ] **Function 'detect_format' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/io/decompressor/formats.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Detects archive format from file extension"] # [doc = ""] # [doc = " # Arguments"] # [doc = " * `path` - Path to check"] # [doc = ""] # [doc = " # Returns"] # [doc = " * `Some(ArchiveFormat)` if recognized, `None` otherwise"] pub fn detect_format (path : & Path) -> Option < ArchiveFormat > { let filename = path . file_name () ? . to_str () ? . to_lowercase () ; if filename . ends_with (".zip") { Some (ArchiveFormat :: Zip) } else if filename . ends_with (".rar") { Some (ArchiveFormat :: Rar) } else if filename . ends_with (".7z") { Some (ArchiveFormat :: SevenZip) } else if filename . ends_with (".tar.gz") || filename . ends_with (".tgz") { Some (ArchiveFormat :: TarGz) } else if filename . ends_with (".tar") { Some (ArchiveFormat :: Tar) } else { None } }

- [ ] **Function 'is_archive' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/io/decompressor/formats.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Checks if file is a supported archive"] # [doc = ""] # [doc = " # Arguments"] # [doc = " * `path` - Path to check"] # [doc = ""] # [doc = " # Returns"] # [doc = " * `true` if file is a recognized archive format"] pub fn is_archive (path : & Path) -> bool { detect_format (path) . is_some () }

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/io/decompressor/temp_manager.rs`
  - Category: Performance

- [ ] **Function 'init_logging' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/main.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Initialize logging/tracing system"] fn init_logging () { let log_dir = std :: env :: var ("LOG_DIR") . unwrap_or_else (| _ | "./logs" . to_string ()) ; std :: fs :: create_dir_all (& log_dir) . ok () ; let file_appender = tracing_appender :: rolling :: daily (log_dir , "pipeline.log") ; let (non_blocking , _guard) = tracing_appender :: non_blocking (file_appender) ; tracing_subscriber :: registry () . with (tracing_subscriber :: EnvFilter :: try_from_default_env () . unwrap_or_else (| _ | "info,midi_pipeline=debug" . into ()) ,) . with (tracing_subscriber :: fmt :: layer () . with_writer (std :: io :: stdout)) . with (tracing_subscriber :: fmt :: layer () . with_writer (non_blocking)) . init () ; }

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/windows/manager.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/windows/manager.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/windows/manager.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/windows/manager.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/windows/manager.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/windows/manager.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/windows/manager.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/windows/manager.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/windows/manager.rs`
  - Category: Performance

- [ ] **Function 'create_windows_menu' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/windows/menu.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Create the Windows menu (for menu bar)"] pub fn create_windows_menu () -> Submenu { Submenu :: new ("Windows" , Menu :: new () . add_item (CustomMenuItem :: new ("show_pipeline" , "Show Pipeline")) . add_item (CustomMenuItem :: new ("show_daw" , "Show DAW")) . add_item (CustomMenuItem :: new ("show_database" , "Show Database")) . add_item (CustomMenuItem :: new ("show_settings" , "Show Settings")) . add_native_item (MenuItem :: Separator) . add_item (CustomMenuItem :: new ("arrange_tile_h" , "Tile Horizontally")) . add_item (CustomMenuItem :: new ("arrange_tile_v" , "Tile Vertically")) . add_item (CustomMenuItem :: new ("arrange_cascade" , "Cascade")) . add_native_item (MenuItem :: Separator) . add_item (CustomMenuItem :: new ("save_layout" , "Save Layout...")) . add_item (CustomMenuItem :: new ("load_layout" , "Load Layout...")) . add_item (CustomMenuItem :: new ("manage_layouts" , "Manage Layouts...")) ,) }

- [ ] **Function 'create_view_menu' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/windows/menu.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Create View menu with window controls"] pub fn create_view_menu () -> Submenu { Submenu :: new ("View" , Menu :: new () . add_item (CustomMenuItem :: new ("toggle_sidebar" , "Toggle Sidebar")) . add_item (CustomMenuItem :: new ("toggle_inspector" , "Toggle Inspector")) . add_native_item (MenuItem :: Separator) . add_item (CustomMenuItem :: new ("zoom_in" , "Zoom In")) . add_item (CustomMenuItem :: new ("zoom_out" , "Zoom Out")) . add_item (CustomMenuItem :: new ("zoom_reset" , "Reset Zoom")) ,) }

- [ ] **Function 'setup_window_shortcuts' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/windows/shortcuts.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Setup window management global shortcuts"] # [doc = ""] # [doc = " Shortcuts:"] # [doc = " - Cmd/Ctrl+1: Show Pipeline"] # [doc = " - Cmd/Ctrl+2: Show DAW"] # [doc = " - Cmd/Ctrl+3: Show Database"] # [doc = " - Cmd/Ctrl+`: Cycle windows (next)"] # [doc = " - Cmd/Ctrl+Shift+`: Cycle windows (prev)"] pub fn setup_window_shortcuts (app : & AppHandle) -> Result < () , String > { let mut manager = app . global_shortcut_manager () ; { let app_handle = app . clone () ; manager . register ("CmdOrCtrl+1" , move | | { let _ = app_handle . emit_all ("command:show-pipeline" , ()) ; }) . map_err (| e | format ! ("Failed to register Cmd+1: {}" , e)) ? ; } { let app_handle = app . clone () ; manager . register ("CmdOrCtrl+2" , move | | { let _ = app_handle . emit_all ("command:show-daw" , ()) ; }) . map_err (| e | format ! ("Failed to register Cmd+2: {}" , e)) ? ; } { let app_handle = app . clone () ; manager . register ("CmdOrCtrl+3" , move | | { let _ = app_handle . emit_all ("command:show-database" , ()) ; }) . map_err (| e | format ! ("Failed to register Cmd+3: {}" , e)) ? ; } { let app_handle = app . clone () ; manager . register ("CmdOrCtrl+grave" , move | | { let _ = app_handle . emit_all ("command:cycle-windows" , ()) ; }) . map_err (| e | format ! ("Failed to register Cmd+`: {}" , e)) ? ; } { let app_handle = app . clone () ; manager . register ("CmdOrCtrl+Shift+grave" , move | | { let _ = app_handle . emit_all ("command:cycle-windows-back" , ()) ; }) . map_err (| e | format ! ("Failed to register Cmd+Shift+`: {}" , e)) ? ; } { let app_handle = app . clone () ; manager . register ("CmdOrCtrl+b" , move | | { let _ = app_handle . emit ("command:toggle-sidebar" , ()) ; }) . map_err (| e | format ! ("Failed to register Cmd+B: {}" , e)) ? ; } { let app_handle = app . clone () ; manager . register ("CmdOrCtrl+Alt+i" , move | | { let _ = app_handle . emit ("command:toggle-inspector" , ()) ; }) . map_err (| e | format ! ("Failed to register Cmd+Alt+I: {}" , e)) ? ; } info ! ("âœ… Window shortcuts registered") ; Ok (()) }

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/windows/shortcuts.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/windows/shortcuts.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/windows/shortcuts.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/windows/shortcuts.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/windows/shortcuts.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/windows/shortcuts.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/windows/shortcuts.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/windows/state.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/windows/state.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/pipeline/src-tauri/src/windows/state.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/scripts/import-tool/src/main.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/scripts/import-tool/src/main.rs`
  - Category: Performance

- [ ] **Function 'get_bpm_regex' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/scripts/import-tool/src/main.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn get_bpm_regex () -> & 'static Regex { BPM_REGEX . get_or_init (| | { Regex :: new (r"(?i)([0-9]{2,3})[\s_]*(bpm|beats|tempo)|(?:^|_|\s|-|/)([0-9]{2,3})(?:_|\s|-|/|\.)" ,) . unwrap () }) }

- [ ] **Function 'extract_bpm_from_filename' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/scripts/import-tool/src/main.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn extract_bpm_from_filename (filename : & str) -> Option < f32 > { let regex = get_bpm_regex () ; for caps in regex . captures_iter (filename) { if let Some (m) = caps . get (1) { if let Ok (bpm) = m . as_str () . parse :: < f32 > () { if (30.0 ..= 300.0) . contains (& bpm) { return Some (bpm) ; } } } } for caps in regex . captures_iter (filename) { if let Some (m) = caps . get (3) { if let Ok (bpm) = m . as_str () . parse :: < f32 > () { if (30.0 ..= 300.0) . contains (& bpm) { return Some (bpm) ; } } } } None }

- [ ] **Function 'get_key_regex' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/scripts/import-tool/src/main.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn get_key_regex () -> & 'static Regex { KEY_REGEX . get_or_init (| | Regex :: new (r"(?i)(?:^|_|\s|-|/)([A-G](?:#|b)?m?)(?:_|\s|-|/|\.)") . unwrap ()) }

- [ ] **Function 'get_key_map' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/scripts/import-tool/src/main.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn get_key_map () -> & 'static HashMap < & 'static str , & 'static str > { KEY_NORMALIZATION_MAP . get_or_init (| | { HashMap :: from ([("amin" , "Am") , ("am" , "Am") , ("bmin" , "Bm") , ("bm" , "Bm") , ("cmin" , "Cm") , ("cm" , "Cm") , ("dmin" , "Dm") , ("dm" , "Dm") , ("emin" , "Em") , ("em" , "Em") , ("fmin" , "Fm") , ("fm" , "Fm") , ("gmin" , "Gm") , ("gm" , "Gm") , ("amaj" , "A") , ("cmaj" , "C") , ("dmaj" , "D") , ("emaj" , "E") , ("fmaj" , "F") , ("gmaj" , "G") , ("bmaj" , "B") , ("bb" , "Bb") , ("a#" , "A#") , ("c#" , "C#") , ("d#" , "D#") , ("f#" , "F#") , ("g#" , "G#") , ("ab" , "Ab") , ("db" , "Db") , ("eb" , "Eb") , ("gb" , "Gb") , ("a" , "A") , ("b" , "B") , ("c" , "C") , ("d" , "D") , ("e" , "E") , ("f" , "F") , ("g" , "G") ,]) }) }

- [ ] **Function 'normalize_key_signature' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/scripts/import-tool/src/main.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn normalize_key_signature (raw_key : & str) -> Option < String > { get_key_map () . get (raw_key . to_lowercase () . as_str ()) . map (| & s | s . to_string ()) }

- [ ] **Function 'extract_key_from_filename' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/scripts/import-tool/src/main.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn extract_key_from_filename (filename : & str) -> Option < String > { get_key_regex () . captures (filename) . and_then (| caps | caps . get (1)) . and_then (| m | normalize_key_signature (m . as_str ())) }

- [ ] **Function 'get_genre_regex' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/scripts/import-tool/src/main.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn get_genre_regex () -> & 'static Regex { GENRE_REGEX . get_or_init (| | { Regex :: new (r"(?i)(house|techno|trance|hip.?hop|trap|dubstep|dnb|drum.?n.?bass|jazz|funk|soul|rock|pop|edm|ambient|downtempo|break|jungle|garage|electro|acid|minimal|deep|progressive)") . unwrap () }) }

- [ ] **Function 'normalize_genre' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/scripts/import-tool/src/main.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn normalize_genre (raw : & str) -> String { match raw { "hip hop" | "hiphop" | "hip-hop" => "hip-hop" . to_string () , "dnb" | "drum n bass" | "drum and bass" | "drum-n-bass" | "drum_n_bass" => { "dnb" . to_string () } , genre => genre . to_string () , } }

- [ ] **Function 'extract_genres_from_filename' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/scripts/import-tool/src/main.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn extract_genres_from_filename (filename : & str) -> Vec < String > { get_genre_regex () . find_iter (filename) . map (| m | m . as_str () . to_lowercase ()) . map (| g | normalize_genre (& g)) . collect () }

- [ ] **Function 'get_structure_regex' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/scripts/import-tool/src/main.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn get_structure_regex () -> & 'static Regex { STRUCTURE_REGEX . get_or_init (| | { Regex :: new (r"(?i)(verse|chorus|bridge|intro|outro|drop|build|breakdown|fill|loop|one.?shot|sample|melody|hook|riff|lick|main|full|short|long)") . unwrap () }) }

- [ ] **Function 'normalize_structure_tag' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/scripts/import-tool/src/main.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn normalize_structure_tag (raw : & str) -> String { match raw { "one shot" | "one-shot" | "oneshot" => "oneshot" . to_string () , tag => tag . to_string () , } }

- [ ] **Function 'extract_structure_tags' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/scripts/import-tool/src/main.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn extract_structure_tags (filename : & str) -> Vec < String > { get_structure_regex () . find_iter (filename) . map (| m | m . as_str () . to_lowercase ()) . map (| s | normalize_structure_tag (& s)) . collect () }

- [ ] **Function 'get_leading_number_regex' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/scripts/import-tool/src/main.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn get_leading_number_regex () -> & 'static Regex { LEADING_NUMBER_REGEX . get_or_init (| | Regex :: new (r"^([0-9]+)") . unwrap ()) }

- [ ] **Function 'extract_leading_number' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/scripts/import-tool/src/main.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn extract_leading_number (filename : & str) -> Option < i32 > { get_leading_number_regex () . captures (filename) . and_then (| caps | caps . get (1)) . and_then (| m | m . as_str () . parse :: < i32 > () . ok ()) }

- [ ] **Function 'calculate_metadata_source' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/scripts/import-tool/src/main.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Calculate metadata source based on what data is available"] fn calculate_metadata_source (filename_bpm : Option < f32 > , filename_key : Option < & str > , filename_genres : & [String] , structure_tags : & [String] ,) -> & 'static str { let has_filename_metadata = filename_bpm . is_some () || filename_key . is_some () || ! filename_genres . is_empty () || ! structure_tags . is_empty () ; if has_filename_metadata { "filename" } else { "none" } }

- [ ] **Function 'parse_midi_basic' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/scripts/import-tool/src/main.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Parse basic MIDI info (tracks and TPPQ)"] fn parse_midi_basic (data : & [u8]) -> (i16 , i32) { if data . len () < 14 || & data [0 .. 4] != b"MThd" { return (1 , 480) ; } let num_tracks = i16 :: from_be_bytes ([data [10] , data [11]]) ; let ticks = u16 :: from_be_bytes ([data [12] , data [13]]) ; (num_tracks , ticks as i32) }

- [ ] **Function 'count_notes' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/scripts/test-midi-files/src/main.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn count_notes (midi_file : & MidiFile) -> usize { midi_file . tracks . iter () . flat_map (| track | & track . events) . filter (| event | matches ! (event . event , Event :: NoteOn { .. })) . count () }

- [ ] **Function 'get_duration_ticks' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/scripts/test-midi-files/src/main.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn get_duration_ticks (midi_file : & MidiFile) -> u32 { midi_file . tracks . iter () . flat_map (| track | & track . events) . map (| event | event . delta_ticks) . sum () }

- [ ] **Function 'analyze_file' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/scripts/test-midi-files/src/main.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn analyze_file (file_path : & Path) -> Result < TestResult > { let start = Instant :: now () ; let file_name = file_path . file_name () . and_then (| n | n . to_str ()) . unwrap_or ("unknown") . to_string () ; println ! ("\nğŸ“„ Analyzing: {}" , file_name) ; let data = fs :: read (file_path) . context ("Failed to read file") ? ; let file_size = data . len () as u64 ; println ! ("  ğŸ“¦ Size: {} bytes" , file_size) ; let midi_file = parse_midi_file (& data) . context ("Failed to parse MIDI") ? ; println ! ("  âœ… Parse successful") ; let track_count = midi_file . tracks . len () ; let note_count = count_notes (& midi_file) ; let duration_ticks = get_duration_ticks (& midi_file) ; println ! ("  ğŸµ Tracks: {}" , track_count) ; println ! ("  ğŸ¹ Notes: {}" , note_count) ; let bpm_result = detect_bpm (& midi_file) ; let bpm = if bpm_result . confidence > 0.5 { Some (bpm_result . bpm) } else { None } ; if let Some (bpm_value) = bpm { println ! ("  â±ï¸  BPM: {:.1} (confidence: {:.1}%)" , bpm_value , bpm_result . confidence * 100.0) ; } else { println ! ("  âš ï¸  BPM: Not detected") ; } use midi_library_shared :: core :: analysis :: key_detector :: detect_key ; let key = detect_key (& midi_file) ; if let Some (ref key_str) = key { println ! ("  ğŸ¹ Key: {}" , key_str) ; } else { println ! ("  âš ï¸  Key: Unable to detect (low confidence or insufficient notes)") ; } let parse_time = start . elapsed () ; println ! ("  â±ï¸  Processing time: {}ms" , parse_time . as_millis ()) ; Ok (TestResult { file_path : file_path . to_string_lossy () . to_string () , file_name , success : true , error : None , file_size , parse_time_ms : parse_time . as_millis () , bpm , key , duration_ms : Some ((duration_ticks as u64 * 500) / 1000) , track_count : Some (track_count) , note_count : Some (note_count) , }) }

- [ ] **Function 'main' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/scripts/test-midi-files/src/main.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn main () -> Result < () > { let args : Vec < String > = env :: args () . collect () ; if args . len () < 2 { eprintln ! ("Usage: {} <midi_file1> [midi_file2] ..." , args [0]) ; eprintln ! ("       {} <directory>" , args [0]) ; std :: process :: exit (1) ; } let mut results = Vec :: new () ; let mut total_files = 0 ; let mut successful = 0 ; let mut failed = 0 ; let mut bpm_detected = 0 ; let mut key_detected = 0 ; let mut total_time_ms = 0u128 ; println ! ("ğŸµ MIDI Pipeline Real-World Testing") ; println ! ("====================================\n") ; for arg in & args [1 ..] { let path = Path :: new (arg) ; let files : Vec < _ > = if path . is_dir () { walkdir :: WalkDir :: new (path) . into_iter () . filter_map (| e | e . ok ()) . filter (| e | { e . path () . extension () . and_then (| s | s . to_str ()) . map (| s | s . eq_ignore_ascii_case ("mid") || s . eq_ignore_ascii_case ("midi")) . unwrap_or (false) }) . map (| e | e . path () . to_path_buf ()) . collect () } else { vec ! [path . to_path_buf ()] } ; for file_path in files { total_files += 1 ; match analyze_file (& file_path) { Ok (result) => { successful += 1 ; total_time_ms += result . parse_time_ms ; if result . bpm . is_some () { bpm_detected += 1 ; } if result . key . is_some () { key_detected += 1 ; } results . push (result) ; } , Err (e) => { failed += 1 ; println ! ("\nâŒ Error: {}" , e) ; results . push (TestResult { file_path : file_path . to_string_lossy () . to_string () , file_name : file_path . file_name () . and_then (| n | n . to_str ()) . unwrap_or ("unknown") . to_string () , success : false , error : Some (e . to_string ()) , file_size : 0 , parse_time_ms : 0 , bpm : None , key : None , duration_ms : None , track_count : None , note_count : None , }) ; } , } } } println ! ("\n") ; println ! ("ğŸ“Š SUMMARY") ; println ! ("====================================") ; println ! ("âœ… Files tested: {}" , total_files) ; println ! ("âœ… Successful parses: {} ({:.1}%)" , successful , (successful as f64 / total_files as f64) * 100.0) ; println ! ("âŒ Failed parses: {} ({:.1}%)" , failed , (failed as f64 / total_files as f64) * 100.0) ; println ! ("â±ï¸  BPM detection rate: {}/{} ({:.1}%)" , bpm_detected , total_files , (bpm_detected as f64 / total_files as f64) * 100.0) ; println ! ("ğŸ¼ Key detection rate: {}/{} ({:.1}%)" , key_detected , total_files , (key_detected as f64 / total_files as f64) * 100.0) ; if total_files > 0 { let avg_time = total_time_ms / total_files as u128 ; println ! ("â±ï¸  Average processing time: {}ms/file" , avg_time) ; println ! ("â±ï¸  Total processing time: {}ms" , total_time_ms) ; } println ! ("\n") ; println ! ("ğŸ¯ PRODUCTION READINESS ASSESSMENT") ; println ! ("====================================") ; let success_rate = (successful as f64 / total_files as f64) * 100.0 ; if success_rate >= 95.0 { println ! ("âœ… Parse success rate: EXCELLENT ({:.1}%)" , success_rate) ; } else if success_rate >= 85.0 { println ! ("âš ï¸  Parse success rate: ACCEPTABLE ({:.1}%)" , success_rate) ; } else { println ! ("âŒ Parse success rate: NEEDS IMPROVEMENT ({:.1}%)" , success_rate) ; } if total_files > 0 { let avg_time = total_time_ms / total_files as u128 ; if avg_time <= 100 { println ! ("âœ… Performance: EXCELLENT ({}ms avg)" , avg_time) ; } else if avg_time <= 500 { println ! ("âœ… Performance: GOOD ({}ms avg)" , avg_time) ; } else { println ! ("âš ï¸  Performance: NEEDS OPTIMIZATION ({}ms avg)" , avg_time) ; } } let results_json = serde_json :: to_string_pretty (& results) ? ; fs :: write ("/tmp/midi_test_results.json" , results_json) ? ; println ! ("\nğŸ“„ Detailed results written to: /tmp/midi_test_results.json") ; Ok (()) }

- [ ] **Function 'generate_tags' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/shared/rust/src/core/analysis/auto_tagger.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Auto-tagging functionality wrapper"] # [doc = ""] # [doc = " This is a simplified wrapper for the shared library."] # [doc = " The full implementation lives in the Pipeline component at"] # [doc = " `pipeline/src-tauri/src/core/analysis/auto_tagger.rs`"] # [doc = ""] # [doc = " Generates tags based on MIDI file content analysis including:"] # [doc = " - Instrument detection from GM program changes"] # [doc = " - Note density and patterns"] # [doc = " - Tempo characteristics (if BPM detected)"] # [doc = " - Channel usage patterns"] # [doc = ""] # [doc = " # Arguments"] # [doc = " * `midi_file` - Parsed MIDI file structure"] # [doc = ""] # [doc = " # Returns"] # [doc = " * `Vec<String>` - List of detected tags (e.g., \"drums\", \"piano\", \"fast\", \"melodic\")"] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " ```"] # [doc = " use midi_library_shared::core::midi::MidiFile;"] # [doc = " use midi_library_shared::core::analysis::auto_tagger::generate_tags;"] # [doc = ""] # [doc = " // let midi_file = MidiFile::parse(&data)?;"] # [doc = " // let tags = generate_tags(&midi_file);"] # [doc = " // println!(\"Tags: {:?}\", tags);"] # [doc = " ```"] pub fn generate_tags (midi_file : & crate :: core :: midi :: MidiFile) -> Vec < String > { let mut tags = Vec :: new () ; let mut instruments_seen = std :: collections :: HashSet :: new () ; let mut note_count = 0u32 ; for track in midi_file . tracks . iter () { for timed_event in & track . events { match & timed_event . event { crate :: core :: midi :: Event :: ProgramChange { channel , program } => { if * channel == 9 { instruments_seen . insert ("drums") ; } else { let instrument = map_gm_program_to_instrument (* program) ; instruments_seen . insert (instrument) ; } } , crate :: core :: midi :: Event :: NoteOn { channel , .. } => { if * channel == 9 { instruments_seen . insert ("drums") ; } note_count = note_count . saturating_add (1) ; } , crate :: core :: midi :: Event :: Text { text_type : _ , text } => { let text_lower = text . to_lowercase () ; if text_lower . contains ("rock") { tags . push ("rock" . to_string ()) ; } if text_lower . contains ("jazz") { tags . push ("jazz" . to_string ()) ; } if text_lower . contains ("classical") { tags . push ("classical" . to_string ()) ; } if text_lower . contains ("electronic") { tags . push ("electronic" . to_string ()) ; } } , _ => { } , } } } for instrument in instruments_seen { tags . push (instrument . to_string ()) ; } if note_count > 1000 { tags . push ("dense" . to_string ()) ; } else if note_count > 500 { tags . push ("moderate" . to_string ()) ; } else if note_count > 0 { tags . push ("sparse" . to_string ()) ; } let track_count = midi_file . tracks . len () ; if track_count > 10 { tags . push ("multi-track" . to_string ()) ; } else if track_count > 1 { tags . push ("layered" . to_string ()) ; } else { tags . push ("single-track" . to_string ()) ; } if let Some (tempo) = detect_average_tempo (midi_file) { if tempo > 140.0 { tags . push ("fast" . to_string ()) ; } else if tempo > 100.0 { tags . push ("moderate-tempo" . to_string ()) ; } else if tempo > 60.0 { tags . push ("slow" . to_string ()) ; } } tags }

- [ ] **Function 'map_gm_program_to_instrument' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/shared/rust/src/core/analysis/auto_tagger.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Map GM program numbers to instrument names"] fn map_gm_program_to_instrument (program : u8) -> & 'static str { match program { 0 ..= 7 => "piano" , 8 ..= 15 => "chromatic-percussion" , 16 ..= 23 => "organ" , 24 ..= 31 => "guitar" , 32 ..= 39 => "bass" , 40 ..= 47 => "strings" , 48 ..= 55 => "ensemble" , 56 ..= 63 => "brass" , 64 ..= 71 => "reed" , 72 ..= 79 => "pipe" , 80 ..= 87 => "synth-lead" , 88 ..= 95 => "synth-pad" , 96 ..= 103 => "synth-effects" , 104 ..= 111 => "ethnic" , 112 ..= 119 => "percussive" , 120 ..= 127 => "sound-effects" , _ => "unknown" , } }

- [ ] **Function 'detect_average_tempo' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/shared/rust/src/core/analysis/auto_tagger.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Detect average tempo from MIDI tempo events"] fn detect_average_tempo (midi_file : & crate :: core :: midi :: MidiFile) -> Option < f64 > { let mut tempo_sum = 0.0 ; let mut tempo_count = 0 ; for track in & midi_file . tracks { for timed_event in & track . events { if let crate :: core :: midi :: Event :: TempoChange { microseconds_per_quarter } = & timed_event . event { let bpm = 60_000_000.0 / (* microseconds_per_quarter as f64) ; tempo_sum += bpm ; tempo_count += 1 ; } } } if tempo_count > 0 { Some (tempo_sum / tempo_count as f64) } else { None } }

- [ ] **Function 'detect_bpm' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/shared/rust/src/core/analysis/bpm_detector.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Detects BPM from a parsed MIDI file"] # [doc = ""] # [doc = " # Arguments"] # [doc = " * `midi_file` - Parsed MIDI file structure"] # [doc = ""] # [doc = " # Returns"] # [doc = " * `BpmDetectionResult` - Detection result with confidence and metadata"] # [doc = ""] # [doc = " # Examples"] # [doc = " ```ignore"] # [doc = " use midi_library_shared::core::analysis::bpm_detector::detect_bpm;"] # [doc = " use midi_library_shared::core::midi::types::MidiFile;"] # [doc = ""] # [doc = " let result = detect_bpm(&midi_file);"] # [doc = " println!(\"Detected BPM: {:.2}\", result.bpm);"] # [doc = " ```"] pub fn detect_bpm (midi_file : & MidiFile) -> BpmDetectionResult { let tempo_events = extract_tempo_events (midi_file) ; if tempo_events . is_empty () { return BpmDetectionResult { bpm : DEFAULT_BPM , confidence : 0.3 , method : BpmDetectionMethod :: DefaultTempo , metadata : BpmMetadata { tempo_changes : vec ! [] , is_constant : true , tempo_range : None } , } ; } let tempo_changes : Vec < TempoChange > = tempo_events . into_iter () . map (| (tick , microseconds_per_quarter) | TempoChange { tick , bpm : microseconds_to_bpm (microseconds_per_quarter) , }) . collect () ; let is_constant = tempo_changes . len () == 1 ; let bpms : Vec < f64 > = tempo_changes . iter () . map (| tc | tc . bpm) . collect () ; let total_ticks = calculate_total_ticks (midi_file) ; let avg_bpm = calculate_weighted_average (& tempo_changes , total_ticks) ; let tempo_range = if tempo_changes . len () > 1 { let min = bpms . iter () . cloned () . fold (f64 :: INFINITY , f64 :: min) ; let max = bpms . iter () . cloned () . fold (f64 :: NEG_INFINITY , f64 :: max) ; Some ((min , max)) } else { None } ; let confidence = calculate_confidence (& tempo_changes) ; let method = if tempo_changes . len () == 1 { BpmDetectionMethod :: SingleTempo } else { BpmDetectionMethod :: WeightedAverage } ; BpmDetectionResult { bpm : avg_bpm , confidence , method , metadata : BpmMetadata { tempo_changes , is_constant , tempo_range } , } }

- [ ] **Function 'extract_tempo_events' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/shared/rust/src/core/analysis/bpm_detector.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Extracts tempo events from all tracks in the MIDI file"] fn extract_tempo_events (midi_file : & MidiFile) -> Vec < (u32 , u32) > { let mut tempo_events = Vec :: new () ; for track in & midi_file . tracks { let mut current_tick = 0u32 ; for timed_event in & track . events { current_tick = current_tick . saturating_add (timed_event . delta_ticks) ; if let Event :: TempoChange { microseconds_per_quarter } = timed_event . event { tempo_events . push ((current_tick , microseconds_per_quarter)) ; } } } tempo_events . sort_by_key (| (tick , _) | * tick) ; tempo_events }

- [ ] **Function 'calculate_total_ticks' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/shared/rust/src/core/analysis/bpm_detector.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Calculates the total number of ticks in the MIDI file"] fn calculate_total_ticks (midi_file : & MidiFile) -> u32 { let mut max_ticks = 0u32 ; for track in & midi_file . tracks { let mut track_ticks = 0u32 ; for timed_event in & track . events { track_ticks = track_ticks . saturating_add (timed_event . delta_ticks) ; } max_ticks = max_ticks . max (track_ticks) ; } max_ticks }

- [ ] **Function 'microseconds_to_bpm' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/shared/rust/src/core/analysis/bpm_detector.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Converts microseconds per quarter note to BPM"] fn microseconds_to_bpm (microseconds_per_quarter : u32) -> f64 { if microseconds_per_quarter == 0 { return DEFAULT_BPM ; } let bpm = 60_000_000.0 / microseconds_per_quarter as f64 ; bpm . clamp (MIN_BPM , MAX_BPM) }

- [ ] **Function 'calculate_weighted_average' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/shared/rust/src/core/analysis/bpm_detector.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Calculates weighted average BPM based on duration each tempo is active"] fn calculate_weighted_average (tempo_changes : & [TempoChange] , total_ticks : u32) -> f64 { if tempo_changes . is_empty () { return DEFAULT_BPM ; } if tempo_changes . len () == 1 { return tempo_changes [0] . bpm ; } let mut weighted_sum = 0.0 ; let mut total_weight = 0.0 ; for (i , tempo_change) in tempo_changes . iter () . enumerate () { let duration = if i + 1 < tempo_changes . len () { tempo_changes [i + 1] . tick - tempo_change . tick } else { total_ticks . saturating_sub (tempo_change . tick) } ; let weight = duration as f64 ; weighted_sum += tempo_change . bpm * weight ; total_weight += weight ; } if total_weight > 0.0 { weighted_sum / total_weight } else { tempo_changes [0] . bpm } }

- [ ] **Function 'calculate_confidence' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/shared/rust/src/core/analysis/bpm_detector.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Calculates confidence score based on tempo consistency"] fn calculate_confidence (tempo_changes : & [TempoChange]) -> f64 { if tempo_changes . is_empty () { return 0.3 ; } if tempo_changes . len () == 1 { return 1.0 ; } let bpms : Vec < f64 > = tempo_changes . iter () . map (| tc | tc . bpm) . collect () ; let mean = bpms . iter () . sum :: < f64 > () / bpms . len () as f64 ; let variance = bpms . iter () . map (| bpm | (bpm - mean) . powi (2)) . sum :: < f64 > () / bpms . len () as f64 ; let std_dev = variance . sqrt () ; let cv = std_dev / mean ; (1.0 - cv) . clamp (0.5 , 1.0) }

- [ ] **Function 'create_test_midi_with_tempos' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/shared/rust/src/core/analysis/bpm_detector.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Create a MIDI file with specific tempo events"] # [doc = " Each tuple is (tick, microseconds_per_quarter)"] # [doc = " If total_ticks is Some(n), extends file to n ticks with EndOfTrack"] fn create_test_midi_with_tempos (tempos : Vec < (u32 , u32) > , total_ticks : Option < u32 >) -> MidiFile { let mut events : Vec < TimedEvent > = Vec :: new () ; let mut last_tick = 0u32 ; for (tick , microseconds) in tempos { let delta = tick - last_tick ; events . push (TimedEvent { delta_ticks : delta , event : Event :: TempoChange { microseconds_per_quarter : microseconds } , }) ; last_tick = tick ; } let eot_delta = if let Some (total) = total_ticks { total . saturating_sub (last_tick) } else { 0 } ; events . push (TimedEvent { delta_ticks : eot_delta , event : Event :: EndOfTrack }) ; MidiFile { header : Header { format : 1 , num_tracks : 1 , ticks_per_quarter_note : 480 } , tracks : vec ! [Track { events }] , } }

- [ ] **Function 'create_midi_no_tempo' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/shared/rust/src/core/analysis/bpm_detector.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Create a MIDI file with no tempo events"] fn create_midi_no_tempo (num_tracks : u16) -> MidiFile { let mut tracks = Vec :: new () ; for _ in 0 .. num_tracks { tracks . push (Track { events : vec ! [TimedEvent { delta_ticks : 1000 , event : Event :: EndOfTrack }] , }) ; } MidiFile { header : Header { format : 1 , num_tracks , ticks_per_quarter_note : 480 } , tracks } }

- [ ] **Function 'create_midi_with_length' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/shared/rust/src/core/analysis/bpm_detector.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Create a MIDI file with specific length (total ticks)"] fn create_midi_with_length (total_ticks : u32) -> MidiFile { MidiFile { header : Header { format : 1 , num_tracks : 1 , ticks_per_quarter_note : 480 } , tracks : vec ! [Track { events : vec ! [TimedEvent { delta_ticks : total_ticks , event : Event :: EndOfTrack }] , }] , } }

- [ ] **Function 'assert_bpm_approx_eq' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/shared/rust/src/core/analysis/bpm_detector.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Assert BPM is approximately equal (floating point tolerance)"] fn assert_bpm_approx_eq (actual : f64 , expected : f64 , tolerance : f64) { assert ! ((actual - expected) . abs () < tolerance , "BPM mismatch: expected {}, got {} (tolerance: {})" , expected , actual , tolerance) ; }

- [ ] **Function 'detect_key' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/shared/rust/src/core/analysis/key_detector.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Key detection wrapper"] # [doc = ""] # [doc = " This is a simplified wrapper for the shared library."] # [doc = " The full implementation lives in the Pipeline component at"] # [doc = " `pipeline/src-tauri/src/core/analysis/key_detector.rs`"] # [doc = ""] # [doc = " Returns the detected key as a string (e.g., \"C\", \"Am\", \"F#\")"] # [doc = " or None if detection confidence is too low."] # [doc = ""] # [doc = " # Arguments"] # [doc = " * `midi_file` - Parsed MIDI file structure"] # [doc = ""] # [doc = " # Returns"] # [doc = " * `Some(String)` - Detected key (e.g., \"C major\", \"A minor\")"] # [doc = " * `None` - No clear key detected (confidence < 0.5)"] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " ```"] # [doc = " use midi_library_shared::core::midi::MidiFile;"] # [doc = " use midi_library_shared::core::analysis::key_detector::detect_key;"] # [doc = ""] # [doc = " // let midi_file = MidiFile::parse(&data)?;"] # [doc = " // if let Some(key) = detect_key(&midi_file) {"] # [doc = " //     println!(\"Detected key: {}\", key);"] # [doc = " // }"] # [doc = " ```"] pub fn detect_key (midi_file : & crate :: core :: midi :: MidiFile) -> Option < String > { let mut pitch_class_counts = [0u32 ; 12] ; for track in & midi_file . tracks { for timed_event in & track . events { if let crate :: core :: midi :: Event :: NoteOn { note , .. } = & timed_event . event { let pitch_class = (note % 12) as usize ; pitch_class_counts [pitch_class] = pitch_class_counts [pitch_class] . saturating_add (1) ; } } } let total_notes : u32 = pitch_class_counts . iter () . sum () ; if total_notes < 10 { return None ; } let mut pitch_class_dist = [0.0 ; 12] ; for (i , & count) in pitch_class_counts . iter () . enumerate () { pitch_class_dist [i] = count as f64 / total_notes as f64 ; } const MAJOR_PROFILE : [f64 ; 12] = [6.35 , 2.23 , 3.48 , 2.33 , 4.38 , 4.09 , 2.52 , 5.19 , 2.39 , 3.66 , 2.29 , 2.88] ; const MINOR_PROFILE : [f64 ; 12] = [6.33 , 2.68 , 3.52 , 5.38 , 2.60 , 3.53 , 2.54 , 4.75 , 3.98 , 2.69 , 3.34 , 3.17] ; let mut best_correlation = - 1.0 ; let mut best_key = String :: new () ; const NOTE_NAMES : [& str ; 12] = ["C" , "C#" , "D" , "D#" , "E" , "F" , "F#" , "G" , "G#" , "A" , "A#" , "B"] ; for (root , note_name) in NOTE_NAMES . iter () . enumerate () { let major_corr = calculate_correlation (& pitch_class_dist , & MAJOR_PROFILE , root) ; if major_corr > best_correlation { best_correlation = major_corr ; best_key = format ! ("{} major" , note_name) ; } let minor_corr = calculate_correlation (& pitch_class_dist , & MINOR_PROFILE , root) ; if minor_corr > best_correlation { best_correlation = minor_corr ; best_key = format ! ("{} minor" , note_name) ; } } if best_correlation > 0.5 { Some (best_key) } else { None } }

- [ ] **Function 'calculate_correlation' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/shared/rust/src/core/analysis/key_detector.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Calculate Pearson correlation between pitch class distribution and key profile"] fn calculate_correlation (distribution : & [f64 ; 12] , profile : & [f64 ; 12] , rotation : usize) -> f64 { let mut rotated = [0.0 ; 12] ; for i in 0 .. 12 { rotated [i] = profile [(i + rotation) % 12] ; } let dist_mean : f64 = distribution . iter () . sum :: < f64 > () / 12.0 ; let prof_mean : f64 = rotated . iter () . sum :: < f64 > () / 12.0 ; let mut numerator = 0.0 ; let mut dist_sq_sum = 0.0 ; let mut prof_sq_sum = 0.0 ; for i in 0 .. 12 { let dist_diff = distribution [i] - dist_mean ; let prof_diff = rotated [i] - prof_mean ; numerator += dist_diff * prof_diff ; dist_sq_sum += dist_diff * dist_diff ; prof_sq_sum += prof_diff * prof_diff ; } let denominator = (dist_sq_sum * prof_sq_sum) . sqrt () ; if denominator > 0.0 { numerator / denominator } else { 0.0 } }

- [ ] **Function 'rotate_profile' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/shared/rust/src/core/analysis/key_profiles.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Rotate a profile array by the specified number of semitones."] # [doc = ""] # [doc = " This is used to test different key centers by rotating the profile"] # [doc = " so that each pitch class can become the tonic."] # [doc = ""] # [doc = " # Arguments"] # [doc = " * `profile` - The base profile array (length 12)"] # [doc = " * `rotation` - Number of semitones to rotate (0-11)"] # [doc = ""] # [doc = " # Returns"] # [doc = " Rotated profile array"] pub fn rotate_profile (profile : & [f64 ; 12] , rotation : usize) -> [f64 ; 12] { let mut rotated = [0.0 ; 12] ; for i in 0 .. 12 { rotated [i] = profile [(i + rotation) % 12] ; } rotated }

- [ ] **Function 'get_profiles_for_genre' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/shared/rust/src/core/analysis/key_profiles.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Get the appropriate profile for a given genre and scale type."] # [doc = ""] # [doc = " Returns a tuple of (major_profile, minor_profile) for the genre."] # [doc = " If the genre is not recognized, returns the standard Krumhansl profiles."] pub fn get_profiles_for_genre (genre : & str) -> (& 'static [f64 ; 12] , & 'static [f64 ; 12]) { match genre . to_lowercase () . as_str () { "techno" | "house" | "edm" | "electronic" | "dance" => { (& EDM_PROFILE , & EDM_PROFILE) } , "drum and bass" | "dnb" | "jungle" => (& DRUM_AND_BASS_PROFILE , & DRUM_AND_BASS_PROFILE) , "trance" | "progressive" | "progressive house" => (& TRANCE_PROFILE , & TRANCE_PROFILE) , "hiphop" | "hip-hop" | "trap" | "rap" => (& HIPHOP_PROFILE , & HIPHOP_PROFILE) , "ambient" | "chillout" | "downtempo" => (& AMBIENT_PROFILE , & AMBIENT_PROFILE) , "blues" | "rock" | "rock and roll" => (& BLUES_PROFILE , & BLUES_PROFILE) , "jazz" | "fusion" | "bebop" => (& JAZZ_MAJOR_PROFILE , & JAZZ_MINOR_PROFILE) , "classical" | "romantic" | "baroque" => (& CLASSICAL_PROFILE , & CLASSICAL_PROFILE) , "pop" | "popular" | "top 40" => (& POP_PROFILE , & POP_PROFILE) , _ => { (& KRUMHANSL_MAJOR_PROFILE , & KRUMHANSL_MINOR_PROFILE) } , } }

- [ ] **Function 'get_all_profiles' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/shared/rust/src/core/analysis/key_profiles.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Get all available profile types as a vector of (name, major_profile, minor_profile)."] pub fn get_all_profiles () -> Vec < (& 'static str , & 'static [f64 ; 12] , & 'static [f64 ; 12]) > { vec ! [("Krumhansl" , & KRUMHANSL_MAJOR_PROFILE , & KRUMHANSL_MINOR_PROFILE ,) , ("Temperley" , & TEMPERLEY_MAJOR_PROFILE , & TEMPERLEY_MINOR_PROFILE ,) , ("Simple" , & SIMPLE_MAJOR_PROFILE , & SIMPLE_MINOR_PROFILE) , ("EDM" , & EDM_PROFILE , & EDM_PROFILE) , ("Drum & Bass" , & DRUM_AND_BASS_PROFILE , & DRUM_AND_BASS_PROFILE ,) , ("Trance" , & TRANCE_PROFILE , & TRANCE_PROFILE) , ("Hip-Hop" , & HIPHOP_PROFILE , & HIPHOP_PROFILE) , ("Ambient" , & AMBIENT_PROFILE , & AMBIENT_PROFILE) , ("Blues" , & BLUES_PROFILE , & BLUES_PROFILE) , ("Jazz" , & JAZZ_MAJOR_PROFILE , & JAZZ_MINOR_PROFILE) , ("Classical" , & CLASSICAL_PROFILE , & CLASSICAL_PROFILE) , ("Pop" , & POP_PROFILE , & POP_PROFILE) ,] }

- [ ] **Function 'normalize_profile' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/shared/rust/src/core/analysis/key_profiles.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Normalize a profile so that its values sum to 1.0."] # [doc = ""] # [doc = " This is useful for converting profile weights to probability distributions."] pub fn normalize_profile (profile : & [f64 ; 12]) -> [f64 ; 12] { let sum : f64 = profile . iter () . sum () ; if sum . abs () < f64 :: EPSILON { return [1.0 / 12.0 ; 12] ; } let mut normalized = [0.0 ; 12] ; for i in 0 .. 12 { normalized [i] = profile [i] / sum ; } normalized }

- [ ] **Function 'combine_profiles' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/shared/rust/src/core/analysis/key_profiles.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Create a weighted combination of multiple profiles."] # [doc = ""] # [doc = " Useful for creating custom profiles that blend characteristics"] # [doc = " of multiple base profiles."] # [doc = ""] # [doc = " # Arguments"] # [doc = " * `profiles` - Slice of profile arrays"] # [doc = " * `weights` - Corresponding weights for each profile"] # [doc = ""] # [doc = " # Returns"] # [doc = " Combined profile array"] pub fn combine_profiles (profiles : & [& [f64 ; 12]] , weights : & [f64]) -> [f64 ; 12] { assert_eq ! (profiles . len () , weights . len () , "Profiles and weights must have same length") ; let mut combined = [0.0 ; 12] ; let weight_sum : f64 = weights . iter () . sum () ; for i in 0 .. 12 { for (profile_idx , & profile) in profiles . iter () . enumerate () { combined [i] += profile [i] * weights [profile_idx] ; } if weight_sum . abs () > f64 :: EPSILON { combined [i] /= weight_sum ; } } combined }

- [ ] **Function 'calculate_profile_strength' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/shared/rust/src/core/analysis/key_profiles.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Calculate the \"profile strength\" - how strongly a profile defines a key."] # [doc = ""] # [doc = " Returns a value between 0.0 and 1.0 where higher values indicate"] # [doc = " profiles that give more unambiguous key predictions."] pub fn calculate_profile_strength (profile : & [f64 ; 12]) -> f64 { let normalized = normalize_profile (profile) ; let max_weight = normalized . iter () . fold (f64 :: NEG_INFINITY , | a , & b | a . max (b)) ; let min_weight = normalized . iter () . fold (f64 :: INFINITY , | a , & b | a . min (b)) ; (max_weight - min_weight) . clamp (0.0 , 1.0) }

- [ ] **Function 'get_scale_degree_weights' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/shared/rust/src/core/analysis/key_profiles.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Get the scale degree weights for a profile at a specific key."] # [doc = ""] # [doc = " Returns an array where index 0 is the tonic weight, index 1 is the minor 2nd, etc."] # [doc = " Rotated appropriately for the specified key."] pub fn get_scale_degree_weights (profile : & [f64 ; 12] , tonic_pitch_class : usize) -> [f64 ; 12] { rotate_profile (profile , tonic_pitch_class) }

- [ ] **Function 'detect_profile_type' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/shared/rust/src/core/analysis/key_profiles.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Detect the most likely profile type for a given pitch distribution."] # [doc = ""] # [doc = " Compares the distribution against all known profiles and returns"] # [doc = " the best match along with a confidence score."] pub fn detect_profile_type (pitch_distribution : & [f64 ; 12]) -> (ProfileType , f64) { let profile_groups = [(ProfileType :: Major , & KRUMHANSL_MAJOR_PROFILE) , (ProfileType :: Minor , & KRUMHANSL_MINOR_PROFILE) , (ProfileType :: Blues , & BLUES_PROFILE) , (ProfileType :: Jazz , & JAZZ_MAJOR_PROFILE) , (ProfileType :: Electronic , & EDM_PROFILE) , (ProfileType :: Classical , & CLASSICAL_PROFILE) , (ProfileType :: Pop , & POP_PROFILE) ,] ; let mut best_match = ProfileType :: Major ; let mut best_correlation = f64 :: NEG_INFINITY ; for (profile_type , profile) in profile_groups { let correlation = calculate_profile_correlation (pitch_distribution , profile) ; if correlation > best_correlation { best_correlation = correlation ; best_match = profile_type ; } } (best_match , best_correlation) }

- [ ] **Function 'calculate_profile_correlation' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/shared/rust/src/core/analysis/key_profiles.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Calculate Pearson correlation between a pitch distribution and a profile."] # [doc = ""] # [doc = " Helper function used by `detect_profile_type`."] pub fn calculate_profile_correlation (distribution : & [f64 ; 12] , profile : & [f64 ; 12]) -> f64 { let dist_mean : f64 = distribution . iter () . sum :: < f64 > () / 12.0 ; let prof_mean : f64 = profile . iter () . sum :: < f64 > () / 12.0 ; let mut numerator = 0.0 ; let mut dist_sq_sum = 0.0 ; let mut prof_sq_sum = 0.0 ; for i in 0 .. 12 { let dist_diff = distribution [i] - dist_mean ; let prof_diff = profile [i] - prof_mean ; numerator += dist_diff * prof_diff ; dist_sq_sum += dist_diff * dist_diff ; prof_sq_sum += prof_diff * prof_diff ; } let denominator = (dist_sq_sum * prof_sq_sum) . sqrt () ; if denominator > 0.0 { numerator / denominator } else { 0.0 } }

- [ ] **Function 'create_key_profile' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/shared/rust/src/core/analysis/key_profiles.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Create a KeyProfile struct from raw weights."] pub fn create_key_profile (name : & str , weights : [f64 ; 12] , profile_type : ProfileType) -> KeyProfile { KeyProfile { name : name . to_string () , weights , description : match profile_type { ProfileType :: Major => Some ("Standard major key profile" . to_string ()) , ProfileType :: Minor => Some ("Standard minor key profile" . to_string ()) , ProfileType :: Blues => Some ("Blues/rock profile emphasizing blue notes" . to_string ()) , ProfileType :: Jazz => Some ("Jazz profile with extended harmonies" . to_string ()) , ProfileType :: Electronic => { Some ("Electronic music profile with strong root/fifth" . to_string ()) } , ProfileType :: Classical => Some ("Classical/romantic era profile" . to_string ()) , ProfileType :: Pop => Some ("Contemporary pop music profile" . to_string ()) , ProfileType :: Custom => Some ("Custom user-defined profile" . to_string ()) , } , profile_type , } }

- [ ] **Function 'get_default_profile' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/shared/rust/src/core/analysis/key_profiles.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Get the default Krumhansl key profile."] pub fn get_default_profile () -> KeyProfile { create_key_profile ("Krumhansl Major" , KRUMHANSL_MAJOR_PROFILE , ProfileType :: Major ,) }

- [ ] **Function 'approx_eq' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/shared/rust/src/core/analysis/key_profiles.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Helper function to check if two floats are approximately equal"] fn approx_eq (a : f64 , b : f64 , epsilon : f64) -> bool { (a - b) . abs () < epsilon }

- [ ] **Function 'parse_midi_file' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/shared/rust/src/core/midi/parser.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Parse a MIDI file from raw bytes"] # [doc = ""] # [doc = " This is the main entry point for MIDI parsing. It accepts raw file bytes"] # [doc = " and returns a structured MidiFile or an error."] # [doc = ""] # [doc = " # Examples"] # [doc = " ```ignore"] # [doc = " use midi_library_shared::core::midi::parse_midi_file;"] # [doc = ""] # [doc = " let data = std::fs::read(\"song.mid\").unwrap();"] # [doc = " let midi_file = parse_midi_file(&data)?;"] # [doc = " println!(\"Format: {}, Tracks: {}\", midi_file.header.format, midi_file.header.num_tracks);"] # [doc = " # Ok::<(), Box<dyn std::error::Error>>(())"] # [doc = " ```"] pub fn parse_midi_file (data : & [u8]) -> Result < MidiFile > { if data . len () < 14 { return Err (MidiParseError :: IncompleteData { expected : 14 , actual : data . len () }) ; } let header = parse_header (& data [0 .. 14]) ? ; let mut tracks = Vec :: with_capacity (header . num_tracks as usize) ; let mut pos = 14 ; for track_num in 0 .. header . num_tracks { let (track , bytes_read) = parse_track (& data [pos ..]) . map_err (| e | match e { MidiParseError :: InvalidTrack { position , reason } => MidiParseError :: InvalidTrack { position : pos + position , reason : format ! ("Track {}: {}" , track_num , reason) , } , e => e , }) ? ; tracks . push (track) ; pos += bytes_read ; } Ok (MidiFile { header , tracks }) }

- [ ] **Function 'parse_header' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/shared/rust/src/core/midi/parser.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Parse MIDI header chunk (MThd)"] fn parse_header (data : & [u8]) -> Result < Header > { if & data [0 .. 4] != b"MThd" { return Err (MidiParseError :: InvalidHeader (format ! ("Expected 'MThd', got {:?}" , & data [0 .. 4]))) ; } let length = u32 :: from_be_bytes ([data [4] , data [5] , data [6] , data [7]]) ; if length != 6 { return Err (MidiParseError :: InvalidHeader (format ! ("Expected header length 6, got {}" , length))) ; } let format = u16 :: from_be_bytes ([data [8] , data [9]]) ; let num_tracks = u16 :: from_be_bytes ([data [10] , data [11]]) ; let ticks_per_quarter_note = u16 :: from_be_bytes ([data [12] , data [13]]) ; if format > 2 { return Err (MidiParseError :: UnsupportedFormat (format)) ; } Ok (Header { format , num_tracks , ticks_per_quarter_note }) }

- [ ] **Function 'parse_track' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/shared/rust/src/core/midi/parser.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Parse a single MIDI track (MTrk)"] # [doc = " Returns (Track, bytes_consumed)"] fn parse_track (data : & [u8]) -> Result < (Track , usize) > { if data . len () < 8 { return Err (MidiParseError :: InvalidTrack { position : 0 , reason : "Track too short" . to_string () , }) ; } if & data [0 .. 4] != b"MTrk" { return Err (MidiParseError :: InvalidTrack { position : 0 , reason : format ! ("Expected 'MTrk', got {:?}" , & data [0 .. 4]) , }) ; } let track_length = u32 :: from_be_bytes ([data [4] , data [5] , data [6] , data [7]]) as usize ; if data . len () < 8 + track_length { return Err (MidiParseError :: InvalidTrack { position : 0 , reason : format ! ("Track data incomplete: expected {} bytes, got {}" , track_length , data . len () - 8) , }) ; } let track_data = & data [8 .. 8 + track_length] ; let events = parse_track_events (track_data) ? ; Ok ((Track { events } , 8 + track_length)) }

- [ ] **Function 'parse_track_events' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/shared/rust/src/core/midi/parser.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Parse all events within a track"] fn parse_track_events (data : & [u8]) -> Result < Vec < TimedEvent > > { let mut events = Vec :: new () ; let mut pos = 0 ; let mut running_status : Option < u8 > = None ; while pos < data . len () { let (delta_ticks , delta_bytes) = read_var_len (& data [pos ..]) . ok_or (MidiParseError :: InvalidVarLen (pos)) ? ; pos += delta_bytes ; let (event , event_bytes , new_running_status) = parse_event (& data [pos ..] , running_status) . map_err (| e | match e { MidiParseError :: InvalidEvent { position , reason } => { MidiParseError :: InvalidEvent { position : pos + position , reason } } , e => e , }) ? ; pos += event_bytes ; running_status = new_running_status ; events . push (TimedEvent { delta_ticks , event }) ; if matches ! (events . last () , Some (TimedEvent { event : Event :: EndOfTrack , .. })) { break ; } } Ok (events) }

- [ ] **Function 'parse_event' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/shared/rust/src/core/midi/parser.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Parse a single MIDI event"] # [doc = " Returns (Event, bytes_consumed, new_running_status)"] fn parse_event (data : & [u8] , running_status : Option < u8 >) -> Result < (Event , usize , Option < u8 >) > { if data . is_empty () { return Err (MidiParseError :: InvalidEvent { position : 0 , reason : "No data for event" . to_string () , }) ; } let mut status = data [0] ; let mut pos = 1 ; if status < 0x80 { if let Some (rs) = running_status { status = rs ; pos = 0 ; } else { return Err (MidiParseError :: InvalidEvent { position : 0 , reason : "Data byte without running status" . to_string () , }) ; } } let event_type = status & 0xF0 ; let channel = status & 0x0F ; match event_type { 0x80 => { if data . len () < pos + 2 { return Err (MidiParseError :: IncompleteData { expected : pos + 2 , actual : data . len () , }) ; } Ok ((Event :: NoteOff { channel , note : data [pos] , velocity : data [pos + 1] } , pos + 2 , Some (status) ,)) } , 0x90 => { if data . len () < pos + 2 { return Err (MidiParseError :: IncompleteData { expected : pos + 2 , actual : data . len () , }) ; } Ok ((Event :: NoteOn { channel , note : data [pos] , velocity : data [pos + 1] } , pos + 2 , Some (status) ,)) } , 0xA0 => { if data . len () < pos + 2 { return Err (MidiParseError :: IncompleteData { expected : pos + 2 , actual : data . len () , }) ; } Ok ((Event :: Aftertouch { channel , note : data [pos] , pressure : data [pos + 1] } , pos + 2 , Some (status) ,)) } , 0xB0 => { if data . len () < pos + 2 { return Err (MidiParseError :: IncompleteData { expected : pos + 2 , actual : data . len () , }) ; } Ok ((Event :: ControlChange { channel , controller : data [pos] , value : data [pos + 1] } , pos + 2 , Some (status) ,)) } , 0xC0 => { if data . len () < pos + 1 { return Err (MidiParseError :: IncompleteData { expected : pos + 1 , actual : data . len () , }) ; } Ok ((Event :: ProgramChange { channel , program : data [pos] } , pos + 1 , Some (status) ,)) } , 0xD0 => { if data . len () < pos + 1 { return Err (MidiParseError :: IncompleteData { expected : pos + 1 , actual : data . len () , }) ; } Ok ((Event :: ChannelAftertouch { channel , pressure : data [pos] } , pos + 1 , Some (status) ,)) } , 0xE0 => { if data . len () < pos + 2 { return Err (MidiParseError :: IncompleteData { expected : pos + 2 , actual : data . len () , }) ; } let lsb = data [pos] as i16 ; let msb = data [pos + 1] as i16 ; let value = ((msb << 7) | lsb) - 8192 ; Ok ((Event :: PitchBend { channel , value } , pos + 2 , Some (status))) } , 0xF0 => { parse_meta_or_sysex (& data [pos - 1 ..]) } , _ => Err (MidiParseError :: InvalidEvent { position : 0 , reason : format ! ("Unknown event type: 0x{:02X}" , status) , }) , } }

- [ ] **Function 'parse_meta_or_sysex' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/shared/rust/src/core/midi/parser.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Parse meta events and SysEx"] fn parse_meta_or_sysex (data : & [u8]) -> Result < (Event , usize , Option < u8 >) > { let status = data [0] ; match status { 0xFF => { if data . len () < 2 { return Err (MidiParseError :: IncompleteData { expected : 2 , actual : data . len () }) ; } let meta_type = data [1] ; let (length , len_bytes) = read_var_len (& data [2 ..]) . ok_or (MidiParseError :: InvalidVarLen (2)) ? ; let data_start = 2 + len_bytes ; let data_end = data_start + length as usize ; if data . len () < data_end { return Err (MidiParseError :: IncompleteData { expected : data_end , actual : data . len () , }) ; } let event_data = & data [data_start .. data_end] ; let event = match meta_type { 0x2F => Event :: EndOfTrack , 0x51 => { if event_data . len () != 3 { return Err (MidiParseError :: InvalidEvent { position : 0 , reason : "Tempo event must be 3 bytes" . to_string () , }) ; } let microseconds_per_quarter = u32 :: from_be_bytes ([0 , event_data [0] , event_data [1] , event_data [2]]) ; Event :: TempoChange { microseconds_per_quarter } } , 0x58 => { if event_data . len () != 4 { return Err (MidiParseError :: InvalidEvent { position : 0 , reason : "Time signature event must be 4 bytes" . to_string () , }) ; } Event :: TimeSignature { numerator : event_data [0] , denominator : event_data [1] , clocks_per_click : event_data [2] , thirty_seconds_per_quarter : event_data [3] , } } , 0x59 => { if event_data . len () != 2 { return Err (MidiParseError :: InvalidEvent { position : 0 , reason : "Key signature event must be 2 bytes" . to_string () , }) ; } Event :: KeySignature { sharps_flats : event_data [0] as i8 , is_minor : event_data [1] != 0 , } } , 0x01 ..= 0x0F => { let text = String :: from_utf8_lossy (event_data) . to_string () ; let text_type = match meta_type { 0x01 => TextType :: Text , 0x02 => TextType :: Copyright , 0x03 => TextType :: TrackName , 0x04 => TextType :: InstrumentName , 0x05 => TextType :: Lyric , 0x06 => TextType :: Marker , 0x07 => TextType :: CuePoint , _ => TextType :: Text , } ; Event :: Text { text_type , text } } , _ => Event :: Unknown { status , data : event_data . to_vec () } , } ; Ok ((event , data_end , None)) } , 0xF0 | 0xF7 => { let (length , len_bytes) = read_var_len (& data [1 ..]) . ok_or (MidiParseError :: InvalidVarLen (1)) ? ; let data_start = 1 + len_bytes ; let data_end = data_start + length as usize ; if data . len () < data_end { return Err (MidiParseError :: IncompleteData { expected : data_end , actual : data . len () , }) ; } Ok ((Event :: SysEx { data : data [data_start .. data_end] . to_vec () } , data_end , None ,)) } , _ => Err (MidiParseError :: InvalidEvent { position : 0 , reason : format ! ("Unknown system event: 0x{:02X}" , status) , }) , } }

- [ ] **Function 'read_var_len' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/shared/rust/src/core/midi/parser.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Read a MIDI variable-length quantity"] # [doc = " Returns (value, bytes_consumed) or None if invalid"] fn read_var_len (data : & [u8]) -> Option < (u32 , usize) > { let mut value = 0u32 ; let mut bytes_read = 0 ; for (i , & byte) in data . iter () . enumerate () { if i >= 4 { return None ; } value = (value << 7) | (byte & 0x7F) as u32 ; bytes_read += 1 ; if byte & 0x80 == 0 { return Some ((value , bytes_read)) ; } } None }

- [ ] **Function 'encode_vlq' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/shared/rust/src/core/midi/parser.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn encode_vlq (mut value : u32) -> Vec < u8 > { if value == 0 { return vec ! [0] ; } let mut bytes = Vec :: new () ; let mut buffer = value & 0x7F ; value >>= 7 ; while value > 0 { buffer <<= 8 ; buffer |= (value & 0x7F) | 0x80 ; value >>= 7 ; } loop { bytes . push ((buffer & 0xFF) as u8) ; if buffer & 0x80 == 0 { break ; } buffer >>= 8 ; } bytes }

- [ ] **Function 'minimal_track_with_eot' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/shared/rust/src/core/midi/parser.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [allow (dead_code)] fn minimal_track_with_eot () -> Vec < u8 > { vec ! [0x00 , 0xFF , 0x2F , 0x00 ,] }

- [ ] **Function 'create_test_midi_with_text' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/shared/rust/src/core/midi/text_metadata.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn create_test_midi_with_text () -> MidiFile { MidiFile { header : Header { format : 1 , num_tracks : 2 , ticks_per_quarter_note : 480 } , tracks : vec ! [Track { events : vec ! [TimedEvent { delta_ticks : 0 , event : Event :: Text { text_type : TextType :: TrackName , text : "Piano Track" . to_string () , } , } , TimedEvent { delta_ticks : 0 , event : Event :: Text { text_type : TextType :: Copyright , text : "2025 Test Artist" . to_string () , } , } , TimedEvent { delta_ticks : 100 , event : Event :: Text { text_type : TextType :: Marker , text : "Verse 1" . to_string () , } , } ,] , } , Track { events : vec ! [TimedEvent { delta_ticks : 0 , event : Event :: Text { text_type : TextType :: TrackName , text : "Bass Track" . to_string () , } , } , TimedEvent { delta_ticks : 0 , event : Event :: Text { text_type : TextType :: InstrumentName , text : "Electric Bass" . to_string () , } , } ,] , } ,] , } }

- [ ] **Function 'create_basic_midi' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/shared/rust/src/core/midi/types.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Helper function to create a basic MIDI file for testing"] fn create_basic_midi () -> MidiFile { MidiFile { header : Header { format : 1 , num_tracks : 1 , ticks_per_quarter_note : 480 } , tracks : vec ! [Track { events : vec ! [] }] , } }

- [ ] **Function 'create_midi_with_notes' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/shared/rust/src/core/midi/types.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Helper function to create a MIDI file with notes"] fn create_midi_with_notes () -> MidiFile { MidiFile { header : Header { format : 1 , num_tracks : 1 , ticks_per_quarter_note : 480 } , tracks : vec ! [Track { events : vec ! [TimedEvent { delta_ticks : 0 , event : Event :: NoteOn { channel : 0 , note : 60 , velocity : 100 } , } , TimedEvent { delta_ticks : 480 , event : Event :: NoteOff { channel : 0 , note : 60 , velocity : 0 } , } , TimedEvent { delta_ticks : 0 , event : Event :: NoteOn { channel : 1 , note : 64 , velocity : 80 } , } ,] , }] , } }

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/shared/rust/src/db/models/midi_file.rs`
  - Category: Performance

- [ ] **Potential excessive clone() detected**
  - Consider using references or borrowing instead of cloning
  - File: `/home/dojevou/projects/midi-software-center/shared/rust/src/db/repositories/search_repository.rs`
  - Category: Performance

- [ ] **Function 'extract_function_name' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/verification/src/categories/api_commands.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Extract function name from a line like \"pub async fn foo_bar(...)\""] fn extract_function_name (line : & str) -> Option < String > { let line = line . trim () ; if let Some (fn_pos) = line . find ("fn ") { let after_fn = & line [fn_pos + 3 ..] ; if let Some (paren_pos) = after_fn . find ('(') { let name = after_fn [.. paren_pos] . trim () ; if ! name . is_empty () { return Some (name . to_string ()) ; } } } None }

- [ ] **Function 'types_compatible' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/verification/src/categories/database_sync.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Check if two PostgreSQL types are compatible"] fn types_compatible (expected : & str , actual : & str) -> bool { let expected_lower = expected . to_lowercase () ; let actual_lower = actual . to_lowercase () ; if expected_lower == actual_lower { return true ; } let aliases : Vec < (& str , & [& str]) > = vec ! [("bigint" , & ["bigint" , "int8" , "bigserial"]) , ("integer" , & ["integer" , "int" , "int4" , "serial"]) , ("text" , & ["text" , "character varying" , "varchar"]) , ("double precision" , & ["double precision" , "float8" , "real"]) , ("timestamp with time zone" , & ["timestamp with time zone" , "timestamptz"] ,) , ("boolean" , & ["boolean" , "bool"]) ,] ; for (canonical , variations) in & aliases { if (expected_lower . contains (canonical) || variations . contains (& expected_lower . as_str ())) && (actual_lower . contains (canonical) || variations . contains (& actual_lower . as_str ())) { return true ; } } false }

- [ ] **Function 'scan_for_patterns_recursive' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/verification/src/categories/performance.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Recursively scan for code patterns"] fn scan_for_patterns_recursive (dir : & str , patterns : & [(& str , & str)] , findings : & mut Vec < String >) { if let Ok (entries) = fs :: read_dir (dir) { for entry in entries . flatten () { let path = entry . path () ; if path . is_dir () { let dir_name = path . file_name () . unwrap_or_default () . to_string_lossy () ; if ! ["target" , ".git" , "node_modules"] . contains (& dir_name . as_ref ()) { scan_for_patterns_recursive (& path . to_string_lossy () , patterns , findings) ; } } else if path . is_file () && path . extension () . is_some_and (| e | e == "rs") { let path_str = path . to_string_lossy () ; if path_str . contains ("test") || path_str . contains ("fixture") { continue ; } if let Ok (content) = fs :: read_to_string (& path) { for (line_num , line) in content . lines () . enumerate () { for (pattern , description) in patterns { if line . contains (pattern) { findings . push (format ! ("{}:{} - {}" , path . display () , line_num + 1 , description)) ; } } } } } } } }

- [ ] **Function 'scan_directory_recursive' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/verification/src/categories/security.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Recursively scan directory for secrets"] fn scan_directory_recursive (dir : & str , patterns : & [(& str , & str)] , findings : & mut Vec < String >) { if let Ok (entries) = fs :: read_dir (dir) { for entry in entries . flatten () { let path = entry . path () ; if path . is_dir () { let dir_name = path . file_name () . unwrap_or_default () . to_string_lossy () ; if ! ["target" , "node_modules" , ".git" , "dist" , "build"] . contains (& dir_name . as_ref ()) { scan_directory_recursive (& path . to_string_lossy () , patterns , findings) ; } } else if path . is_file () { scan_file_for_secrets (& path , patterns , findings) ; } } } }

- [ ] **Function 'scan_file_for_secrets' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/verification/src/categories/security.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Scan a single file for secret patterns"] fn scan_file_for_secrets (path : & Path , patterns : & [(& str , & str)] , findings : & mut Vec < String >) { let ext = path . extension () . and_then (| e | e . to_str ()) . unwrap_or ("") ; if ! ["rs" , "ts" , "js" , "json" , "toml" , "yaml" , "yml" , "env"] . contains (& ext) { return ; } let path_str = path . to_string_lossy () ; if path_str . contains ("test") || path_str . contains ("fixture") || path_str . contains ("mock") { return ; } if let Ok (content) = fs :: read_to_string (path) { for (line_num , line) in content . lines () . enumerate () { let line_lower = line . to_lowercase () ; for (pattern , description) in patterns { if line_lower . contains (pattern) { if line . contains ("env::var") || line . contains ("std::env") { continue ; } if line . trim () . starts_with ("//") || line . trim () . starts_with ('#') { continue ; } if line . contains ('=') && (line . contains ('"') || line . contains ('\'')) { findings . push (format ! ("{}:{} - {}: {}" , path . display () , line_num + 1 , description , line . trim ())) ; } } } } } }

- [ ] **Function 'scan_for_unsafe_recursive' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/verification/src/categories/security.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
# [doc = " Recursively scan for unsafe blocks"] fn scan_for_unsafe_recursive (dir : & str , findings : & mut Vec < String >) { if let Ok (entries) = fs :: read_dir (dir) { for entry in entries . flatten () { let path = entry . path () ; if path . is_dir () { let dir_name = path . file_name () . unwrap_or_default () . to_string_lossy () ; if ! ["target" , ".git"] . contains (& dir_name . as_ref ()) { scan_for_unsafe_recursive (& path . to_string_lossy () , findings) ; } } else if path . is_file () && path . extension () . is_some_and (| e | e == "rs") { if let Ok (content) = fs :: read_to_string (& path) { for (line_num , line) in content . lines () . enumerate () { if line . contains ("unsafe {") || line . contains ("unsafe fn") { findings . push (format ! ("{}:{} - {}" , path . display () , line_num + 1 , line . trim ())) ; } } } } } } }

- [ ] **Function 'print_header' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/verification/src/main.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn print_header (name : & str) { println ! ("â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”") ; println ! ("â”‚ Verifying: {:<50} â”‚" , name) ; println ! ("â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜") ; }

- [ ] **Function 'get_git_commit' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/verification/src/shared/types.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn get_git_commit () -> String { get_command_output ("git" , & ["rev-parse" , "--short" , "HEAD"]) }

- [ ] **Function 'get_command_output' could benefit from #[inline]**
  - Small functions (<10 lines) should consider #[inline] for better performance
  - File: `/home/dojevou/projects/midi-software-center/verification/src/shared/types.rs`
  - Category: Performance
  - Suggested fix:
#[inline]
fn get_command_output (cmd : & str , args : & [& str]) -> String { std :: process :: Command :: new (cmd) . args (args) . output () . ok () . and_then (| o | String :: from_utf8 (o . stdout) . ok ()) . map (| s | s . trim () . to_string ()) . unwrap_or_else (| | "unknown" . to_string ()) }

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/components/WindowBase.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/components/WindowBase.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/components/WindowBase.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/components/FileBrowser.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/components/FileBrowser.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/components/TagCloud.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/components/VUMeter.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/components/VUMeter.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/components/Toolbar.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/components/MenuBar.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/components/MenuBar.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/components/MenuBar.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/components/MenuBar.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/components/MenuBar.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/components/MenuBar.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/components/VirtualKeyboard.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/components/VirtualKeyboard.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/CommandPaletteWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/TagEditorWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/TagEditorWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/TagEditorWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/TagEditorWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/TagEditorWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/TagEditorWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/TagEditorWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/TagEditorWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/TagEditorWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/TagEditorWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/TagEditorWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/TagEditorWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/TagEditorWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/AutomationWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/AutomationWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/AutomationWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/AutomationWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/AutomationWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/AutomationWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/AutomationWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/AutomationWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/AutomationWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/PipelineWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/PipelineWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/PipelineWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/PipelineWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/PipelineWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/PipelineWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/PipelineWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/PipelineWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/PipelineWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/PipelineWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/LoopBrowserWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/LoopBrowserWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/LoopBrowserWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/LoopBrowserWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/LoopBrowserWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/LoopBrowserWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/LoopBrowserWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/LoopBrowserWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/LoopBrowserWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/LoopBrowserWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/LoopBrowserWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/LoopBrowserWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/LoopBrowserWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/LoopBrowserWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/LoopBrowserWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/LoopBrowserWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/MixerWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/MixerWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/MixerWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/MixerWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/MixerWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/MixerWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/MixerWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/MixerWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/ProjectBrowserWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/ProjectBrowserWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/ProjectBrowserWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/ProjectBrowserWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/ProjectBrowserWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/ProjectBrowserWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/ProjectBrowserWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/ProjectBrowserWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/ProjectBrowserWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/ProjectBrowserWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/ProjectBrowserWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/ProjectBrowserWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/ProjectBrowserWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/ProjectBrowserWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/ProjectBrowserWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/ProjectBrowserWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/ProjectBrowserWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/ProjectBrowserWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/ProjectBrowserWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/ProjectBrowserWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/FavoritesWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/FavoritesWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/FavoritesWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/FavoritesWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/FavoritesWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/FavoritesWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/FavoritesWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/FavoritesWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/FavoritesWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/FavoritesWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/FavoritesWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/FavoritesWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/FavoritesWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/FavoritesWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/DAWWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/DAWWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/DAWWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/DAWWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/DAWWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/DAWWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/DAWWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/VelocityEditorWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/VelocityEditorWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/VelocityEditorWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/VelocityEditorWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/VelocityEditorWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/VelocityEditorWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/VelocityEditorWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/VelocityEditorWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/VelocityEditorWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/SettingsWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/SettingsWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/SettingsWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/SettingsWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/SettingsWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/SettingsWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/SettingsWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/SettingsWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/SettingsWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/SettingsWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/SettingsWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/SettingsWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/SettingsWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/SettingsWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/ExportWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/ExportWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/ExportWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/ExportWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/ExportWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/ExportWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/ExportWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/ExportWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/DatabaseWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/DatabaseWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/DatabaseWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/DatabaseWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/DatabaseWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/DatabaseWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/DatabaseWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/DatabaseWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/DatabaseWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/DatabaseWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/FileDetailsWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/FileDetailsWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/FileDetailsWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/FileDetailsWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/FileDetailsWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/FileDetailsWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/FileDetailsWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/FileDetailsWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/FileDetailsWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/FileDetailsWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/FileDetailsWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/FileDetailsWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/FileDetailsWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/FileDetailsWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/MIDIDeviceWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/MIDIDeviceWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/MIDIDeviceWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/MIDIDeviceWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/MIDIDeviceWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/MIDIDeviceWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/MIDIDeviceWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/MIDIDeviceWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/MIDIDeviceWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/MIDIDeviceWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/MIDIDeviceWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/MIDIDeviceWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/MIDIDeviceWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/MIDIDeviceWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/MIDIDeviceWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/MIDIDeviceWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/MIDIDeviceWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/MIDIDeviceWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Button missing type attribute**
  - Buttons should explicitly set type="button" or type="submit"
  - File: `/home/dojevou/projects/midi-software-center/app/src/lib/windows/PianoRollWindow.svelte`
  - Category: Safety
  - Suggested fix:
Add type="button" to button element

- [ ] **Best practice: Consider adding 'set -e' or 'set -euo pipefail' at top of script**
  - 
  - File: `/home/dojevou/projects/midi-software-center/app/launch-cpu-only.sh`
  - Category: Documentation
  - Suggested fix:
Add 'set -euo pipefail' after shebang for safer scripts

- [ ] **Best practice: Consider adding 'set -e' or 'set -euo pipefail' at top of script**
  - 
  - File: `/home/dojevou/projects/midi-software-center/scripts/check-progress.sh`
  - Category: Documentation
  - Suggested fix:
Add 'set -euo pipefail' after shebang for safer scripts

- [ ] **Best practice: Consider adding 'set -e' or 'set -euo pipefail' at top of script**
  - 
  - File: `/home/dojevou/projects/midi-software-center/scripts/launch/frontend.sh`
  - Category: Documentation
  - Suggested fix:
Add 'set -euo pipefail' after shebang for safer scripts

- [ ] **Best practice: Consider adding 'set -e' or 'set -euo pipefail' at top of script**
  - 
  - File: `/home/dojevou/projects/midi-software-center/scripts/launch/status.sh`
  - Category: Documentation
  - Suggested fix:
Add 'set -euo pipefail' after shebang for safer scripts

- [ ] **Best practice: Consider adding 'set -e' or 'set -euo pipefail' at top of script**
  - 
  - File: `/home/dojevou/projects/midi-software-center/scripts/launch/launch-daw.sh`
  - Category: Documentation
  - Suggested fix:
Add 'set -euo pipefail' after shebang for safer scripts

- [ ] **Best practice: Consider adding 'set -e' or 'set -euo pipefail' at top of script**
  - 
  - File: `/home/dojevou/projects/midi-software-center/scripts/launch/launch-pipeline.sh`
  - Category: Documentation
  - Suggested fix:
Add 'set -euo pipefail' after shebang for safer scripts

- [ ] **Best practice: Consider adding 'set -e' or 'set -euo pipefail' at top of script**
  - 
  - File: `/home/dojevou/projects/midi-software-center/scripts/pgo-build.sh`
  - Category: Documentation
  - Suggested fix:
Add 'set -euo pipefail' after shebang for safer scripts

- [ ] **Best practice: Consider adding 'set -e' or 'set -euo pipefail' at top of script**
  - 
  - File: `/home/dojevou/projects/midi-software-center/scripts/monitor-pipeline.sh`
  - Category: Documentation
  - Suggested fix:
Add 'set -euo pipefail' after shebang for safer scripts

- [ ] **Best practice: Consider adding 'set -e' or 'set -euo pipefail' at top of script**
  - 
  - File: `/home/dojevou/projects/midi-software-center/scripts/monitor-import.sh`
  - Category: Documentation
  - Suggested fix:
Add 'set -euo pipefail' after shebang for safer scripts

- [ ] **Best practice: Consider adding 'set -e' or 'set -euo pipefail' at top of script**
  - 
  - File: `/home/dojevou/projects/midi-software-center/scripts/benchmark-comparison.sh`
  - Category: Documentation
  - Suggested fix:
Add 'set -euo pipefail' after shebang for safer scripts

- [ ] **Best practice: Consider adding 'set -e' or 'set -euo pipefail' at top of script**
  - 
  - File: `/home/dojevou/projects/midi-software-center/scripts/monitor-and-continue.sh`
  - Category: Documentation
  - Suggested fix:
Add 'set -euo pipefail' after shebang for safer scripts

- [ ] **Best practice: Consider adding 'set -e' or 'set -euo pipefail' at top of script**
  - 
  - File: `/home/dojevou/projects/midi-software-center/scripts/verify-split-relationships.sh`
  - Category: Documentation
  - Suggested fix:
Add 'set -euo pipefail' after shebang for safer scripts

- [ ] **Best practice: Consider adding 'set -e' or 'set -euo pipefail' at top of script**
  - 
  - File: `/home/dojevou/projects/midi-software-center/scripts/wait-for-import.sh`
  - Category: Documentation
  - Suggested fix:
Add 'set -euo pipefail' after shebang for safer scripts

- [ ] **Best practice: Consider adding 'set -e' or 'set -euo pipefail' at top of script**
  - 
  - File: `/home/dojevou/projects/midi-software-center/scripts/verify-database-files.sh`
  - Category: Documentation
  - Suggested fix:
Add 'set -euo pipefail' after shebang for safer scripts

- [ ] **Best practice: Consider adding 'set -e' or 'set -euo pipefail' at top of script**
  - 
  - File: `/home/dojevou/projects/midi-software-center/scripts/monitor-dedup.sh`
  - Category: Documentation
  - Suggested fix:
Add 'set -euo pipefail' after shebang for safer scripts

- [ ] **Best practice: Consider adding 'set -e' or 'set -euo pipefail' at top of script**
  - 
  - File: `/home/dojevou/projects/midi-software-center/scripts/convert_midian_format_5.sh`
  - Category: Documentation
  - Suggested fix:
Add 'set -euo pipefail' after shebang for safer scripts

- [ ] **Best practice: Consider adding 'set -e' or 'set -euo pipefail' at top of script**
  - 
  - File: `/home/dojevou/projects/midi-software-center/scripts/convert_test_5_fixed.sh`
  - Category: Documentation
  - Suggested fix:
Add 'set -euo pipefail' after shebang for safer scripts

- [ ] **Best practice: Consider adding 'set -e' or 'set -euo pipefail' at top of script**
  - 
  - File: `/home/dojevou/projects/midi-software-center/scripts/convert_test_100.sh`
  - Category: Documentation
  - Suggested fix:
Add 'set -euo pipefail' after shebang for safer scripts

- [ ] **Best practice: Consider adding 'set -e' or 'set -euo pipefail' at top of script**
  - 
  - File: `/home/dojevou/projects/midi-software-center/scripts/populate-codememory.sh`
  - Category: Documentation
  - Suggested fix:
Add 'set -euo pipefail' after shebang for safer scripts

- [ ] **Best practice: Consider adding 'set -e' or 'set -euo pipefail' at top of script**
  - 
  - File: `/home/dojevou/projects/midi-software-center/scripts/organization/organize-files.sh`
  - Category: Documentation
  - Suggested fix:
Add 'set -euo pipefail' after shebang for safer scripts

- [ ] **Best practice: Consider adding 'set -e' or 'set -euo pipefail' at top of script**
  - 
  - File: `/home/dojevou/projects/midi-software-center/scripts/fixes/fix_workflows_manually.sh`
  - Category: Documentation
  - Suggested fix:
Add 'set -euo pipefail' after shebang for safer scripts

- [ ] **Best practice: Consider adding 'set -e' or 'set -euo pipefail' at top of script**
  - 
  - File: `/home/dojevou/projects/midi-software-center/scripts/fixes/fix_e0308_calls.sh`
  - Category: Documentation
  - Suggested fix:
Add 'set -euo pipefail' after shebang for safer scripts

- [ ] **Best practice: Consider adding 'set -e' or 'set -euo pipefail' at top of script**
  - 
  - File: `/home/dojevou/projects/midi-software-center/scripts/fixes/fix_lint.sh`
  - Category: Documentation
  - Suggested fix:
Add 'set -euo pipefail' after shebang for safer scripts

- [ ] **Best practice: Consider adding 'set -e' or 'set -euo pipefail' at top of script**
  - 
  - File: `/home/dojevou/projects/midi-software-center/scripts/fixes/fix_workflows_imports.sh`
  - Category: Documentation
  - Suggested fix:
Add 'set -euo pipefail' after shebang for safer scripts

- [ ] **Best practice: Consider adding 'set -e' or 'set -euo pipefail' at top of script**
  - 
  - File: `/home/dojevou/projects/midi-software-center/scripts/setup/setup-project-structure.sh`
  - Category: Documentation
  - Suggested fix:
Add 'set -euo pipefail' after shebang for safer scripts

- [ ] **Best practice: Consider adding 'set -e' or 'set -euo pipefail' at top of script**
  - 
  - File: `/home/dojevou/projects/midi-software-center/run_all_analysis.sh`
  - Category: Documentation
  - Suggested fix:
Add 'set -euo pipefail' after shebang for safer scripts

- [ ] **Best practice: Consider adding 'set -e' or 'set -euo pipefail' at top of script**
  - 
  - File: `/home/dojevou/projects/midi-software-center/rust_analyzer/create_docs.sh`
  - Category: Documentation
  - Suggested fix:
Add 'set -euo pipefail' after shebang for safer scripts

- [ ] **Performance: Consider adding index on foreign key columns (line 14)**
  - 
  - File: `/home/dojevou/projects/midi-software-center/database/migrations/006_track_splits.sql`
  - Category: Performance
  - Suggested fix:
Add CREATE INDEX for frequently queried columns


